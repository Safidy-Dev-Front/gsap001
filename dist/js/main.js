/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/gsap/CSSPlugin.js":
/*!****************************************!*\
  !*** ./node_modules/gsap/CSSPlugin.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CSSPlugin": () => (/* binding */ CSSPlugin),
/* harmony export */   "_createElement": () => (/* binding */ _createElement),
/* harmony export */   "_getBBox": () => (/* binding */ _getBBox),
/* harmony export */   "checkPrefix": () => (/* binding */ _checkPropPrefix),
/* harmony export */   "default": () => (/* binding */ CSSPlugin)
/* harmony export */ });
/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ "./node_modules/gsap/gsap-core.js");
/*!
 * CSSPlugin 3.9.1
 * https://greensock.com
 *
 * Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */


var _win,
    _doc,
    _docElement,
    _pluginInitted,
    _tempDiv,
    _tempDivStyler,
    _recentSetterPlugin,
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _transformProps = {},
    _RAD2DEG = 180 / Math.PI,
    _DEG2RAD = Math.PI / 180,
    _atan2 = Math.atan2,
    _bigNum = 1e8,
    _capsExp = /([A-Z])/g,
    _horizontalExp = /(?:left|right|width|margin|padding|x)/i,
    _complexExp = /[\s,\(]\S/,
    _propertyAliases = {
  autoAlpha: "opacity,visibility",
  scale: "scaleX,scaleY",
  alpha: "opacity"
},
    _renderCSSProp = function _renderCSSProp(ratio, data) {
  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
},
    _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {
  return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
},
    _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {
  return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);
},
    //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)
_renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {
  var value = data.s + data.c * ratio;
  data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);
},
    _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {
  return data.set(data.t, data.p, ratio ? data.e : data.b, data);
},
    _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {
  return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
},
    _setterCSSStyle = function _setterCSSStyle(target, property, value) {
  return target.style[property] = value;
},
    _setterCSSProp = function _setterCSSProp(target, property, value) {
  return target.style.setProperty(property, value);
},
    _setterTransform = function _setterTransform(target, property, value) {
  return target._gsap[property] = value;
},
    _setterScale = function _setterScale(target, property, value) {
  return target._gsap.scaleX = target._gsap.scaleY = value;
},
    _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {
  var cache = target._gsap;
  cache.scaleX = cache.scaleY = value;
  cache.renderTransform(ratio, cache);
},
    _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {
  var cache = target._gsap;
  cache[property] = value;
  cache.renderTransform(ratio, cache);
},
    _transformProp = "transform",
    _transformOriginProp = _transformProp + "Origin",
    _supports3D,
    _createElement = function _createElement(type, ns) {
  var e = _doc.createElementNS ? _doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making "style" inaccessible.

  return e.style ? e : _doc.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://greensock.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).
},
    _getComputedProperty = function _getComputedProperty(target, property, skipPrefixFallback) {
  var cs = getComputedStyle(target);
  return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty(target, _checkPropPrefix(property) || property, 1) || ""; //css variables may not need caps swapped out for dashes and lowercase.
},
    _prefixes = "O,Moz,ms,Ms,Webkit".split(","),
    _checkPropPrefix = function _checkPropPrefix(property, element, preferPrefix) {
  var e = element || _tempDiv,
      s = e.style,
      i = 5;

  if (property in s && !preferPrefix) {
    return property;
  }

  property = property.charAt(0).toUpperCase() + property.substr(1);

  while (i-- && !(_prefixes[i] + property in s)) {}

  return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
},
    _initCore = function _initCore() {
  if (_windowExists() && window.document) {
    _win = window;
    _doc = _win.document;
    _docElement = _doc.documentElement;
    _tempDiv = _createElement("div") || {
      style: {}
    };
    _tempDivStyler = _createElement("div");
    _transformProp = _checkPropPrefix(_transformProp);
    _transformOriginProp = _transformProp + "Origin";
    _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0"; //make sure to override certain properties that may contaminate measurements, in case the user has overreaching style sheets.

    _supports3D = !!_checkPropPrefix("perspective");
    _pluginInitted = 1;
  }
},
    _getBBoxHack = function _getBBoxHack(swapIfPossible) {
  //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).
  var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
      oldParent = this.parentNode,
      oldSibling = this.nextSibling,
      oldCSS = this.style.cssText,
      bbox;

  _docElement.appendChild(svg);

  svg.appendChild(this);
  this.style.display = "block";

  if (swapIfPossible) {
    try {
      bbox = this.getBBox();
      this._gsapBBox = this.getBBox; //store the original

      this.getBBox = _getBBoxHack;
    } catch (e) {}
  } else if (this._gsapBBox) {
    bbox = this._gsapBBox();
  }

  if (oldParent) {
    if (oldSibling) {
      oldParent.insertBefore(this, oldSibling);
    } else {
      oldParent.appendChild(this);
    }
  }

  _docElement.removeChild(svg);

  this.style.cssText = oldCSS;
  return bbox;
},
    _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {
  var i = attributesArray.length;

  while (i--) {
    if (target.hasAttribute(attributesArray[i])) {
      return target.getAttribute(attributesArray[i]);
    }
  }
},
    _getBBox = function _getBBox(target) {
  var bounds;

  try {
    bounds = target.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
  } catch (error) {
    bounds = _getBBoxHack.call(target, true);
  }

  bounds && (bounds.width || bounds.height) || target.getBBox === _getBBoxHack || (bounds = _getBBoxHack.call(target, true)); //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.

  return bounds && !bounds.width && !bounds.x && !bounds.y ? {
    x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
    y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
    width: 0,
    height: 0
  } : bounds;
},
    _isSVG = function _isSVG(e) {
  return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
},
    //reports if the element is an SVG on which getBBox() actually works
_removeProperty = function _removeProperty(target, property) {
  if (property) {
    var style = target.style;

    if (property in _transformProps && property !== _transformOriginProp) {
      property = _transformProp;
    }

    if (style.removeProperty) {
      if (property.substr(0, 2) === "ms" || property.substr(0, 6) === "webkit") {
        //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
        property = "-" + property;
      }

      style.removeProperty(property.replace(_capsExp, "-$1").toLowerCase());
    } else {
      //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
      style.removeAttribute(property);
    }
  }
},
    _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {
  var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
  plugin._pt = pt;
  pt.b = beginning;
  pt.e = end;

  plugin._props.push(property);

  return pt;
},
    _nonConvertibleUnits = {
  deg: 1,
  rad: 1,
  turn: 1
},
    //takes a single value like 20px and converts it to the unit specified, like "%", returning only the numeric amount.
_convertToUnit = function _convertToUnit(target, property, value, unit) {
  var curValue = parseFloat(value) || 0,
      curUnit = (value + "").trim().substr((curValue + "").length) || "px",
      // some browsers leave extra whitespace at the beginning of CSS variables, hence the need to trim()
  style = _tempDiv.style,
      horizontal = _horizontalExp.test(property),
      isRootSVG = target.tagName.toLowerCase() === "svg",
      measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"),
      amount = 100,
      toPixels = unit === "px",
      toPercent = unit === "%",
      px,
      parent,
      cache,
      isSVG;

  if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
    return curValue;
  }

  curUnit !== "px" && !toPixels && (curValue = _convertToUnit(target, property, value, "px"));
  isSVG = target.getCTM && _isSVG(target);

  if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
    px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
    return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(toPercent ? curValue / px * amount : curValue / 100 * px);
  }

  style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
  parent = ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;

  if (isSVG) {
    parent = (target.ownerSVGElement || {}).parentNode;
  }

  if (!parent || parent === _doc || !parent.appendChild) {
    parent = _doc.body;
  }

  cache = parent._gsap;

  if (cache && toPercent && cache.width && horizontal && cache.time === _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._ticker.time) {
    return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(curValue / cache.width * amount);
  } else {
    (toPercent || curUnit === "%") && (style.position = _getComputedProperty(target, "position"));
    parent === target && (style.position = "static"); // like for borderRadius, if it's a % we must have it relative to the target itself but that may not have position: relative or position: absolute in which case it'd go up the chain until it finds its offsetParent (bad). position: static protects against that.

    parent.appendChild(_tempDiv);
    px = _tempDiv[measureProperty];
    parent.removeChild(_tempDiv);
    style.position = "absolute";

    if (horizontal && toPercent) {
      cache = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getCache)(parent);
      cache.time = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._ticker.time;
      cache.width = parent[measureProperty];
    }
  }

  return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
},
    _get = function _get(target, property, unit, uncache) {
  var value;
  _pluginInitted || _initCore();

  if (property in _propertyAliases && property !== "transform") {
    property = _propertyAliases[property];

    if (~property.indexOf(",")) {
      property = property.split(",")[0];
    }
  }

  if (_transformProps[property] && property !== "transform") {
    value = _parseTransform(target, uncache);
    value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
  } else {
    value = target.style[property];

    if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
      value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getProperty)(target, property) || (property === "opacity" ? 1 : 0); // note: some browsers, like Firefox, don't report borderRadius correctly! Instead, it only reports every corner like  borderTopLeftRadius
    }
  }

  return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
},
    _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {
  //note: we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
  if (!start || start === "none") {
    // some browsers like Safari actually PREFER the prefixed property and mis-report the unprefixed value like clipPath (BUG). In other words, even though clipPath exists in the style ("clipPath" in target.style) and it's set in the CSS properly (along with -webkit-clip-path), Safari reports clipPath as "none" whereas WebkitClipPath reports accurately like "ellipse(100% 0% at 50% 0%)", so in this case we must SWITCH to using the prefixed property instead. See https://greensock.com/forums/topic/18310-clippath-doesnt-work-on-ios/
    var p = _checkPropPrefix(prop, target, 1),
        s = p && _getComputedProperty(target, p, 1);

    if (s && s !== start) {
      prop = p;
      start = s;
    } else if (prop === "borderColor") {
      start = _getComputedProperty(target, "borderTopColor"); // Firefox bug: always reports "borderColor" as "", so we must fall back to borderTopColor. See https://greensock.com/forums/topic/24583-how-to-return-colors-that-i-had-after-reverse/
    }
  }

  var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, target.style, prop, 0, 1, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._renderComplexString),
      index = 0,
      matchIndex = 0,
      a,
      result,
      startValues,
      startNum,
      color,
      startValue,
      endValue,
      endNum,
      chunk,
      endUnit,
      startUnit,
      relative,
      endValues;
  pt.b = start;
  pt.e = end;
  start += ""; //ensure values are strings

  end += "";

  if (end === "auto") {
    target.style[prop] = end;
    end = _getComputedProperty(target, prop) || end;
    target.style[prop] = start;
  }

  a = [start, end];

  (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorStringFilter)(a); //pass an array with the starting and ending values and let the filter do whatever it needs to the values. If colors are found, it returns true and then we must match where the color shows up order-wise because for things like boxShadow, sometimes the browser provides the computed values with the color FIRST, but the user provides it with the color LAST, so flip them if necessary. Same for drop-shadow().


  start = a[0];
  end = a[1];
  startValues = start.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp) || [];
  endValues = end.match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp) || [];

  if (endValues.length) {
    while (result = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp.exec(end)) {
      endValue = result[0];
      chunk = end.substring(index, result.index);

      if (color) {
        color = (color + 1) % 5;
      } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
        color = 1;
      }

      if (endValue !== (startValue = startValues[matchIndex++] || "")) {
        startNum = parseFloat(startValue) || 0;
        startUnit = startValue.substr((startNum + "").length);
        relative = endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0;

        if (relative) {
          endValue = endValue.substr(2);
        }

        endNum = parseFloat(endValue);
        endUnit = endValue.substr((endNum + "").length);
        index = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numWithUnitExp.lastIndex - endUnit.length;

        if (!endUnit) {
          //if something like "perspective:300" is passed in and we must add a unit to the end
          endUnit = endUnit || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[prop] || startUnit;

          if (index === end.length) {
            end += endUnit;
            pt.e += endUnit;
          }
        }

        if (startUnit !== endUnit) {
          startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
        } //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.


        pt._pt = {
          _next: pt._pt,
          p: chunk || matchIndex === 1 ? chunk : ",",
          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
          s: startNum,
          c: relative ? relative * endNum : endNum - startNum,
          m: color && color < 4 || prop === "zIndex" ? Math.round : 0
        };
      }
    }

    pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)
  } else {
    pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
  }

  _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._relExp.test(end) && (pt.e = 0); //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).

  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within another plugin too, thus "this" would refer to the plugin.

  return pt;
},
    _keywordToPercent = {
  top: "0%",
  bottom: "100%",
  left: "0%",
  right: "100%",
  center: "50%"
},
    _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {
  var split = value.split(" "),
      x = split[0],
      y = split[1] || "50%";

  if (x === "top" || x === "bottom" || y === "left" || y === "right") {
    //the user provided them in the wrong order, so flip them
    value = x;
    x = y;
    y = value;
  }

  split[0] = _keywordToPercent[x] || x;
  split[1] = _keywordToPercent[y] || y;
  return split.join(" ");
},
    _renderClearProps = function _renderClearProps(ratio, data) {
  if (data.tween && data.tween._time === data.tween._dur) {
    var target = data.t,
        style = target.style,
        props = data.u,
        cache = target._gsap,
        prop,
        clearTransforms,
        i;

    if (props === "all" || props === true) {
      style.cssText = "";
      clearTransforms = 1;
    } else {
      props = props.split(",");
      i = props.length;

      while (--i > -1) {
        prop = props[i];

        if (_transformProps[prop]) {
          clearTransforms = 1;
          prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
        }

        _removeProperty(target, prop);
      }
    }

    if (clearTransforms) {
      _removeProperty(target, _transformProp);

      if (cache) {
        cache.svg && target.removeAttribute("transform");

        _parseTransform(target, 1); // force all the cached values back to "normal"/identity, otherwise if there's another tween that's already set to render transforms on this element, it could display the wrong values.


        cache.uncache = 1;
      }
    }
  }
},
    // note: specialProps should return 1 if (and only if) they have a non-zero priority. It indicates we need to sort the linked list.
_specialProps = {
  clearProps: function clearProps(plugin, target, property, endValue, tween) {
    if (tween.data !== "isFromStart") {
      var pt = plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
      pt.u = endValue;
      pt.pr = -10;
      pt.tween = tween;

      plugin._props.push(property);

      return 1;
    }
  }
  /* className feature (about 0.4kb gzipped).
  , className(plugin, target, property, endValue, tween) {
  	let _renderClassName = (ratio, data) => {
  			data.css.render(ratio, data.css);
  			if (!ratio || ratio === 1) {
  				let inline = data.rmv,
  					target = data.t,
  					p;
  				target.setAttribute("class", ratio ? data.e : data.b);
  				for (p in inline) {
  					_removeProperty(target, p);
  				}
  			}
  		},
  		_getAllStyles = (target) => {
  			let styles = {},
  				computed = getComputedStyle(target),
  				p;
  			for (p in computed) {
  				if (isNaN(p) && p !== "cssText" && p !== "length") {
  					styles[p] = computed[p];
  				}
  			}
  			_setDefaults(styles, _parseTransform(target, 1));
  			return styles;
  		},
  		startClassList = target.getAttribute("class"),
  		style = target.style,
  		cssText = style.cssText,
  		cache = target._gsap,
  		classPT = cache.classPT,
  		inlineToRemoveAtEnd = {},
  		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
  		changingVars = {},
  		startVars = _getAllStyles(target),
  		transformRelated = /(transform|perspective)/i,
  		endVars, p;
  	if (classPT) {
  		classPT.r(1, classPT.d);
  		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
  	}
  	target.setAttribute("class", data.e);
  	endVars = _getAllStyles(target, true);
  	target.setAttribute("class", startClassList);
  	for (p in endVars) {
  		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
  			changingVars[p] = endVars[p];
  			if (!style[p] && style[p] !== "0") {
  				inlineToRemoveAtEnd[p] = 1;
  			}
  		}
  	}
  	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
  	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://greensock.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
  		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
  	}
  	_parseTransform(target, true); //to clear the caching of transforms
  	data.css = new gsap.plugins.css();
  	data.css.init(target, changingVars, tween);
  	plugin._props.push(...data.css._props);
  	return 1;
  }
  */

},

/*
 * --------------------------------------------------------------------------------------
 * TRANSFORMS
 * --------------------------------------------------------------------------------------
 */
_identity2DMatrix = [1, 0, 0, 1, 0, 0],
    _rotationalProperties = {},
    _isNullTransform = function _isNullTransform(value) {
  return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
},
    _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {
  var matrixString = _getComputedProperty(target, _transformProp);

  return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._numExp).map(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round);
},
    _getMatrix = function _getMatrix(target, force2D) {
  var cache = target._gsap || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getCache)(target),
      style = target.style,
      matrix = _getComputedTransformMatrixAsArray(target),
      parent,
      nextSibling,
      temp,
      addedToDOM;

  if (cache.svg && target.getAttribute("transform")) {
    temp = target.transform.baseVal.consolidate().matrix; //ensures that even complex values like "translate(50,60) rotate(135,0,0)" are parsed because it mashes it into a matrix.

    matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
    return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
  } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
    //note: if offsetParent is null, that means the element isn't in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397
    //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not "none". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).
    temp = style.display;
    style.display = "block";
    parent = target.parentNode;

    if (!parent || !target.offsetParent) {
      // note: in 3.3.0 we switched target.offsetParent to _doc.body.contains(target) to avoid [sometimes unnecessary] MutationObserver calls but that wasn't adequate because there are edge cases where nested position: fixed elements need to get reparented to accurately sense transforms. See https://github.com/greensock/GSAP/issues/388 and https://github.com/greensock/GSAP/issues/375
      addedToDOM = 1; //flag

      nextSibling = target.nextSibling;

      _docElement.appendChild(target); //we must add it to the DOM in order to get values properly

    }

    matrix = _getComputedTransformMatrixAsArray(target);
    temp ? style.display = temp : _removeProperty(target, "display");

    if (addedToDOM) {
      nextSibling ? parent.insertBefore(target, nextSibling) : parent ? parent.appendChild(target) : _docElement.removeChild(target);
    }
  }

  return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
},
    _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
  var cache = target._gsap,
      matrix = matrixArray || _getMatrix(target, true),
      xOriginOld = cache.xOrigin || 0,
      yOriginOld = cache.yOrigin || 0,
      xOffsetOld = cache.xOffset || 0,
      yOffsetOld = cache.yOffset || 0,
      a = matrix[0],
      b = matrix[1],
      c = matrix[2],
      d = matrix[3],
      tx = matrix[4],
      ty = matrix[5],
      originSplit = origin.split(" "),
      xOrigin = parseFloat(originSplit[0]) || 0,
      yOrigin = parseFloat(originSplit[1]) || 0,
      bounds,
      determinant,
      x,
      y;

  if (!originIsAbsolute) {
    bounds = _getBBox(target);
    xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
    yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
  } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
    //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.
    x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
    y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
    xOrigin = x;
    yOrigin = y;
  }

  if (smooth || smooth !== false && cache.smooth) {
    tx = xOrigin - xOriginOld;
    ty = yOrigin - yOriginOld;
    cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
    cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
  } else {
    cache.xOffset = cache.yOffset = 0;
  }

  cache.xOrigin = xOrigin;
  cache.yOrigin = yOrigin;
  cache.smooth = !!smooth;
  cache.origin = origin;
  cache.originIsAbsolute = !!originIsAbsolute;
  target.style[_transformOriginProp] = "0px 0px"; //otherwise, if someone sets  an origin via CSS, it will likely interfere with the SVG transform attribute ones (because remember, we're baking the origin into the matrix() value).

  if (pluginToAddPropTweensTo) {
    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
  }

  target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
},
    _parseTransform = function _parseTransform(target, uncache) {
  var cache = target._gsap || new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.GSCache(target);

  if ("x" in cache && !uncache && !cache.uncache) {
    return cache;
  }

  var style = target.style,
      invertedScaleX = cache.scaleX < 0,
      px = "px",
      deg = "deg",
      origin = _getComputedProperty(target, _transformOriginProp) || "0",
      x,
      y,
      z,
      scaleX,
      scaleY,
      rotation,
      rotationX,
      rotationY,
      skewX,
      skewY,
      perspective,
      xOrigin,
      yOrigin,
      matrix,
      angle,
      cos,
      sin,
      a,
      b,
      c,
      d,
      a12,
      a22,
      t1,
      t2,
      t3,
      a13,
      a23,
      a33,
      a42,
      a43,
      a32;
  x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
  scaleX = scaleY = 1;
  cache.svg = !!(target.getCTM && _isSVG(target));
  matrix = _getMatrix(target, cache.svg);

  if (cache.svg) {
    t1 = (!cache.uncache || origin === "0px 0px") && !uncache && target.getAttribute("data-svg-origin"); // if origin is 0,0 and cache.uncache is true, let the recorded data-svg-origin stay. Otherwise, whenever we set cache.uncache to true, we'd need to set element.style.transformOrigin = (cache.xOrigin - bbox.x) + "px " + (cache.yOrigin - bbox.y) + "px". Remember, to work around browser inconsistencies we always force SVG elements' transformOrigin to 0,0 and offset the translation accordingly.

    _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
  }

  xOrigin = cache.xOrigin || 0;
  yOrigin = cache.yOrigin || 0;

  if (matrix !== _identity2DMatrix) {
    a = matrix[0]; //a11

    b = matrix[1]; //a21

    c = matrix[2]; //a31

    d = matrix[3]; //a41

    x = a12 = matrix[4];
    y = a22 = matrix[5]; //2D matrix

    if (matrix.length === 6) {
      scaleX = Math.sqrt(a * a + b * b);
      scaleY = Math.sqrt(d * d + c * c);
      rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).

      skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
      skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));

      if (cache.svg) {
        x -= xOrigin - (xOrigin * a + yOrigin * c);
        y -= yOrigin - (xOrigin * b + yOrigin * d);
      } //3D matrix

    } else {
      a32 = matrix[6];
      a42 = matrix[7];
      a13 = matrix[8];
      a23 = matrix[9];
      a33 = matrix[10];
      a43 = matrix[11];
      x = matrix[12];
      y = matrix[13];
      z = matrix[14];
      angle = _atan2(a32, a33);
      rotationX = angle * _RAD2DEG; //rotationX

      if (angle) {
        cos = Math.cos(-angle);
        sin = Math.sin(-angle);
        t1 = a12 * cos + a13 * sin;
        t2 = a22 * cos + a23 * sin;
        t3 = a32 * cos + a33 * sin;
        a13 = a12 * -sin + a13 * cos;
        a23 = a22 * -sin + a23 * cos;
        a33 = a32 * -sin + a33 * cos;
        a43 = a42 * -sin + a43 * cos;
        a12 = t1;
        a22 = t2;
        a32 = t3;
      } //rotationY


      angle = _atan2(-c, a33);
      rotationY = angle * _RAD2DEG;

      if (angle) {
        cos = Math.cos(-angle);
        sin = Math.sin(-angle);
        t1 = a * cos - a13 * sin;
        t2 = b * cos - a23 * sin;
        t3 = c * cos - a33 * sin;
        a43 = d * sin + a43 * cos;
        a = t1;
        b = t2;
        c = t3;
      } //rotationZ


      angle = _atan2(b, a);
      rotation = angle * _RAD2DEG;

      if (angle) {
        cos = Math.cos(angle);
        sin = Math.sin(angle);
        t1 = a * cos + b * sin;
        t2 = a12 * cos + a22 * sin;
        b = b * cos - a * sin;
        a22 = a22 * cos - a12 * sin;
        a = t1;
        a12 = t2;
      }

      if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
        //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
        rotationX = rotation = 0;
        rotationY = 180 - rotationY;
      }

      scaleX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(Math.sqrt(a * a + b * b + c * c));
      scaleY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(Math.sqrt(a22 * a22 + a32 * a32));
      angle = _atan2(a12, a22);
      skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;
      perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
    }

    if (cache.svg) {
      //sense if there are CSS transforms applied on an SVG element in which case we must overwrite them when rendering. The transform attribute is more reliable cross-browser, but we can't just remove the CSS ones because they may be applied in a CSS rule somewhere (not just inline).
      t1 = target.getAttribute("transform");
      cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
      t1 && target.setAttribute("transform", t1);
    }
  }

  if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
    if (invertedScaleX) {
      scaleX *= -1;
      skewX += rotation <= 0 ? 180 : -180;
      rotation += rotation <= 0 ? 180 : -180;
    } else {
      scaleY *= -1;
      skewX += skewX <= 0 ? 180 : -180;
    }
  }

  cache.x = x - ((cache.xPercent = x && (cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
  cache.y = y - ((cache.yPercent = y && (cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
  cache.z = z + px;
  cache.scaleX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(scaleX);
  cache.scaleY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(scaleY);
  cache.rotation = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotation) + deg;
  cache.rotationX = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotationX) + deg;
  cache.rotationY = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(rotationY) + deg;
  cache.skewX = skewX + deg;
  cache.skewY = skewY + deg;
  cache.transformPerspective = perspective + px;

  if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || 0) {
    style[_transformOriginProp] = _firstTwoOnly(origin);
  }

  cache.xOffset = cache.yOffset = 0;
  cache.force3D = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.force3D;
  cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
  cache.uncache = 0;
  return cache;
},
    _firstTwoOnly = function _firstTwoOnly(value) {
  return (value = value.split(" "))[0] + " " + value[1];
},
    //for handling transformOrigin values, stripping out the 3rd dimension
_addPxTranslate = function _addPxTranslate(target, start, value) {
  var unit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(start);
  return (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
},
    _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {
  cache.z = "0px";
  cache.rotationY = cache.rotationX = "0deg";
  cache.force3D = 0;

  _renderCSSTransforms(ratio, cache);
},
    _zeroDeg = "0deg",
    _zeroPx = "0px",
    _endParenthesis = ") ",
    _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {
  var _ref = cache || this,
      xPercent = _ref.xPercent,
      yPercent = _ref.yPercent,
      x = _ref.x,
      y = _ref.y,
      z = _ref.z,
      rotation = _ref.rotation,
      rotationY = _ref.rotationY,
      rotationX = _ref.rotationX,
      skewX = _ref.skewX,
      skewY = _ref.skewY,
      scaleX = _ref.scaleX,
      scaleY = _ref.scaleY,
      transformPerspective = _ref.transformPerspective,
      force3D = _ref.force3D,
      target = _ref.target,
      zOrigin = _ref.zOrigin,
      transforms = "",
      use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true; // Safari has a bug that causes it not to render 3D transform-origin values properly, so we force the z origin to 0, record it in the cache, and then do the math here to offset the translate values accordingly (basically do the 3D transform-origin part manually)


  if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
    var angle = parseFloat(rotationY) * _DEG2RAD,
        a13 = Math.sin(angle),
        a33 = Math.cos(angle),
        cos;

    angle = parseFloat(rotationX) * _DEG2RAD;
    cos = Math.cos(angle);
    x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
    y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
    z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
  }

  if (transformPerspective !== _zeroPx) {
    transforms += "perspective(" + transformPerspective + _endParenthesis;
  }

  if (xPercent || yPercent) {
    transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
  }

  if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
    transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
  }

  if (rotation !== _zeroDeg) {
    transforms += "rotate(" + rotation + _endParenthesis;
  }

  if (rotationY !== _zeroDeg) {
    transforms += "rotateY(" + rotationY + _endParenthesis;
  }

  if (rotationX !== _zeroDeg) {
    transforms += "rotateX(" + rotationX + _endParenthesis;
  }

  if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
    transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
  }

  if (scaleX !== 1 || scaleY !== 1) {
    transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
  }

  target.style[_transformProp] = transforms || "translate(0, 0)";
},
    _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {
  var _ref2 = cache || this,
      xPercent = _ref2.xPercent,
      yPercent = _ref2.yPercent,
      x = _ref2.x,
      y = _ref2.y,
      rotation = _ref2.rotation,
      skewX = _ref2.skewX,
      skewY = _ref2.skewY,
      scaleX = _ref2.scaleX,
      scaleY = _ref2.scaleY,
      target = _ref2.target,
      xOrigin = _ref2.xOrigin,
      yOrigin = _ref2.yOrigin,
      xOffset = _ref2.xOffset,
      yOffset = _ref2.yOffset,
      forceCSS = _ref2.forceCSS,
      tx = parseFloat(x),
      ty = parseFloat(y),
      a11,
      a21,
      a12,
      a22,
      temp;

  rotation = parseFloat(rotation);
  skewX = parseFloat(skewX);
  skewY = parseFloat(skewY);

  if (skewY) {
    //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.
    skewY = parseFloat(skewY);
    skewX += skewY;
    rotation += skewY;
  }

  if (rotation || skewX) {
    rotation *= _DEG2RAD;
    skewX *= _DEG2RAD;
    a11 = Math.cos(rotation) * scaleX;
    a21 = Math.sin(rotation) * scaleX;
    a12 = Math.sin(rotation - skewX) * -scaleY;
    a22 = Math.cos(rotation - skewX) * scaleY;

    if (skewX) {
      skewY *= _DEG2RAD;
      temp = Math.tan(skewX - skewY);
      temp = Math.sqrt(1 + temp * temp);
      a12 *= temp;
      a22 *= temp;

      if (skewY) {
        temp = Math.tan(skewY);
        temp = Math.sqrt(1 + temp * temp);
        a11 *= temp;
        a21 *= temp;
      }
    }

    a11 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a11);
    a21 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a21);
    a12 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a12);
    a22 = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(a22);
  } else {
    a11 = scaleX;
    a22 = scaleY;
    a21 = a12 = 0;
  }

  if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
    tx = _convertToUnit(target, "x", x, "px");
    ty = _convertToUnit(target, "y", y, "px");
  }

  if (xOrigin || yOrigin || xOffset || yOffset) {
    tx = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
    ty = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
  }

  if (xPercent || yPercent) {
    //The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the translation to simulate it.
    temp = target.getBBox();
    tx = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(tx + xPercent / 100 * temp.width);
    ty = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._round)(ty + yPercent / 100 * temp.height);
  }

  temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
  target.setAttribute("transform", temp);
  forceCSS && (target.style[_transformProp] = temp); //some browsers prioritize CSS transforms over the transform attribute. When we sense that the user has CSS transforms applied, we must overwrite them this way (otherwise some browser simply won't render the  transform attribute changes!)
},
    _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue, relative) {
  var cap = 360,
      isString = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isString)(endValue),
      endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1),
      change = relative ? endNum * relative : endNum - startNum,
      finalValue = startNum + change + "deg",
      direction,
      pt;

  if (isString) {
    direction = endValue.split("_")[1];

    if (direction === "short") {
      change %= cap;

      if (change !== change % (cap / 2)) {
        change += change < 0 ? cap : -cap;
      }
    }

    if (direction === "cw" && change < 0) {
      change = (change + cap * _bigNum) % cap - ~~(change / cap) * cap;
    } else if (direction === "ccw" && change > 0) {
      change = (change - cap * _bigNum) % cap - ~~(change / cap) * cap;
    }
  }

  plugin._pt = pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
  pt.e = finalValue;
  pt.u = "deg";

  plugin._props.push(property);

  return pt;
},
    _assign = function _assign(target, source) {
  // Internet Explorer doesn't have Object.assign(), so we recreate it here.
  for (var p in source) {
    target[p] = source[p];
  }

  return target;
},
    _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {
  //for handling cases where someone passes in a whole transform string, like transform: "scale(2, 3) rotate(20deg) translateY(30em)"
  var startCache = _assign({}, target._gsap),
      exclude = "perspective,force3D,transformOrigin,svgOrigin",
      style = target.style,
      endCache,
      p,
      startValue,
      endValue,
      startNum,
      endNum,
      startUnit,
      endUnit;

  if (startCache.svg) {
    startValue = target.getAttribute("transform");
    target.setAttribute("transform", "");
    style[_transformProp] = transforms;
    endCache = _parseTransform(target, 1);

    _removeProperty(target, _transformProp);

    target.setAttribute("transform", startValue);
  } else {
    startValue = getComputedStyle(target)[_transformProp];
    style[_transformProp] = transforms;
    endCache = _parseTransform(target, 1);
    style[_transformProp] = startValue;
  }

  for (p in _transformProps) {
    startValue = startCache[p];
    endValue = endCache[p];

    if (startValue !== endValue && exclude.indexOf(p) < 0) {
      //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
      startUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue);
      endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue);
      startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
      endNum = parseFloat(endValue);
      plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
      plugin._pt.u = endUnit || 0;

      plugin._props.push(p);
    }
  }

  _assign(endCache, startCache);
}; // handle splitting apart padding, margin, borderWidth, and borderRadius into their 4 components. Firefox, for example, won't report borderRadius correctly - it will only do borderTopLeftRadius and the other corners. We also want to handle paddingTop, marginLeft, borderRightWidth, etc.


(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)("padding,margin,Width,Radius", function (name, index) {
  var t = "Top",
      r = "Right",
      b = "Bottom",
      l = "Left",
      props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function (side) {
    return index < 2 ? name + side : "border" + side + name;
  });

  _specialProps[index > 1 ? "border" + name : name] = function (plugin, target, property, endValue, tween) {
    var a, vars;

    if (arguments.length < 4) {
      // getter, passed target, property, and unit (from _get())
      a = props.map(function (prop) {
        return _get(plugin, prop, property);
      });
      vars = a.join(" ");
      return vars.split(a[0]).length === 5 ? a[0] : vars;
    }

    a = (endValue + "").split(" ");
    vars = {};
    props.forEach(function (prop, i) {
      return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];
    });
    plugin.init(target, vars, tween);
  };
});

var CSSPlugin = {
  name: "css",
  register: _initCore,
  targetTest: function targetTest(target) {
    return target.style && target.nodeType;
  },
  init: function init(target, vars, tween, index, targets) {
    var props = this._props,
        style = target.style,
        startAt = tween.vars.startAt,
        startValue,
        endValue,
        endNum,
        startNum,
        type,
        specialProp,
        p,
        startUnit,
        endUnit,
        relative,
        isTransformRelated,
        transformPropTween,
        cache,
        smooth,
        hasPriority;
    _pluginInitted || _initCore();

    for (p in vars) {
      if (p === "autoRound") {
        continue;
      }

      endValue = vars[p];

      if (_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._plugins[p] && (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._checkPlugin)(p, vars, tween, index, target, targets)) {
        // plugins
        continue;
      }

      type = typeof endValue;
      specialProp = _specialProps[p];

      if (type === "function") {
        endValue = endValue.call(tween, index, target, targets);
        type = typeof endValue;
      }

      if (type === "string" && ~endValue.indexOf("random(")) {
        endValue = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._replaceRandom)(endValue);
      }

      if (specialProp) {
        specialProp(this, target, p, endValue, tween) && (hasPriority = 1);
      } else if (p.substr(0, 2) === "--") {
        //CSS variable
        startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
        endValue += "";
        _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorExp.lastIndex = 0;

        if (!_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._colorExp.test(startValue)) {
          // colors don't have units
          startUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue);
          endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue);
        }

        endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
        this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);
        props.push(p);
      } else if (type !== "undefined") {
        if (startAt && p in startAt) {
          // in case someone hard-codes a complex value as the start, like top: "calc(2vh / 2)". Without this, it'd use the computed value (always in px)
          startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];
          (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isString)(startValue) && ~startValue.indexOf("random(") && (startValue = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._replaceRandom)(startValue));
          (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(startValue + "") || (startValue += _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[p] || (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(_get(target, p)) || ""); // for cases when someone passes in a unitless value like {x: 100}; if we try setting translate(100, 0px) it won't work.

          (startValue + "").charAt(1) === "=" && (startValue = _get(target, p)); // can't work with relative values
        } else {
          startValue = _get(target, p);
        }

        startNum = parseFloat(startValue);
        relative = type === "string" && endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0;
        relative && (endValue = endValue.substr(2));
        endNum = parseFloat(endValue);

        if (p in _propertyAliases) {
          if (p === "autoAlpha") {
            //special case where we control the visibility along with opacity. We still allow the opacity value to pass through and get tweened.
            if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
              //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
              startNum = 0;
            }

            _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
          }

          if (p !== "scale" && p !== "transform") {
            p = _propertyAliases[p];
            ~p.indexOf(",") && (p = p.split(",")[0]);
          }
        }

        isTransformRelated = p in _transformProps; //--- TRANSFORM-RELATED ---

        if (isTransformRelated) {
          if (!transformPropTween) {
            cache = target._gsap;
            cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform); // if, for example, gsap.set(... {transform:"translateX(50vw)"}), the _get() call doesn't parse the transform, thus cache.renderTransform won't be set yet so force the parsing of the transform here.

            smooth = vars.smoothOrigin !== false && cache.smooth;
            transformPropTween = this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1); //the first time through, create the rendering PropTween so that it runs LAST (in the linked list, we keep adding to the beginning)

            transformPropTween.dep = 1; //flag it as dependent so that if things get killed/overwritten and this is the only PropTween left, we can safely kill the whole tween.
          }

          if (p === "scale") {
            this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? relative * endNum : endNum - cache.scaleY) || 0);
            props.push("scaleY", p);
            p += "X";
          } else if (p === "transformOrigin") {
            endValue = _convertKeywordsToPercentages(endValue); //in case something like "left top" or "bottom right" is passed in. Convert to percentages.

            if (cache.svg) {
              _applySVGOrigin(target, endValue, 0, smooth, 0, this);
            } else {
              endUnit = parseFloat(endValue.split(" ")[2]) || 0; //handle the zOrigin separately!

              endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);

              _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
            }

            continue;
          } else if (p === "svgOrigin") {
            _applySVGOrigin(target, endValue, 1, smooth, 0, this);

            continue;
          } else if (p in _rotationalProperties) {
            _addRotationalPropTween(this, cache, p, startNum, endValue, relative);

            continue;
          } else if (p === "smoothOrigin") {
            _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);

            continue;
          } else if (p === "force3D") {
            cache[p] = endValue;
            continue;
          } else if (p === "transform") {
            _addRawTransformPTs(this, endValue, target);

            continue;
          }
        } else if (!(p in style)) {
          p = _checkPropPrefix(p) || p;
        }

        if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
          startUnit = (startValue + "").substr((startNum + "").length);
          endNum || (endNum = 0); // protect against NaN

          endUnit = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit)(endValue) || (p in _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units ? _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[p] : startUnit);
          startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
          this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, relative ? relative * endNum : endNum - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
          this._pt.u = endUnit || 0;

          if (startUnit !== endUnit && endUnit !== "%") {
            //when the tween goes all the way back to the beginning, we need to revert it to the OLD/ORIGINAL value (with those units). We record that as a "b" (beginning) property and point to a render method that handles that. (performance optimization)
            this._pt.b = startValue;
            this._pt.r = _renderCSSPropWithBeginning;
          }
        } else if (!(p in style)) {
          if (p in target) {
            //maybe it's not a style - it could be a property added directly to an element in which case we'll try to animate that.
            this.add(target, p, startValue || target[p], endValue, index, targets);
          } else {
            (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._missingPlugin)(p, endValue);

            continue;
          }
        } else {
          _tweenComplexCSSString.call(this, target, p, startValue, endValue);
        }

        props.push(p);
      }
    }

    hasPriority && (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._sortPropTweensByPriority)(this);
  },
  get: _get,
  aliases: _propertyAliases,
  getSetter: function getSetter(target, property, plugin) {
    //returns a setter function that accepts target, property, value and applies it accordingly. Remember, properties like "x" aren't as simple as target.style.property = value because they've got to be applied to a proxy object and then merged into a transform string in a renderer.
    var p = _propertyAliases[property];
    p && p.indexOf(",") < 0 && (property = p);
    return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._isUndefined)(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._getSetter)(target, property);
  },
  core: {
    _removeProperty: _removeProperty,
    _getMatrix: _getMatrix
  }
};
_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.utils.checkPrefix = _checkPropPrefix;

(function (positionAndScale, rotation, others, aliases) {
  var all = (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(positionAndScale + "," + rotation + "," + others, function (name) {
    _transformProps[name] = 1;
  });

  (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(rotation, function (name) {
    _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[name] = "deg";
    _rotationalProperties[name] = 1;
  });

  _propertyAliases[all[13]] = positionAndScale + "," + rotation;

  (0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)(aliases, function (name) {
    var split = name.split(":");
    _propertyAliases[split[1]] = all[split[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");

(0,_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._forEachName)("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (name) {
  _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__._config.units[name] = "px";
});

_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.gsap.registerPlugin(CSSPlugin);


/***/ }),

/***/ "./node_modules/gsap/CSSRulePlugin.js":
/*!********************************************!*\
  !*** ./node_modules/gsap/CSSRulePlugin.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CSSRulePlugin": () => (/* binding */ CSSRulePlugin),
/* harmony export */   "default": () => (/* binding */ CSSRulePlugin)
/* harmony export */ });
/*!
 * CSSRulePlugin 3.9.1
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */
var gsap,
    _coreInitted,
    _win,
    _doc,
    CSSPlugin,
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _getGSAP = function _getGSAP() {
  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;
},
    _checkRegister = function _checkRegister() {
  if (!_coreInitted) {
    _initCore();

    if (!CSSPlugin) {
      console.warn("Please gsap.registerPlugin(CSSPlugin, CSSRulePlugin)");
    }
  }

  return _coreInitted;
},
    _initCore = function _initCore(core) {
  gsap = core || _getGSAP();

  if (_windowExists()) {
    _win = window;
    _doc = document;
  }

  if (gsap) {
    CSSPlugin = gsap.plugins.css;

    if (CSSPlugin) {
      _coreInitted = 1;
    }
  }
};

var CSSRulePlugin = {
  version: "3.9.1",
  name: "cssRule",
  init: function init(target, value, tween, index, targets) {
    if (!_checkRegister() || typeof target.cssText === "undefined") {
      return false;
    }

    var div = target._gsProxy = target._gsProxy || _doc.createElement("div");

    this.ss = target;
    this.style = div.style;
    div.style.cssText = target.cssText;
    CSSPlugin.prototype.init.call(this, div, value, tween, index, targets); //we just offload all the work to the regular CSSPlugin and then copy the cssText back over to the rule in the render() method. This allows us to have all of the updates to CSSPlugin automatically flow through to CSSRulePlugin instead of having to maintain both
  },
  render: function render(ratio, data) {
    var pt = data._pt,
        style = data.style,
        ss = data.ss,
        i;

    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }

    i = style.length;

    while (--i > -1) {
      ss[style[i]] = style[style[i]];
    }
  },
  getRule: function getRule(selector) {
    _checkRegister();

    var ruleProp = _doc.all ? "rules" : "cssRules",
        styleSheets = _doc.styleSheets,
        i = styleSheets.length,
        pseudo = selector.charAt(0) === ":",
        j,
        curSS,
        cs,
        a;
    selector = (pseudo ? "" : ",") + selector.split("::").join(":").toLowerCase() + ","; //note: old versions of IE report tag name selectors as upper case, so we just change everything to lowercase.

    if (pseudo) {
      a = [];
    }

    while (i--) {
      //Firefox may throw insecure operation errors when css is loaded from other domains, so try/catch.
      try {
        curSS = styleSheets[i][ruleProp];

        if (!curSS) {
          continue;
        }

        j = curSS.length;
      } catch (e) {
        console.warn(e);
        continue;
      }

      while (--j > -1) {
        cs = curSS[j];

        if (cs.selectorText && ("," + cs.selectorText.split("::").join(":").toLowerCase() + ",").indexOf(selector) !== -1) {
          //note: IE adds an extra ":" to pseudo selectors, so .myClass:after becomes .myClass::after, so we need to strip the extra one out.
          if (pseudo) {
            a.push(cs.style);
          } else {
            return cs.style;
          }
        }
      }
    }

    return a;
  },
  register: _initCore
};
_getGSAP() && gsap.registerPlugin(CSSRulePlugin);


/***/ }),

/***/ "./node_modules/gsap/CustomEase.js":
/*!*****************************************!*\
  !*** ./node_modules/gsap/CustomEase.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CustomEase": () => (/* binding */ CustomEase),
/* harmony export */   "default": () => (/* binding */ CustomEase)
/* harmony export */ });
/* harmony import */ var _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/paths.js */ "./node_modules/gsap/utils/paths.js");
/*!
 * CustomEase 3.9.1
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */


var gsap,
    _coreInitted,
    _getGSAP = function _getGSAP() {
  return gsap || typeof window !== "undefined" && (gsap = window.gsap) && gsap.registerPlugin && gsap;
},
    _initCore = function _initCore() {
  gsap = _getGSAP();

  if (gsap) {
    gsap.registerEase("_CE", CustomEase.create);
    _coreInitted = 1;
  } else {
    console.warn("Please gsap.registerPlugin(CustomEase)");
  }
},
    _bigNum = 1e20,
    _round = function _round(value) {
  return ~~(value * 1000 + (value < 0 ? -.5 : .5)) / 1000;
},
    _bonusValidated = 1,
    //<name>CustomEase</name>
_numExp = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi,
    //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.
_needsParsingExp = /[cLlsSaAhHvVtTqQ]/g,
    _findMinimum = function _findMinimum(values) {
  var l = values.length,
      min = _bigNum,
      i;

  for (i = 1; i < l; i += 6) {
    +values[i] < min && (min = +values[i]);
  }

  return min;
},
    //takes all the points and translates/scales them so that the x starts at 0 and ends at 1.
_normalize = function _normalize(values, height, originY) {
  if (!originY && originY !== 0) {
    originY = Math.max(+values[values.length - 1], +values[1]);
  }

  var tx = +values[0] * -1,
      ty = -originY,
      l = values.length,
      sx = 1 / (+values[l - 2] + tx),
      sy = -height || (Math.abs(+values[l - 1] - +values[1]) < 0.01 * (+values[l - 2] - +values[0]) ? _findMinimum(values) + ty : +values[l - 1] + ty),
      i;

  if (sy) {
    //typically y ends at 1 (so that the end values are reached)
    sy = 1 / sy;
  } else {
    //in case the ease returns to its beginning value, scale everything proportionally
    sy = -sx;
  }

  for (i = 0; i < l; i += 2) {
    values[i] = (+values[i] + tx) * sx;
    values[i + 1] = (+values[i + 1] + ty) * sy;
  }
},
    //note that this function returns point objects like {x, y} rather than working with segments which are arrays with alternating x, y values as in the similar function in paths.js
_bezierToPoints = function _bezierToPoints(x1, y1, x2, y2, x3, y3, x4, y4, threshold, points, index) {
  var x12 = (x1 + x2) / 2,
      y12 = (y1 + y2) / 2,
      x23 = (x2 + x3) / 2,
      y23 = (y2 + y3) / 2,
      x34 = (x3 + x4) / 2,
      y34 = (y3 + y4) / 2,
      x123 = (x12 + x23) / 2,
      y123 = (y12 + y23) / 2,
      x234 = (x23 + x34) / 2,
      y234 = (y23 + y34) / 2,
      x1234 = (x123 + x234) / 2,
      y1234 = (y123 + y234) / 2,
      dx = x4 - x1,
      dy = y4 - y1,
      d2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx),
      d3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx),
      length;

  if (!points) {
    points = [{
      x: x1,
      y: y1
    }, {
      x: x4,
      y: y4
    }];
    index = 1;
  }

  points.splice(index || points.length - 1, 0, {
    x: x1234,
    y: y1234
  });

  if ((d2 + d3) * (d2 + d3) > threshold * (dx * dx + dy * dy)) {
    length = points.length;

    _bezierToPoints(x1, y1, x12, y12, x123, y123, x1234, y1234, threshold, points, index);

    _bezierToPoints(x1234, y1234, x234, y234, x34, y34, x4, y4, threshold, points, index + 1 + (points.length - length));
  }

  return points;
};

var CustomEase = /*#__PURE__*/function () {
  function CustomEase(id, data, config) {
    _coreInitted || _initCore();
    this.id = id;
    _bonusValidated && this.setData(data, config);
  }

  var _proto = CustomEase.prototype;

  _proto.setData = function setData(data, config) {
    config = config || {};
    data = data || "0,0,1,1";
    var values = data.match(_numExp),
        closest = 1,
        points = [],
        lookup = [],
        precision = config.precision || 1,
        fast = precision <= 1,
        l,
        a1,
        a2,
        i,
        inc,
        j,
        point,
        prevPoint,
        p;
    this.data = data;

    if (_needsParsingExp.test(data) || ~data.indexOf("M") && data.indexOf("C") < 0) {
      values = (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.stringToRawPath)(data)[0];
    }

    l = values.length;

    if (l === 4) {
      values.unshift(0, 0);
      values.push(1, 1);
      l = 8;
    } else if ((l - 2) % 6) {
      throw "Invalid CustomEase";
    }

    if (+values[0] !== 0 || +values[l - 2] !== 1) {
      _normalize(values, config.height, config.originY);
    }

    this.segment = values;

    for (i = 2; i < l; i += 6) {
      a1 = {
        x: +values[i - 2],
        y: +values[i - 1]
      };
      a2 = {
        x: +values[i + 4],
        y: +values[i + 5]
      };
      points.push(a1, a2);

      _bezierToPoints(a1.x, a1.y, +values[i], +values[i + 1], +values[i + 2], +values[i + 3], a2.x, a2.y, 1 / (precision * 200000), points, points.length - 1);
    }

    l = points.length;

    for (i = 0; i < l; i++) {
      point = points[i];
      prevPoint = points[i - 1] || point;

      if ((point.x > prevPoint.x || prevPoint.y !== point.y && prevPoint.x === point.x || point === prevPoint) && point.x <= 1) {
        //if a point goes BACKWARD in time or is a duplicate, just drop it. Also it shouldn't go past 1 on the x axis, as could happen in a string like "M0,0 C0,0 0.12,0.68 0.18,0.788 0.195,0.845 0.308,1 0.32,1 0.403,1.005 0.398,1 0.5,1 0.602,1 0.816,1.005 0.9,1 0.91,1 0.948,0.69 0.962,0.615 1.003,0.376 1,0 1,0".
        prevPoint.cx = point.x - prevPoint.x; //change in x between this point and the next point (performance optimization)

        prevPoint.cy = point.y - prevPoint.y;
        prevPoint.n = point;
        prevPoint.nx = point.x; //next point's x value (performance optimization, making lookups faster in getRatio()). Remember, the lookup will always land on a spot where it's either this point or the very next one (never beyond that)

        if (fast && i > 1 && Math.abs(prevPoint.cy / prevPoint.cx - points[i - 2].cy / points[i - 2].cx) > 2) {
          //if there's a sudden change in direction, prioritize accuracy over speed. Like a bounce ease - you don't want to risk the sampling chunks landing on each side of the bounce anchor and having it clipped off.
          fast = 0;
        }

        if (prevPoint.cx < closest) {
          if (!prevPoint.cx) {
            prevPoint.cx = 0.001; //avoids math problems in getRatio() (dividing by zero)

            if (i === l - 1) {
              //in case the final segment goes vertical RIGHT at the end, make sure we end at the end.
              prevPoint.x -= 0.001;
              closest = Math.min(closest, 0.001);
              fast = 0;
            }
          } else {
            closest = prevPoint.cx;
          }
        }
      } else {
        points.splice(i--, 1);
        l--;
      }
    }

    l = 1 / closest + 1 | 0;
    inc = 1 / l;
    j = 0;
    point = points[0];

    if (fast) {
      for (i = 0; i < l; i++) {
        //for fastest lookups, we just sample along the path at equal x (time) distance. Uses more memory and is slightly less accurate for anchors that don't land on the sampling points, but for the vast majority of eases it's excellent (and fast).
        p = i * inc;

        if (point.nx < p) {
          point = points[++j];
        }

        a1 = point.y + (p - point.x) / point.cx * point.cy;
        lookup[i] = {
          x: p,
          cx: inc,
          y: a1,
          cy: 0,
          nx: 9
        };

        if (i) {
          lookup[i - 1].cy = a1 - lookup[i - 1].y;
        }
      }

      lookup[l - 1].cy = points[points.length - 1].y - a1;
    } else {
      //this option is more accurate, ensuring that EVERY anchor is hit perfectly. Clipping across a bounce, for example, would never happen.
      for (i = 0; i < l; i++) {
        //build a lookup table based on the smallest distance so that we can instantly find the appropriate point (well, it'll either be that point or the very next one). We'll look up based on the linear progress. So it's it's 0.5 and the lookup table has 100 elements, it'd be like lookup[Math.floor(0.5 * 100)]
        if (point.nx < i * inc) {
          point = points[++j];
        }

        lookup[i] = point;
      }

      if (j < points.length - 1) {
        lookup[i - 1] = points[points.length - 2];
      }
    } //this._calcEnd = (points[points.length-1].y !== 1 || points[0].y !== 0); //ensures that we don't run into floating point errors. As long as we're starting at 0 and ending at 1, tell GSAP to skip the final calculation and use 0/1 as the factor.


    this.ease = function (p) {
      var point = lookup[p * l | 0] || lookup[l - 1];

      if (point.nx < p) {
        point = point.n;
      }

      return point.y + (p - point.x) / point.cx * point.cy;
    };

    this.ease.custom = this;
    this.id && gsap && gsap.registerEase(this.id, this.ease);
    return this;
  };

  _proto.getSVGData = function getSVGData(config) {
    return CustomEase.getSVGData(this, config);
  };

  CustomEase.create = function create(id, data, config) {
    return new CustomEase(id, data, config).ease;
  };

  CustomEase.register = function register(core) {
    gsap = core;

    _initCore();
  };

  CustomEase.get = function get(id) {
    return gsap.parseEase(id);
  };

  CustomEase.getSVGData = function getSVGData(ease, config) {
    config = config || {};
    var width = config.width || 100,
        height = config.height || 100,
        x = config.x || 0,
        y = (config.y || 0) + height,
        e = gsap.utils.toArray(config.path)[0],
        a,
        slope,
        i,
        inc,
        tx,
        ty,
        precision,
        threshold,
        prevX,
        prevY;

    if (config.invert) {
      height = -height;
      y = 0;
    }

    if (typeof ease === "string") {
      ease = gsap.parseEase(ease);
    }

    if (ease.custom) {
      ease = ease.custom;
    }

    if (ease instanceof CustomEase) {
      a = (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.rawPathToString)((0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath)([ease.segment], width, 0, 0, -height, x, y));
    } else {
      a = [x, y];
      precision = Math.max(5, (config.precision || 1) * 200);
      inc = 1 / precision;
      precision += 2;
      threshold = 5 / precision;
      prevX = _round(x + inc * width);
      prevY = _round(y + ease(inc) * -height);
      slope = (prevY - y) / (prevX - x);

      for (i = 2; i < precision; i++) {
        tx = _round(x + i * inc * width);
        ty = _round(y + ease(i * inc) * -height);

        if (Math.abs((ty - prevY) / (tx - prevX) - slope) > threshold || i === precision - 1) {
          //only add points when the slope changes beyond the threshold
          a.push(prevX, prevY);
          slope = (ty - prevY) / (tx - prevX);
        }

        prevX = tx;
        prevY = ty;
      }

      a = "M" + a.join(",");
    }

    e && e.setAttribute("d", a);
    return a;
  };

  return CustomEase;
}();
_getGSAP() && gsap.registerPlugin(CustomEase);
CustomEase.version = "3.9.1";


/***/ }),

/***/ "./node_modules/gsap/Draggable.js":
/*!****************************************!*\
  !*** ./node_modules/gsap/Draggable.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Draggable": () => (/* binding */ Draggable),
/* harmony export */   "default": () => (/* binding */ Draggable)
/* harmony export */ });
/* harmony import */ var _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/matrix.js */ "./node_modules/gsap/utils/matrix.js");
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/*!
 * Draggable 3.9.1
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */

/* eslint-disable */


var gsap,
    _win,
    _doc,
    _docElement,
    _body,
    _tempDiv,
    _placeholderDiv,
    _coreInitted,
    _checkPrefix,
    _toArray,
    _supportsPassive,
    _isTouchDevice,
    _touchEventLookup,
    _dragCount,
    _isMultiTouching,
    _isAndroid,
    InertiaPlugin,
    _defaultCursor,
    _supportsPointer,
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _getGSAP = function _getGSAP() {
  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;
},
    _isFunction = function _isFunction(value) {
  return typeof value === "function";
},
    _isObject = function _isObject(value) {
  return typeof value === "object";
},
    _isUndefined = function _isUndefined(value) {
  return typeof value === "undefined";
},
    _emptyFunc = function _emptyFunc() {
  return false;
},
    _transformProp = "transform",
    _transformOriginProp = "transformOrigin",
    _round = function _round(value) {
  return Math.round(value * 10000) / 10000;
},
    _isArray = Array.isArray,
    _createElement = function _createElement(type, ns) {
  var e = _doc.createElementNS ? _doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making "style" inaccessible.

  return e.style ? e : _doc.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://greensock.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).
},
    _RAD2DEG = 180 / Math.PI,
    _bigNum = 1e20,
    _identityMatrix = new _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.Matrix2D(),
    _getTime = Date.now || function () {
  return new Date().getTime();
},
    _renderQueue = [],
    _lookup = {},
    //when a Draggable is created, the target gets a unique _gsDragID property that allows gets associated with the Draggable instance for quick lookups in Draggable.get(). This avoids circular references that could cause gc problems.
_lookupCount = 0,
    _clickableTagExp = /^(?:a|input|textarea|button|select)$/i,
    _lastDragTime = 0,
    _temp1 = {},
    // a simple object we reuse and populate (usually x/y properties) to conserve memory and improve performance.
_windowProxy = {},
    //memory/performance optimization - we reuse this object during autoScroll to store window-related bounds/offsets.
_copy = function _copy(obj, factor) {
  var copy = {},
      p;

  for (p in obj) {
    copy[p] = factor ? obj[p] * factor : obj[p];
  }

  return copy;
},
    _extend = function _extend(obj, defaults) {
  for (var p in defaults) {
    if (!(p in obj)) {
      obj[p] = defaults[p];
    }
  }

  return obj;
},
    _setTouchActionForAllDescendants = function _setTouchActionForAllDescendants(elements, value) {
  var i = elements.length,
      children;

  while (i--) {
    value ? elements[i].style.touchAction = value : elements[i].style.removeProperty("touch-action");
    children = elements[i].children;
    children && children.length && _setTouchActionForAllDescendants(children, value);
  }
},
    _renderQueueTick = function _renderQueueTick() {
  return _renderQueue.forEach(function (func) {
    return func();
  });
},
    _addToRenderQueue = function _addToRenderQueue(func) {
  _renderQueue.push(func);

  if (_renderQueue.length === 1) {
    gsap.ticker.add(_renderQueueTick);
  }
},
    _renderQueueTimeout = function _renderQueueTimeout() {
  return !_renderQueue.length && gsap.ticker.remove(_renderQueueTick);
},
    _removeFromRenderQueue = function _removeFromRenderQueue(func) {
  var i = _renderQueue.length;

  while (i--) {
    if (_renderQueue[i] === func) {
      _renderQueue.splice(i, 1);
    }
  }

  gsap.to(_renderQueueTimeout, {
    overwrite: true,
    delay: 15,
    duration: 0,
    onComplete: _renderQueueTimeout,
    data: "_draggable"
  }); //remove the "tick" listener only after the render queue is empty for 15 seconds (to improve performance). Adding/removing it constantly for every click/touch wouldn't deliver optimal speed, and we also don't want the ticker to keep calling the render method when things are idle for long periods of time (we want to improve battery life on mobile devices).
},
    _setDefaults = function _setDefaults(obj, defaults) {
  for (var p in defaults) {
    if (!(p in obj)) {
      obj[p] = defaults[p];
    }
  }

  return obj;
},
    _addListener = function _addListener(element, type, func, capture) {
  if (element.addEventListener) {
    var touchType = _touchEventLookup[type];
    capture = capture || (_supportsPassive ? {
      passive: false
    } : null);
    element.addEventListener(touchType || type, func, capture);
    touchType && type !== touchType && element.addEventListener(type, func, capture); //some browsers actually support both, so must we. But pointer events cover all.
  }
},
    _removeListener = function _removeListener(element, type, func) {
  if (element.removeEventListener) {
    var touchType = _touchEventLookup[type];
    element.removeEventListener(touchType || type, func);
    touchType && type !== touchType && element.removeEventListener(type, func);
  }
},
    _preventDefault = function _preventDefault(event) {
  event.preventDefault && event.preventDefault();
  event.preventManipulation && event.preventManipulation(); //for some Microsoft browsers
},
    _hasTouchID = function _hasTouchID(list, ID) {
  var i = list.length;

  while (i--) {
    if (list[i].identifier === ID) {
      return true;
    }
  }
},
    _onMultiTouchDocumentEnd = function _onMultiTouchDocumentEnd(event) {
  _isMultiTouching = event.touches && _dragCount < event.touches.length;

  _removeListener(event.target, "touchend", _onMultiTouchDocumentEnd);
},
    _onMultiTouchDocument = function _onMultiTouchDocument(event) {
  _isMultiTouching = event.touches && _dragCount < event.touches.length;

  _addListener(event.target, "touchend", _onMultiTouchDocumentEnd);
},
    _getDocScrollTop = function _getDocScrollTop(doc) {
  return _win.pageYOffset || doc.scrollTop || doc.documentElement.scrollTop || doc.body.scrollTop || 0;
},
    _getDocScrollLeft = function _getDocScrollLeft(doc) {
  return _win.pageXOffset || doc.scrollLeft || doc.documentElement.scrollLeft || doc.body.scrollLeft || 0;
},
    _addScrollListener = function _addScrollListener(e, callback) {
  _addListener(e, "scroll", callback);

  if (!_isRoot(e.parentNode)) {
    _addScrollListener(e.parentNode, callback);
  }
},
    _removeScrollListener = function _removeScrollListener(e, callback) {
  _removeListener(e, "scroll", callback);

  if (!_isRoot(e.parentNode)) {
    _removeScrollListener(e.parentNode, callback);
  }
},
    _isRoot = function _isRoot(e) {
  return !!(!e || e === _docElement || e.nodeType === 9 || e === _doc.body || e === _win || !e.nodeType || !e.parentNode);
},
    _getMaxScroll = function _getMaxScroll(element, axis) {
  var dim = axis === "x" ? "Width" : "Height",
      scroll = "scroll" + dim,
      client = "client" + dim;
  return Math.max(0, _isRoot(element) ? Math.max(_docElement[scroll], _body[scroll]) - (_win["inner" + dim] || _docElement[client] || _body[client]) : element[scroll] - element[client]);
},
    _recordMaxScrolls = function _recordMaxScrolls(e, skipCurrent) {
  //records _gsMaxScrollX and _gsMaxScrollY properties for the element and all ancestors up the chain so that we can cap it, otherwise dragging beyond the edges with autoScroll on can endlessly scroll.
  var x = _getMaxScroll(e, "x"),
      y = _getMaxScroll(e, "y");

  if (_isRoot(e)) {
    e = _windowProxy;
  } else {
    _recordMaxScrolls(e.parentNode, skipCurrent);
  }

  e._gsMaxScrollX = x;
  e._gsMaxScrollY = y;

  if (!skipCurrent) {
    e._gsScrollX = e.scrollLeft || 0;
    e._gsScrollY = e.scrollTop || 0;
  }
},
    _setStyle = function _setStyle(element, property, value) {
  var style = element.style;

  if (!style) {
    return;
  }

  if (_isUndefined(style[property])) {
    property = _checkPrefix(property, element) || property;
  }

  if (value == null) {
    style.removeProperty && style.removeProperty(property.replace(/([A-Z])/g, "-$1").toLowerCase());
  } else {
    style[property] = value;
  }
},
    _getComputedStyle = function _getComputedStyle(element) {
  return _win.getComputedStyle(element instanceof Element ? element : element.host || (element.parentNode || {}).host || element);
},
    //the "host" stuff helps to accommodate ShadowDom objects.
_tempRect = {},
    //reuse to reduce garbage collection tasks
_parseRect = function _parseRect(e) {
  //accepts a DOM element, a mouse event, or a rectangle object and returns the corresponding rectangle with left, right, width, height, top, and bottom properties
  if (e === _win) {
    _tempRect.left = _tempRect.top = 0;
    _tempRect.width = _tempRect.right = _docElement.clientWidth || e.innerWidth || _body.clientWidth || 0;
    _tempRect.height = _tempRect.bottom = (e.innerHeight || 0) - 20 < _docElement.clientHeight ? _docElement.clientHeight : e.innerHeight || _body.clientHeight || 0;
    return _tempRect;
  }

  var doc = e.ownerDocument || _doc,
      r = !_isUndefined(e.pageX) ? {
    left: e.pageX - _getDocScrollLeft(doc),
    top: e.pageY - _getDocScrollTop(doc),
    right: e.pageX - _getDocScrollLeft(doc) + 1,
    bottom: e.pageY - _getDocScrollTop(doc) + 1
  } : !e.nodeType && !_isUndefined(e.left) && !_isUndefined(e.top) ? e : _toArray(e)[0].getBoundingClientRect();

  if (_isUndefined(r.right) && !_isUndefined(r.width)) {
    r.right = r.left + r.width;
    r.bottom = r.top + r.height;
  } else if (_isUndefined(r.width)) {
    //some browsers don't include width and height properties. We can't just set them directly on r because some browsers throw errors, so create a new generic object.
    r = {
      width: r.right - r.left,
      height: r.bottom - r.top,
      right: r.right,
      left: r.left,
      bottom: r.bottom,
      top: r.top
    };
  }

  return r;
},
    _dispatchEvent = function _dispatchEvent(target, type, callbackName) {
  var vars = target.vars,
      callback = vars[callbackName],
      listeners = target._listeners[type],
      result;

  if (_isFunction(callback)) {
    result = callback.apply(vars.callbackScope || target, vars[callbackName + "Params"] || [target.pointerEvent]);
  }

  if (listeners && target.dispatchEvent(type) === false) {
    result = false;
  }

  return result;
},
    _getBounds = function _getBounds(target, context) {
  //accepts any of the following: a DOM element, jQuery object, selector text, or an object defining bounds as {top, left, width, height} or {minX, maxX, minY, maxY}. Returns an object with left, top, width, and height properties.
  var e = _toArray(target)[0],
      top,
      left,
      offset;

  if (!e.nodeType && e !== _win) {
    if (!_isUndefined(target.left)) {
      offset = {
        x: 0,
        y: 0
      }; //_getOffsetTransformOrigin(context); //the bounds should be relative to the origin

      return {
        left: target.left - offset.x,
        top: target.top - offset.y,
        width: target.width,
        height: target.height
      };
    }

    left = target.min || target.minX || target.minRotation || 0;
    top = target.min || target.minY || 0;
    return {
      left: left,
      top: top,
      width: (target.max || target.maxX || target.maxRotation || 0) - left,
      height: (target.max || target.maxY || 0) - top
    };
  }

  return _getElementBounds(e, context);
},
    _point1 = {},
    //we reuse to minimize garbage collection tasks.
_getElementBounds = function _getElementBounds(element, context) {
  context = _toArray(context)[0];
  var isSVG = element.getBBox && element.ownerSVGElement,
      doc = element.ownerDocument || _doc,
      left,
      right,
      top,
      bottom,
      matrix,
      p1,
      p2,
      p3,
      p4,
      bbox,
      width,
      height,
      cs,
      contextParent;

  if (element === _win) {
    top = _getDocScrollTop(doc);
    left = _getDocScrollLeft(doc);
    right = left + (doc.documentElement.clientWidth || element.innerWidth || doc.body.clientWidth || 0);
    bottom = top + ((element.innerHeight || 0) - 20 < doc.documentElement.clientHeight ? doc.documentElement.clientHeight : element.innerHeight || doc.body.clientHeight || 0); //some browsers (like Firefox) ignore absolutely positioned elements, and collapse the height of the documentElement, so it could be 8px, for example, if you have just an absolutely positioned div. In that case, we use the innerHeight to resolve this.
  } else if (context === _win || _isUndefined(context)) {
    return element.getBoundingClientRect();
  } else {
    left = top = 0;

    if (isSVG) {
      bbox = element.getBBox();
      width = bbox.width;
      height = bbox.height;
    } else {
      if (element.viewBox && (bbox = element.viewBox.baseVal)) {
        left = bbox.x || 0;
        top = bbox.y || 0;
        width = bbox.width;
        height = bbox.height;
      }

      if (!width) {
        cs = _getComputedStyle(element);
        bbox = cs.boxSizing === "border-box";
        width = (parseFloat(cs.width) || element.clientWidth || 0) + (bbox ? 0 : parseFloat(cs.borderLeftWidth) + parseFloat(cs.borderRightWidth));
        height = (parseFloat(cs.height) || element.clientHeight || 0) + (bbox ? 0 : parseFloat(cs.borderTopWidth) + parseFloat(cs.borderBottomWidth));
      }
    }

    right = width;
    bottom = height;
  }

  if (element === context) {
    return {
      left: left,
      top: top,
      width: right - left,
      height: bottom - top
    };
  }

  matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(context, true).multiply((0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(element));
  p1 = matrix.apply({
    x: left,
    y: top
  });
  p2 = matrix.apply({
    x: right,
    y: top
  });
  p3 = matrix.apply({
    x: right,
    y: bottom
  });
  p4 = matrix.apply({
    x: left,
    y: bottom
  });
  left = Math.min(p1.x, p2.x, p3.x, p4.x);
  top = Math.min(p1.y, p2.y, p3.y, p4.y);
  contextParent = context.parentNode || {};
  return {
    left: left + (contextParent.scrollLeft || 0),
    top: top + (contextParent.scrollTop || 0),
    width: Math.max(p1.x, p2.x, p3.x, p4.x) - left,
    height: Math.max(p1.y, p2.y, p3.y, p4.y) - top
  };
},
    _parseInertia = function _parseInertia(draggable, snap, max, min, factor, forceZeroVelocity) {
  var vars = {},
      a,
      i,
      l;

  if (snap) {
    if (factor !== 1 && snap instanceof Array) {
      //some data must be altered to make sense, like if the user passes in an array of rotational values in degrees, we must convert it to radians. Or for scrollLeft and scrollTop, we invert the values.
      vars.end = a = [];
      l = snap.length;

      if (_isObject(snap[0])) {
        //if the array is populated with objects, like points ({x:100, y:200}), make copies before multiplying by the factor, otherwise we'll mess up the originals and the user may reuse it elsewhere.
        for (i = 0; i < l; i++) {
          a[i] = _copy(snap[i], factor);
        }
      } else {
        for (i = 0; i < l; i++) {
          a[i] = snap[i] * factor;
        }
      }

      max += 1.1; //allow 1.1 pixels of wiggle room when snapping in order to work around some browser inconsistencies in the way bounds are reported which can make them roughly a pixel off. For example, if "snap:[-$('#menu').width(), 0]" was defined and #menu had a wrapper that was used as the bounds, some browsers would be one pixel off, making the minimum -752 for example when snap was [-753,0], thus instead of snapping to -753, it would snap to 0 since -753 was below the minimum.

      min -= 1.1;
    } else if (_isFunction(snap)) {
      vars.end = function (value) {
        var result = snap.call(draggable, value),
            copy,
            p;

        if (factor !== 1) {
          if (_isObject(result)) {
            copy = {};

            for (p in result) {
              copy[p] = result[p] * factor;
            }

            result = copy;
          } else {
            result *= factor;
          }
        }

        return result; //we need to ensure that we can scope the function call to the Draggable instance itself so that users can access important values like maxX, minX, maxY, minY, x, and y from within that function.
      };
    } else {
      vars.end = snap;
    }
  }

  if (max || max === 0) {
    vars.max = max;
  }

  if (min || min === 0) {
    vars.min = min;
  }

  if (forceZeroVelocity) {
    vars.velocity = 0;
  }

  return vars;
},
    _isClickable = function _isClickable(element) {
  //sometimes it's convenient to mark an element as clickable by adding a data-clickable="true" attribute (in which case we won't preventDefault() the mouse/touch event). This method checks if the element is an <a>, <input>, or <button> or has an onclick or has the data-clickable or contentEditable attribute set to true (or any of its parent elements).
  var data;
  return !element || !element.getAttribute || element === _body ? false : (data = element.getAttribute("data-clickable")) === "true" || data !== "false" && (element.onclick || _clickableTagExp.test(element.nodeName + "") || element.getAttribute("contentEditable") === "true") ? true : _isClickable(element.parentNode);
},
    _setSelectable = function _setSelectable(elements, selectable) {
  var i = elements.length,
      e;

  while (i--) {
    e = elements[i];
    e.ondragstart = e.onselectstart = selectable ? null : _emptyFunc;
    gsap.set(e, {
      lazy: true,
      userSelect: selectable ? "text" : "none"
    });
  }
},
    _isFixed = function _isFixed(element) {
  if (_getComputedStyle(element).position === "fixed") {
    return true;
  }

  element = element.parentNode;

  if (element && element.nodeType === 1) {
    // avoid document fragments which will throw an error.
    return _isFixed(element);
  }
},
    _supports3D,
    _addPaddingBR,
    //The ScrollProxy class wraps an element's contents into another div (we call it "content") that we either add padding when necessary or apply a translate3d() transform in order to overscroll (scroll past the boundaries). This allows us to simply set the scrollTop/scrollLeft (or top/left for easier reverse-axis orientation, which is what we do in Draggable) and it'll do all the work for us. For example, if we tried setting scrollTop to -100 on a normal DOM element, it wouldn't work - it'd look the same as setting it to 0, but if we set scrollTop of a ScrollProxy to -100, it'll give the correct appearance by either setting paddingTop of the wrapper to 100 or applying a 100-pixel translateY.
ScrollProxy = function ScrollProxy(element, vars) {
  element = gsap.utils.toArray(element)[0];
  vars = vars || {};
  var content = document.createElement("div"),
      style = content.style,
      node = element.firstChild,
      offsetTop = 0,
      offsetLeft = 0,
      prevTop = element.scrollTop,
      prevLeft = element.scrollLeft,
      scrollWidth = element.scrollWidth,
      scrollHeight = element.scrollHeight,
      extraPadRight = 0,
      maxLeft = 0,
      maxTop = 0,
      elementWidth,
      elementHeight,
      contentHeight,
      nextNode,
      transformStart,
      transformEnd;

  if (_supports3D && vars.force3D !== false) {
    transformStart = "translate3d(";
    transformEnd = "px,0px)";
  } else if (_transformProp) {
    transformStart = "translate(";
    transformEnd = "px)";
  }

  this.scrollTop = function (value, force) {
    if (!arguments.length) {
      return -this.top();
    }

    this.top(-value, force);
  };

  this.scrollLeft = function (value, force) {
    if (!arguments.length) {
      return -this.left();
    }

    this.left(-value, force);
  };

  this.left = function (value, force) {
    if (!arguments.length) {
      return -(element.scrollLeft + offsetLeft);
    }

    var dif = element.scrollLeft - prevLeft,
        oldOffset = offsetLeft;

    if ((dif > 2 || dif < -2) && !force) {
      //if the user interacts with the scrollbar (or something else scrolls it, like the mouse wheel), we should kill any tweens of the ScrollProxy.
      prevLeft = element.scrollLeft;
      gsap.killTweensOf(this, {
        left: 1,
        scrollLeft: 1
      });
      this.left(-prevLeft);

      if (vars.onKill) {
        vars.onKill();
      }

      return;
    }

    value = -value; //invert because scrolling works in the opposite direction

    if (value < 0) {
      offsetLeft = value - 0.5 | 0;
      value = 0;
    } else if (value > maxLeft) {
      offsetLeft = value - maxLeft | 0;
      value = maxLeft;
    } else {
      offsetLeft = 0;
    }

    if (offsetLeft || oldOffset) {
      if (!this._skip) {
        style[_transformProp] = transformStart + -offsetLeft + "px," + -offsetTop + transformEnd;
      }

      if (offsetLeft + extraPadRight >= 0) {
        style.paddingRight = offsetLeft + extraPadRight + "px";
      }
    }

    element.scrollLeft = value | 0;
    prevLeft = element.scrollLeft; //don't merge this with the line above because some browsers adjust the scrollLeft after it's set, so in order to be 100% accurate in tracking it, we need to ask the browser to report it.
  };

  this.top = function (value, force) {
    if (!arguments.length) {
      return -(element.scrollTop + offsetTop);
    }

    var dif = element.scrollTop - prevTop,
        oldOffset = offsetTop;

    if ((dif > 2 || dif < -2) && !force) {
      //if the user interacts with the scrollbar (or something else scrolls it, like the mouse wheel), we should kill any tweens of the ScrollProxy.
      prevTop = element.scrollTop;
      gsap.killTweensOf(this, {
        top: 1,
        scrollTop: 1
      });
      this.top(-prevTop);

      if (vars.onKill) {
        vars.onKill();
      }

      return;
    }

    value = -value; //invert because scrolling works in the opposite direction

    if (value < 0) {
      offsetTop = value - 0.5 | 0;
      value = 0;
    } else if (value > maxTop) {
      offsetTop = value - maxTop | 0;
      value = maxTop;
    } else {
      offsetTop = 0;
    }

    if (offsetTop || oldOffset) {
      if (!this._skip) {
        style[_transformProp] = transformStart + -offsetLeft + "px," + -offsetTop + transformEnd;
      }
    }

    element.scrollTop = value | 0;
    prevTop = element.scrollTop;
  };

  this.maxScrollTop = function () {
    return maxTop;
  };

  this.maxScrollLeft = function () {
    return maxLeft;
  };

  this.disable = function () {
    node = content.firstChild;

    while (node) {
      nextNode = node.nextSibling;
      element.appendChild(node);
      node = nextNode;
    }

    if (element === content.parentNode) {
      //in case disable() is called when it's already disabled.
      element.removeChild(content);
    }
  };

  this.enable = function () {
    node = element.firstChild;

    if (node === content) {
      return;
    }

    while (node) {
      nextNode = node.nextSibling;
      content.appendChild(node);
      node = nextNode;
    }

    element.appendChild(content);
    this.calibrate();
  };

  this.calibrate = function (force) {
    var widthMatches = element.clientWidth === elementWidth,
        cs,
        x,
        y;
    prevTop = element.scrollTop;
    prevLeft = element.scrollLeft;

    if (widthMatches && element.clientHeight === elementHeight && content.offsetHeight === contentHeight && scrollWidth === element.scrollWidth && scrollHeight === element.scrollHeight && !force) {
      return; //no need to recalculate things if the width and height haven't changed.
    }

    if (offsetTop || offsetLeft) {
      x = this.left();
      y = this.top();
      this.left(-element.scrollLeft);
      this.top(-element.scrollTop);
    }

    cs = _getComputedStyle(element); //first, we need to remove any width constraints to see how the content naturally flows so that we can see if it's wider than the containing element. If so, we've got to record the amount of overage so that we can apply that as padding in order for browsers to correctly handle things. Then we switch back to a width of 100% (without that, some browsers don't flow the content correctly)

    if (!widthMatches || force) {
      style.display = "block";
      style.width = "auto";
      style.paddingRight = "0px";
      extraPadRight = Math.max(0, element.scrollWidth - element.clientWidth); //if the content is wider than the container, we need to add the paddingLeft and paddingRight in order for things to behave correctly.

      if (extraPadRight) {
        extraPadRight += parseFloat(cs.paddingLeft) + (_addPaddingBR ? parseFloat(cs.paddingRight) : 0);
      }
    }

    style.display = "inline-block";
    style.position = "relative";
    style.overflow = "visible";
    style.verticalAlign = "top";
    style.boxSizing = "content-box";
    style.width = "100%";
    style.paddingRight = extraPadRight + "px"; //some browsers neglect to factor in the bottom padding when calculating the scrollHeight, so we need to add that padding to the content when that happens. Allow a 2px margin for error

    if (_addPaddingBR) {
      style.paddingBottom = cs.paddingBottom;
    }

    elementWidth = element.clientWidth;
    elementHeight = element.clientHeight;
    scrollWidth = element.scrollWidth;
    scrollHeight = element.scrollHeight;
    maxLeft = element.scrollWidth - elementWidth;
    maxTop = element.scrollHeight - elementHeight;
    contentHeight = content.offsetHeight;
    style.display = "block";

    if (x || y) {
      this.left(x);
      this.top(y);
    }
  };

  this.content = content;
  this.element = element;
  this._skip = false;
  this.enable();
},
    _initCore = function _initCore(required) {
  if (_windowExists() && document.body) {
    var nav = window && window.navigator;
    _win = window;
    _doc = document;
    _docElement = _doc.documentElement;
    _body = _doc.body;
    _tempDiv = _createElement("div");
    _supportsPointer = !!window.PointerEvent;
    _placeholderDiv = _createElement("div");
    _placeholderDiv.style.cssText = "visibility:hidden;height:1px;top:-1px;pointer-events:none;position:relative;clear:both;cursor:grab";
    _defaultCursor = _placeholderDiv.style.cursor === "grab" ? "grab" : "move";
    _isAndroid = nav && nav.userAgent.toLowerCase().indexOf("android") !== -1; //Android handles touch events in an odd way and it's virtually impossible to "feature test" so we resort to UA sniffing

    _isTouchDevice = "ontouchstart" in _docElement && "orientation" in _win || nav && (nav.MaxTouchPoints > 0 || nav.msMaxTouchPoints > 0);

    _addPaddingBR = function () {
      //this function is in charge of analyzing browser behavior related to padding. It sets the _addPaddingBR to true if the browser doesn't normally factor in the bottom or right padding on the element inside the scrolling area, and it sets _addPaddingLeft to true if it's a browser that requires the extra offset (offsetLeft) to be added to the paddingRight (like Opera).
      var div = _createElement("div"),
          child = _createElement("div"),
          childStyle = child.style,
          parent = _body,
          val;

      childStyle.display = "inline-block";
      childStyle.position = "relative";
      div.style.cssText = child.innerHTML = "width:90px;height:40px;padding:10px;overflow:auto;visibility:hidden";
      div.appendChild(child);
      parent.appendChild(div);
      val = child.offsetHeight + 18 > div.scrollHeight; //div.scrollHeight should be child.offsetHeight + 20 because of the 10px of padding on each side, but some browsers ignore one side. We allow a 2px margin of error.

      parent.removeChild(div);
      return val;
    }();

    _touchEventLookup = function (types) {
      //we create an object that makes it easy to translate touch event types into their "pointer" counterparts if we're in a browser that uses those instead. Like IE10 uses "MSPointerDown" instead of "touchstart", for example.
      var standard = types.split(","),
          converted = ("onpointerdown" in _tempDiv ? "pointerdown,pointermove,pointerup,pointercancel" : "onmspointerdown" in _tempDiv ? "MSPointerDown,MSPointerMove,MSPointerUp,MSPointerCancel" : types).split(","),
          obj = {},
          i = 4;

      while (--i > -1) {
        obj[standard[i]] = converted[i];
        obj[converted[i]] = standard[i];
      } //to avoid problems in iOS 9, test to see if the browser supports the "passive" option on addEventListener().


      try {
        _docElement.addEventListener("test", null, Object.defineProperty({}, "passive", {
          get: function get() {
            _supportsPassive = 1;
          }
        }));
      } catch (e) {}

      return obj;
    }("touchstart,touchmove,touchend,touchcancel");

    _addListener(_doc, "touchcancel", _emptyFunc); //some older Android devices intermittently stop dispatching "touchmove" events if we don't listen for "touchcancel" on the document. Very strange indeed.


    _addListener(_win, "touchmove", _emptyFunc); //works around Safari bugs that still allow the page to scroll even when we preventDefault() on the touchmove event.


    _body && _body.addEventListener("touchstart", _emptyFunc); //works around Safari bug: https://greensock.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/

    _addListener(_doc, "contextmenu", function () {
      for (var p in _lookup) {
        if (_lookup[p].isPressed) {
          _lookup[p].endDrag();
        }
      }
    });

    gsap = _coreInitted = _getGSAP();
  }

  if (gsap) {
    InertiaPlugin = gsap.plugins.inertia;
    _checkPrefix = gsap.utils.checkPrefix;
    _transformProp = _checkPrefix(_transformProp);
    _transformOriginProp = _checkPrefix(_transformOriginProp);
    _toArray = gsap.utils.toArray;
    _supports3D = !!_checkPrefix("perspective");
  } else if (required) {
    console.warn("Please gsap.registerPlugin(Draggable)");
  }
};

var EventDispatcher = /*#__PURE__*/function () {
  function EventDispatcher(target) {
    this._listeners = {};
    this.target = target || this;
  }

  var _proto = EventDispatcher.prototype;

  _proto.addEventListener = function addEventListener(type, callback) {
    var list = this._listeners[type] || (this._listeners[type] = []);

    if (!~list.indexOf(callback)) {
      list.push(callback);
    }
  };

  _proto.removeEventListener = function removeEventListener(type, callback) {
    var list = this._listeners[type],
        i = list && list.indexOf(callback) || -1;
    i > -1 && list.splice(i, 1);
  };

  _proto.dispatchEvent = function dispatchEvent(type) {
    var _this = this;

    var result;
    (this._listeners[type] || []).forEach(function (callback) {
      return callback.call(_this, {
        type: type,
        target: _this.target
      }) === false && (result = false);
    });
    return result; //if any of the callbacks return false, pass that along.
  };

  return EventDispatcher;
}();

var Draggable = /*#__PURE__*/function (_EventDispatcher) {
  _inheritsLoose(Draggable, _EventDispatcher);

  function Draggable(target, vars) {
    var _this2;

    _this2 = _EventDispatcher.call(this) || this;
    _coreInitted || _initCore(1);
    target = _toArray(target)[0]; //in case the target is a selector object or selector text

    if (!InertiaPlugin) {
      InertiaPlugin = gsap.plugins.inertia;
    }

    _this2.vars = vars = _copy(vars || {});
    _this2.target = target;
    _this2.x = _this2.y = _this2.rotation = 0;
    _this2.dragResistance = parseFloat(vars.dragResistance) || 0;
    _this2.edgeResistance = isNaN(vars.edgeResistance) ? 1 : parseFloat(vars.edgeResistance) || 0;
    _this2.lockAxis = vars.lockAxis;
    _this2.autoScroll = vars.autoScroll || 0;
    _this2.lockedAxis = null;
    _this2.allowEventDefault = !!vars.allowEventDefault;
    gsap.getProperty(target, "x"); // to ensure that transforms are instantiated.

    var type = (vars.type || "x,y").toLowerCase(),
        xyMode = ~type.indexOf("x") || ~type.indexOf("y"),
        rotationMode = type.indexOf("rotation") !== -1,
        xProp = rotationMode ? "rotation" : xyMode ? "x" : "left",
        yProp = xyMode ? "y" : "top",
        allowX = !!(~type.indexOf("x") || ~type.indexOf("left") || type === "scroll"),
        allowY = !!(~type.indexOf("y") || ~type.indexOf("top") || type === "scroll"),
        minimumMovement = vars.minimumMovement || 2,
        self = _assertThisInitialized(_this2),
        triggers = _toArray(vars.trigger || vars.handle || target),
        killProps = {},
        dragEndTime = 0,
        checkAutoScrollBounds = false,
        autoScrollMarginTop = vars.autoScrollMarginTop || 40,
        autoScrollMarginRight = vars.autoScrollMarginRight || 40,
        autoScrollMarginBottom = vars.autoScrollMarginBottom || 40,
        autoScrollMarginLeft = vars.autoScrollMarginLeft || 40,
        isClickable = vars.clickableTest || _isClickable,
        clickTime = 0,
        gsCache = target._gsap || gsap.core.getCache(target),
        isFixed = _isFixed(target),
        getPropAsNum = function getPropAsNum(property, unit) {
      return parseFloat(gsCache.get(target, property, unit));
    },
        ownerDoc = target.ownerDocument || _doc,
        enabled,
        scrollProxy,
        startPointerX,
        startPointerY,
        startElementX,
        startElementY,
        hasBounds,
        hasDragCallback,
        hasMoveCallback,
        maxX,
        minX,
        maxY,
        minY,
        touch,
        touchID,
        rotationOrigin,
        dirty,
        old,
        snapX,
        snapY,
        snapXY,
        isClicking,
        touchEventTarget,
        matrix,
        interrupted,
        allowNativeTouchScrolling,
        touchDragAxis,
        isDispatching,
        clickDispatch,
        trustedClickDispatch,
        isPreventingDefault,
        innerMatrix,
        onContextMenu = function onContextMenu(e) {
      //used to prevent long-touch from triggering a context menu.
      // (self.isPressed && e.which < 2) && self.endDrag() // previously ended drag when context menu was triggered, but instead we should just stop propagation and prevent the default event behavior.
      _preventDefault(e);

      e.stopImmediatePropagation && e.stopImmediatePropagation();
      return false;
    },
        //this method gets called on every tick of TweenLite.ticker which allows us to synchronize the renders to the core engine (which is typically synchronized with the display refresh via requestAnimationFrame). This is an optimization - it's better than applying the values inside the "mousemove" or "touchmove" event handler which may get called many times inbetween refreshes.
    render = function render(suppressEvents) {
      if (self.autoScroll && self.isDragging && (checkAutoScrollBounds || dirty)) {
        var e = target,
            autoScrollFactor = self.autoScroll * 15,
            //multiplying by 15 just gives us a better "feel" speed-wise.
        parent,
            isRoot,
            rect,
            pointerX,
            pointerY,
            changeX,
            changeY,
            gap;
        checkAutoScrollBounds = false;
        _windowProxy.scrollTop = _win.pageYOffset != null ? _win.pageYOffset : ownerDoc.documentElement.scrollTop != null ? ownerDoc.documentElement.scrollTop : ownerDoc.body.scrollTop;
        _windowProxy.scrollLeft = _win.pageXOffset != null ? _win.pageXOffset : ownerDoc.documentElement.scrollLeft != null ? ownerDoc.documentElement.scrollLeft : ownerDoc.body.scrollLeft;
        pointerX = self.pointerX - _windowProxy.scrollLeft;
        pointerY = self.pointerY - _windowProxy.scrollTop;

        while (e && !isRoot) {
          //walk up the chain and sense wherever the pointer is within 40px of an edge that's scrollable.
          isRoot = _isRoot(e.parentNode);
          parent = isRoot ? _windowProxy : e.parentNode;
          rect = isRoot ? {
            bottom: Math.max(_docElement.clientHeight, _win.innerHeight || 0),
            right: Math.max(_docElement.clientWidth, _win.innerWidth || 0),
            left: 0,
            top: 0
          } : parent.getBoundingClientRect();
          changeX = changeY = 0;

          if (allowY) {
            gap = parent._gsMaxScrollY - parent.scrollTop;

            if (gap < 0) {
              changeY = gap;
            } else if (pointerY > rect.bottom - autoScrollMarginBottom && gap) {
              checkAutoScrollBounds = true;
              changeY = Math.min(gap, autoScrollFactor * (1 - Math.max(0, rect.bottom - pointerY) / autoScrollMarginBottom) | 0);
            } else if (pointerY < rect.top + autoScrollMarginTop && parent.scrollTop) {
              checkAutoScrollBounds = true;
              changeY = -Math.min(parent.scrollTop, autoScrollFactor * (1 - Math.max(0, pointerY - rect.top) / autoScrollMarginTop) | 0);
            }

            if (changeY) {
              parent.scrollTop += changeY;
            }
          }

          if (allowX) {
            gap = parent._gsMaxScrollX - parent.scrollLeft;

            if (gap < 0) {
              changeX = gap;
            } else if (pointerX > rect.right - autoScrollMarginRight && gap) {
              checkAutoScrollBounds = true;
              changeX = Math.min(gap, autoScrollFactor * (1 - Math.max(0, rect.right - pointerX) / autoScrollMarginRight) | 0);
            } else if (pointerX < rect.left + autoScrollMarginLeft && parent.scrollLeft) {
              checkAutoScrollBounds = true;
              changeX = -Math.min(parent.scrollLeft, autoScrollFactor * (1 - Math.max(0, pointerX - rect.left) / autoScrollMarginLeft) | 0);
            }

            if (changeX) {
              parent.scrollLeft += changeX;
            }
          }

          if (isRoot && (changeX || changeY)) {
            _win.scrollTo(parent.scrollLeft, parent.scrollTop);

            setPointerPosition(self.pointerX + changeX, self.pointerY + changeY);
          }

          e = parent;
        }
      }

      if (dirty) {
        var x = self.x,
            y = self.y;

        if (rotationMode) {
          self.deltaX = x - parseFloat(gsCache.rotation);
          self.rotation = x;
          gsCache.rotation = x + "deg";
          gsCache.renderTransform(1, gsCache);
        } else {
          if (scrollProxy) {
            if (allowY) {
              self.deltaY = y - scrollProxy.top();
              scrollProxy.top(y);
            }

            if (allowX) {
              self.deltaX = x - scrollProxy.left();
              scrollProxy.left(x);
            }
          } else if (xyMode) {
            if (allowY) {
              self.deltaY = y - parseFloat(gsCache.y);
              gsCache.y = y + "px";
            }

            if (allowX) {
              self.deltaX = x - parseFloat(gsCache.x);
              gsCache.x = x + "px";
            }

            gsCache.renderTransform(1, gsCache);
          } else {
            if (allowY) {
              self.deltaY = y - parseFloat(target.style.top || 0);
              target.style.top = y + "px";
            }

            if (allowX) {
              self.deltaX = x - parseFloat(target.style.left || 0);
              target.style.left = x + "px";
            }
          }
        }

        if (hasDragCallback && !suppressEvents && !isDispatching) {
          isDispatching = true; //in case onDrag has an update() call (avoid endless loop)

          if (_dispatchEvent(self, "drag", "onDrag") === false) {
            if (allowX) {
              self.x -= self.deltaX;
            }

            if (allowY) {
              self.y -= self.deltaY;
            }

            render(true);
          }

          isDispatching = false;
        }
      }

      dirty = false;
    },
        //copies the x/y from the element (whether that be transforms, top/left, or ScrollProxy's top/left) to the Draggable's x and y (and rotation if necessary) properties so that they reflect reality and it also (optionally) applies any snapping necessary. This is used by the InertiaPlugin tween in an onUpdate to ensure things are synced and snapped.
    syncXY = function syncXY(skipOnUpdate, skipSnap) {
      var x = self.x,
          y = self.y,
          snappedValue,
          cs;

      if (!target._gsap) {
        //just in case the _gsap cache got wiped, like if the user called clearProps on the transform or something (very rare).
        gsCache = gsap.core.getCache(target);
      }

      gsCache.uncache && gsap.getProperty(target, "x"); // trigger a re-cache

      if (xyMode) {
        self.x = parseFloat(gsCache.x);
        self.y = parseFloat(gsCache.y);
      } else if (rotationMode) {
        self.x = self.rotation = parseFloat(gsCache.rotation);
      } else if (scrollProxy) {
        self.y = scrollProxy.top();
        self.x = scrollProxy.left();
      } else {
        self.y = parseFloat(target.style.top || (cs = _getComputedStyle(target)) && cs.top) || 0;
        self.x = parseFloat(target.style.left || (cs || {}).left) || 0;
      }

      if ((snapX || snapY || snapXY) && !skipSnap && (self.isDragging || self.isThrowing)) {
        if (snapXY) {
          _temp1.x = self.x;
          _temp1.y = self.y;
          snappedValue = snapXY(_temp1);

          if (snappedValue.x !== self.x) {
            self.x = snappedValue.x;
            dirty = true;
          }

          if (snappedValue.y !== self.y) {
            self.y = snappedValue.y;
            dirty = true;
          }
        }

        if (snapX) {
          snappedValue = snapX(self.x);

          if (snappedValue !== self.x) {
            self.x = snappedValue;

            if (rotationMode) {
              self.rotation = snappedValue;
            }

            dirty = true;
          }
        }

        if (snapY) {
          snappedValue = snapY(self.y);

          if (snappedValue !== self.y) {
            self.y = snappedValue;
          }

          dirty = true;
        }
      }

      dirty && render(true);

      if (!skipOnUpdate) {
        self.deltaX = self.x - x;
        self.deltaY = self.y - y;

        _dispatchEvent(self, "throwupdate", "onThrowUpdate");
      }
    },
        buildSnapFunc = function buildSnapFunc(snap, min, max, factor) {
      if (min == null) {
        min = -_bigNum;
      }

      if (max == null) {
        max = _bigNum;
      }

      if (_isFunction(snap)) {
        return function (n) {
          var edgeTolerance = !self.isPressed ? 1 : 1 - self.edgeResistance; //if we're tweening, disable the edgeTolerance because it's already factored into the tweening values (we don't want to apply it multiple times)

          return snap.call(self, n > max ? max + (n - max) * edgeTolerance : n < min ? min + (n - min) * edgeTolerance : n) * factor;
        };
      }

      if (_isArray(snap)) {
        return function (n) {
          var i = snap.length,
              closest = 0,
              absDif = _bigNum,
              val,
              dif;

          while (--i > -1) {
            val = snap[i];
            dif = val - n;

            if (dif < 0) {
              dif = -dif;
            }

            if (dif < absDif && val >= min && val <= max) {
              closest = i;
              absDif = dif;
            }
          }

          return snap[closest];
        };
      }

      return isNaN(snap) ? function (n) {
        return n;
      } : function () {
        return snap * factor;
      };
    },
        buildPointSnapFunc = function buildPointSnapFunc(snap, minX, maxX, minY, maxY, radius, factor) {
      radius = radius && radius < _bigNum ? radius * radius : _bigNum; //so we don't have to Math.sqrt() in the functions. Performance optimization.

      if (_isFunction(snap)) {
        return function (point) {
          var edgeTolerance = !self.isPressed ? 1 : 1 - self.edgeResistance,
              x = point.x,
              y = point.y,
              result,
              dx,
              dy; //if we're tweening, disable the edgeTolerance because it's already factored into the tweening values (we don't want to apply it multiple times)

          point.x = x = x > maxX ? maxX + (x - maxX) * edgeTolerance : x < minX ? minX + (x - minX) * edgeTolerance : x;
          point.y = y = y > maxY ? maxY + (y - maxY) * edgeTolerance : y < minY ? minY + (y - minY) * edgeTolerance : y;
          result = snap.call(self, point);

          if (result !== point) {
            point.x = result.x;
            point.y = result.y;
          }

          if (factor !== 1) {
            point.x *= factor;
            point.y *= factor;
          }

          if (radius < _bigNum) {
            dx = point.x - x;
            dy = point.y - y;

            if (dx * dx + dy * dy > radius) {
              point.x = x;
              point.y = y;
            }
          }

          return point;
        };
      }

      if (_isArray(snap)) {
        return function (p) {
          var i = snap.length,
              closest = 0,
              minDist = _bigNum,
              x,
              y,
              point,
              dist;

          while (--i > -1) {
            point = snap[i];
            x = point.x - p.x;
            y = point.y - p.y;
            dist = x * x + y * y;

            if (dist < minDist) {
              closest = i;
              minDist = dist;
            }
          }

          return minDist <= radius ? snap[closest] : p;
        };
      }

      return function (n) {
        return n;
      };
    },
        calculateBounds = function calculateBounds() {
      var bounds, targetBounds, snap, snapIsRaw;
      hasBounds = false;

      if (scrollProxy) {
        scrollProxy.calibrate();
        self.minX = minX = -scrollProxy.maxScrollLeft();
        self.minY = minY = -scrollProxy.maxScrollTop();
        self.maxX = maxX = self.maxY = maxY = 0;
        hasBounds = true;
      } else if (!!vars.bounds) {
        bounds = _getBounds(vars.bounds, target.parentNode); //could be a selector/jQuery object or a DOM element or a generic object like {top:0, left:100, width:1000, height:800} or {minX:100, maxX:1100, minY:0, maxY:800}

        if (rotationMode) {
          self.minX = minX = bounds.left;
          self.maxX = maxX = bounds.left + bounds.width;
          self.minY = minY = self.maxY = maxY = 0;
        } else if (!_isUndefined(vars.bounds.maxX) || !_isUndefined(vars.bounds.maxY)) {
          bounds = vars.bounds;
          self.minX = minX = bounds.minX;
          self.minY = minY = bounds.minY;
          self.maxX = maxX = bounds.maxX;
          self.maxY = maxY = bounds.maxY;
        } else {
          targetBounds = _getBounds(target, target.parentNode);
          self.minX = minX = Math.round(getPropAsNum(xProp, "px") + bounds.left - targetBounds.left);
          self.minY = minY = Math.round(getPropAsNum(yProp, "px") + bounds.top - targetBounds.top);
          self.maxX = maxX = Math.round(minX + (bounds.width - targetBounds.width));
          self.maxY = maxY = Math.round(minY + (bounds.height - targetBounds.height));
        }

        if (minX > maxX) {
          self.minX = maxX;
          self.maxX = maxX = minX;
          minX = self.minX;
        }

        if (minY > maxY) {
          self.minY = maxY;
          self.maxY = maxY = minY;
          minY = self.minY;
        }

        if (rotationMode) {
          self.minRotation = minX;
          self.maxRotation = maxX;
        }

        hasBounds = true;
      }

      if (vars.liveSnap) {
        snap = vars.liveSnap === true ? vars.snap || {} : vars.liveSnap;
        snapIsRaw = _isArray(snap) || _isFunction(snap);

        if (rotationMode) {
          snapX = buildSnapFunc(snapIsRaw ? snap : snap.rotation, minX, maxX, 1);
          snapY = null;
        } else {
          if (snap.points) {
            snapXY = buildPointSnapFunc(snapIsRaw ? snap : snap.points, minX, maxX, minY, maxY, snap.radius, scrollProxy ? -1 : 1);
          } else {
            if (allowX) {
              snapX = buildSnapFunc(snapIsRaw ? snap : snap.x || snap.left || snap.scrollLeft, minX, maxX, scrollProxy ? -1 : 1);
            }

            if (allowY) {
              snapY = buildSnapFunc(snapIsRaw ? snap : snap.y || snap.top || snap.scrollTop, minY, maxY, scrollProxy ? -1 : 1);
            }
          }
        }
      }
    },
        onThrowComplete = function onThrowComplete() {
      self.isThrowing = false;

      _dispatchEvent(self, "throwcomplete", "onThrowComplete");
    },
        onThrowInterrupt = function onThrowInterrupt() {
      self.isThrowing = false;
    },
        animate = function animate(inertia, forceZeroVelocity) {
      var snap, snapIsRaw, tween, overshootTolerance;

      if (inertia && InertiaPlugin) {
        if (inertia === true) {
          snap = vars.snap || vars.liveSnap || {};
          snapIsRaw = _isArray(snap) || _isFunction(snap);
          inertia = {
            resistance: (vars.throwResistance || vars.resistance || 1000) / (rotationMode ? 10 : 1)
          };

          if (rotationMode) {
            inertia.rotation = _parseInertia(self, snapIsRaw ? snap : snap.rotation, maxX, minX, 1, forceZeroVelocity);
          } else {
            if (allowX) {
              inertia[xProp] = _parseInertia(self, snapIsRaw ? snap : snap.points || snap.x || snap.left, maxX, minX, scrollProxy ? -1 : 1, forceZeroVelocity || self.lockedAxis === "x");
            }

            if (allowY) {
              inertia[yProp] = _parseInertia(self, snapIsRaw ? snap : snap.points || snap.y || snap.top, maxY, minY, scrollProxy ? -1 : 1, forceZeroVelocity || self.lockedAxis === "y");
            }

            if (snap.points || _isArray(snap) && _isObject(snap[0])) {
              inertia.linkedProps = xProp + "," + yProp;
              inertia.radius = snap.radius; //note: we also disable liveSnapping while throwing if there's a "radius" defined, otherwise it looks weird to have the item thrown past a snapping point but live-snapping mid-tween. We do this by altering the onUpdateParams so that "skipSnap" parameter is true for syncXY.
            }
          }
        }

        self.isThrowing = true;
        overshootTolerance = !isNaN(vars.overshootTolerance) ? vars.overshootTolerance : vars.edgeResistance === 1 ? 0 : 1 - self.edgeResistance + 0.2;

        if (!inertia.duration) {
          inertia.duration = {
            max: Math.max(vars.minDuration || 0, "maxDuration" in vars ? vars.maxDuration : 2),
            min: !isNaN(vars.minDuration) ? vars.minDuration : overshootTolerance === 0 || _isObject(inertia) && inertia.resistance > 1000 ? 0 : 0.5,
            overshoot: overshootTolerance
          };
        }

        self.tween = tween = gsap.to(scrollProxy || target, {
          inertia: inertia,
          data: "_draggable",
          onComplete: onThrowComplete,
          onInterrupt: onThrowInterrupt,
          onUpdate: vars.fastMode ? _dispatchEvent : syncXY,
          onUpdateParams: vars.fastMode ? [self, "onthrowupdate", "onThrowUpdate"] : snap && snap.radius ? [false, true] : []
        });

        if (!vars.fastMode) {
          if (scrollProxy) {
            scrollProxy._skip = true; // Microsoft browsers have a bug that causes them to briefly render the position incorrectly (it flashes to the end state when we seek() the tween even though we jump right back to the current position, and this only seems to happen when we're affecting both top and left), so we set a _suspendTransforms flag to prevent it from actually applying the values in the ScrollProxy.
          }

          tween.render(1e9, true, true); // force to the end. Remember, the duration will likely change upon initting because that's when InertiaPlugin calculates it.

          syncXY(true, true);
          self.endX = self.x;
          self.endY = self.y;

          if (rotationMode) {
            self.endRotation = self.x;
          }

          tween.play(0);
          syncXY(true, true);

          if (scrollProxy) {
            scrollProxy._skip = false; //Microsoft browsers have a bug that causes them to briefly render the position incorrectly (it flashes to the end state when we seek() the tween even though we jump right back to the current position, and this only seems to happen when we're affecting both top and left), so we set a _suspendTransforms flag to prevent it from actually applying the values in the ScrollProxy.
          }
        }
      } else if (hasBounds) {
        self.applyBounds();
      }
    },
        updateMatrix = function updateMatrix(shiftStart) {
      var start = matrix,
          p;
      matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(target.parentNode, true);

      if (shiftStart && self.isPressed && !matrix.equals(start || new _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.Matrix2D())) {
        //if the matrix changes WHILE the element is pressed, we must adjust the startPointerX and startPointerY accordingly, so we invert the original matrix and figure out where the pointerX and pointerY were in the global space, then apply the new matrix to get the updated coordinates.
        p = start.inverse().apply({
          x: startPointerX,
          y: startPointerY
        });
        matrix.apply(p, p);
        startPointerX = p.x;
        startPointerY = p.y;
      }

      if (matrix.equals(_identityMatrix)) {
        //if there are no transforms, we can optimize performance by not factoring in the matrix
        matrix = null;
      }
    },
        recordStartPositions = function recordStartPositions() {
      var edgeTolerance = 1 - self.edgeResistance,
          offsetX = isFixed ? _getDocScrollLeft(ownerDoc) : 0,
          offsetY = isFixed ? _getDocScrollTop(ownerDoc) : 0,
          parsedOrigin,
          x,
          y;
      updateMatrix(false);
      _point1.x = self.pointerX - offsetX;
      _point1.y = self.pointerY - offsetY;
      matrix && matrix.apply(_point1, _point1);
      startPointerX = _point1.x; //translate to local coordinate system

      startPointerY = _point1.y;

      if (dirty) {
        setPointerPosition(self.pointerX, self.pointerY);
        render(true);
      }

      innerMatrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(target);

      if (scrollProxy) {
        calculateBounds();
        startElementY = scrollProxy.top();
        startElementX = scrollProxy.left();
      } else {
        //if the element is in the process of tweening, don't force snapping to occur because it could make it jump. Imagine the user throwing, then before it's done, clicking on the element in its inbetween state.
        if (isTweening()) {
          syncXY(true, true);
          calculateBounds();
        } else {
          self.applyBounds();
        }

        if (rotationMode) {
          parsedOrigin = target.ownerSVGElement ? [gsCache.xOrigin - target.getBBox().x, gsCache.yOrigin - target.getBBox().y] : (_getComputedStyle(target)[_transformOriginProp] || "0 0").split(" ");
          rotationOrigin = self.rotationOrigin = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(target).apply({
            x: parseFloat(parsedOrigin[0]) || 0,
            y: parseFloat(parsedOrigin[1]) || 0
          });
          syncXY(true, true);
          x = self.pointerX - rotationOrigin.x - offsetX;
          y = rotationOrigin.y - self.pointerY + offsetY;
          startElementX = self.x; //starting rotation (x always refers to rotation in type:"rotation", measured in degrees)

          startElementY = self.y = Math.atan2(y, x) * _RAD2DEG;
        } else {
          //parent = !isFixed && target.parentNode;
          //startScrollTop = parent ? parent.scrollTop || 0 : 0;
          //startScrollLeft = parent ? parent.scrollLeft || 0 : 0;
          startElementY = getPropAsNum(yProp, "px"); //record the starting top and left values so that we can just add the mouse's movement to them later.

          startElementX = getPropAsNum(xProp, "px");
        }
      }

      if (hasBounds && edgeTolerance) {
        if (startElementX > maxX) {
          startElementX = maxX + (startElementX - maxX) / edgeTolerance;
        } else if (startElementX < minX) {
          startElementX = minX - (minX - startElementX) / edgeTolerance;
        }

        if (!rotationMode) {
          if (startElementY > maxY) {
            startElementY = maxY + (startElementY - maxY) / edgeTolerance;
          } else if (startElementY < minY) {
            startElementY = minY - (minY - startElementY) / edgeTolerance;
          }
        }
      }

      self.startX = startElementX = _round(startElementX);
      self.startY = startElementY = _round(startElementY);
    },
        isTweening = function isTweening() {
      return self.tween && self.tween.isActive();
    },
        removePlaceholder = function removePlaceholder() {
      if (_placeholderDiv.parentNode && !isTweening() && !self.isDragging) {
        //_placeholderDiv just props open auto-scrolling containers so they don't collapse as the user drags left/up. We remove it after dragging (and throwing, if necessary) finishes.
        _placeholderDiv.parentNode.removeChild(_placeholderDiv);
      }
    },
        //called when the mouse is pressed (or touch starts)
    onPress = function onPress(e, force) {
      var i;

      if (!enabled || self.isPressed || !e || (e.type === "mousedown" || e.type === "pointerdown") && !force && _getTime() - clickTime < 30 && _touchEventLookup[self.pointerEvent.type]) {
        //when we DON'T preventDefault() in order to accommodate touch-scrolling and the user just taps, many browsers also fire a mousedown/mouseup sequence AFTER the touchstart/touchend sequence, thus it'd result in two quick "click" events being dispatched. This line senses that condition and halts it on the subsequent mousedown.
        isPreventingDefault && e && enabled && _preventDefault(e); // in some browsers, we must listen for multiple event types like touchstart, pointerdown, mousedown. The first time this function is called, we record whether or not we _preventDefault() so that on duplicate calls, we can do the same if necessary.

        return;
      }

      interrupted = isTweening();
      self.pointerEvent = e;

      if (_touchEventLookup[e.type]) {
        //note: on iOS, BOTH touchmove and mousemove are dispatched, but the mousemove has pageY and pageX of 0 which would mess up the calculations and needlessly hurt performance.
        touchEventTarget = ~e.type.indexOf("touch") ? e.currentTarget || e.target : ownerDoc; //pointer-based touches (for Microsoft browsers) don't remain locked to the original target like other browsers, so we must use the document instead. The event type would be "MSPointerDown" or "pointerdown".

        _addListener(touchEventTarget, "touchend", onRelease);

        _addListener(touchEventTarget, "touchmove", onMove);

        _addListener(touchEventTarget, "touchcancel", onRelease);

        _addListener(ownerDoc, "touchstart", _onMultiTouchDocument);
      } else {
        touchEventTarget = null;

        _addListener(ownerDoc, "mousemove", onMove); //attach these to the document instead of the box itself so that if the user's mouse moves too quickly (and off of the box), things still work.

      }

      touchDragAxis = null;

      if (!_supportsPointer || !touchEventTarget) {
        _addListener(ownerDoc, "mouseup", onRelease);

        e && e.target && _addListener(e.target, "mouseup", onRelease); //we also have to listen directly on the element because some browsers don't bubble up the event to the _doc on elements with contentEditable="true"
      }

      isClicking = isClickable.call(self, e.target) && vars.dragClickables === false && !force;

      if (isClicking) {
        _addListener(e.target, "change", onRelease); //in some browsers, when you mousedown on a <select> element, no mouseup gets dispatched! So we listen for a "change" event instead.


        _dispatchEvent(self, "pressInit", "onPressInit");

        _dispatchEvent(self, "press", "onPress");

        _setSelectable(triggers, true); //accommodates things like inputs and elements with contentEditable="true" (otherwise user couldn't drag to select text)


        isPreventingDefault = false;
        return;
      }

      allowNativeTouchScrolling = !touchEventTarget || allowX === allowY || self.vars.allowNativeTouchScrolling === false || self.vars.allowContextMenu && e && (e.ctrlKey || e.which > 2) ? false : allowX ? "y" : "x"; //note: in Chrome, right-clicking (for a context menu) fires onPress and it doesn't have the event.which set properly, so we must look for event.ctrlKey. If the user wants to allow context menus we should of course sense it here and not allow native touch scrolling.

      isPreventingDefault = !allowNativeTouchScrolling && !self.allowEventDefault;

      if (isPreventingDefault) {
        _preventDefault(e);

        _addListener(_win, "touchforcechange", _preventDefault); //works around safari bug: https://greensock.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/

      }

      if (e.changedTouches) {
        //touch events store the data slightly differently
        e = touch = e.changedTouches[0];
        touchID = e.identifier;
      } else if (e.pointerId) {
        touchID = e.pointerId; //for some Microsoft browsers
      } else {
        touch = touchID = null;
      }

      _dragCount++;

      _addToRenderQueue(render); //causes the Draggable to render on each "tick" of TweenLite.ticker (performance optimization - updating values in a mousemove can cause them to happen too frequently, like multiple times between frame redraws which is wasteful, and it also prevents values from updating properly in IE8)


      startPointerY = self.pointerY = e.pageY; //record the starting x and y so that we can calculate the movement from the original in _onMouseMove

      startPointerX = self.pointerX = e.pageX;

      _dispatchEvent(self, "pressInit", "onPressInit");

      if (allowNativeTouchScrolling || self.autoScroll) {
        _recordMaxScrolls(target.parentNode);
      }

      if (target.parentNode && self.autoScroll && !scrollProxy && !rotationMode && target.parentNode._gsMaxScrollX && !_placeholderDiv.parentNode && !target.getBBox) {
        //add a placeholder div to prevent the parent container from collapsing when the user drags the element left.
        _placeholderDiv.style.width = target.parentNode.scrollWidth + "px";
        target.parentNode.appendChild(_placeholderDiv);
      }

      recordStartPositions();
      self.tween && self.tween.kill();
      self.isThrowing = false;
      gsap.killTweensOf(scrollProxy || target, killProps, true); //in case the user tries to drag it before the last tween is done.

      scrollProxy && gsap.killTweensOf(target, {
        scrollTo: 1
      }, true); //just in case the original target's scroll position is being tweened somewhere else.

      self.tween = self.lockedAxis = null;

      if (vars.zIndexBoost || !rotationMode && !scrollProxy && vars.zIndexBoost !== false) {
        target.style.zIndex = Draggable.zIndex++;
      }

      self.isPressed = true;
      hasDragCallback = !!(vars.onDrag || self._listeners.drag);
      hasMoveCallback = !!(vars.onMove || self._listeners.move);

      if (vars.cursor !== false || vars.activeCursor) {
        i = triggers.length;

        while (--i > -1) {
          gsap.set(triggers[i], {
            cursor: vars.activeCursor || vars.cursor || (_defaultCursor === "grab" ? "grabbing" : _defaultCursor)
          });
        }
      }

      _dispatchEvent(self, "press", "onPress");
    },
        //called every time the mouse/touch moves
    onMove = function onMove(e) {
      var originalEvent = e,
          touches,
          pointerX,
          pointerY,
          i,
          dx,
          dy;

      if (!enabled || _isMultiTouching || !self.isPressed || !e) {
        isPreventingDefault && e && enabled && _preventDefault(e); // in some browsers, we must listen for multiple event types like touchmove, pointermove, mousemove. The first time this function is called, we record whether or not we _preventDefault() so that on duplicate calls, we can do the same if necessary.

        return;
      }

      self.pointerEvent = e;
      touches = e.changedTouches;

      if (touches) {
        //touch events store the data slightly differently
        e = touches[0];

        if (e !== touch && e.identifier !== touchID) {
          //Usually changedTouches[0] will be what we're looking for, but in case it's not, look through the rest of the array...(and Android browsers don't reuse the event like iOS)
          i = touches.length;

          while (--i > -1 && (e = touches[i]).identifier !== touchID && e.target !== target) {} // Some Android devices dispatch a touchstart AND pointerdown initially, and then only pointermove thus the touchID may not match because it was grabbed from the touchstart event whereas the pointer event is the one that the browser dispatches for move, so if the event target matches this Draggable's target, let it through.


          if (i < 0) {
            return;
          }
        }
      } else if (e.pointerId && touchID && e.pointerId !== touchID) {
        //for some Microsoft browsers, we must attach the listener to the doc rather than the trigger so that when the finger moves outside the bounds of the trigger, things still work. So if the event we're receiving has a pointerId that doesn't match the touchID, ignore it (for multi-touch)
        return;
      }

      if (touchEventTarget && allowNativeTouchScrolling && !touchDragAxis) {
        //Android browsers force us to decide on the first "touchmove" event if we should allow the default (scrolling) behavior or preventDefault(). Otherwise, a "touchcancel" will be fired and then no "touchmove" or "touchend" will fire during the scrolling (no good).
        _point1.x = e.pageX - (isFixed ? _getDocScrollLeft(ownerDoc) : 0);
        _point1.y = e.pageY - (isFixed ? _getDocScrollTop(ownerDoc) : 0);
        matrix && matrix.apply(_point1, _point1);
        pointerX = _point1.x;
        pointerY = _point1.y;
        dx = Math.abs(pointerX - startPointerX);
        dy = Math.abs(pointerY - startPointerY);

        if (dx !== dy && (dx > minimumMovement || dy > minimumMovement) || _isAndroid && allowNativeTouchScrolling === touchDragAxis) {
          touchDragAxis = dx > dy && allowX ? "x" : "y";

          if (allowNativeTouchScrolling && touchDragAxis !== allowNativeTouchScrolling) {
            _addListener(_win, "touchforcechange", _preventDefault); // prevents native touch scrolling from taking over if the user started dragging in the other direction in iOS Safari

          }

          if (self.vars.lockAxisOnTouchScroll !== false && allowX && allowY) {
            self.lockedAxis = touchDragAxis === "x" ? "y" : "x";
            _isFunction(self.vars.onLockAxis) && self.vars.onLockAxis.call(self, originalEvent);
          }

          if (_isAndroid && allowNativeTouchScrolling === touchDragAxis) {
            onRelease(originalEvent);
            return;
          }
        }
      }

      if (!self.allowEventDefault && (!allowNativeTouchScrolling || touchDragAxis && allowNativeTouchScrolling !== touchDragAxis) && originalEvent.cancelable !== false) {
        _preventDefault(originalEvent);

        isPreventingDefault = true;
      } else if (isPreventingDefault) {
        isPreventingDefault = false;
      }

      if (self.autoScroll) {
        checkAutoScrollBounds = true;
      }

      setPointerPosition(e.pageX, e.pageY, hasMoveCallback);
    },
        setPointerPosition = function setPointerPosition(pointerX, pointerY, invokeOnMove) {
      var dragTolerance = 1 - self.dragResistance,
          edgeTolerance = 1 - self.edgeResistance,
          prevPointerX = self.pointerX,
          prevPointerY = self.pointerY,
          prevStartElementY = startElementY,
          prevX = self.x,
          prevY = self.y,
          prevEndX = self.endX,
          prevEndY = self.endY,
          prevEndRotation = self.endRotation,
          prevDirty = dirty,
          xChange,
          yChange,
          x,
          y,
          dif,
          temp;
      self.pointerX = pointerX;
      self.pointerY = pointerY;

      if (isFixed) {
        pointerX -= _getDocScrollLeft(ownerDoc);
        pointerY -= _getDocScrollTop(ownerDoc);
      }

      if (rotationMode) {
        y = Math.atan2(rotationOrigin.y - pointerY, pointerX - rotationOrigin.x) * _RAD2DEG;
        dif = self.y - y;

        if (dif > 180) {
          startElementY -= 360;
          self.y = y;
        } else if (dif < -180) {
          startElementY += 360;
          self.y = y;
        }

        if (self.x !== startElementX || Math.abs(startElementY - y) > minimumMovement) {
          self.y = y;
          x = startElementX + (startElementY - y) * dragTolerance;
        } else {
          x = startElementX;
        }
      } else {
        if (matrix) {
          temp = pointerX * matrix.a + pointerY * matrix.c + matrix.e;
          pointerY = pointerX * matrix.b + pointerY * matrix.d + matrix.f;
          pointerX = temp;
        }

        yChange = pointerY - startPointerY;
        xChange = pointerX - startPointerX;

        if (yChange < minimumMovement && yChange > -minimumMovement) {
          yChange = 0;
        }

        if (xChange < minimumMovement && xChange > -minimumMovement) {
          xChange = 0;
        }

        if ((self.lockAxis || self.lockedAxis) && (xChange || yChange)) {
          temp = self.lockedAxis;

          if (!temp) {
            self.lockedAxis = temp = allowX && Math.abs(xChange) > Math.abs(yChange) ? "y" : allowY ? "x" : null;

            if (temp && _isFunction(self.vars.onLockAxis)) {
              self.vars.onLockAxis.call(self, self.pointerEvent);
            }
          }

          if (temp === "y") {
            yChange = 0;
          } else if (temp === "x") {
            xChange = 0;
          }
        }

        x = _round(startElementX + xChange * dragTolerance);
        y = _round(startElementY + yChange * dragTolerance);
      }

      if ((snapX || snapY || snapXY) && (self.x !== x || self.y !== y && !rotationMode)) {
        if (snapXY) {
          _temp1.x = x;
          _temp1.y = y;
          temp = snapXY(_temp1);
          x = _round(temp.x);
          y = _round(temp.y);
        }

        if (snapX) {
          x = _round(snapX(x));
        }

        if (snapY) {
          y = _round(snapY(y));
        }
      }

      if (hasBounds) {
        if (x > maxX) {
          x = maxX + Math.round((x - maxX) * edgeTolerance);
        } else if (x < minX) {
          x = minX + Math.round((x - minX) * edgeTolerance);
        }

        if (!rotationMode) {
          if (y > maxY) {
            y = Math.round(maxY + (y - maxY) * edgeTolerance);
          } else if (y < minY) {
            y = Math.round(minY + (y - minY) * edgeTolerance);
          }
        }
      }

      if (self.x !== x || self.y !== y && !rotationMode) {
        if (rotationMode) {
          self.endRotation = self.x = self.endX = x;
          dirty = true;
        } else {
          if (allowY) {
            self.y = self.endY = y;
            dirty = true; //a flag that indicates we need to render the target next time the TweenLite.ticker dispatches a "tick" event (typically on a requestAnimationFrame) - this is a performance optimization (we shouldn't render on every move because sometimes many move events can get dispatched between screen refreshes, and that'd be wasteful to render every time)
          }

          if (allowX) {
            self.x = self.endX = x;
            dirty = true;
          }
        }

        if (!invokeOnMove || _dispatchEvent(self, "move", "onMove") !== false) {
          if (!self.isDragging && self.isPressed) {
            self.isDragging = true;

            _dispatchEvent(self, "dragstart", "onDragStart");
          }
        } else {
          //revert because the onMove returned false!
          self.pointerX = prevPointerX;
          self.pointerY = prevPointerY;
          startElementY = prevStartElementY;
          self.x = prevX;
          self.y = prevY;
          self.endX = prevEndX;
          self.endY = prevEndY;
          self.endRotation = prevEndRotation;
          dirty = prevDirty;
        }
      }
    },
        //called when the mouse/touch is released
    onRelease = function onRelease(e, force) {
      if (!enabled || !self.isPressed || e && touchID != null && !force && (e.pointerId && e.pointerId !== touchID && e.target !== target || e.changedTouches && !_hasTouchID(e.changedTouches, touchID))) {
        //for some Microsoft browsers, we must attach the listener to the doc rather than the trigger so that when the finger moves outside the bounds of the trigger, things still work. So if the event we're receiving has a pointerId that doesn't match the touchID, ignore it (for multi-touch)
        isPreventingDefault && e && enabled && _preventDefault(e); // in some browsers, we must listen for multiple event types like touchend, pointerup, mouseup. The first time this function is called, we record whether or not we _preventDefault() so that on duplicate calls, we can do the same if necessary.

        return;
      }

      self.isPressed = false;
      var originalEvent = e,
          wasDragging = self.isDragging,
          isContextMenuRelease = self.vars.allowContextMenu && e && (e.ctrlKey || e.which > 2),
          placeholderDelayedCall = gsap.delayedCall(0.001, removePlaceholder),
          touches,
          i,
          syntheticEvent,
          eventTarget,
          syntheticClick;

      if (touchEventTarget) {
        _removeListener(touchEventTarget, "touchend", onRelease);

        _removeListener(touchEventTarget, "touchmove", onMove);

        _removeListener(touchEventTarget, "touchcancel", onRelease);

        _removeListener(ownerDoc, "touchstart", _onMultiTouchDocument);
      } else {
        _removeListener(ownerDoc, "mousemove", onMove);
      }

      _removeListener(_win, "touchforcechange", _preventDefault);

      if (!_supportsPointer || !touchEventTarget) {
        _removeListener(ownerDoc, "mouseup", onRelease);

        e && e.target && _removeListener(e.target, "mouseup", onRelease);
      }

      dirty = false;

      if (wasDragging) {
        dragEndTime = _lastDragTime = _getTime();
        self.isDragging = false;
      }

      if (isClicking && !isContextMenuRelease) {
        if (e) {
          _removeListener(e.target, "change", onRelease);

          self.pointerEvent = originalEvent;
        }

        _setSelectable(triggers, false);

        _dispatchEvent(self, "release", "onRelease");

        _dispatchEvent(self, "click", "onClick");

        isClicking = false;
        return;
      }

      _removeFromRenderQueue(render);

      i = triggers.length;

      while (--i > -1) {
        _setStyle(triggers[i], "cursor", vars.cursor || (vars.cursor !== false ? _defaultCursor : null));
      }

      _dragCount--;

      if (e) {
        touches = e.changedTouches;

        if (touches) {
          //touch events store the data slightly differently
          e = touches[0];

          if (e !== touch && e.identifier !== touchID) {
            //Usually changedTouches[0] will be what we're looking for, but in case it's not, look through the rest of the array...(and Android browsers don't reuse the event like iOS)
            i = touches.length;

            while (--i > -1 && (e = touches[i]).identifier !== touchID && e.target !== target) {}

            if (i < 0) {
              return;
            }
          }
        }

        self.pointerEvent = originalEvent;
        self.pointerX = e.pageX;
        self.pointerY = e.pageY;
      }

      if (isContextMenuRelease && originalEvent) {
        _preventDefault(originalEvent);

        isPreventingDefault = true;

        _dispatchEvent(self, "release", "onRelease");
      } else if (originalEvent && !wasDragging) {
        isPreventingDefault = false;

        if (interrupted && (vars.snap || vars.bounds)) {
          //otherwise, if the user clicks on the object while it's animating to a snapped position, and then releases without moving 3 pixels, it will just stay there (it should animate/snap)
          animate(vars.inertia || vars.throwProps);
        }

        _dispatchEvent(self, "release", "onRelease");

        if ((!_isAndroid || originalEvent.type !== "touchmove") && originalEvent.type.indexOf("cancel") === -1) {
          //to accommodate native scrolling on Android devices, we have to immediately call onRelease() on the first touchmove event, but that shouldn't trigger a "click".
          _dispatchEvent(self, "click", "onClick");

          if (_getTime() - clickTime < 300) {
            _dispatchEvent(self, "doubleclick", "onDoubleClick");
          }

          eventTarget = originalEvent.target || target; //old IE uses srcElement

          clickTime = _getTime();

          syntheticClick = function syntheticClick() {
            // some browsers (like Firefox) won't trust script-generated clicks, so if the user tries to click on a video to play it, for example, it simply won't work. Since a regular "click" event will most likely be generated anyway (one that has its isTrusted flag set to true), we must slightly delay our script-generated click so that the "real"/trusted one is prioritized. Remember, when there are duplicate events in quick succession, we suppress all but the first one. Some browsers don't even trigger the "real" one at all, so our synthetic one is a safety valve that ensures that no matter what, a click event does get dispatched.
            if (clickTime !== clickDispatch && self.enabled() && !self.isPressed && !originalEvent.defaultPrevented) {
              if (eventTarget.click) {
                //some browsers (like mobile Safari) don't properly trigger the click event
                eventTarget.click();
              } else if (ownerDoc.createEvent) {
                syntheticEvent = ownerDoc.createEvent("MouseEvents");
                syntheticEvent.initMouseEvent("click", true, true, _win, 1, self.pointerEvent.screenX, self.pointerEvent.screenY, self.pointerX, self.pointerY, false, false, false, false, 0, null);
                eventTarget.dispatchEvent(syntheticEvent);
              }
            }
          };

          if (!_isAndroid && !originalEvent.defaultPrevented) {
            //iOS Safari requires the synthetic click to happen immediately or else it simply won't work, but Android doesn't play nice.
            gsap.delayedCall(0.05, syntheticClick); //in addition to the iOS bug workaround, there's a Firefox issue with clicking on things like a video to play, so we must fake a click event in a slightly delayed fashion. Previously, we listened for the "click" event with "capture" false which solved the video-click-to-play issue, but it would allow the "click" event to be dispatched twice like if you were using a jQuery.click() because that was handled in the capture phase, thus we had to switch to the capture phase to avoid the double-dispatching, but do the delayed synthetic click. Don't fire it too fast (like 0.00001) because we want to give the native event a chance to fire first as it's "trusted".
          }
        }
      } else {
        animate(vars.inertia || vars.throwProps); //will skip if inertia/throwProps isn't defined or IntertiaPlugin isn't loaded.

        if (!self.allowEventDefault && originalEvent && (vars.dragClickables !== false || !isClickable.call(self, originalEvent.target)) && wasDragging && (!allowNativeTouchScrolling || touchDragAxis && allowNativeTouchScrolling === touchDragAxis) && originalEvent.cancelable !== false) {
          isPreventingDefault = true;

          _preventDefault(originalEvent);
        } else {
          isPreventingDefault = false;
        }

        _dispatchEvent(self, "release", "onRelease");
      }

      isTweening() && placeholderDelayedCall.duration(self.tween.duration()); //sync the timing so that the placeholder DIV gets

      wasDragging && _dispatchEvent(self, "dragend", "onDragEnd");
      return true;
    },
        updateScroll = function updateScroll(e) {
      if (e && self.isDragging && !scrollProxy) {
        var parent = e.target || target.parentNode,
            deltaX = parent.scrollLeft - parent._gsScrollX,
            deltaY = parent.scrollTop - parent._gsScrollY;

        if (deltaX || deltaY) {
          if (matrix) {
            startPointerX -= deltaX * matrix.a + deltaY * matrix.c;
            startPointerY -= deltaY * matrix.d + deltaX * matrix.b;
          } else {
            startPointerX -= deltaX;
            startPointerY -= deltaY;
          }

          parent._gsScrollX += deltaX;
          parent._gsScrollY += deltaY;
          setPointerPosition(self.pointerX, self.pointerY);
        }
      }
    },
        onClick = function onClick(e) {
      //this was a huge pain in the neck to align all the various browsers and their behaviors. Chrome, Firefox, Safari, Opera, Android, and Microsoft Edge all handle events differently! Some will only trigger native behavior (like checkbox toggling) from trusted events. Others don't even support isTrusted, but require 2 events to flow through before triggering native behavior. Edge treats everything as trusted but also mandates that 2 flow through to trigger the correct native behavior.
      var time = _getTime(),
          recentlyClicked = time - clickTime < 100,
          recentlyDragged = time - dragEndTime < 50,
          alreadyDispatched = recentlyClicked && clickDispatch === clickTime,
          defaultPrevented = self.pointerEvent && self.pointerEvent.defaultPrevented,
          alreadyDispatchedTrusted = recentlyClicked && trustedClickDispatch === clickTime,
          trusted = e.isTrusted || e.isTrusted == null && recentlyClicked && alreadyDispatched; //note: Safari doesn't support isTrusted, and it won't properly execute native behavior (like toggling checkboxes) on the first synthetic "click" event - we must wait for the 2nd and treat it as trusted (but stop propagation at that point). Confusing, I know. Don't you love cross-browser compatibility challenges?


      if ((alreadyDispatched || recentlyDragged && self.vars.suppressClickOnDrag !== false) && e.stopImmediatePropagation) {
        e.stopImmediatePropagation();
      }

      if (recentlyClicked && !(self.pointerEvent && self.pointerEvent.defaultPrevented) && (!alreadyDispatched || trusted && !alreadyDispatchedTrusted)) {
        //let the first click pass through unhindered. Let the next one only if it's trusted, then no more (stop quick-succession ones)
        if (trusted && alreadyDispatched) {
          trustedClickDispatch = clickTime;
        }

        clickDispatch = clickTime;
        return;
      }

      if (self.isPressed || recentlyDragged || recentlyClicked) {
        if (!trusted || !e.detail || !recentlyClicked || defaultPrevented) {
          _preventDefault(e);
        }
      }

      if (!recentlyClicked && !recentlyDragged) {
        // for script-triggered event dispatches, like element.click()
        e && e.target && (self.pointerEvent = e);

        _dispatchEvent(self, "click", "onClick");
      }
    },
        localizePoint = function localizePoint(p) {
      return matrix ? {
        x: p.x * matrix.a + p.y * matrix.c + matrix.e,
        y: p.x * matrix.b + p.y * matrix.d + matrix.f
      } : {
        x: p.x,
        y: p.y
      };
    };

    old = Draggable.get(target);
    old && old.kill(); // avoids duplicates (an element can only be controlled by one Draggable)
    //give the user access to start/stop dragging...

    _this2.startDrag = function (event, align) {
      var r1, r2, p1, p2;
      onPress(event || self.pointerEvent, true); //if the pointer isn't on top of the element, adjust things accordingly

      if (align && !self.hitTest(event || self.pointerEvent)) {
        r1 = _parseRect(event || self.pointerEvent);
        r2 = _parseRect(target);
        p1 = localizePoint({
          x: r1.left + r1.width / 2,
          y: r1.top + r1.height / 2
        });
        p2 = localizePoint({
          x: r2.left + r2.width / 2,
          y: r2.top + r2.height / 2
        });
        startPointerX -= p1.x - p2.x;
        startPointerY -= p1.y - p2.y;
      }

      if (!self.isDragging) {
        self.isDragging = true;

        _dispatchEvent(self, "dragstart", "onDragStart");
      }
    };

    _this2.drag = onMove;

    _this2.endDrag = function (e) {
      return onRelease(e || self.pointerEvent, true);
    };

    _this2.timeSinceDrag = function () {
      return self.isDragging ? 0 : (_getTime() - dragEndTime) / 1000;
    };

    _this2.timeSinceClick = function () {
      return (_getTime() - clickTime) / 1000;
    };

    _this2.hitTest = function (target, threshold) {
      return Draggable.hitTest(self.target, target, threshold);
    };

    _this2.getDirection = function (from, diagonalThreshold) {
      //from can be "start" (default), "velocity", or an element
      var mode = from === "velocity" && InertiaPlugin ? from : _isObject(from) && !rotationMode ? "element" : "start",
          xChange,
          yChange,
          ratio,
          direction,
          r1,
          r2;

      if (mode === "element") {
        r1 = _parseRect(self.target);
        r2 = _parseRect(from);
      }

      xChange = mode === "start" ? self.x - startElementX : mode === "velocity" ? InertiaPlugin.getVelocity(target, xProp) : r1.left + r1.width / 2 - (r2.left + r2.width / 2);

      if (rotationMode) {
        return xChange < 0 ? "counter-clockwise" : "clockwise";
      } else {
        diagonalThreshold = diagonalThreshold || 2;
        yChange = mode === "start" ? self.y - startElementY : mode === "velocity" ? InertiaPlugin.getVelocity(target, yProp) : r1.top + r1.height / 2 - (r2.top + r2.height / 2);
        ratio = Math.abs(xChange / yChange);
        direction = ratio < 1 / diagonalThreshold ? "" : xChange < 0 ? "left" : "right";

        if (ratio < diagonalThreshold) {
          if (direction !== "") {
            direction += "-";
          }

          direction += yChange < 0 ? "up" : "down";
        }
      }

      return direction;
    };

    _this2.applyBounds = function (newBounds, sticky) {
      var x, y, forceZeroVelocity, e, parent, isRoot;

      if (newBounds && vars.bounds !== newBounds) {
        vars.bounds = newBounds;
        return self.update(true, sticky);
      }

      syncXY(true);
      calculateBounds();

      if (hasBounds && !isTweening()) {
        x = self.x;
        y = self.y;

        if (x > maxX) {
          x = maxX;
        } else if (x < minX) {
          x = minX;
        }

        if (y > maxY) {
          y = maxY;
        } else if (y < minY) {
          y = minY;
        }

        if (self.x !== x || self.y !== y) {
          forceZeroVelocity = true;
          self.x = self.endX = x;

          if (rotationMode) {
            self.endRotation = x;
          } else {
            self.y = self.endY = y;
          }

          dirty = true;
          render(true);

          if (self.autoScroll && !self.isDragging) {
            _recordMaxScrolls(target.parentNode);

            e = target;
            _windowProxy.scrollTop = _win.pageYOffset != null ? _win.pageYOffset : ownerDoc.documentElement.scrollTop != null ? ownerDoc.documentElement.scrollTop : ownerDoc.body.scrollTop;
            _windowProxy.scrollLeft = _win.pageXOffset != null ? _win.pageXOffset : ownerDoc.documentElement.scrollLeft != null ? ownerDoc.documentElement.scrollLeft : ownerDoc.body.scrollLeft;

            while (e && !isRoot) {
              //walk up the chain and sense wherever the scrollTop/scrollLeft exceeds the maximum.
              isRoot = _isRoot(e.parentNode);
              parent = isRoot ? _windowProxy : e.parentNode;

              if (allowY && parent.scrollTop > parent._gsMaxScrollY) {
                parent.scrollTop = parent._gsMaxScrollY;
              }

              if (allowX && parent.scrollLeft > parent._gsMaxScrollX) {
                parent.scrollLeft = parent._gsMaxScrollX;
              }

              e = parent;
            }
          }
        }

        if (self.isThrowing && (forceZeroVelocity || self.endX > maxX || self.endX < minX || self.endY > maxY || self.endY < minY)) {
          animate(vars.inertia || vars.throwProps, forceZeroVelocity);
        }
      }

      return self;
    };

    _this2.update = function (applyBounds, sticky, ignoreExternalChanges) {
      if (sticky && self.isPressed) {
        // in case the element was repositioned in the document flow, thus its x/y may be identical but its position is actually quite different.
        var m = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(target),
            p = innerMatrix.apply({
          x: self.x - startElementX,
          y: self.y - startElementY
        }),
            m2 = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(target.parentNode, true);
        m2.apply({
          x: m.e - p.x,
          y: m.f - p.y
        }, p);
        self.x -= p.x - m2.e;
        self.y -= p.y - m2.f;
        render(true);
        recordStartPositions();
      }

      var x = self.x,
          y = self.y;
      updateMatrix(!sticky);

      if (applyBounds) {
        self.applyBounds();
      } else {
        dirty && ignoreExternalChanges && render(true);
        syncXY(true);
      }

      if (sticky) {
        setPointerPosition(self.pointerX, self.pointerY);
        dirty && render(true);
      }

      if (self.isPressed && !sticky && (allowX && Math.abs(x - self.x) > 0.01 || allowY && Math.abs(y - self.y) > 0.01 && !rotationMode)) {
        recordStartPositions();
      }

      if (self.autoScroll) {
        _recordMaxScrolls(target.parentNode, self.isDragging);

        checkAutoScrollBounds = self.isDragging;
        render(true); //in case reparenting occurred.

        _removeScrollListener(target, updateScroll);

        _addScrollListener(target, updateScroll);
      }

      return self;
    };

    _this2.enable = function (type) {
      var setVars = {
        lazy: true
      },
          id,
          i,
          trigger;

      if (vars.cursor !== false) {
        setVars.cursor = vars.cursor || _defaultCursor;
      }

      if (gsap.utils.checkPrefix("touchCallout")) {
        setVars.touchCallout = "none";
      }

      if (type !== "soft") {
        _setTouchActionForAllDescendants(triggers, allowX === allowY ? "none" : vars.allowNativeTouchScrolling && target.scrollHeight === target.clientHeight === (target.scrollWidth === target.clientHeight) || vars.allowEventDefault ? "manipulation" : allowX ? "pan-y" : "pan-x"); // Some browsers like Internet Explorer will fire a pointercancel event when the user attempts to drag when touchAction is "manipulate" because it's perceived as a pan. If the element has scrollable content in only one direction, we should use pan-x or pan-y accordingly so that the pointercancel doesn't prevent dragging.


        i = triggers.length;

        while (--i > -1) {
          trigger = triggers[i];
          _supportsPointer || _addListener(trigger, "mousedown", onPress);

          _addListener(trigger, "touchstart", onPress);

          _addListener(trigger, "click", onClick, true); //note: used to pass true for capture but it prevented click-to-play-video functionality in Firefox.


          gsap.set(trigger, setVars);

          if (trigger.getBBox && trigger.ownerSVGElement) {
            // a bug in chrome doesn't respect touch-action on SVG elements - it only works if we set it on the parent SVG.
            gsap.set(trigger.ownerSVGElement, {
              touchAction: allowX === allowY ? "none" : vars.allowNativeTouchScrolling || vars.allowEventDefault ? "manipulation" : allowX ? "pan-y" : "pan-x"
            });
          }

          vars.allowContextMenu || _addListener(trigger, "contextmenu", onContextMenu);
        }

        _setSelectable(triggers, false);
      }

      _addScrollListener(target, updateScroll);

      enabled = true;

      if (InertiaPlugin && type !== "soft") {
        InertiaPlugin.track(scrollProxy || target, xyMode ? "x,y" : rotationMode ? "rotation" : "top,left");
      }

      target._gsDragID = id = "d" + _lookupCount++;
      _lookup[id] = self;

      if (scrollProxy) {
        scrollProxy.enable();
        scrollProxy.element._gsDragID = id;
      }

      (vars.bounds || rotationMode) && recordStartPositions();
      vars.bounds && self.applyBounds();
      return self;
    };

    _this2.disable = function (type) {
      var dragging = self.isDragging,
          i = triggers.length,
          trigger;

      while (--i > -1) {
        _setStyle(triggers[i], "cursor", null);
      }

      if (type !== "soft") {
        _setTouchActionForAllDescendants(triggers, null);

        i = triggers.length;

        while (--i > -1) {
          trigger = triggers[i];

          _setStyle(trigger, "touchCallout", null);

          _removeListener(trigger, "mousedown", onPress);

          _removeListener(trigger, "touchstart", onPress);

          _removeListener(trigger, "click", onClick);

          _removeListener(trigger, "contextmenu", onContextMenu);
        }

        _setSelectable(triggers, true);

        if (touchEventTarget) {
          _removeListener(touchEventTarget, "touchcancel", onRelease);

          _removeListener(touchEventTarget, "touchend", onRelease);

          _removeListener(touchEventTarget, "touchmove", onMove);
        }

        _removeListener(ownerDoc, "mouseup", onRelease);

        _removeListener(ownerDoc, "mousemove", onMove);
      }

      _removeScrollListener(target, updateScroll);

      enabled = false;
      InertiaPlugin && type !== "soft" && InertiaPlugin.untrack(scrollProxy || target, xyMode ? "x,y" : rotationMode ? "rotation" : "top,left");
      scrollProxy && scrollProxy.disable();

      _removeFromRenderQueue(render);

      self.isDragging = self.isPressed = isClicking = false;
      dragging && _dispatchEvent(self, "dragend", "onDragEnd");
      return self;
    };

    _this2.enabled = function (value, type) {
      return arguments.length ? value ? self.enable(type) : self.disable(type) : enabled;
    };

    _this2.kill = function () {
      self.isThrowing = false;
      self.tween && self.tween.kill();
      self.disable();
      gsap.set(triggers, {
        clearProps: "userSelect"
      });
      delete _lookup[target._gsDragID];
      return self;
    };

    if (~type.indexOf("scroll")) {
      scrollProxy = _this2.scrollProxy = new ScrollProxy(target, _extend({
        onKill: function onKill() {
          //ScrollProxy's onKill() gets called if/when the ScrollProxy senses that the user interacted with the scroll position manually (like using the scrollbar). IE9 doesn't fire the "mouseup" properly when users drag the scrollbar of an element, so this works around that issue.
          self.isPressed && onRelease(null);
        }
      }, vars)); //a bug in many Android devices' stock browser causes scrollTop to get forced back to 0 after it is altered via JS, so we set overflow to "hidden" on mobile/touch devices (they hide the scroll bar anyway). That works around the bug. (This bug is discussed at https://code.google.com/p/android/issues/detail?id=19625)

      target.style.overflowY = allowY && !_isTouchDevice ? "auto" : "hidden";
      target.style.overflowX = allowX && !_isTouchDevice ? "auto" : "hidden";
      target = scrollProxy.content;
    }

    if (rotationMode) {
      killProps.rotation = 1;
    } else {
      if (allowX) {
        killProps[xProp] = 1;
      }

      if (allowY) {
        killProps[yProp] = 1;
      }
    }

    gsCache.force3D = "force3D" in vars ? vars.force3D : true; //otherwise, normal dragging would be in 2D and then as soon as it's released and there's an inertia tween, it'd jump to 3D which can create an initial jump due to the work the browser must to do layerize it.

    _this2.enable();

    return _this2;
  }

  Draggable.register = function register(core) {
    gsap = core;

    _initCore();
  };

  Draggable.create = function create(targets, vars) {
    _coreInitted || _initCore(true);
    return _toArray(targets).map(function (target) {
      return new Draggable(target, vars);
    });
  };

  Draggable.get = function get(target) {
    return _lookup[(_toArray(target)[0] || {})._gsDragID];
  };

  Draggable.timeSinceDrag = function timeSinceDrag() {
    return (_getTime() - _lastDragTime) / 1000;
  };

  Draggable.hitTest = function hitTest(obj1, obj2, threshold) {
    if (obj1 === obj2) {
      return false;
    }

    var r1 = _parseRect(obj1),
        r2 = _parseRect(obj2),
        top = r1.top,
        left = r1.left,
        right = r1.right,
        bottom = r1.bottom,
        width = r1.width,
        height = r1.height,
        isOutside = r2.left > right || r2.right < left || r2.top > bottom || r2.bottom < top,
        overlap,
        area,
        isRatio;

    if (isOutside || !threshold) {
      return !isOutside;
    }

    isRatio = (threshold + "").indexOf("%") !== -1;
    threshold = parseFloat(threshold) || 0;
    overlap = {
      left: Math.max(left, r2.left),
      top: Math.max(top, r2.top)
    };
    overlap.width = Math.min(right, r2.right) - overlap.left;
    overlap.height = Math.min(bottom, r2.bottom) - overlap.top;

    if (overlap.width < 0 || overlap.height < 0) {
      return false;
    }

    if (isRatio) {
      threshold *= 0.01;
      area = overlap.width * overlap.height;
      return area >= width * height * threshold || area >= r2.width * r2.height * threshold;
    }

    return overlap.width > threshold && overlap.height > threshold;
  };

  return Draggable;
}(EventDispatcher);

_setDefaults(Draggable.prototype, {
  pointerX: 0,
  pointerY: 0,
  startX: 0,
  startY: 0,
  deltaX: 0,
  deltaY: 0,
  isDragging: false,
  isPressed: false
});

Draggable.zIndex = 1000;
Draggable.version = "3.9.1";
_getGSAP() && gsap.registerPlugin(Draggable);


/***/ }),

/***/ "./node_modules/gsap/EasePack.js":
/*!***************************************!*\
  !*** ./node_modules/gsap/EasePack.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EasePack": () => (/* binding */ EasePack),
/* harmony export */   "ExpoScaleEase": () => (/* binding */ ExpoScaleEase),
/* harmony export */   "RoughEase": () => (/* binding */ RoughEase),
/* harmony export */   "SlowMo": () => (/* binding */ SlowMo),
/* harmony export */   "default": () => (/* binding */ EasePack)
/* harmony export */ });
/*!
 * EasePack 3.9.1
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */
var gsap,
    _coreInitted,
    _registerEase,
    _getGSAP = function _getGSAP() {
  return gsap || typeof window !== "undefined" && (gsap = window.gsap) && gsap.registerPlugin && gsap;
},
    _boolean = function _boolean(value, defaultValue) {
  return !!(typeof value === "undefined" ? defaultValue : value && !~(value + "").indexOf("false"));
},
    _initCore = function _initCore(core) {
  gsap = core || _getGSAP();

  if (gsap) {
    _registerEase = gsap.registerEase; //add weighted ease capabilities to standard eases so users can do "power2.inOut(0.8)" for example to push everything toward the "out", or (-0.8) to push it toward the "in" (0 is neutral)

    var eases = gsap.parseEase(),
        createConfig = function createConfig(ease) {
      return function (ratio) {
        var y = 0.5 + ratio / 2;

        ease.config = function (p) {
          return ease(2 * (1 - p) * p * y + p * p);
        };
      };
    },
        p;

    for (p in eases) {
      if (!eases[p].config) {
        createConfig(eases[p]);
      }
    }

    _registerEase("slow", SlowMo);

    _registerEase("expoScale", ExpoScaleEase);

    _registerEase("rough", RoughEase);

    for (p in EasePack) {
      p !== "version" && gsap.core.globals(p, EasePack[p]);
    }

    _coreInitted = 1;
  }
},
    _createSlowMo = function _createSlowMo(linearRatio, power, yoyoMode) {
  linearRatio = Math.min(1, linearRatio || 0.7);

  var pow = linearRatio < 1 ? power || power === 0 ? power : 0.7 : 0,
      p1 = (1 - linearRatio) / 2,
      p3 = p1 + linearRatio,
      calcEnd = _boolean(yoyoMode);

  return function (p) {
    var r = p + (0.5 - p) * pow;
    return p < p1 ? calcEnd ? 1 - (p = 1 - p / p1) * p : r - (p = 1 - p / p1) * p * p * p * r : p > p3 ? calcEnd ? p === 1 ? 0 : 1 - (p = (p - p3) / p1) * p : r + (p - r) * (p = (p - p3) / p1) * p * p * p : calcEnd ? 1 : r;
  };
},
    _createExpoScale = function _createExpoScale(start, end, ease) {
  var p1 = Math.log(end / start),
      p2 = end - start;
  ease && (ease = gsap.parseEase(ease));
  return function (p) {
    return (start * Math.exp(p1 * (ease ? ease(p) : p)) - start) / p2;
  };
},
    EasePoint = function EasePoint(time, value, next) {
  this.t = time;
  this.v = value;

  if (next) {
    this.next = next;
    next.prev = this;
    this.c = next.v - value;
    this.gap = next.t - time;
  }
},
    _createRoughEase = function _createRoughEase(vars) {
  if (typeof vars !== "object") {
    //users may pass in via a string, like "rough(30)"
    vars = {
      points: +vars || 20
    };
  }

  var taper = vars.taper || "none",
      a = [],
      cnt = 0,
      points = (+vars.points || 20) | 0,
      i = points,
      randomize = _boolean(vars.randomize, true),
      clamp = _boolean(vars.clamp),
      template = gsap ? gsap.parseEase(vars.template) : 0,
      strength = (+vars.strength || 1) * 0.4,
      x,
      y,
      bump,
      invX,
      obj,
      pnt,
      recent;

  while (--i > -1) {
    x = randomize ? Math.random() : 1 / points * i;
    y = template ? template(x) : x;

    if (taper === "none") {
      bump = strength;
    } else if (taper === "out") {
      invX = 1 - x;
      bump = invX * invX * strength;
    } else if (taper === "in") {
      bump = x * x * strength;
    } else if (x < 0.5) {
      //"both" (start)
      invX = x * 2;
      bump = invX * invX * 0.5 * strength;
    } else {
      //"both" (end)
      invX = (1 - x) * 2;
      bump = invX * invX * 0.5 * strength;
    }

    if (randomize) {
      y += Math.random() * bump - bump * 0.5;
    } else if (i % 2) {
      y += bump * 0.5;
    } else {
      y -= bump * 0.5;
    }

    if (clamp) {
      if (y > 1) {
        y = 1;
      } else if (y < 0) {
        y = 0;
      }
    }

    a[cnt++] = {
      x: x,
      y: y
    };
  }

  a.sort(function (a, b) {
    return a.x - b.x;
  });
  pnt = new EasePoint(1, 1, null);
  i = points;

  while (i--) {
    obj = a[i];
    pnt = new EasePoint(obj.x, obj.y, pnt);
  }

  recent = new EasePoint(0, 0, pnt.t ? pnt : pnt.next);
  return function (p) {
    var pnt = recent;

    if (p > pnt.t) {
      while (pnt.next && p >= pnt.t) {
        pnt = pnt.next;
      }

      pnt = pnt.prev;
    } else {
      while (pnt.prev && p <= pnt.t) {
        pnt = pnt.prev;
      }
    }

    recent = pnt;
    return pnt.v + (p - pnt.t) / pnt.gap * pnt.c;
  };
};

var SlowMo = _createSlowMo(0.7);
SlowMo.ease = SlowMo; //for backward compatibility

SlowMo.config = _createSlowMo;
var ExpoScaleEase = _createExpoScale(1, 2);
ExpoScaleEase.config = _createExpoScale;
var RoughEase = _createRoughEase();
RoughEase.ease = RoughEase; //for backward compatibility

RoughEase.config = _createRoughEase;
var EasePack = {
  SlowMo: SlowMo,
  RoughEase: RoughEase,
  ExpoScaleEase: ExpoScaleEase
};

for (var p in EasePack) {
  EasePack[p].register = _initCore;
  EasePack[p].version = "3.9.1";
}

_getGSAP() && gsap.registerPlugin(SlowMo);


/***/ }),

/***/ "./node_modules/gsap/EaselPlugin.js":
/*!******************************************!*\
  !*** ./node_modules/gsap/EaselPlugin.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EaselPlugin": () => (/* binding */ EaselPlugin),
/* harmony export */   "default": () => (/* binding */ EaselPlugin)
/* harmony export */ });
/*!
 * EaselPlugin 3.9.1
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */
var gsap,
    _coreInitted,
    _win,
    _createJS,
    _ColorFilter,
    _ColorMatrixFilter,
    _colorProps = "redMultiplier,greenMultiplier,blueMultiplier,alphaMultiplier,redOffset,greenOffset,blueOffset,alphaOffset".split(","),
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _getGSAP = function _getGSAP() {
  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;
},
    _getCreateJS = function _getCreateJS() {
  return _createJS || _win && _win.createjs || _win || {};
},
    _warn = function _warn(message) {
  return console.warn(message);
},
    _cache = function _cache(target) {
  var b = target.getBounds && target.getBounds();

  if (!b) {
    b = target.nominalBounds || {
      x: 0,
      y: 0,
      width: 100,
      height: 100
    };
    target.setBounds && target.setBounds(b.x, b.y, b.width, b.height);
  }

  target.cache && target.cache(b.x, b.y, b.width, b.height);

  _warn("EaselPlugin: for filters to display in EaselJS, you must call the object's cache() method first. GSAP attempted to use the target's getBounds() for the cache but that may not be completely accurate. " + target);
},
    _parseColorFilter = function _parseColorFilter(target, v, plugin) {
  if (!_ColorFilter) {
    _ColorFilter = _getCreateJS().ColorFilter;

    if (!_ColorFilter) {
      _warn("EaselPlugin error: The EaselJS ColorFilter JavaScript file wasn't loaded.");
    }
  }

  var filters = target.filters || [],
      i = filters.length,
      c,
      s,
      e,
      a,
      p,
      pt;

  while (i--) {
    if (filters[i] instanceof _ColorFilter) {
      s = filters[i];
      break;
    }
  }

  if (!s) {
    s = new _ColorFilter();
    filters.push(s);
    target.filters = filters;
  }

  e = s.clone();

  if (v.tint != null) {
    c = gsap.utils.splitColor(v.tint);
    a = v.tintAmount != null ? +v.tintAmount : 1;
    e.redOffset = +c[0] * a;
    e.greenOffset = +c[1] * a;
    e.blueOffset = +c[2] * a;
    e.redMultiplier = e.greenMultiplier = e.blueMultiplier = 1 - a;
  } else {
    for (p in v) {
      if (p !== "exposure") if (p !== "brightness") {
        e[p] = +v[p];
      }
    }
  }

  if (v.exposure != null) {
    e.redOffset = e.greenOffset = e.blueOffset = 255 * (+v.exposure - 1);
    e.redMultiplier = e.greenMultiplier = e.blueMultiplier = 1;
  } else if (v.brightness != null) {
    a = +v.brightness - 1;
    e.redOffset = e.greenOffset = e.blueOffset = a > 0 ? a * 255 : 0;
    e.redMultiplier = e.greenMultiplier = e.blueMultiplier = 1 - Math.abs(a);
  }

  i = 8;

  while (i--) {
    p = _colorProps[i];

    if (s[p] !== e[p]) {
      pt = plugin.add(s, p, s[p], e[p]);

      if (pt) {
        pt.op = "easel_colorFilter";
      }
    }
  }

  plugin._props.push("easel_colorFilter");

  if (!target.cacheID) {
    _cache(target);
  }
},
    _idMatrix = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
    _lumR = 0.212671,
    _lumG = 0.715160,
    _lumB = 0.072169,
    _applyMatrix = function _applyMatrix(m, m2) {
  if (!(m instanceof Array) || !(m2 instanceof Array)) {
    return m2;
  }

  var temp = [],
      i = 0,
      z = 0,
      y,
      x;

  for (y = 0; y < 4; y++) {
    for (x = 0; x < 5; x++) {
      z = x === 4 ? m[i + 4] : 0;
      temp[i + x] = m[i] * m2[x] + m[i + 1] * m2[x + 5] + m[i + 2] * m2[x + 10] + m[i + 3] * m2[x + 15] + z;
    }

    i += 5;
  }

  return temp;
},
    _setSaturation = function _setSaturation(m, n) {
  if (isNaN(n)) {
    return m;
  }

  var inv = 1 - n,
      r = inv * _lumR,
      g = inv * _lumG,
      b = inv * _lumB;
  return _applyMatrix([r + n, g, b, 0, 0, r, g + n, b, 0, 0, r, g, b + n, 0, 0, 0, 0, 0, 1, 0], m);
},
    _colorize = function _colorize(m, color, amount) {
  if (isNaN(amount)) {
    amount = 1;
  }

  var c = gsap.utils.splitColor(color),
      r = c[0] / 255,
      g = c[1] / 255,
      b = c[2] / 255,
      inv = 1 - amount;
  return _applyMatrix([inv + amount * r * _lumR, amount * r * _lumG, amount * r * _lumB, 0, 0, amount * g * _lumR, inv + amount * g * _lumG, amount * g * _lumB, 0, 0, amount * b * _lumR, amount * b * _lumG, inv + amount * b * _lumB, 0, 0, 0, 0, 0, 1, 0], m);
},
    _setHue = function _setHue(m, n) {
  if (isNaN(n)) {
    return m;
  }

  n *= Math.PI / 180;
  var c = Math.cos(n),
      s = Math.sin(n);
  return _applyMatrix([_lumR + c * (1 - _lumR) + s * -_lumR, _lumG + c * -_lumG + s * -_lumG, _lumB + c * -_lumB + s * (1 - _lumB), 0, 0, _lumR + c * -_lumR + s * 0.143, _lumG + c * (1 - _lumG) + s * 0.14, _lumB + c * -_lumB + s * -0.283, 0, 0, _lumR + c * -_lumR + s * -(1 - _lumR), _lumG + c * -_lumG + s * _lumG, _lumB + c * (1 - _lumB) + s * _lumB, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], m);
},
    _setContrast = function _setContrast(m, n) {
  if (isNaN(n)) {
    return m;
  }

  n += 0.01;
  return _applyMatrix([n, 0, 0, 0, 128 * (1 - n), 0, n, 0, 0, 128 * (1 - n), 0, 0, n, 0, 128 * (1 - n), 0, 0, 0, 1, 0], m);
},
    _parseColorMatrixFilter = function _parseColorMatrixFilter(target, v, plugin) {
  if (!_ColorMatrixFilter) {
    _ColorMatrixFilter = _getCreateJS().ColorMatrixFilter;

    if (!_ColorMatrixFilter) {
      _warn("EaselPlugin: The EaselJS ColorMatrixFilter JavaScript file wasn't loaded.");
    }
  }

  var filters = target.filters || [],
      i = filters.length,
      matrix,
      startMatrix,
      s,
      pg;

  while (--i > -1) {
    if (filters[i] instanceof _ColorMatrixFilter) {
      s = filters[i];
      break;
    }
  }

  if (!s) {
    s = new _ColorMatrixFilter(_idMatrix.slice());
    filters.push(s);
    target.filters = filters;
  }

  startMatrix = s.matrix;
  matrix = _idMatrix.slice();

  if (v.colorize != null) {
    matrix = _colorize(matrix, v.colorize, Number(v.colorizeAmount));
  }

  if (v.contrast != null) {
    matrix = _setContrast(matrix, Number(v.contrast));
  }

  if (v.hue != null) {
    matrix = _setHue(matrix, Number(v.hue));
  }

  if (v.saturation != null) {
    matrix = _setSaturation(matrix, Number(v.saturation));
  }

  i = matrix.length;

  while (--i > -1) {
    if (matrix[i] !== startMatrix[i]) {
      pg = plugin.add(startMatrix, i, startMatrix[i], matrix[i]);

      if (pg) {
        pg.op = "easel_colorMatrixFilter";
      }
    }
  }

  plugin._props.push("easel_colorMatrixFilter");

  if (!target.cacheID) {
    _cache();
  }

  plugin._matrix = startMatrix;
},
    _initCore = function _initCore(core) {
  gsap = core || _getGSAP();

  if (_windowExists()) {
    _win = window;
  }

  if (gsap) {
    _coreInitted = 1;
  }
};

var EaselPlugin = {
  version: "3.9.1",
  name: "easel",
  init: function init(target, value, tween, index, targets) {
    if (!_coreInitted) {
      _initCore();

      if (!gsap) {
        _warn("Please gsap.registerPlugin(EaselPlugin)");
      }
    }

    this.target = target;
    var p, pt, tint, colorMatrix, end, labels, i;

    for (p in value) {
      end = value[p];

      if (p === "colorFilter" || p === "tint" || p === "tintAmount" || p === "exposure" || p === "brightness") {
        if (!tint) {
          _parseColorFilter(target, value.colorFilter || value, this);

          tint = true;
        }
      } else if (p === "saturation" || p === "contrast" || p === "hue" || p === "colorize" || p === "colorizeAmount") {
        if (!colorMatrix) {
          _parseColorMatrixFilter(target, value.colorMatrixFilter || value, this);

          colorMatrix = true;
        }
      } else if (p === "frame") {
        if (typeof end === "string" && end.charAt(1) !== "=" && (labels = target.labels)) {
          for (i = 0; i < labels.length; i++) {
            if (labels[i].label === end) {
              end = labels[i].position;
            }
          }
        }

        pt = this.add(target, "gotoAndStop", target.currentFrame, end, index, targets, Math.round);

        if (pt) {
          pt.op = p;
        }
      } else if (target[p] != null) {
        this.add(target, p, "get", end);
      }
    }
  },
  render: function render(ratio, data) {
    var pt = data._pt;

    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }

    if (data.target.cacheID) {
      data.target.updateCache();
    }
  },
  register: _initCore
};

EaselPlugin.registerCreateJS = function (createjs) {
  _createJS = createjs;
};

_getGSAP() && gsap.registerPlugin(EaselPlugin);


/***/ }),

/***/ "./node_modules/gsap/Flip.js":
/*!***********************************!*\
  !*** ./node_modules/gsap/Flip.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Flip": () => (/* binding */ Flip),
/* harmony export */   "default": () => (/* binding */ Flip)
/* harmony export */ });
/* harmony import */ var _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/matrix.js */ "./node_modules/gsap/utils/matrix.js");
/*!
 * Flip 3.9.1
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */


var _id = 1,
    _toArray,
    gsap,
    _batch,
    _batchAction,
    _body,
    _closestTenth,
    _forEachBatch = function _forEachBatch(batch, name) {
  return batch.actions.forEach(function (a) {
    return a.vars[name] && a.vars[name](a);
  });
},
    _batchLookup = {},
    _RAD2DEG = 180 / Math.PI,
    _DEG2RAD = Math.PI / 180,
    _emptyObj = {},
    _dashedNameLookup = {},
    _memoizedRemoveProps = {},
    _listToArray = function _listToArray(list) {
  return typeof list === "string" ? list.split(" ").join("").split(",") : list;
},
    // removes extra spaces contaminating the names, returns an Array.
_callbacks = _listToArray("onStart,onUpdate,onComplete,onReverseComplete,onInterrupt"),
    _removeProps = _listToArray("transform,transformOrigin,width,height,position,top,left,opacity,zIndex,maxWidth,maxHeight,minWidth,minHeight"),
    _getEl = function _getEl(target) {
  return _toArray(target)[0] || console.warn("Element not found:", target);
},
    _round = function _round(value) {
  return Math.round(value * 10000) / 10000 || 0;
},
    _toggleClass = function _toggleClass(targets, className, action) {
  return targets.forEach(function (el) {
    return el.classList[action](className);
  });
},
    _reserved = {
  zIndex: 1,
  kill: 1,
  simple: 1,
  spin: 1,
  clearProps: 1,
  targets: 1,
  toggleClass: 1,
  onComplete: 1,
  onUpdate: 1,
  onInterrupt: 1,
  onStart: 1,
  delay: 1,
  repeat: 1,
  repeatDelay: 1,
  yoyo: 1,
  scale: 1,
  fade: 1,
  absolute: 1,
  props: 1,
  onEnter: 1,
  onLeave: 1,
  custom: 1,
  paused: 1,
  nested: 1,
  prune: 1,
  absoluteOnLeave: 1
},
    _fitReserved = {
  zIndex: 1,
  simple: 1,
  clearProps: 1,
  scale: 1,
  absolute: 1,
  fitChild: 1,
  getVars: 1,
  props: 1
},
    _camelToDashed = function _camelToDashed(p) {
  return p.replace(/([A-Z])/g, "-$1").toLowerCase();
},
    _copy = function _copy(obj, exclude) {
  var result = {},
      p;

  for (p in obj) {
    exclude[p] || (result[p] = obj[p]);
  }

  return result;
},
    _memoizedProps = {},
    _memoizeProps = function _memoizeProps(props) {
  var p = _memoizedProps[props] = _listToArray(props);

  _memoizedRemoveProps[props] = p.concat(_removeProps);
  return p;
},
    _getInverseGlobalMatrix = function _getInverseGlobalMatrix(el) {
  // integrates caching for improved performance
  var cache = el._gsap || gsap.core.getCache(el);

  if (cache.gmCache === gsap.ticker.frame) {
    return cache.gMatrix;
  }

  cache.gmCache = gsap.ticker.frame;
  return cache.gMatrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(el, true, false, true);
},
    _getDOMDepth = function _getDOMDepth(el, invert, level) {
  if (level === void 0) {
    level = 0;
  }

  // In invert is true, the sibling depth is increments of 1, and parent/nesting depth is increments of 1000. This lets us order elements in an Array to reflect document flow.
  var parent = el.parentNode,
      inc = 1000 * Math.pow(10, level) * (invert ? -1 : 1),
      l = invert ? -inc * 900 : 0;

  while (el) {
    l += inc;
    el = el.previousSibling;
  }

  return parent ? l + _getDOMDepth(parent, invert, level + 1) : l;
},
    _orderByDOMDepth = function _orderByDOMDepth(comps, invert, isElStates) {
  comps.forEach(function (comp) {
    return comp.d = _getDOMDepth(isElStates ? comp.element : comp.t, invert);
  });
  comps.sort(function (c1, c2) {
    return c1.d - c2.d;
  });
  return comps;
},
    _recordInlineStyles = function _recordInlineStyles(elState, props) {
  // records the current inline CSS properties into an Array in alternating name/value pairs that's stored in a "css" property on the state object so that we can revert later.
  var style = elState.element.style,
      a = elState.css = elState.css || [],
      i = props.length,
      p,
      v;

  while (i--) {
    p = props[i];
    v = style[p] || style.getPropertyValue(p);
    a.push(v ? p : _dashedNameLookup[p] || (_dashedNameLookup[p] = _camelToDashed(p)), v);
  }

  return style;
},
    _applyInlineStyles = function _applyInlineStyles(state) {
  var css = state.css,
      style = state.element.style,
      i = 0;
  state.cache.uncache = 1;

  for (; i < css.length; i += 2) {
    css[i + 1] ? style[css[i]] = css[i + 1] : style.removeProperty(css[i]);
  }
},
    _setFinalStates = function _setFinalStates(comps, onlyTransforms) {
  comps.forEach(function (c) {
    return c.a.cache.uncache = 1;
  });
  onlyTransforms || comps.finalStates.forEach(_applyInlineStyles);
},
    _absoluteProps = "paddingTop,paddingRight,paddingBottom,paddingLeft,gridArea,transition".split(","),
    // properties that we must record just
_makeAbsolute = function _makeAbsolute(elState, fallbackNode, ignoreBatch) {
  var element = elState.element,
      width = elState.width,
      height = elState.height,
      uncache = elState.uncache,
      getProp = elState.getProp,
      style = element.style,
      i = 4,
      result,
      displayIsNone,
      cs;
  typeof fallbackNode !== "object" && (fallbackNode = elState);

  if (_batch && ignoreBatch !== 1) {
    _batch._abs.push({
      t: element,
      b: elState,
      a: elState,
      sd: 0
    });

    _batch._final.push(function () {
      return (elState.cache.uncache = 1) && _applyInlineStyles(elState);
    });

    return element;
  }

  displayIsNone = getProp("display") === "none";

  if (!elState.isVisible || displayIsNone) {
    displayIsNone && (_recordInlineStyles(elState, ["display"]).display = fallbackNode.display);
    elState.matrix = fallbackNode.matrix;
    elState.width = width = elState.width || fallbackNode.width;
    elState.height = height = elState.height || fallbackNode.height;
  }

  _recordInlineStyles(elState, _absoluteProps);

  cs = window.getComputedStyle(element);

  while (i--) {
    style[_absoluteProps[i]] = cs[_absoluteProps[i]]; // record paddings as px-based because if removed from grid, percentage-based ones could be altered.
  }

  style.gridArea = "1 / 1 / 1 / 1";
  style.transition = "none";
  style.position = "absolute";
  style.width = width + "px";
  style.height = height + "px";
  style.top || (style.top = "0px");
  style.left || (style.left = "0px");

  if (uncache) {
    result = new ElementState(element);
  } else {
    // better performance
    result = _copy(elState, _emptyObj);
    result.position = "absolute";

    if (elState.simple) {
      var bounds = element.getBoundingClientRect();
      result.matrix = new _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.Matrix2D(1, 0, 0, 1, bounds.left + (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__._getDocScrollLeft)(), bounds.top + (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__._getDocScrollTop)());
    } else {
      result.matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(element, false, false, true);
    }
  }

  result = _fit(result, elState, true);
  elState.x = _closestTenth(result.x, 0.01);
  elState.y = _closestTenth(result.y, 0.01);
  return element;
},
    _filterComps = function _filterComps(comps, targets) {
  if (targets !== true) {
    targets = _toArray(targets);
    comps = comps.filter(function (c) {
      if (targets.indexOf((c.sd < 0 ? c.b : c.a).element) !== -1) {
        return true;
      } else {
        c.t._gsap.renderTransform(1); // we must force transforms to render on anything that isn't being made position: absolute, otherwise the absolute position happens and then when animation begins it applies transforms which can create a new stacking context, throwing off positioning!


        c.t.style.width = c.b.width + "px"; // otherwise things can collapse when contents are made position: absolute.

        c.t.style.height = c.b.height + "px";
      }
    });
  }

  return comps;
},
    _makeCompsAbsolute = function _makeCompsAbsolute(comps) {
  return _orderByDOMDepth(comps, true).forEach(function (c) {
    return (c.a.isVisible || c.b.isVisible) && _makeAbsolute(c.sd < 0 ? c.b : c.a, c.b, 1);
  });
},
    _findElStateInState = function _findElStateInState(state, other) {
  return other && state.idLookup[_parseElementState(other).id] || state.elementStates[0];
},
    _parseElementState = function _parseElementState(elOrNode, props, simple, other) {
  return elOrNode instanceof ElementState ? elOrNode : elOrNode instanceof FlipState ? _findElStateInState(elOrNode, other) : new ElementState(typeof elOrNode === "string" ? _getEl(elOrNode) || console.warn(elOrNode + " not found") : elOrNode, props, simple);
},
    _recordProps = function _recordProps(elState, props) {
  var getProp = gsap.getProperty(elState.element, null, "native"),
      obj = elState.props = {},
      i = props.length;

  while (i--) {
    obj[props[i]] = (getProp(props[i]) + "").trim();
  }

  obj.zIndex && (obj.zIndex = parseFloat(obj.zIndex) || 0);
  return elState;
},
    _applyProps = function _applyProps(element, props) {
  var style = element.style || element,
      // could pass in a vars object.
  p;

  for (p in props) {
    style[p] = props[p];
  }
},
    _getID = function _getID(el) {
  var id = el.getAttribute("data-flip-id");
  id || el.setAttribute("data-flip-id", id = "auto-" + _id++);
  return id;
},
    _elementsFromElementStates = function _elementsFromElementStates(elStates) {
  return elStates.map(function (elState) {
    return elState.element;
  });
},
    _handleCallback = function _handleCallback(callback, elStates, tl) {
  return callback && elStates.length && tl.add(callback(_elementsFromElementStates(elStates), tl, new FlipState(elStates, 0, true)), 0);
},
    _fit = function _fit(fromState, toState, scale, applyProps, fitChild, vars) {
  var element = fromState.element,
      cache = fromState.cache,
      parent = fromState.parent,
      x = fromState.x,
      y = fromState.y,
      width = toState.width,
      height = toState.height,
      scaleX = toState.scaleX,
      scaleY = toState.scaleY,
      rotation = toState.rotation,
      bounds = toState.bounds,
      cssText = vars && element.style.cssText,
      transform = vars && element.getBBox && element.getAttribute("transform"),
      dimensionState = fromState,
      _toState$matrix = toState.matrix,
      e = _toState$matrix.e,
      f = _toState$matrix.f,
      deep = fromState.bounds.width !== bounds.width || fromState.bounds.height !== bounds.height || fromState.scaleX !== scaleX || fromState.scaleY !== scaleY || fromState.rotation !== rotation,
      simple = !deep && fromState.simple && toState.simple && !fitChild,
      skewX,
      fromPoint,
      toPoint,
      getProp,
      parentMatrix,
      matrix,
      bbox;

  if (simple) {
    scaleX = scaleY = 1;
    rotation = skewX = 0;
  } else {
    parentMatrix = _getInverseGlobalMatrix(parent);
    matrix = parentMatrix.clone().multiply(toState.ctm ? toState.matrix.clone().multiply(toState.ctm) : toState.matrix); // root SVG elements have a ctm that we must factor out (for example, viewBox:"0 0 94 94" with a width of 200px would scale the internals by 2.127 but when we're matching the size of the root <svg> element itself, that scaling shouldn't factor in!)

    rotation = _round(Math.atan2(matrix.b, matrix.a) * _RAD2DEG);
    skewX = _round(Math.atan2(matrix.c, matrix.d) * _RAD2DEG + rotation) % 360; // in very rare cases, minor rounding might end up with 360 which should be 0.

    scaleX = Math.sqrt(Math.pow(matrix.a, 2) + Math.pow(matrix.b, 2));
    scaleY = Math.sqrt(Math.pow(matrix.c, 2) + Math.pow(matrix.d, 2)) * Math.cos(skewX * _DEG2RAD);

    if (fitChild) {
      fitChild = _toArray(fitChild)[0];
      getProp = gsap.getProperty(fitChild);
      bbox = fitChild.getBBox && typeof fitChild.getBBox === "function" && fitChild.getBBox();
      dimensionState = {
        scaleX: getProp("scaleX"),
        scaleY: getProp("scaleY"),
        width: bbox ? bbox.width : Math.ceil(parseFloat(getProp("width", "px"))),
        height: bbox ? bbox.height : parseFloat(getProp("height", "px"))
      };
    }

    cache.rotation = rotation + "deg";
    cache.skewX = skewX + "deg";
  }

  if (scale) {
    scaleX *= width === dimensionState.width || !dimensionState.width ? 1 : width / dimensionState.width; // note if widths are both 0, we should make scaleX 1 - some elements have box-sizing that incorporates padding, etc. and we don't want it to collapse in that case.

    scaleY *= height === dimensionState.height || !dimensionState.height ? 1 : height / dimensionState.height;
    cache.scaleX = scaleX;
    cache.scaleY = scaleY;
  } else {
    width = _closestTenth(width * scaleX / dimensionState.scaleX, 0);
    height = _closestTenth(height * scaleY / dimensionState.scaleY, 0);
    element.style.width = width + "px";
    element.style.height = height + "px";
  } // if (fromState.isFixed) { // commented out because it's now taken care of in getGlobalMatrix() with a flag at the end.
  // 	e -= _getDocScrollLeft();
  // 	f -= _getDocScrollTop();
  // }


  applyProps && _applyProps(element, toState.props);

  if (simple) {
    x += e - fromState.matrix.e;
    y += f - fromState.matrix.f;
  } else if (deep || parent !== toState.parent) {
    cache.renderTransform(1, cache);
    matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(fitChild || element, false, false, true);
    fromPoint = parentMatrix.apply({
      x: matrix.e,
      y: matrix.f
    });
    toPoint = parentMatrix.apply({
      x: e,
      y: f
    });
    x += toPoint.x - fromPoint.x;
    y += toPoint.y - fromPoint.y;
  } else {
    // use a faster/cheaper algorithm if we're just moving x/y
    parentMatrix.e = parentMatrix.f = 0;
    toPoint = parentMatrix.apply({
      x: e - fromState.matrix.e,
      y: f - fromState.matrix.f
    });
    x += toPoint.x;
    y += toPoint.y;
  }

  x = _closestTenth(x, 0.02);
  y = _closestTenth(y, 0.02);

  if (vars && !(vars instanceof ElementState)) {
    // revert
    element.style.cssText = cssText;
    element.getBBox && element.setAttribute("transform", transform || "");
    cache.uncache = 1;
  } else {
    // or apply the transform immediately
    cache.x = x + "px";
    cache.y = y + "px";
    cache.renderTransform(1, cache);
  }

  if (vars) {
    vars.x = x;
    vars.y = y;
    vars.rotation = rotation;
    vars.skewX = skewX;

    if (scale) {
      vars.scaleX = scaleX;
      vars.scaleY = scaleY;
    } else {
      vars.width = width;
      vars.height = height;
    }
  }

  return vars || cache;
},
    _parseState = function _parseState(targetsOrState, vars) {
  return targetsOrState instanceof FlipState ? targetsOrState : new FlipState(targetsOrState, vars);
},
    _getChangingElState = function _getChangingElState(toState, fromState, id) {
  var to1 = toState.idLookup[id],
      to2 = toState.alt[id];
  return to2.isVisible && (!(fromState.getElementState(to2.element) || to2).isVisible || !to1.isVisible) ? to2 : to1;
},
    _bodyMetrics = [],
    _bodyProps = "width,height,overflowX,overflowY".split(","),
    _bodyLocked,
    _lockBodyScroll = function _lockBodyScroll(lock) {
  // if there's no scrollbar, we should lock that so that measurements don't get affected by temporary repositioning, like if something is centered in the window.
  if (lock !== _bodyLocked) {
    var s = _body.style,
        w = _body.clientWidth === window.outerWidth,
        h = _body.clientHeight === window.outerHeight,
        i = 4;

    if (lock && (w || h)) {
      while (i--) {
        _bodyMetrics[i] = s[_bodyProps[i]];
      }

      if (w) {
        s.width = _body.clientWidth + "px";
        s.overflowY = "hidden";
      }

      if (h) {
        s.height = _body.clientHeight + "px";
        s.overflowX = "hidden";
      }

      _bodyLocked = lock;
    } else if (_bodyLocked) {
      while (i--) {
        _bodyMetrics[i] ? s[_bodyProps[i]] = _bodyMetrics[i] : s.removeProperty(_camelToDashed(_bodyProps[i]));
      }

      _bodyLocked = lock;
    }
  }
},
    _fromTo = function _fromTo(fromState, toState, vars, relative) {
  // relative is -1 if "from()", and 1 if "to()"
  fromState instanceof FlipState && toState instanceof FlipState || console.warn("Not a valid state object.");
  vars = vars || {};

  var _vars = vars,
      clearProps = _vars.clearProps,
      onEnter = _vars.onEnter,
      onLeave = _vars.onLeave,
      absolute = _vars.absolute,
      absoluteOnLeave = _vars.absoluteOnLeave,
      custom = _vars.custom,
      delay = _vars.delay,
      paused = _vars.paused,
      repeat = _vars.repeat,
      repeatDelay = _vars.repeatDelay,
      yoyo = _vars.yoyo,
      toggleClass = _vars.toggleClass,
      nested = _vars.nested,
      _zIndex = _vars.zIndex,
      scale = _vars.scale,
      fade = _vars.fade,
      stagger = _vars.stagger,
      spin = _vars.spin,
      prune = _vars.prune,
      props = ("props" in vars ? vars : fromState).props,
      tweenVars = _copy(vars, _reserved),
      animation = gsap.timeline({
    delay: delay,
    paused: paused,
    repeat: repeat,
    repeatDelay: repeatDelay,
    yoyo: yoyo
  }),
      remainingProps = tweenVars,
      entering = [],
      leaving = [],
      comps = [],
      swapOutTargets = [],
      spinNum = spin === true ? 1 : spin || 0,
      spinFunc = typeof spin === "function" ? spin : function () {
    return spinNum;
  },
      interrupted = fromState.interrupted || toState.interrupted,
      addFunc = animation[relative !== 1 ? "to" : "from"],
      v,
      p,
      endTime,
      i,
      el,
      comp,
      state,
      targets,
      finalStates,
      fromNode,
      toNode,
      run,
      a,
      b; //relative || (toState = (new FlipState(toState.targets, {props: props})).fit(toState, scale));


  for (p in toState.idLookup) {
    toNode = !toState.alt[p] ? toState.idLookup[p] : _getChangingElState(toState, fromState, p);
    el = toNode.element;
    fromNode = fromState.idLookup[p];
    fromState.alt[p] && el === fromNode.element && (fromState.alt[p].isVisible || !toNode.isVisible) && (fromNode = fromState.alt[p]);

    if (fromNode) {
      comp = {
        t: el,
        b: fromNode,
        a: toNode,
        sd: fromNode.element === el ? 0 : toNode.isVisible ? 1 : -1
      };
      comps.push(comp);

      if (comp.sd) {
        if (comp.sd < 0) {
          comp.b = toNode;
          comp.a = fromNode;
        } // for swapping elements that got interrupted, we must re-record the inline styles to ensure they're not tainted. Remember, .batch() permits getState() not to force in-progress flips to their end state.


        interrupted && _recordInlineStyles(comp.b, props ? _memoizedRemoveProps[props] : _removeProps);
        fade && comps.push(comp.swap = {
          t: fromNode.element,
          b: comp.b,
          a: comp.a,
          sd: -comp.sd,
          swap: comp
        });
      }

      el._flip = fromNode.element._flip = _batch ? _batch.timeline : animation;
    } else if (toNode.isVisible) {
      comps.push({
        t: el,
        b: _copy(toNode, {
          isVisible: 1
        }),
        a: toNode,
        sd: 0
      }); // to include it in the "entering" Array and do absolute positioning if necessary

      el._flip = _batch ? _batch.timeline : animation;
    }
  }

  props && (_memoizedProps[props] || _memoizeProps(props)).forEach(function (p) {
    return tweenVars[p] = function (i) {
      return comps[i].a.props[p];
    };
  });
  comps.finalStates = finalStates = [];

  run = function run() {
    _orderByDOMDepth(comps);

    _lockBodyScroll(true); // otherwise, measurements may get thrown off when things get fit.
    // TODO: cache the matrix, especially for parent because it'll probably get reused quite a bit, but lock it to a particular cycle(?).


    for (i = 0; i < comps.length; i++) {
      comp = comps[i];
      a = comp.a;
      b = comp.b;

      if (prune && !a.isDifferent(b)) {
        // only flip if things changed! Don't omit it from comps initially because that'd prevent the element from being positioned absolutely (if necessary)
        comps.splice(i--, 1);
      } else {
        el = comp.t;
        nested && !(comp.sd < 0) && i && (a.matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(el, false, false, true)); // moving a parent affects the position of children

        if (comp.sd || b.isVisible && a.isVisible) {
          if (comp.sd < 0) {
            // swapping OUT (swap direction of -1 is out)
            state = new ElementState(el, props, fromState.simple);

            _fit(state, a, scale, 0, 0, state);

            state.matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(el, false, false, true);
            state.css = comp.b.css;
            comp.a = a = state;
            fade && (el.style.opacity = interrupted ? b.opacity : a.opacity);
            stagger && swapOutTargets.push(el);
          } else if (comp.sd > 0 && fade) {
            // swapping IN (swap direction of 1 is in)
            el.style.opacity = interrupted ? a.opacity - b.opacity : "0";
          }

          _fit(a, b, scale, props);
        } else if (b.isVisible !== a.isVisible) {
          // either entering or leaving (one side is invisible)
          if (!b.isVisible) {
            // entering
            a.isVisible && entering.push(a);
            comps.splice(i--, 1);
          } else if (!a.isVisible) {
            // leaving
            b.css = a.css;
            leaving.push(b);
            comps.splice(i--, 1);
            absolute && nested && _fit(a, b, scale, props);
          }
        }

        if (!scale) {
          el.style.maxWidth = Math.max(a.width, b.width) + "px";
          el.style.maxHeight = Math.max(a.height, b.height) + "px";
          el.style.minWidth = Math.min(a.width, b.width) + "px";
          el.style.minHeight = Math.min(a.height, b.height) + "px";
        }

        nested && toggleClass && el.classList.add(toggleClass);
      }

      finalStates.push(a);
    }

    var classTargets;

    if (toggleClass) {
      classTargets = finalStates.map(function (s) {
        return s.element;
      });
      nested && classTargets.forEach(function (e) {
        return e.classList.remove(toggleClass);
      }); // there could be a delay, so don't leave the classes applied (we'll do it in a timeline callback)
    }

    _lockBodyScroll(false);

    if (scale) {
      tweenVars.scaleX = function (i) {
        return comps[i].a.scaleX;
      };

      tweenVars.scaleY = function (i) {
        return comps[i].a.scaleY;
      };
    } else {
      tweenVars.width = function (i) {
        return comps[i].a.width + "px";
      };

      tweenVars.height = function (i) {
        return comps[i].a.height + "px";
      };

      tweenVars.autoRound = vars.autoRound || false;
    }

    tweenVars.x = function (i) {
      return comps[i].a.x + "px";
    };

    tweenVars.y = function (i) {
      return comps[i].a.y + "px";
    };

    tweenVars.rotation = function (i) {
      return comps[i].a.rotation + (spin ? spinFunc(i, targets[i], targets) * 360 : 0);
    };

    tweenVars.skewX = function (i) {
      return comps[i].a.skewX;
    };

    targets = comps.map(function (c) {
      return c.t;
    });

    if (_zIndex || _zIndex === 0) {
      tweenVars.modifiers = {
        zIndex: function zIndex() {
          return _zIndex;
        }
      };
      tweenVars.zIndex = _zIndex;
      tweenVars.immediateRender = vars.immediateRender !== false;
    }

    fade && (tweenVars.opacity = function (i) {
      return comps[i].sd < 0 ? 0 : comps[i].sd > 0 ? comps[i].a.opacity : "+=0";
    });

    if (swapOutTargets.length) {
      stagger = gsap.utils.distribute(stagger);
      var dummyArray = targets.slice(swapOutTargets.length);

      tweenVars.stagger = function (i, el) {
        return stagger(~swapOutTargets.indexOf(el) ? targets.indexOf(comps[i].swap.t) : i, el, dummyArray);
      };
    } // // for testing...
    // gsap.delayedCall(vars.data ? 50 : 1, function() {
    // 	animation.eventCallback("onComplete", () => _setFinalStates(comps, !clearProps));
    // 	addFunc.call(animation, targets, tweenVars, 0).play();
    // });
    // return;


    _callbacks.forEach(function (name) {
      return vars[name] && animation.eventCallback(name, vars[name], vars[name + "Params"]);
    }); // apply callbacks to the timeline, not tweens (because "custom" timing can make multiple tweens)


    if (custom && targets.length) {
      // bust out the custom properties as their own tweens so they can use different eases, durations, etc.
      remainingProps = _copy(tweenVars, _reserved);

      if ("scale" in custom) {
        custom.scaleX = custom.scaleY = custom.scale;
        delete custom.scale;
      }

      for (p in custom) {
        v = _copy(custom[p], _fitReserved);
        v[p] = tweenVars[p];
        !("duration" in v) && "duration" in tweenVars && (v.duration = tweenVars.duration);
        v.stagger = tweenVars.stagger;
        addFunc.call(animation, targets, v, 0);
        delete remainingProps[p];
      }
    }

    if (targets.length || leaving.length || entering.length) {
      toggleClass && animation.add(function () {
        return _toggleClass(classTargets, toggleClass, animation._zTime < 0 ? "remove" : "add");
      }, 0) && !paused && _toggleClass(classTargets, toggleClass, "add");
      targets.length && addFunc.call(animation, targets, remainingProps, 0);
    }

    _handleCallback(onEnter, entering, animation);

    _handleCallback(onLeave, leaving, animation);

    var batchTl = _batch && _batch.timeline;

    if (batchTl) {
      batchTl.add(animation, 0);

      _batch._final.push(function () {
        return _setFinalStates(comps, !clearProps);
      });
    }

    endTime = animation.duration();
    animation.call(function () {
      var forward = animation.time() >= endTime;
      forward && !batchTl && _setFinalStates(comps, !clearProps);
      toggleClass && _toggleClass(classTargets, toggleClass, forward ? "remove" : "add");
    });
  };

  absoluteOnLeave && (absolute = comps.filter(function (comp) {
    return !comp.sd && !comp.a.isVisible && comp.b.isVisible;
  }).map(function (comp) {
    return comp.a.element;
  }));

  if (_batch) {
    var _batch$_abs;

    absolute && (_batch$_abs = _batch._abs).push.apply(_batch$_abs, _filterComps(comps, absolute));

    _batch._run.push(run);
  } else {
    absolute && _makeCompsAbsolute(_filterComps(comps, absolute)); // when making absolute, we must go in a very particular order so that document flow changes don't affect things. Don't make it visible if both the before and after states are invisible! There's no point, and it could make things appear visible during the flip that shouldn't be.

    run();
  }

  return _batch ? _batch.timeline : animation;
},
    _interrupt = function _interrupt(tl) {
  tl.vars.onInterrupt && tl.vars.onInterrupt.apply(tl, tl.vars.onInterruptParams || []);
  tl.getChildren(true, false, true).forEach(_interrupt);
},
    _killFlip = function _killFlip(tl, action) {
  // action: 0 = nothing, 1 = complete, 2 = only kill (don't complete)
  if (tl && tl.progress() < 1 && !tl.paused()) {
    if (action) {
      _interrupt(tl);

      action < 2 && tl.progress(1); // we should also kill it in case it was added to a parent timeline.

      tl.kill();
    }

    return true;
  }
},
    _createLookup = function _createLookup(state) {
  var lookup = state.idLookup = {},
      alt = state.alt = {},
      elStates = state.elementStates,
      i = elStates.length,
      elState;

  while (i--) {
    elState = elStates[i];
    lookup[elState.id] ? alt[elState.id] = elState : lookup[elState.id] = elState;
  }
};

var FlipState = /*#__PURE__*/function () {
  function FlipState(targets, vars, targetsAreElementStates) {
    this.props = vars && vars.props;
    this.simple = !!(vars && vars.simple);

    if (targetsAreElementStates) {
      this.targets = _elementsFromElementStates(targets);
      this.elementStates = targets;

      _createLookup(this);
    } else {
      this.targets = _toArray(targets);
      var soft = vars && (vars.kill === false || vars.batch && !vars.kill);
      _batch && !soft && _batch._kill.push(this);
      this.update(soft || !!_batch); // when batching, don't force in-progress flips to their end; we need to do that AFTER all getStates() are called.
    }
  }

  var _proto = FlipState.prototype;

  _proto.update = function update(soft) {
    var _this = this;

    this.elementStates = this.targets.map(function (el) {
      return new ElementState(el, _this.props, _this.simple);
    });

    _createLookup(this);

    this.interrupt(soft);
    this.recordInlineStyles();
    return this;
  };

  _proto.clear = function clear() {
    this.targets.length = this.elementStates.length = 0;

    _createLookup(this);

    return this;
  };

  _proto.fit = function fit(state, scale, nested) {
    var elStatesInOrder = _orderByDOMDepth(this.elementStates.slice(0), false, true),
        toElStates = (state || this).idLookup,
        i = 0,
        fromNode,
        toNode;

    for (; i < elStatesInOrder.length; i++) {
      fromNode = elStatesInOrder[i];
      nested && (fromNode.matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(fromNode.element, false, false, true)); // moving a parent affects the position of children

      toNode = toElStates[fromNode.id];
      toNode && _fit(fromNode, toNode, scale, true, 0, fromNode);
      fromNode.matrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(fromNode.element, false, false, true);
    }

    return this;
  };

  _proto.getProperty = function getProperty(element, property) {
    var es = this.getElementState(element) || _emptyObj;

    return (property in es ? es : es.props || _emptyObj)[property];
  };

  _proto.add = function add(state) {
    var i = state.targets.length,
        lookup = this.idLookup,
        alt = this.alt,
        index,
        es,
        es2;

    while (i--) {
      es = state.elementStates[i];
      es2 = lookup[es.id];

      if (es2 && (es.element === es2.element || alt[es.id] && alt[es.id].element === es.element)) {
        // if the flip id is already in this FlipState, replace it!
        index = this.elementStates.indexOf(es.element === es2.element ? es2 : alt[es.id]);
        this.targets.splice(index, 1, state.targets[i]);
        this.elementStates.splice(index, 1, es);
      } else {
        this.targets.push(state.targets[i]);
        this.elementStates.push(es);
      }
    }

    state.interrupted && (this.interrupted = true);
    state.simple || (this.simple = false);

    _createLookup(this);

    return this;
  };

  _proto.compare = function compare(state) {
    var l1 = state.idLookup,
        l2 = this.idLookup,
        unchanged = [],
        changed = [],
        enter = [],
        leave = [],
        targets = [],
        a1 = state.alt,
        a2 = this.alt,
        place = function place(s1, s2, el) {
      return (s1.isVisible !== s2.isVisible ? s1.isVisible ? enter : leave : s1.isVisible ? changed : unchanged).push(el) && targets.push(el);
    },
        placeIfDoesNotExist = function placeIfDoesNotExist(s1, s2, el) {
      return targets.indexOf(el) < 0 && place(s1, s2, el);
    },
        s1,
        s2,
        p,
        el,
        s1Alt,
        s2Alt,
        c1,
        c2;

    for (p in l1) {
      s1Alt = a1[p];
      s2Alt = a2[p];
      s1 = !s1Alt ? l1[p] : _getChangingElState(state, this, p);
      el = s1.element;
      s2 = l2[p];

      if (s2Alt) {
        c2 = s2.isVisible || !s2Alt.isVisible && el === s2.element ? s2 : s2Alt;
        c1 = s1Alt && !s1.isVisible && !s1Alt.isVisible && c2.element === s1Alt.element ? s1Alt : s1; //c1.element !== c2.element && c1.element === s2.element && (c2 = s2);

        if (c1.isVisible && c2.isVisible && c1.element !== c2.element) {
          // swapping, so force into "changed" array
          (c1.isDifferent(c2) ? changed : unchanged).push(c1.element, c2.element);
          targets.push(c1.element, c2.element);
        } else {
          place(c1, c2, c1.element);
        }

        s1Alt && c1.element === s1Alt.element && (s1Alt = l1[p]);
        placeIfDoesNotExist(c1.element !== s2.element && s1Alt ? s1Alt : c1, s2, s2.element);
        placeIfDoesNotExist(s1Alt && s1Alt.element === s2Alt.element ? s1Alt : c1, s2Alt, s2Alt.element);
        s1Alt && placeIfDoesNotExist(s1Alt, s2Alt.element === s1Alt.element ? s2Alt : s2, s1Alt.element);
      } else {
        !s2 ? enter.push(el) : !s2.isDifferent(s1) ? unchanged.push(el) : place(s1, s2, el);
        s1Alt && placeIfDoesNotExist(s1Alt, s2, s1Alt.element);
      }
    }

    for (p in l2) {
      if (!l1[p]) {
        leave.push(l2[p].element);
        a2[p] && leave.push(a2[p].element);
      }
    }

    return {
      changed: changed,
      unchanged: unchanged,
      enter: enter,
      leave: leave
    };
  };

  _proto.recordInlineStyles = function recordInlineStyles() {
    var props = _memoizedRemoveProps[this.props] || _removeProps,
        i = this.elementStates.length;

    while (i--) {
      _recordInlineStyles(this.elementStates[i], props);
    }
  };

  _proto.interrupt = function interrupt(soft) {
    var _this2 = this;

    // soft = DON'T force in-progress flip animations to completion (like when running a batch, we can't immediately kill flips when getting states because it could contaminate positioning and other .getState() calls that will run in the batch (we kill AFTER all the .getState() calls complete).
    var timelines = [];
    this.targets.forEach(function (t) {
      var tl = t._flip,
          foundInProgress = _killFlip(tl, soft ? 0 : 1);

      soft && foundInProgress && timelines.indexOf(tl) < 0 && tl.add(function () {
        return _this2.updateVisibility();
      });
      foundInProgress && timelines.push(tl);
    });
    !soft && timelines.length && this.updateVisibility(); // if we found an in-progress Flip animation, we must record all the values in their current state at that point BUT we should update the isVisible value AFTER pushing that flip to completion so that elements that are entering or leaving will populate those Arrays properly.

    this.interrupted || (this.interrupted = !!timelines.length);
  };

  _proto.updateVisibility = function updateVisibility() {
    this.elementStates.forEach(function (es) {
      var b = es.element.getBoundingClientRect();
      es.isVisible = !!(b.width || b.height || b.top || b.left);
      es.uncache = 1;
    });
  };

  _proto.getElementState = function getElementState(element) {
    return this.elementStates[this.targets.indexOf(_getEl(element))];
  };

  _proto.makeAbsolute = function makeAbsolute() {
    return _orderByDOMDepth(this.elementStates.slice(0), true, true).map(_makeAbsolute);
  };

  return FlipState;
}();

var ElementState = /*#__PURE__*/function () {
  function ElementState(element, props, simple) {
    this.element = element;
    this.update(props, simple);
  }

  var _proto2 = ElementState.prototype;

  _proto2.isDifferent = function isDifferent(state) {
    var b1 = this.bounds,
        b2 = state.bounds;
    return b1.top !== b2.top || b1.left !== b2.left || b1.width !== b2.width || b1.height !== b2.height || !this.matrix.equals(state.matrix) || this.opacity !== state.opacity || this.props && state.props && JSON.stringify(this.props) !== JSON.stringify(state.props);
  };

  _proto2.update = function update(props, simple) {
    var self = this,
        element = self.element,
        getProp = gsap.getProperty(element),
        cache = gsap.core.getCache(element),
        bounds = element.getBoundingClientRect(),
        bbox = element.getBBox && typeof element.getBBox === "function" && element.nodeName.toLowerCase() !== "svg" && element.getBBox(),
        m = simple ? new _utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.Matrix2D(1, 0, 0, 1, bounds.left + (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__._getDocScrollLeft)(), bounds.top + (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__._getDocScrollTop)()) : (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(element, false, false, true);
    self.getProp = getProp;
    self.element = element;
    self.id = _getID(element);
    self.matrix = m;
    self.cache = cache;
    self.bounds = bounds;
    self.isVisible = !!(bounds.width || bounds.height || bounds.left || bounds.top);
    self.display = getProp("display");
    self.position = getProp("position");
    self.parent = element.parentNode;
    self.x = getProp("x");
    self.y = getProp("y");
    self.scaleX = cache.scaleX;
    self.scaleY = cache.scaleY;
    self.rotation = getProp("rotation");
    self.skewX = getProp("skewX");
    self.opacity = getProp("opacity");
    self.width = bbox ? bbox.width : _closestTenth(getProp("width", "px"), 0.04); // round up to the closest 0.1 so that text doesn't wrap.

    self.height = bbox ? bbox.height : _closestTenth(getProp("height", "px"), 0.04);
    props && _recordProps(self, _memoizedProps[props] || _memoizeProps(props));
    self.ctm = element.getCTM && element.nodeName.toLowerCase() === "svg" && (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__._getCTM)(element).inverse();
    self.simple = simple || _round(m.a) === 1 && !_round(m.b) && !_round(m.c) && _round(m.d) === 1; // allows us to speed through some other tasks if it's not scale/rotated

    self.uncache = 0;
  };

  return ElementState;
}();

var FlipAction = /*#__PURE__*/function () {
  function FlipAction(vars, batch) {
    this.vars = vars;
    this.batch = batch;
    this.states = [];
    this.timeline = batch.timeline;
  }

  var _proto3 = FlipAction.prototype;

  _proto3.getStateById = function getStateById(id) {
    var i = this.states.length;

    while (i--) {
      if (this.states[i].idLookup[id]) {
        return this.states[i];
      }
    }
  };

  _proto3.kill = function kill() {
    this.batch.remove(this);
  };

  return FlipAction;
}();

var FlipBatch = /*#__PURE__*/function () {
  function FlipBatch(id) {
    this.id = id;
    this.actions = [];
    this._kill = [];
    this._final = [];
    this._abs = [];
    this._run = [];
    this.data = {};
    this.state = new FlipState();
    this.timeline = gsap.timeline();
  }

  var _proto4 = FlipBatch.prototype;

  _proto4.add = function add(config) {
    var result = this.actions.filter(function (action) {
      return action.vars === config;
    });

    if (result.length) {
      return result[0];
    }

    result = new FlipAction(typeof config === "function" ? {
      animate: config
    } : config, this);
    this.actions.push(result);
    return result;
  };

  _proto4.remove = function remove(action) {
    var i = this.actions.indexOf(action);
    i >= 0 && this.actions.splice(i, 1);
    return this;
  };

  _proto4.getState = function getState(merge) {
    var _this3 = this;

    var prevBatch = _batch,
        prevAction = _batchAction;
    _batch = this;
    this.state.clear();
    this._kill.length = 0;
    this.actions.forEach(function (action) {
      if (action.vars.getState) {
        action.states.length = 0;
        _batchAction = action;
        action.state = action.vars.getState(action);
      }

      merge && action.states.forEach(function (s) {
        return _this3.state.add(s);
      });
    });
    _batchAction = prevAction;
    _batch = prevBatch;
    this.killConflicts();
    return this;
  };

  _proto4.animate = function animate() {
    var _this4 = this;

    var prevBatch = _batch,
        tl = this.timeline,
        i = this.actions.length,
        finalStates,
        endTime;
    _batch = this;
    tl.clear();
    this._abs.length = this._final.length = this._run.length = 0;
    this.actions.forEach(function (a) {
      a.vars.animate && a.vars.animate(a);
      var onEnter = a.vars.onEnter,
          onLeave = a.vars.onLeave,
          targets = a.targets,
          s,
          result;

      if (targets && targets.length && (onEnter || onLeave)) {
        s = new FlipState();
        a.states.forEach(function (state) {
          return s.add(state);
        });
        result = s.compare(Flip.getState(targets));
        result.enter.length && onEnter && onEnter(result.enter);
        result.leave.length && onLeave && onLeave(result.leave);
      }
    });

    _makeCompsAbsolute(this._abs);

    this._run.forEach(function (f) {
      return f();
    });

    endTime = tl.duration();
    finalStates = this._final.slice(0);
    tl.add(function () {
      if (endTime <= tl.time()) {
        // only call if moving forward in the timeline (in case it's nested in a timeline that gets reversed)
        finalStates.forEach(function (f) {
          return f();
        });

        _forEachBatch(_this4, "onComplete");
      }
    });
    _batch = prevBatch;

    while (i--) {
      this.actions[i].vars.once && this.actions[i].kill();
    }

    _forEachBatch(this, "onStart");

    tl.restart();
    return this;
  };

  _proto4.loadState = function loadState(done) {
    done || (done = function done() {
      return 0;
    });
    var queue = [];
    this.actions.forEach(function (c) {
      if (c.vars.loadState) {
        var i,
            f = function f(targets) {
          targets && (c.targets = targets);
          i = queue.indexOf(f);

          if (~i) {
            queue.splice(i, 1);
            queue.length || done();
          }
        };

        queue.push(f);
        c.vars.loadState(f);
      }
    });
    queue.length || done();
    return this;
  };

  _proto4.setState = function setState() {
    this.actions.forEach(function (c) {
      return c.targets = c.vars.setState && c.vars.setState(c);
    });
    return this;
  };

  _proto4.killConflicts = function killConflicts(soft) {
    this.state.interrupt(soft);

    this._kill.forEach(function (state) {
      return state.interrupt(soft);
    });

    return this;
  };

  _proto4.run = function run(skipGetState, merge) {
    var _this5 = this;

    if (this !== _batch) {
      skipGetState || this.getState(merge);
      this.loadState(function () {
        if (!_this5._killed) {
          _this5.setState();

          _this5.animate();
        }
      });
    }

    return this;
  };

  _proto4.clear = function clear(stateOnly) {
    this.state.clear();
    stateOnly || (this.actions.length = 0);
  };

  _proto4.getStateById = function getStateById(id) {
    var i = this.actions.length,
        s;

    while (i--) {
      s = this.actions[i].getStateById(id);

      if (s) {
        return s;
      }
    }

    return this.state.idLookup[id] && this.state;
  };

  _proto4.kill = function kill() {
    this._killed = 1;
    this.clear();
    delete _batchLookup[this.id];
  };

  return FlipBatch;
}();

var Flip = /*#__PURE__*/function () {
  function Flip() {}

  Flip.getState = function getState(targets, vars) {
    var state = _parseState(targets, vars);

    _batchAction && _batchAction.states.push(state);
    vars && vars.batch && Flip.batch(vars.batch).state.add(state);
    return state;
  };

  Flip.from = function from(state, vars) {
    vars = vars || {};
    "clearProps" in vars || (vars.clearProps = true);
    return _fromTo(state, _parseState(vars.targets || state.targets, {
      props: vars.props || state.props,
      simple: vars.simple,
      kill: !!vars.kill
    }), vars, -1);
  };

  Flip.to = function to(state, vars) {
    return _fromTo(state, _parseState(vars.targets || state.targets, {
      props: vars.props || state.props,
      simple: vars.simple,
      kill: !!vars.kill
    }), vars, 1);
  };

  Flip.fromTo = function fromTo(fromState, toState, vars) {
    return _fromTo(fromState, toState, vars);
  };

  Flip.fit = function fit(fromEl, toEl, vars) {
    var v = vars ? _copy(vars, _fitReserved) : {},
        _ref = vars || v,
        absolute = _ref.absolute,
        scale = _ref.scale,
        getVars = _ref.getVars,
        props = _ref.props,
        runBackwards = _ref.runBackwards,
        onComplete = _ref.onComplete,
        simple = _ref.simple,
        fitChild = vars && vars.fitChild && _getEl(vars.fitChild),
        before = _parseElementState(toEl, props, simple, fromEl),
        after = _parseElementState(fromEl, 0, simple, before),
        inlineProps = props ? _memoizedRemoveProps[props] : _removeProps;

    props && _applyProps(v, before.props);

    if (runBackwards) {
      _recordInlineStyles(after, inlineProps);

      "immediateRender" in v || (v.immediateRender = true);

      v.onComplete = function () {
        _applyInlineStyles(after);

        onComplete && onComplete.apply(this, arguments);
      };
    }

    absolute && _makeAbsolute(after, before);
    v = _fit(after, before, scale || fitChild, props, fitChild, v.duration || getVars ? v : 0);
    return getVars ? v : v.duration ? gsap.to(after.element, v) : null;
  };

  Flip.makeAbsolute = function makeAbsolute(targetsOrStates, vars) {
    return (targetsOrStates instanceof FlipState ? targetsOrStates : new FlipState(targetsOrStates, vars)).makeAbsolute();
  };

  Flip.batch = function batch(id) {
    id || (id = "default");
    return _batchLookup[id] || (_batchLookup[id] = new FlipBatch(id));
  };

  Flip.killFlipsOf = function killFlipsOf(targets, complete) {
    (targets instanceof FlipState ? targets.targets : _toArray(targets)).forEach(function (t) {
      return t && _killFlip(t._flip, complete !== false ? 1 : 2);
    });
  };

  Flip.isFlipping = function isFlipping(target) {
    var f = Flip.getByTarget(target);
    return !!f && f.isActive();
  };

  Flip.getByTarget = function getByTarget(target) {
    return (_getEl(target) || _emptyObj)._flip;
  };

  Flip.getElementState = function getElementState(target, props) {
    return new ElementState(_getEl(target), props);
  };

  Flip.convertCoordinates = function convertCoordinates(fromElement, toElement, point) {
    var m = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(toElement, true, true).multiply((0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__.getGlobalMatrix)(fromElement));
    return point ? m.apply(point) : m;
  };

  Flip.register = function register(core) {
    _body = typeof document !== "undefined" && document.body;

    if (_body) {
      gsap = core;

      (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_0__._setDoc)(_body);

      _toArray = gsap.utils.toArray;
      var snap = gsap.utils.snap(0.1);

      _closestTenth = function _closestTenth(value, add) {
        return snap(parseFloat(value) + add);
      };
    }
  };

  return Flip;
}();
Flip.version = "3.9.1"; // function whenImagesLoad(el, func) {
// 	let pending = [],
// 		onLoad = e => {
// 			pending.splice(pending.indexOf(e.target), 1);
// 			e.target.removeEventListener("load", onLoad);
// 			pending.length || func();
// 		};
// 	gsap.utils.toArray(el.tagName.toLowerCase() === "img" ? el : el.querySelectorAll("img")).forEach(img => img.complete || img.addEventListener("load", onLoad) || pending.push(img));
// 	pending.length || func();
// }

typeof window !== "undefined" && window.gsap && window.gsap.registerPlugin(Flip);


/***/ }),

/***/ "./node_modules/gsap/MotionPathPlugin.js":
/*!***********************************************!*\
  !*** ./node_modules/gsap/MotionPathPlugin.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MotionPathPlugin": () => (/* binding */ MotionPathPlugin),
/* harmony export */   "default": () => (/* binding */ MotionPathPlugin)
/* harmony export */ });
/* harmony import */ var _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/paths.js */ "./node_modules/gsap/utils/paths.js");
/* harmony import */ var _utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/matrix.js */ "./node_modules/gsap/utils/matrix.js");
/*!
 * MotionPathPlugin 3.9.1
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */



var _xProps = "x,translateX,left,marginLeft,xPercent".split(","),
    _yProps = "y,translateY,top,marginTop,yPercent".split(","),
    _DEG2RAD = Math.PI / 180,
    gsap,
    PropTween,
    _getUnit,
    _toArray,
    _getGSAP = function _getGSAP() {
  return gsap || typeof window !== "undefined" && (gsap = window.gsap) && gsap.registerPlugin && gsap;
},
    _populateSegmentFromArray = function _populateSegmentFromArray(segment, values, property, mode) {
  //mode: 0 = x but don't fill y yet, 1 = y, 2 = x and fill y with 0.
  var l = values.length,
      si = mode === 2 ? 0 : mode,
      i = 0,
      v;

  for (; i < l; i++) {
    segment[si] = v = parseFloat(values[i][property]);
    mode === 2 && (segment[si + 1] = 0);
    si += 2;
  }

  return segment;
},
    _getPropNum = function _getPropNum(target, prop, unit) {
  return parseFloat(target._gsap.get(target, prop, unit || "px")) || 0;
},
    _relativize = function _relativize(segment) {
  var x = segment[0],
      y = segment[1],
      i;

  for (i = 2; i < segment.length; i += 2) {
    x = segment[i] += x;
    y = segment[i + 1] += y;
  }
},
    // feed in an array of quadratic bezier points like [{x: 0, y: 0}, ...] and it'll convert it to cubic bezier
// _quadToCubic = points => {
// 	let cubic = [],
// 		l = points.length - 1,
// 		i = 1,
// 		a, b, c;
// 	for (; i < l; i+=2) {
// 		a = points[i-1];
// 		b = points[i];
// 		c = points[i+1];
// 		cubic.push(a, {x: (2 * b.x + a.x) / 3, y: (2 * b.y + a.y) / 3}, {x: (2 * b.x + c.x) / 3, y: (2 * b.y + c.y) / 3});
// 	}
// 	cubic.push(points[l]);
// 	return cubic;
// },
_segmentToRawPath = function _segmentToRawPath(plugin, segment, target, x, y, slicer, vars, unitX, unitY) {
  if (vars.type === "cubic") {
    segment = [segment];
  } else {
    vars.fromCurrent !== false && segment.unshift(_getPropNum(target, x, unitX), y ? _getPropNum(target, y, unitY) : 0);
    vars.relative && _relativize(segment);
    var pointFunc = y ? _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.pointsToSegment : _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.flatPointsToSegment;
    segment = [pointFunc(segment, vars.curviness)];
  }

  segment = slicer(_align(segment, target, vars));

  _addDimensionalPropTween(plugin, target, x, segment, "x", unitX);

  y && _addDimensionalPropTween(plugin, target, y, segment, "y", unitY);
  return (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.cacheRawPathMeasurements)(segment, vars.resolution || (vars.curviness === 0 ? 20 : 12)); //when curviness is 0, it creates control points right on top of the anchors which makes it more sensitive to resolution, thus we change the default accordingly.
},
    _emptyFunc = function _emptyFunc(v) {
  return v;
},
    _numExp = /[-+\.]*\d+\.?(?:e-|e\+)?\d*/g,
    _originToPoint = function _originToPoint(element, origin, parentMatrix) {
  // origin is an array of normalized values (0-1) in relation to the width/height, so [0.5, 0.5] would be the center. It can also be "auto" in which case it will be the top left unless it's a <path>, when it will start at the beginning of the path itself.
  var m = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix)(element),
      x = 0,
      y = 0,
      svg;

  if ((element.tagName + "").toLowerCase() === "svg") {
    svg = element.viewBox.baseVal;
    svg.width || (svg = {
      width: +element.getAttribute("width"),
      height: +element.getAttribute("height")
    });
  } else {
    svg = origin && element.getBBox && element.getBBox();
  }

  if (origin && origin !== "auto") {
    x = origin.push ? origin[0] * (svg ? svg.width : element.offsetWidth || 0) : origin.x;
    y = origin.push ? origin[1] * (svg ? svg.height : element.offsetHeight || 0) : origin.y;
  }

  return parentMatrix.apply(x || y ? m.apply({
    x: x,
    y: y
  }) : {
    x: m.e,
    y: m.f
  });
},
    _getAlignMatrix = function _getAlignMatrix(fromElement, toElement, fromOrigin, toOrigin) {
  var parentMatrix = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix)(fromElement.parentNode, true, true),
      m = parentMatrix.clone().multiply((0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix)(toElement)),
      fromPoint = _originToPoint(fromElement, fromOrigin, parentMatrix),
      _originToPoint2 = _originToPoint(toElement, toOrigin, parentMatrix),
      x = _originToPoint2.x,
      y = _originToPoint2.y,
      p;

  m.e = m.f = 0;

  if (toOrigin === "auto" && toElement.getTotalLength && toElement.tagName.toLowerCase() === "path") {
    p = toElement.getAttribute("d").match(_numExp) || [];
    p = m.apply({
      x: +p[0],
      y: +p[1]
    });
    x += p.x;
    y += p.y;
  }

  if (p || toElement.getBBox && fromElement.getBBox && toElement.ownerSVGElement === fromElement.ownerSVGElement) {
    p = m.apply(toElement.getBBox());
    x -= p.x;
    y -= p.y;
  }

  m.e = x - fromPoint.x;
  m.f = y - fromPoint.y;
  return m;
},
    _align = function _align(rawPath, target, _ref) {
  var align = _ref.align,
      matrix = _ref.matrix,
      offsetX = _ref.offsetX,
      offsetY = _ref.offsetY,
      alignOrigin = _ref.alignOrigin;

  var x = rawPath[0][0],
      y = rawPath[0][1],
      curX = _getPropNum(target, "x"),
      curY = _getPropNum(target, "y"),
      alignTarget,
      m,
      p;

  if (!rawPath || !rawPath.length) {
    return (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getRawPath)("M0,0L0,0");
  }

  if (align) {
    if (align === "self" || (alignTarget = _toArray(align)[0] || target) === target) {
      (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath)(rawPath, 1, 0, 0, 1, curX - x, curY - y);
    } else {
      if (alignOrigin && alignOrigin[2] !== false) {
        gsap.set(target, {
          transformOrigin: alignOrigin[0] * 100 + "% " + alignOrigin[1] * 100 + "%"
        });
      } else {
        alignOrigin = [_getPropNum(target, "xPercent") / -100, _getPropNum(target, "yPercent") / -100];
      }

      m = _getAlignMatrix(target, alignTarget, alignOrigin, "auto");
      p = m.apply({
        x: x,
        y: y
      });
      (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath)(rawPath, m.a, m.b, m.c, m.d, curX + m.e - (p.x - m.e), curY + m.f - (p.y - m.f));
    }
  }

  if (matrix) {
    (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath)(rawPath, matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
  } else if (offsetX || offsetY) {
    (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath)(rawPath, 1, 0, 0, 1, offsetX || 0, offsetY || 0);
  }

  return rawPath;
},
    _addDimensionalPropTween = function _addDimensionalPropTween(plugin, target, property, rawPath, pathProperty, forceUnit) {
  var cache = target._gsap,
      harness = cache.harness,
      alias = harness && harness.aliases && harness.aliases[property],
      prop = alias && alias.indexOf(",") < 0 ? alias : property,
      pt = plugin._pt = new PropTween(plugin._pt, target, prop, 0, 0, _emptyFunc, 0, cache.set(target, prop, plugin));
  pt.u = _getUnit(cache.get(target, prop, forceUnit)) || 0;
  pt.path = rawPath;
  pt.pp = pathProperty;

  plugin._props.push(prop);
},
    _sliceModifier = function _sliceModifier(start, end) {
  return function (rawPath) {
    return start || end !== 1 ? (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.sliceRawPath)(rawPath, start, end) : rawPath;
  };
};

var MotionPathPlugin = {
  version: "3.9.1",
  name: "motionPath",
  register: function register(core, Plugin, propTween) {
    gsap = core;
    _getUnit = gsap.utils.getUnit;
    _toArray = gsap.utils.toArray;
    PropTween = propTween;
  },
  init: function init(target, vars) {
    if (!gsap) {
      console.warn("Please gsap.registerPlugin(MotionPathPlugin)");
      return false;
    }

    if (!(typeof vars === "object" && !vars.style) || !vars.path) {
      vars = {
        path: vars
      };
    }

    var rawPaths = [],
        _vars = vars,
        path = _vars.path,
        autoRotate = _vars.autoRotate,
        unitX = _vars.unitX,
        unitY = _vars.unitY,
        x = _vars.x,
        y = _vars.y,
        firstObj = path[0],
        slicer = _sliceModifier(vars.start, "end" in vars ? vars.end : 1),
        rawPath,
        p;

    this.rawPaths = rawPaths;
    this.target = target;

    if (this.rotate = autoRotate || autoRotate === 0) {
      //get the rotational data FIRST so that the setTransform() method is called in the correct order in the render() loop - rotation gets set last.
      this.rOffset = parseFloat(autoRotate) || 0;
      this.radians = !!vars.useRadians;
      this.rProp = vars.rotation || "rotation"; // rotation property

      this.rSet = target._gsap.set(target, this.rProp, this); // rotation setter

      this.ru = _getUnit(target._gsap.get(target, this.rProp)) || 0; // rotation units
    }

    if (Array.isArray(path) && !("closed" in path) && typeof firstObj !== "number") {
      for (p in firstObj) {
        if (!x && ~_xProps.indexOf(p)) {
          x = p;
        } else if (!y && ~_yProps.indexOf(p)) {
          y = p;
        }
      }

      if (x && y) {
        //correlated values
        rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray(_populateSegmentFromArray([], path, x, 0), path, y, 1), target, x, y, slicer, vars, unitX || _getUnit(path[0][x]), unitY || _getUnit(path[0][y])));
      } else {
        x = y = 0;
      }

      for (p in firstObj) {
        p !== x && p !== y && rawPaths.push(_segmentToRawPath(this, _populateSegmentFromArray([], path, p, 2), target, p, 0, slicer, vars, _getUnit(path[0][p])));
      }
    } else {
      rawPath = slicer(_align((0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getRawPath)(vars.path), target, vars));
      (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.cacheRawPathMeasurements)(rawPath, vars.resolution);
      rawPaths.push(rawPath);

      _addDimensionalPropTween(this, target, vars.x || "x", rawPath, "x", vars.unitX || "px");

      _addDimensionalPropTween(this, target, vars.y || "y", rawPath, "y", vars.unitY || "px");
    }
  },
  render: function render(ratio, data) {
    var rawPaths = data.rawPaths,
        i = rawPaths.length,
        pt = data._pt;

    if (ratio > 1) {
      ratio = 1;
    } else if (ratio < 0) {
      ratio = 0;
    }

    while (i--) {
      (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getPositionOnPath)(rawPaths[i], ratio, !i && data.rotate, rawPaths[i]);
    }

    while (pt) {
      pt.set(pt.t, pt.p, pt.path[pt.pp] + pt.u, pt.d, ratio);
      pt = pt._next;
    }

    data.rotate && data.rSet(data.target, data.rProp, rawPaths[0].angle * (data.radians ? _DEG2RAD : 1) + data.rOffset + data.ru, data, ratio);
  },
  getLength: function getLength(path) {
    return (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.cacheRawPathMeasurements)((0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getRawPath)(path)).totalLength;
  },
  sliceRawPath: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.sliceRawPath,
  getRawPath: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getRawPath,
  pointsToSegment: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.pointsToSegment,
  stringToRawPath: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.stringToRawPath,
  rawPathToString: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.rawPathToString,
  transformRawPath: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.transformRawPath,
  getGlobalMatrix: _utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix,
  getPositionOnPath: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.getPositionOnPath,
  cacheRawPathMeasurements: _utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.cacheRawPathMeasurements,
  convertToPath: function convertToPath(targets, swap) {
    return _toArray(targets).map(function (target) {
      return (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.convertToPath)(target, swap !== false);
    });
  },
  convertCoordinates: function convertCoordinates(fromElement, toElement, point) {
    var m = (0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix)(toElement, true, true).multiply((0,_utils_matrix_js__WEBPACK_IMPORTED_MODULE_1__.getGlobalMatrix)(fromElement));
    return point ? m.apply(point) : m;
  },
  getAlignMatrix: _getAlignMatrix,
  getRelativePosition: function getRelativePosition(fromElement, toElement, fromOrigin, toOrigin) {
    var m = _getAlignMatrix(fromElement, toElement, fromOrigin, toOrigin);

    return {
      x: m.e,
      y: m.f
    };
  },
  arrayToRawPath: function arrayToRawPath(value, vars) {
    vars = vars || {};

    var segment = _populateSegmentFromArray(_populateSegmentFromArray([], value, vars.x || "x", 0), value, vars.y || "y", 1);

    vars.relative && _relativize(segment);
    return [vars.type === "cubic" ? segment : (0,_utils_paths_js__WEBPACK_IMPORTED_MODULE_0__.pointsToSegment)(segment, vars.curviness)];
  }
};
_getGSAP() && gsap.registerPlugin(MotionPathPlugin);


/***/ }),

/***/ "./node_modules/gsap/PixiPlugin.js":
/*!*****************************************!*\
  !*** ./node_modules/gsap/PixiPlugin.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PixiPlugin": () => (/* binding */ PixiPlugin),
/* harmony export */   "default": () => (/* binding */ PixiPlugin)
/* harmony export */ });
/*!
 * PixiPlugin 3.9.1
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */
var gsap,
    _win,
    _splitColor,
    _coreInitted,
    _PIXI,
    PropTween,
    _getSetter,
    _isV4,
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _getGSAP = function _getGSAP() {
  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;
},
    _isFunction = function _isFunction(value) {
  return typeof value === "function";
},
    _warn = function _warn(message) {
  return console.warn(message);
},
    _idMatrix = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
    _lumR = 0.212671,
    _lumG = 0.715160,
    _lumB = 0.072169,
    _applyMatrix = function _applyMatrix(m, m2) {
  var temp = [],
      i = 0,
      z = 0,
      y,
      x;

  for (y = 0; y < 4; y++) {
    for (x = 0; x < 5; x++) {
      z = x === 4 ? m[i + 4] : 0;
      temp[i + x] = m[i] * m2[x] + m[i + 1] * m2[x + 5] + m[i + 2] * m2[x + 10] + m[i + 3] * m2[x + 15] + z;
    }

    i += 5;
  }

  return temp;
},
    _setSaturation = function _setSaturation(m, n) {
  var inv = 1 - n,
      r = inv * _lumR,
      g = inv * _lumG,
      b = inv * _lumB;
  return _applyMatrix([r + n, g, b, 0, 0, r, g + n, b, 0, 0, r, g, b + n, 0, 0, 0, 0, 0, 1, 0], m);
},
    _colorize = function _colorize(m, color, amount) {
  var c = _splitColor(color),
      r = c[0] / 255,
      g = c[1] / 255,
      b = c[2] / 255,
      inv = 1 - amount;

  return _applyMatrix([inv + amount * r * _lumR, amount * r * _lumG, amount * r * _lumB, 0, 0, amount * g * _lumR, inv + amount * g * _lumG, amount * g * _lumB, 0, 0, amount * b * _lumR, amount * b * _lumG, inv + amount * b * _lumB, 0, 0, 0, 0, 0, 1, 0], m);
},
    _setHue = function _setHue(m, n) {
  n *= Math.PI / 180;
  var c = Math.cos(n),
      s = Math.sin(n);
  return _applyMatrix([_lumR + c * (1 - _lumR) + s * -_lumR, _lumG + c * -_lumG + s * -_lumG, _lumB + c * -_lumB + s * (1 - _lumB), 0, 0, _lumR + c * -_lumR + s * 0.143, _lumG + c * (1 - _lumG) + s * 0.14, _lumB + c * -_lumB + s * -0.283, 0, 0, _lumR + c * -_lumR + s * -(1 - _lumR), _lumG + c * -_lumG + s * _lumG, _lumB + c * (1 - _lumB) + s * _lumB, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1], m);
},
    _setContrast = function _setContrast(m, n) {
  return _applyMatrix([n, 0, 0, 0, 0.5 * (1 - n), 0, n, 0, 0, 0.5 * (1 - n), 0, 0, n, 0, 0.5 * (1 - n), 0, 0, 0, 1, 0], m);
},
    _getFilter = function _getFilter(target, type) {
  var filterClass = _PIXI.filters[type],
      filters = target.filters || [],
      i = filters.length,
      filter;
  filterClass || _warn(type + " not found. PixiPlugin.registerPIXI(PIXI)");

  while (--i > -1) {
    if (filters[i] instanceof filterClass) {
      return filters[i];
    }
  }

  filter = new filterClass();

  if (type === "BlurFilter") {
    filter.blur = 0;
  }

  filters.push(filter);
  target.filters = filters;
  return filter;
},
    _addColorMatrixFilterCacheTween = function _addColorMatrixFilterCacheTween(p, plugin, cache, vars) {
  //we cache the ColorMatrixFilter components in a _gsColorMatrixFilter object attached to the target object so that it's easy to grab the current value at any time.
  plugin.add(cache, p, cache[p], vars[p]);

  plugin._props.push(p);
},
    _applyBrightnessToMatrix = function _applyBrightnessToMatrix(brightness, matrix) {
  var temp = new _PIXI.filters.ColorMatrixFilter();
  temp.matrix = matrix;
  temp.brightness(brightness, true);
  return temp.matrix;
},
    _copy = function _copy(obj) {
  var copy = {},
      p;

  for (p in obj) {
    copy[p] = obj[p];
  }

  return copy;
},
    _CMFdefaults = {
  contrast: 1,
  saturation: 1,
  colorizeAmount: 0,
  colorize: "rgb(255,255,255)",
  hue: 0,
  brightness: 1
},
    _parseColorMatrixFilter = function _parseColorMatrixFilter(target, v, pg) {
  var filter = _getFilter(target, "ColorMatrixFilter"),
      cache = target._gsColorMatrixFilter = target._gsColorMatrixFilter || _copy(_CMFdefaults),
      combine = v.combineCMF && !("colorMatrixFilter" in v && !v.colorMatrixFilter),
      i,
      matrix,
      startMatrix;

  startMatrix = filter.matrix;

  if (v.resolution) {
    filter.resolution = v.resolution;
  }

  if (v.matrix && v.matrix.length === startMatrix.length) {
    matrix = v.matrix;

    if (cache.contrast !== 1) {
      _addColorMatrixFilterCacheTween("contrast", pg, cache, _CMFdefaults);
    }

    if (cache.hue) {
      _addColorMatrixFilterCacheTween("hue", pg, cache, _CMFdefaults);
    }

    if (cache.brightness !== 1) {
      _addColorMatrixFilterCacheTween("brightness", pg, cache, _CMFdefaults);
    }

    if (cache.colorizeAmount) {
      _addColorMatrixFilterCacheTween("colorize", pg, cache, _CMFdefaults);

      _addColorMatrixFilterCacheTween("colorizeAmount", pg, cache, _CMFdefaults);
    }

    if (cache.saturation !== 1) {
      _addColorMatrixFilterCacheTween("saturation", pg, cache, _CMFdefaults);
    }
  } else {
    matrix = _idMatrix.slice();

    if (v.contrast != null) {
      matrix = _setContrast(matrix, +v.contrast);

      _addColorMatrixFilterCacheTween("contrast", pg, cache, v);
    } else if (cache.contrast !== 1) {
      if (combine) {
        matrix = _setContrast(matrix, cache.contrast);
      } else {
        _addColorMatrixFilterCacheTween("contrast", pg, cache, _CMFdefaults);
      }
    }

    if (v.hue != null) {
      matrix = _setHue(matrix, +v.hue);

      _addColorMatrixFilterCacheTween("hue", pg, cache, v);
    } else if (cache.hue) {
      if (combine) {
        matrix = _setHue(matrix, cache.hue);
      } else {
        _addColorMatrixFilterCacheTween("hue", pg, cache, _CMFdefaults);
      }
    }

    if (v.brightness != null) {
      matrix = _applyBrightnessToMatrix(+v.brightness, matrix);

      _addColorMatrixFilterCacheTween("brightness", pg, cache, v);
    } else if (cache.brightness !== 1) {
      if (combine) {
        matrix = _applyBrightnessToMatrix(cache.brightness, matrix);
      } else {
        _addColorMatrixFilterCacheTween("brightness", pg, cache, _CMFdefaults);
      }
    }

    if (v.colorize != null) {
      v.colorizeAmount = "colorizeAmount" in v ? +v.colorizeAmount : 1;
      matrix = _colorize(matrix, v.colorize, v.colorizeAmount);

      _addColorMatrixFilterCacheTween("colorize", pg, cache, v);

      _addColorMatrixFilterCacheTween("colorizeAmount", pg, cache, v);
    } else if (cache.colorizeAmount) {
      if (combine) {
        matrix = _colorize(matrix, cache.colorize, cache.colorizeAmount);
      } else {
        _addColorMatrixFilterCacheTween("colorize", pg, cache, _CMFdefaults);

        _addColorMatrixFilterCacheTween("colorizeAmount", pg, cache, _CMFdefaults);
      }
    }

    if (v.saturation != null) {
      matrix = _setSaturation(matrix, +v.saturation);

      _addColorMatrixFilterCacheTween("saturation", pg, cache, v);
    } else if (cache.saturation !== 1) {
      if (combine) {
        matrix = _setSaturation(matrix, cache.saturation);
      } else {
        _addColorMatrixFilterCacheTween("saturation", pg, cache, _CMFdefaults);
      }
    }
  }

  i = matrix.length;

  while (--i > -1) {
    if (matrix[i] !== startMatrix[i]) {
      pg.add(startMatrix, i, startMatrix[i], matrix[i], "colorMatrixFilter");
    }
  }

  pg._props.push("colorMatrixFilter");
},
    _renderColor = function _renderColor(ratio, _ref) {
  var t = _ref.t,
      p = _ref.p,
      color = _ref.color,
      set = _ref.set;
  set(t, p, color[0] << 16 | color[1] << 8 | color[2]);
},
    _renderDirtyCache = function _renderDirtyCache(ratio, _ref2) {
  var g = _ref2.g;

  if (g) {
    //in order for PixiJS to actually redraw GraphicsData, we've gotta increment the "dirty" and "clearDirty" values. If we don't do this, the values will be tween properly, but not rendered.
    g.dirty++;
    g.clearDirty++;
  }
},
    _renderAutoAlpha = function _renderAutoAlpha(ratio, data) {
  data.t.visible = !!data.t.alpha;
},
    _addColorTween = function _addColorTween(target, p, value, plugin) {
  var currentValue = target[p],
      startColor = _splitColor(_isFunction(currentValue) ? target[p.indexOf("set") || !_isFunction(target["get" + p.substr(3)]) ? p : "get" + p.substr(3)]() : currentValue),
      endColor = _splitColor(value);

  plugin._pt = new PropTween(plugin._pt, target, p, 0, 0, _renderColor, {
    t: target,
    p: p,
    color: startColor,
    set: _getSetter(target, p)
  });
  plugin.add(startColor, 0, startColor[0], endColor[0]);
  plugin.add(startColor, 1, startColor[1], endColor[1]);
  plugin.add(startColor, 2, startColor[2], endColor[2]);
},
    _colorProps = {
  tint: 1,
  lineColor: 1,
  fillColor: 1
},
    _xyContexts = "position,scale,skew,pivot,anchor,tilePosition,tileScale".split(","),
    _contexts = {
  x: "position",
  y: "position",
  tileX: "tilePosition",
  tileY: "tilePosition"
},
    _colorMatrixFilterProps = {
  colorMatrixFilter: 1,
  saturation: 1,
  contrast: 1,
  hue: 1,
  colorize: 1,
  colorizeAmount: 1,
  brightness: 1,
  combineCMF: 1
},
    _DEG2RAD = Math.PI / 180,
    _isString = function _isString(value) {
  return typeof value === "string";
},
    _degreesToRadians = function _degreesToRadians(value) {
  return _isString(value) && value.charAt(1) === "=" ? value.substr(0, 2) + parseFloat(value.substr(2)) * _DEG2RAD : value * _DEG2RAD;
},
    _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {
  return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 100000) / 100000, data);
},
    _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue, radians) {
  var cap = 360 * (radians ? _DEG2RAD : 1),
      isString = _isString(endValue),
      relative = isString && endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0,
      endNum = parseFloat(relative ? endValue.substr(2) : endValue) * (radians ? _DEG2RAD : 1),
      change = relative ? endNum * relative : endNum - startNum,
      finalValue = startNum + change,
      direction,
      pt;

  if (isString) {
    direction = endValue.split("_")[1];

    if (direction === "short") {
      change %= cap;

      if (change !== change % (cap / 2)) {
        change += change < 0 ? cap : -cap;
      }
    }

    if (direction === "cw" && change < 0) {
      change = (change + cap * 1e10) % cap - ~~(change / cap) * cap;
    } else if (direction === "ccw" && change > 0) {
      change = (change - cap * 1e10) % cap - ~~(change / cap) * cap;
    }
  }

  plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
  pt.e = finalValue;
  return pt;
},
    _initCore = function _initCore() {
  if (_windowExists()) {
    _win = window;
    gsap = _getGSAP();
    _PIXI = _coreInitted = _PIXI || _win.PIXI;
    _isV4 = _PIXI && _PIXI.VERSION && _PIXI.VERSION.charAt(0) === "4";

    _splitColor = function _splitColor(color) {
      return gsap.utils.splitColor((color + "").substr(0, 2) === "0x" ? "#" + color.substr(2) : color);
    }; // some colors in PIXI are reported as "0xFF4421" instead of "#FF4421".

  }
},
    i,
    p; //context setup...


for (i = 0; i < _xyContexts.length; i++) {
  p = _xyContexts[i];
  _contexts[p + "X"] = p;
  _contexts[p + "Y"] = p;
}

var PixiPlugin = {
  version: "3.9.1",
  name: "pixi",
  register: function register(core, Plugin, propTween) {
    gsap = core;
    PropTween = propTween;
    _getSetter = Plugin.getSetter;

    _initCore();
  },
  registerPIXI: function registerPIXI(pixi) {
    _PIXI = pixi;
  },
  init: function init(target, values, tween, index, targets) {
    _PIXI || _initCore();

    if (!_PIXI || !(target instanceof _PIXI.DisplayObject)) {
      console.warn(target, "is not a DisplayObject or PIXI was not found. PixiPlugin.registerPIXI(PIXI);");
      return false;
    }

    var context, axis, value, colorMatrix, filter, p, padding, i, data;

    for (p in values) {
      context = _contexts[p];
      value = values[p];

      if (context) {
        axis = ~p.charAt(p.length - 1).toLowerCase().indexOf("x") ? "x" : "y";
        this.add(target[context], axis, target[context][axis], context === "skew" ? _degreesToRadians(value) : value);
      } else if (p === "scale" || p === "anchor" || p === "pivot" || p === "tileScale") {
        this.add(target[p], "x", target[p].x, value);
        this.add(target[p], "y", target[p].y, value);
      } else if (p === "rotation" || p === "angle") {
        //PIXI expects rotation in radians, but as a convenience we let folks define it in degrees and we do the conversion.
        _addRotationalPropTween(this, target, p, target[p], value, p === "rotation");
      } else if (_colorMatrixFilterProps[p]) {
        if (!colorMatrix) {
          _parseColorMatrixFilter(target, values.colorMatrixFilter || values, this);

          colorMatrix = true;
        }
      } else if (p === "blur" || p === "blurX" || p === "blurY" || p === "blurPadding") {
        filter = _getFilter(target, "BlurFilter");
        this.add(filter, p, filter[p], value);

        if (values.blurPadding !== 0) {
          padding = values.blurPadding || Math.max(filter[p], value) * 2;
          i = target.filters.length;

          while (--i > -1) {
            target.filters[i].padding = Math.max(target.filters[i].padding, padding); //if we don't expand the padding on all the filters, it can look clipped.
          }
        }
      } else if (_colorProps[p]) {
        if ((p === "lineColor" || p === "fillColor") && target instanceof _PIXI.Graphics) {
          data = (target.geometry || target).graphicsData; //"geometry" was introduced in PIXI version 5

          this._pt = new PropTween(this._pt, target, p, 0, 0, _renderDirtyCache, {
            g: target.geometry || target
          });
          i = data.length;

          while (--i > -1) {
            _addColorTween(_isV4 ? data[i] : data[i][p.substr(0, 4) + "Style"], _isV4 ? p : "color", value, this);
          }
        } else {
          _addColorTween(target, p, value, this);
        }
      } else if (p === "autoAlpha") {
        this._pt = new PropTween(this._pt, target, "visible", 0, 0, _renderAutoAlpha);
        this.add(target, "alpha", target.alpha, value);

        this._props.push("alpha", "visible");
      } else if (p !== "resolution") {
        this.add(target, p, "get", value);
      }

      this._props.push(p);
    }
  }
};
_getGSAP() && gsap.registerPlugin(PixiPlugin);


/***/ }),

/***/ "./node_modules/gsap/ScrollToPlugin.js":
/*!*********************************************!*\
  !*** ./node_modules/gsap/ScrollToPlugin.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScrollToPlugin": () => (/* binding */ ScrollToPlugin),
/* harmony export */   "default": () => (/* binding */ ScrollToPlugin)
/* harmony export */ });
/*!
 * ScrollToPlugin 3.9.1
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */
var gsap,
    _coreInitted,
    _window,
    _docEl,
    _body,
    _toArray,
    _config,
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _getGSAP = function _getGSAP() {
  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;
},
    _isString = function _isString(value) {
  return typeof value === "string";
},
    _isFunction = function _isFunction(value) {
  return typeof value === "function";
},
    _max = function _max(element, axis) {
  var dim = axis === "x" ? "Width" : "Height",
      scroll = "scroll" + dim,
      client = "client" + dim;
  return element === _window || element === _docEl || element === _body ? Math.max(_docEl[scroll], _body[scroll]) - (_window["inner" + dim] || _docEl[client] || _body[client]) : element[scroll] - element["offset" + dim];
},
    _buildGetter = function _buildGetter(e, axis) {
  //pass in an element and an axis ("x" or "y") and it'll return a getter function for the scroll position of that element (like scrollTop or scrollLeft, although if the element is the window, it'll use the pageXOffset/pageYOffset or the documentElement's scrollTop/scrollLeft or document.body's. Basically this streamlines things and makes a very fast getter across browsers.
  var p = "scroll" + (axis === "x" ? "Left" : "Top");

  if (e === _window) {
    if (e.pageXOffset != null) {
      p = "page" + axis.toUpperCase() + "Offset";
    } else {
      e = _docEl[p] != null ? _docEl : _body;
    }
  }

  return function () {
    return e[p];
  };
},
    _clean = function _clean(value, index, target, targets) {
  _isFunction(value) && (value = value(index, target, targets));

  if (typeof value !== "object") {
    return _isString(value) && value !== "max" && value.charAt(1) !== "=" ? {
      x: value,
      y: value
    } : {
      y: value
    }; //if we don't receive an object as the parameter, assume the user intends "y".
  } else if (value.nodeType) {
    return {
      y: value,
      x: value
    };
  } else {
    var result = {},
        p;

    for (p in value) {
      result[p] = p !== "onAutoKill" && _isFunction(value[p]) ? value[p](index, target, targets) : value[p];
    }

    return result;
  }
},
    _getOffset = function _getOffset(element, container) {
  element = _toArray(element)[0];

  if (!element || !element.getBoundingClientRect) {
    return console.warn("scrollTo target doesn't exist. Using 0") || {
      x: 0,
      y: 0
    };
  }

  var rect = element.getBoundingClientRect(),
      isRoot = !container || container === _window || container === _body,
      cRect = isRoot ? {
    top: _docEl.clientTop - (_window.pageYOffset || _docEl.scrollTop || _body.scrollTop || 0),
    left: _docEl.clientLeft - (_window.pageXOffset || _docEl.scrollLeft || _body.scrollLeft || 0)
  } : container.getBoundingClientRect(),
      offsets = {
    x: rect.left - cRect.left,
    y: rect.top - cRect.top
  };

  if (!isRoot && container) {
    //only add the current scroll position if it's not the window/body.
    offsets.x += _buildGetter(container, "x")();
    offsets.y += _buildGetter(container, "y")();
  }

  return offsets;
},
    _parseVal = function _parseVal(value, target, axis, currentVal, offset) {
  return !isNaN(value) && typeof value !== "object" ? parseFloat(value) - offset : _isString(value) && value.charAt(1) === "=" ? parseFloat(value.substr(2)) * (value.charAt(0) === "-" ? -1 : 1) + currentVal - offset : value === "max" ? _max(target, axis) - offset : Math.min(_max(target, axis), _getOffset(value, target)[axis] - offset);
},
    _initCore = function _initCore() {
  gsap = _getGSAP();

  if (_windowExists() && gsap && document.body) {
    _window = window;
    _body = document.body;
    _docEl = document.documentElement;
    _toArray = gsap.utils.toArray;
    gsap.config({
      autoKillThreshold: 7
    });
    _config = gsap.config();
    _coreInitted = 1;
  }
};

var ScrollToPlugin = {
  version: "3.9.1",
  name: "scrollTo",
  rawVars: 1,
  register: function register(core) {
    gsap = core;

    _initCore();
  },
  init: function init(target, value, tween, index, targets) {
    _coreInitted || _initCore();
    var data = this,
        snapType = gsap.getProperty(target, "scrollSnapType");
    data.isWin = target === _window;
    data.target = target;
    data.tween = tween;
    value = _clean(value, index, target, targets);
    data.vars = value;
    data.autoKill = !!value.autoKill;
    data.getX = _buildGetter(target, "x");
    data.getY = _buildGetter(target, "y");
    data.x = data.xPrev = data.getX();
    data.y = data.yPrev = data.getY();

    if (snapType && snapType !== "none") {
      // disable scroll snapping to avoid strange behavior
      data.snap = 1;
      data.snapInline = target.style.scrollSnapType;
      target.style.scrollSnapType = "none";
    }

    if (value.x != null) {
      data.add(data, "x", data.x, _parseVal(value.x, target, "x", data.x, value.offsetX || 0), index, targets);

      data._props.push("scrollTo_x");
    } else {
      data.skipX = 1;
    }

    if (value.y != null) {
      data.add(data, "y", data.y, _parseVal(value.y, target, "y", data.y, value.offsetY || 0), index, targets);

      data._props.push("scrollTo_y");
    } else {
      data.skipY = 1;
    }
  },
  render: function render(ratio, data) {
    var pt = data._pt,
        target = data.target,
        tween = data.tween,
        autoKill = data.autoKill,
        xPrev = data.xPrev,
        yPrev = data.yPrev,
        isWin = data.isWin,
        snap = data.snap,
        snapInline = data.snapInline,
        x,
        y,
        yDif,
        xDif,
        threshold;

    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }

    x = isWin || !data.skipX ? data.getX() : xPrev;
    y = isWin || !data.skipY ? data.getY() : yPrev;
    yDif = y - yPrev;
    xDif = x - xPrev;
    threshold = _config.autoKillThreshold;

    if (data.x < 0) {
      //can't scroll to a position less than 0! Might happen if someone uses a Back.easeOut or Elastic.easeOut when scrolling back to the top of the page (for example)
      data.x = 0;
    }

    if (data.y < 0) {
      data.y = 0;
    }

    if (autoKill) {
      //note: iOS has a bug that throws off the scroll by several pixels, so we need to check if it's within 7 pixels of the previous one that we set instead of just looking for an exact match.
      if (!data.skipX && (xDif > threshold || xDif < -threshold) && x < _max(target, "x")) {
        data.skipX = 1; //if the user scrolls separately, we should stop tweening!
      }

      if (!data.skipY && (yDif > threshold || yDif < -threshold) && y < _max(target, "y")) {
        data.skipY = 1; //if the user scrolls separately, we should stop tweening!
      }

      if (data.skipX && data.skipY) {
        tween.kill();
        data.vars.onAutoKill && data.vars.onAutoKill.apply(tween, data.vars.onAutoKillParams || []);
      }
    }

    if (isWin) {
      _window.scrollTo(!data.skipX ? data.x : x, !data.skipY ? data.y : y);
    } else {
      data.skipY || (target.scrollTop = data.y);
      data.skipX || (target.scrollLeft = data.x);
    }

    if (snap && (ratio === 1 || ratio === 0)) {
      y = target.scrollTop;
      x = target.scrollLeft;
      snapInline ? target.style.scrollSnapType = snapInline : target.style.removeProperty("scroll-snap-type");
      target.scrollTop = y + 1; // bug in Safari causes the element to totally reset its scroll position when scroll-snap-type changes, so we need to set it to a slightly different value and then back again to work around this bug.

      target.scrollLeft = x + 1;
      target.scrollTop = y;
      target.scrollLeft = x;
    }

    data.xPrev = data.x;
    data.yPrev = data.y;
  },
  kill: function kill(property) {
    var both = property === "scrollTo";

    if (both || property === "scrollTo_x") {
      this.skipX = 1;
    }

    if (both || property === "scrollTo_y") {
      this.skipY = 1;
    }
  }
};
ScrollToPlugin.max = _max;
ScrollToPlugin.getOffset = _getOffset;
ScrollToPlugin.buildGetter = _buildGetter;
_getGSAP() && gsap.registerPlugin(ScrollToPlugin);


/***/ }),

/***/ "./node_modules/gsap/ScrollTrigger.js":
/*!********************************************!*\
  !*** ./node_modules/gsap/ScrollTrigger.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScrollTrigger": () => (/* binding */ ScrollTrigger),
/* harmony export */   "default": () => (/* binding */ ScrollTrigger)
/* harmony export */ });
/*!
 * ScrollTrigger 3.9.1
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */
var gsap,
    _coreInitted,
    _win,
    _doc,
    _docEl,
    _body,
    _root,
    _resizeDelay,
    _toArray,
    _clamp,
    _time2,
    _syncInterval,
    _refreshing,
    _pointerIsDown,
    _transformProp,
    _i,
    _prevWidth,
    _prevHeight,
    _autoRefresh,
    _sort,
    _suppressOverwrites,
    _ignoreResize,
    _limitCallbacks,
    // if true, we'll only trigger callbacks if the active state toggles, so if you scroll immediately past both the start and end positions of a ScrollTrigger (thus inactive to inactive), neither its onEnter nor onLeave will be called. This is useful during startup.
_startup = 1,
    _proxies = [],
    _scrollers = [],
    _getTime = Date.now,
    _time1 = _getTime(),
    _lastScrollTime = 0,
    _enabled = 1,
    _passThrough = function _passThrough(v) {
  return v;
},
    _getTarget = function _getTarget(t) {
  return _toArray(t)[0] || (_isString(t) && gsap.config().nullTargetWarn !== false ? console.warn("Element not found:", t) : null);
},
    _round = function _round(value) {
  return Math.round(value * 100000) / 100000 || 0;
},
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _getGSAP = function _getGSAP() {
  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;
},
    _isViewport = function _isViewport(e) {
  return !!~_root.indexOf(e);
},
    _getProxyProp = function _getProxyProp(element, property) {
  return ~_proxies.indexOf(element) && _proxies[_proxies.indexOf(element) + 1][property];
},
    _getScrollFunc = function _getScrollFunc(element, _ref) {
  var s = _ref.s,
      sc = _ref.sc;

  // we store the scroller functions in a alternating sequenced Array like [element, verticalScrollFunc, horizontalScrollFunc, ...] so that we can minimize memory, maximize performance, and we also record the last position as a ".rec" property in order to revert to that after refreshing to ensure things don't shift around.
  var i = _scrollers.indexOf(element),
      offset = sc === _vertical.sc ? 1 : 2;

  !~i && (i = _scrollers.push(element) - 1);
  return _scrollers[i + offset] || (_scrollers[i + offset] = _getProxyProp(element, s) || (_isViewport(element) ? sc : function (value) {
    return arguments.length ? element[s] = value : element[s];
  }));
},
    _getBoundsFunc = function _getBoundsFunc(element) {
  return _getProxyProp(element, "getBoundingClientRect") || (_isViewport(element) ? function () {
    _winOffsets.width = _win.innerWidth;
    _winOffsets.height = _win.innerHeight;
    return _winOffsets;
  } : function () {
    return _getBounds(element);
  });
},
    _getSizeFunc = function _getSizeFunc(scroller, isViewport, _ref2) {
  var d = _ref2.d,
      d2 = _ref2.d2,
      a = _ref2.a;
  return (a = _getProxyProp(scroller, "getBoundingClientRect")) ? function () {
    return a()[d];
  } : function () {
    return (isViewport ? _win["inner" + d2] : scroller["client" + d2]) || 0;
  };
},
    _getOffsetsFunc = function _getOffsetsFunc(element, isViewport) {
  return !isViewport || ~_proxies.indexOf(element) ? _getBoundsFunc(element) : function () {
    return _winOffsets;
  };
},
    _maxScroll = function _maxScroll(element, _ref3) {
  var s = _ref3.s,
      d2 = _ref3.d2,
      d = _ref3.d,
      a = _ref3.a;
  return (s = "scroll" + d2) && (a = _getProxyProp(element, s)) ? a() - _getBoundsFunc(element)()[d] : _isViewport(element) ? (_body[s] || _docEl[s]) - (_win["inner" + d2] || _docEl["client" + d2] || _body["client" + d2]) : element[s] - element["offset" + d2];
},
    _iterateAutoRefresh = function _iterateAutoRefresh(func, events) {
  for (var i = 0; i < _autoRefresh.length; i += 3) {
    (!events || ~events.indexOf(_autoRefresh[i + 1])) && func(_autoRefresh[i], _autoRefresh[i + 1], _autoRefresh[i + 2]);
  }
},
    _isString = function _isString(value) {
  return typeof value === "string";
},
    _isFunction = function _isFunction(value) {
  return typeof value === "function";
},
    _isNumber = function _isNumber(value) {
  return typeof value === "number";
},
    _isObject = function _isObject(value) {
  return typeof value === "object";
},
    _callIfFunc = function _callIfFunc(value) {
  return _isFunction(value) && value();
},
    _combineFunc = function _combineFunc(f1, f2) {
  return function () {
    var result1 = _callIfFunc(f1),
        result2 = _callIfFunc(f2);

    return function () {
      _callIfFunc(result1);

      _callIfFunc(result2);
    };
  };
},
    _endAnimation = function _endAnimation(animation, reversed, pause) {
  return animation && animation.progress(reversed ? 0 : 1) && pause && animation.pause();
},
    _callback = function _callback(self, func) {
  if (self.enabled) {
    var result = func(self);
    result && result.totalTime && (self.callbackAnimation = result);
  }
},
    _abs = Math.abs,
    _scrollLeft = "scrollLeft",
    _scrollTop = "scrollTop",
    _left = "left",
    _top = "top",
    _right = "right",
    _bottom = "bottom",
    _width = "width",
    _height = "height",
    _Right = "Right",
    _Left = "Left",
    _Top = "Top",
    _Bottom = "Bottom",
    _padding = "padding",
    _margin = "margin",
    _Width = "Width",
    _Height = "Height",
    _px = "px",
    _horizontal = {
  s: _scrollLeft,
  p: _left,
  p2: _Left,
  os: _right,
  os2: _Right,
  d: _width,
  d2: _Width,
  a: "x",
  sc: function sc(value) {
    return arguments.length ? _win.scrollTo(value, _vertical.sc()) : _win.pageXOffset || _doc[_scrollLeft] || _docEl[_scrollLeft] || _body[_scrollLeft] || 0;
  }
},
    _vertical = {
  s: _scrollTop,
  p: _top,
  p2: _Top,
  os: _bottom,
  os2: _Bottom,
  d: _height,
  d2: _Height,
  a: "y",
  op: _horizontal,
  sc: function sc(value) {
    return arguments.length ? _win.scrollTo(_horizontal.sc(), value) : _win.pageYOffset || _doc[_scrollTop] || _docEl[_scrollTop] || _body[_scrollTop] || 0;
  }
},
    _getComputedStyle = function _getComputedStyle(element) {
  return _win.getComputedStyle(element);
},
    _makePositionable = function _makePositionable(element) {
  // if the element already has position: absolute or fixed, leave that, otherwise make it position: relative
  var position = _getComputedStyle(element).position;

  element.style.position = position === "absolute" || position === "fixed" ? position : "relative";
},
    _setDefaults = function _setDefaults(obj, defaults) {
  for (var p in defaults) {
    p in obj || (obj[p] = defaults[p]);
  }

  return obj;
},
    _getBounds = function _getBounds(element, withoutTransforms) {
  var tween = withoutTransforms && _getComputedStyle(element)[_transformProp] !== "matrix(1, 0, 0, 1, 0, 0)" && gsap.to(element, {
    x: 0,
    y: 0,
    xPercent: 0,
    yPercent: 0,
    rotation: 0,
    rotationX: 0,
    rotationY: 0,
    scale: 1,
    skewX: 0,
    skewY: 0
  }).progress(1),
      bounds = element.getBoundingClientRect();
  tween && tween.progress(0).kill();
  return bounds;
},
    _getSize = function _getSize(element, _ref4) {
  var d2 = _ref4.d2;
  return element["offset" + d2] || element["client" + d2] || 0;
},
    _getLabelRatioArray = function _getLabelRatioArray(timeline) {
  var a = [],
      labels = timeline.labels,
      duration = timeline.duration(),
      p;

  for (p in labels) {
    a.push(labels[p] / duration);
  }

  return a;
},
    _getClosestLabel = function _getClosestLabel(animation) {
  return function (value) {
    return gsap.utils.snap(_getLabelRatioArray(animation), value);
  };
},
    _snapDirectional = function _snapDirectional(snapIncrementOrArray) {
  var snap = gsap.utils.snap(snapIncrementOrArray),
      a = Array.isArray(snapIncrementOrArray) && snapIncrementOrArray.slice(0).sort(function (a, b) {
    return a - b;
  });
  return a ? function (value, direction, threshold) {
    if (threshold === void 0) {
      threshold = 1e-3;
    }

    var i;

    if (!direction) {
      return snap(value);
    }

    if (direction > 0) {
      value -= threshold; // to avoid rounding errors. If we're too strict, it might snap forward, then immediately again, and again.

      for (i = 0; i < a.length; i++) {
        if (a[i] >= value) {
          return a[i];
        }
      }

      return a[i - 1];
    } else {
      i = a.length;
      value += threshold;

      while (i--) {
        if (a[i] <= value) {
          return a[i];
        }
      }
    }

    return a[0];
  } : function (value, direction, threshold) {
    if (threshold === void 0) {
      threshold = 1e-3;
    }

    var snapped = snap(value);
    return !direction || Math.abs(snapped - value) < threshold || snapped - value < 0 === direction < 0 ? snapped : snap(direction < 0 ? value - snapIncrementOrArray : value + snapIncrementOrArray);
  };
},
    _getLabelAtDirection = function _getLabelAtDirection(timeline) {
  return function (value, st) {
    return _snapDirectional(_getLabelRatioArray(timeline))(value, st.direction);
  };
},
    _multiListener = function _multiListener(func, element, types, callback) {
  return types.split(",").forEach(function (type) {
    return func(element, type, callback);
  });
},
    _addListener = function _addListener(element, type, func) {
  return element.addEventListener(type, func, {
    passive: true
  });
},
    _removeListener = function _removeListener(element, type, func) {
  return element.removeEventListener(type, func);
},
    _markerDefaults = {
  startColor: "green",
  endColor: "red",
  indent: 0,
  fontSize: "16px",
  fontWeight: "normal"
},
    _defaults = {
  toggleActions: "play",
  anticipatePin: 0
},
    _keywords = {
  top: 0,
  left: 0,
  center: 0.5,
  bottom: 1,
  right: 1
},
    _offsetToPx = function _offsetToPx(value, size) {
  if (_isString(value)) {
    var eqIndex = value.indexOf("="),
        relative = ~eqIndex ? +(value.charAt(eqIndex - 1) + 1) * parseFloat(value.substr(eqIndex + 1)) : 0;

    if (~eqIndex) {
      value.indexOf("%") > eqIndex && (relative *= size / 100);
      value = value.substr(0, eqIndex - 1);
    }

    value = relative + (value in _keywords ? _keywords[value] * size : ~value.indexOf("%") ? parseFloat(value) * size / 100 : parseFloat(value) || 0);
  }

  return value;
},
    _createMarker = function _createMarker(type, name, container, direction, _ref5, offset, matchWidthEl, containerAnimation) {
  var startColor = _ref5.startColor,
      endColor = _ref5.endColor,
      fontSize = _ref5.fontSize,
      indent = _ref5.indent,
      fontWeight = _ref5.fontWeight;

  var e = _doc.createElement("div"),
      useFixedPosition = _isViewport(container) || _getProxyProp(container, "pinType") === "fixed",
      isScroller = type.indexOf("scroller") !== -1,
      parent = useFixedPosition ? _body : container,
      isStart = type.indexOf("start") !== -1,
      color = isStart ? startColor : endColor,
      css = "border-color:" + color + ";font-size:" + fontSize + ";color:" + color + ";font-weight:" + fontWeight + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";

  css += "position:" + ((isScroller || containerAnimation) && useFixedPosition ? "fixed;" : "absolute;");
  (isScroller || containerAnimation || !useFixedPosition) && (css += (direction === _vertical ? _right : _bottom) + ":" + (offset + parseFloat(indent)) + "px;");
  matchWidthEl && (css += "box-sizing:border-box;text-align:left;width:" + matchWidthEl.offsetWidth + "px;");
  e._isStart = isStart;
  e.setAttribute("class", "gsap-marker-" + type + (name ? " marker-" + name : ""));
  e.style.cssText = css;
  e.innerText = name || name === 0 ? type + "-" + name : type;
  parent.children[0] ? parent.insertBefore(e, parent.children[0]) : parent.appendChild(e);
  e._offset = e["offset" + direction.op.d2];

  _positionMarker(e, 0, direction, isStart);

  return e;
},
    _positionMarker = function _positionMarker(marker, start, direction, flipped) {
  var vars = {
    display: "block"
  },
      side = direction[flipped ? "os2" : "p2"],
      oppositeSide = direction[flipped ? "p2" : "os2"];
  marker._isFlipped = flipped;
  vars[direction.a + "Percent"] = flipped ? -100 : 0;
  vars[direction.a] = flipped ? "1px" : 0;
  vars["border" + side + _Width] = 1;
  vars["border" + oppositeSide + _Width] = 0;
  vars[direction.p] = start + "px";
  gsap.set(marker, vars);
},
    _triggers = [],
    _ids = {},
    _sync = function _sync() {
  return _getTime() - _lastScrollTime > 34 && _updateAll();
},
    _onScroll = function _onScroll() {
  // previously, we tried to optimize performance by batching/deferring to the next requestAnimationFrame(), but discovered that Safari has a few bugs that make this unworkable (especially on iOS). See https://codepen.io/GreenSock/pen/16c435b12ef09c38125204818e7b45fc?editors=0010
  _updateAll();

  _lastScrollTime || _dispatch("scrollStart");
  _lastScrollTime = _getTime();
},
    _onResize = function _onResize() {
  return !_refreshing && !_ignoreResize && !_doc.fullscreenElement && _resizeDelay.restart(true);
},
    // ignore resizes triggered by refresh()
_listeners = {},
    _emptyArray = [],
    _media = [],
    _creatingMedia,
    // when ScrollTrigger.matchMedia() is called, we record the current media key here (like "(min-width: 800px)") so that we can assign it to everything that's created during that call. Then we can revert just those when necessary. In the ScrollTrigger's init() call, the _creatingMedia is recorded as a "media" property on the instance.
_lastMediaTick,
    _onMediaChange = function _onMediaChange(e) {
  var tick = gsap.ticker.frame,
      matches = [],
      i = 0,
      index;

  if (_lastMediaTick !== tick || _startup) {
    _revertAll();

    for (; i < _media.length; i += 4) {
      index = _win.matchMedia(_media[i]).matches;

      if (index !== _media[i + 3]) {
        // note: some browsers fire the matchMedia event multiple times, like when going full screen, so we shouldn't call the function multiple times. Check to see if it's already matched.
        _media[i + 3] = index;
        index ? matches.push(i) : _revertAll(1, _media[i]) || _isFunction(_media[i + 2]) && _media[i + 2](); // Firefox doesn't update the "matches" property of the MediaQueryList object correctly - it only does so as it calls its change handler - so we must re-create a media query here to ensure it's accurate.
      }
    }

    _revertRecorded(); // in case killing/reverting any of the animations actually added inline styles back.


    for (i = 0; i < matches.length; i++) {
      index = matches[i];
      _creatingMedia = _media[index];
      _media[index + 2] = _media[index + 1](e);
    }

    _creatingMedia = 0;
    _coreInitted && _refreshAll(0, 1);
    _lastMediaTick = tick;

    _dispatch("matchMedia");
  }
},
    _softRefresh = function _softRefresh() {
  return _removeListener(ScrollTrigger, "scrollEnd", _softRefresh) || _refreshAll(true);
},
    _dispatch = function _dispatch(type) {
  return _listeners[type] && _listeners[type].map(function (f) {
    return f();
  }) || _emptyArray;
},
    _savedStyles = [],
    // when ScrollTrigger.saveStyles() is called, the inline styles are recorded in this Array in a sequential format like [element, cssText, gsCache, media]. This keeps it very memory-efficient and fast to iterate through.
_revertRecorded = function _revertRecorded(media) {
  for (var i = 0; i < _savedStyles.length; i += 5) {
    if (!media || _savedStyles[i + 4] === media) {
      _savedStyles[i].style.cssText = _savedStyles[i + 1];
      _savedStyles[i].getBBox && _savedStyles[i].setAttribute("transform", _savedStyles[i + 2] || "");
      _savedStyles[i + 3].uncache = 1;
    }
  }
},
    _revertAll = function _revertAll(kill, media) {
  var trigger;

  for (_i = 0; _i < _triggers.length; _i++) {
    trigger = _triggers[_i];

    if (!media || trigger.media === media) {
      if (kill) {
        trigger.kill(1);
      } else {
        trigger.revert();
      }
    }
  }

  media && _revertRecorded(media);
  media || _dispatch("revert");
},
    _clearScrollMemory = function _clearScrollMemory() {
  return _scrollers.forEach(function (obj) {
    return typeof obj === "function" && (obj.rec = 0);
  });
},
    // zero-out all the recorded scroll positions. Don't use _triggers because if, for example, .matchMedia() is used to create some ScrollTriggers and then the user resizes and it removes ALL ScrollTriggers, and then go back to a size where there are ScrollTriggers, it would have kept the position(s) saved from the initial state.
_refreshingAll,
    _refreshAll = function _refreshAll(force, skipRevert) {
  if (_lastScrollTime && !force) {
    _addListener(ScrollTrigger, "scrollEnd", _softRefresh);

    return;
  }

  _refreshingAll = true;

  var refreshInits = _dispatch("refreshInit");

  _sort && ScrollTrigger.sort();
  skipRevert || _revertAll();

  _triggers.forEach(function (t) {
    return t.refresh();
  }); // don't loop with _i because during a refresh() someone could call ScrollTrigger.update() which would iterate through _i resulting in a skip.


  _triggers.forEach(function (t) {
    return t.vars.end === "max" && t.setPositions(t.start, _maxScroll(t.scroller, t._dir));
  }); // the scroller's max scroll position may change after all the ScrollTriggers refreshed (like pinning could push it down), so we need to loop back and correct any with end: "max".


  refreshInits.forEach(function (result) {
    return result && result.render && result.render(-1);
  }); // if the onRefreshInit() returns an animation (typically a gsap.set()), revert it. This makes it easy to put things in a certain spot before refreshing for measurement purposes, and then put things back.

  _clearScrollMemory();

  _resizeDelay.pause();

  _refreshingAll = false;

  _dispatch("refresh");
},
    _lastScroll = 0,
    _direction = 1,
    _updateAll = function _updateAll() {
  if (!_refreshingAll) {
    var l = _triggers.length,
        time = _getTime(),
        recordVelocity = time - _time1 >= 50,
        scroll = l && _triggers[0].scroll();

    _direction = _lastScroll > scroll ? -1 : 1;
    _lastScroll = scroll;

    if (recordVelocity) {
      if (_lastScrollTime && !_pointerIsDown && time - _lastScrollTime > 200) {
        _lastScrollTime = 0;

        _dispatch("scrollEnd");
      }

      _time2 = _time1;
      _time1 = time;
    }

    if (_direction < 0) {
      _i = l;

      while (_i-- > 0) {
        _triggers[_i] && _triggers[_i].update(0, recordVelocity);
      }

      _direction = 1;
    } else {
      for (_i = 0; _i < l; _i++) {
        _triggers[_i] && _triggers[_i].update(0, recordVelocity);
      }
    }
  }
},
    _propNamesToCopy = [_left, _top, _bottom, _right, _margin + _Bottom, _margin + _Right, _margin + _Top, _margin + _Left, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"],
    _stateProps = _propNamesToCopy.concat([_width, _height, "boxSizing", "max" + _Width, "max" + _Height, "position", _margin, _padding, _padding + _Top, _padding + _Right, _padding + _Bottom, _padding + _Left]),
    _swapPinOut = function _swapPinOut(pin, spacer, state) {
  _setState(state);

  var cache = pin._gsap;

  if (cache.spacerIsNative) {
    _setState(cache.spacerState);
  } else if (pin.parentNode === spacer) {
    var parent = spacer.parentNode;

    if (parent) {
      parent.insertBefore(pin, spacer);
      parent.removeChild(spacer);
    }
  }
},
    _swapPinIn = function _swapPinIn(pin, spacer, cs, spacerState) {
  if (pin.parentNode !== spacer) {
    var i = _propNamesToCopy.length,
        spacerStyle = spacer.style,
        pinStyle = pin.style,
        p;

    while (i--) {
      p = _propNamesToCopy[i];
      spacerStyle[p] = cs[p];
    }

    spacerStyle.position = cs.position === "absolute" ? "absolute" : "relative";
    cs.display === "inline" && (spacerStyle.display = "inline-block");
    pinStyle[_bottom] = pinStyle[_right] = spacerStyle.flexBasis = "auto";
    spacerStyle.overflow = "visible";
    spacerStyle.boxSizing = "border-box";
    spacerStyle[_width] = _getSize(pin, _horizontal) + _px;
    spacerStyle[_height] = _getSize(pin, _vertical) + _px;
    spacerStyle[_padding] = pinStyle[_margin] = pinStyle[_top] = pinStyle[_left] = "0";

    _setState(spacerState);

    pinStyle[_width] = pinStyle["max" + _Width] = cs[_width];
    pinStyle[_height] = pinStyle["max" + _Height] = cs[_height];
    pinStyle[_padding] = cs[_padding];
    pin.parentNode.insertBefore(spacer, pin);
    spacer.appendChild(pin);
  }
},
    _capsExp = /([A-Z])/g,
    _setState = function _setState(state) {
  if (state) {
    var style = state.t.style,
        l = state.length,
        i = 0,
        p,
        value;
    (state.t._gsap || gsap.core.getCache(state.t)).uncache = 1; // otherwise transforms may be off

    for (; i < l; i += 2) {
      value = state[i + 1];
      p = state[i];

      if (value) {
        style[p] = value;
      } else if (style[p]) {
        style.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());
      }
    }
  }
},
    _getState = function _getState(element) {
  // returns an Array with alternating values like [property, value, property, value] and a "t" property pointing to the target (element). Makes it fast and cheap.
  var l = _stateProps.length,
      style = element.style,
      state = [],
      i = 0;

  for (; i < l; i++) {
    state.push(_stateProps[i], style[_stateProps[i]]);
  }

  state.t = element;
  return state;
},
    _copyState = function _copyState(state, override, omitOffsets) {
  var result = [],
      l = state.length,
      i = omitOffsets ? 8 : 0,
      // skip top, left, right, bottom if omitOffsets is true
  p;

  for (; i < l; i += 2) {
    p = state[i];
    result.push(p, p in override ? override[p] : state[i + 1]);
  }

  result.t = state.t;
  return result;
},
    _winOffsets = {
  left: 0,
  top: 0
},
    // // potential future feature (?) Allow users to calculate where a trigger hits (scroll position) like getScrollPosition("#id", "top bottom")
// _getScrollPosition = (trigger, position, {scroller, containerAnimation, horizontal}) => {
// 	scroller = _getTarget(scroller || _win);
// 	let direction = horizontal ? _horizontal : _vertical,
// 		isViewport = _isViewport(scroller);
// 	_getSizeFunc(scroller, isViewport, direction);
// 	return _parsePosition(position, _getTarget(trigger), _getSizeFunc(scroller, isViewport, direction)(), direction, _getScrollFunc(scroller, direction)(), 0, 0, 0, _getOffsetsFunc(scroller, isViewport)(), isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0, 0, containerAnimation ? containerAnimation.duration() : _maxScroll(scroller), containerAnimation);
// },
_parsePosition = function _parsePosition(value, trigger, scrollerSize, direction, scroll, marker, markerScroller, self, scrollerBounds, borderWidth, useFixedPosition, scrollerMax, containerAnimation) {
  _isFunction(value) && (value = value(self));

  if (_isString(value) && value.substr(0, 3) === "max") {
    value = scrollerMax + (value.charAt(4) === "=" ? _offsetToPx("0" + value.substr(3), scrollerSize) : 0);
  }

  var time = containerAnimation ? containerAnimation.time() : 0,
      p1,
      p2,
      element;
  containerAnimation && containerAnimation.seek(0);

  if (!_isNumber(value)) {
    _isFunction(trigger) && (trigger = trigger(self));
    var offsets = value.split(" "),
        bounds,
        localOffset,
        globalOffset,
        display;
    element = _getTarget(trigger) || _body;
    bounds = _getBounds(element) || {};

    if ((!bounds || !bounds.left && !bounds.top) && _getComputedStyle(element).display === "none") {
      // if display is "none", it won't report getBoundingClientRect() properly
      display = element.style.display;
      element.style.display = "block";
      bounds = _getBounds(element);
      display ? element.style.display = display : element.style.removeProperty("display");
    }

    localOffset = _offsetToPx(offsets[0], bounds[direction.d]);
    globalOffset = _offsetToPx(offsets[1] || "0", scrollerSize);
    value = bounds[direction.p] - scrollerBounds[direction.p] - borderWidth + localOffset + scroll - globalOffset;
    markerScroller && _positionMarker(markerScroller, globalOffset, direction, scrollerSize - globalOffset < 20 || markerScroller._isStart && globalOffset > 20);
    scrollerSize -= scrollerSize - globalOffset; // adjust for the marker
  } else if (markerScroller) {
    _positionMarker(markerScroller, scrollerSize, direction, true);
  }

  if (marker) {
    var position = value + scrollerSize,
        isStart = marker._isStart;
    p1 = "scroll" + direction.d2;

    _positionMarker(marker, position, direction, isStart && position > 20 || !isStart && (useFixedPosition ? Math.max(_body[p1], _docEl[p1]) : marker.parentNode[p1]) <= position + 1);

    if (useFixedPosition) {
      scrollerBounds = _getBounds(markerScroller);
      useFixedPosition && (marker.style[direction.op.p] = scrollerBounds[direction.op.p] - direction.op.m - marker._offset + _px);
    }
  }

  if (containerAnimation && element) {
    p1 = _getBounds(element);
    containerAnimation.seek(scrollerMax);
    p2 = _getBounds(element);
    containerAnimation._caScrollDist = p1[direction.p] - p2[direction.p];
    value = value / containerAnimation._caScrollDist * scrollerMax;
  }

  containerAnimation && containerAnimation.seek(time);
  return containerAnimation ? value : Math.round(value);
},
    _prefixExp = /(?:webkit|moz|length|cssText|inset)/i,
    _reparent = function _reparent(element, parent, top, left) {
  if (element.parentNode !== parent) {
    var style = element.style,
        p,
        cs;

    if (parent === _body) {
      element._stOrig = style.cssText; // record original inline styles so we can revert them later

      cs = _getComputedStyle(element);

      for (p in cs) {
        // must copy all relevant styles to ensure that nothing changes visually when we reparent to the <body>. Skip the vendor prefixed ones.
        if (!+p && !_prefixExp.test(p) && cs[p] && typeof style[p] === "string" && p !== "0") {
          style[p] = cs[p];
        }
      }

      style.top = top;
      style.left = left;
    } else {
      style.cssText = element._stOrig;
    }

    gsap.core.getCache(element).uncache = 1;
    parent.appendChild(element);
  }
},
    // _mergeAnimations = animations => {
// 	let tl = gsap.timeline({smoothChildTiming: true}).startTime(Math.min(...animations.map(a => a.globalTime(0))));
// 	animations.forEach(a => {let time = a.totalTime(); tl.add(a); a.totalTime(time); });
// 	tl.smoothChildTiming = false;
// 	return tl;
// },
// returns a function that can be used to tween the scroll position in the direction provided, and when doing so it'll add a .tween property to the FUNCTION itself, and remove it when the tween completes or gets killed. This gives us a way to have multiple ScrollTriggers use a central function for any given scroller and see if there's a scroll tween running (which would affect if/how things get updated)
_getTweenCreator = function _getTweenCreator(scroller, direction) {
  var getScroll = _getScrollFunc(scroller, direction),
      prop = "_scroll" + direction.p2,
      // add a tweenable property to the scroller that's a getter/setter function, like _scrollTop or _scrollLeft. This way, if someone does gsap.killTweensOf(scroller) it'll kill the scroll tween.
  lastScroll1,
      lastScroll2,
      getTween = function getTween(scrollTo, vars, initialValue, change1, change2) {
    var tween = getTween.tween,
        onComplete = vars.onComplete,
        modifiers = {};
    tween && tween.kill();
    lastScroll1 = Math.round(initialValue);
    vars[prop] = scrollTo;
    vars.modifiers = modifiers;

    modifiers[prop] = function (value) {
      value = _round(getScroll()); // round because in some [very uncommon] Windows environments, it can get reported with decimals even though it was set without.

      if (value !== lastScroll1 && value !== lastScroll2 && Math.abs(value - lastScroll1) > 2 && Math.abs(value - lastScroll2) > 2) {
        // if the user scrolls, kill the tween. iOS Safari intermittently misreports the scroll position, it may be the most recently-set one or the one before that! When Safari is zoomed (CMD-+), it often misreports as 1 pixel off too! So if we set the scroll position to 125, for example, it'll actually report it as 124.
        tween.kill();
        getTween.tween = 0;
      } else {
        value = initialValue + change1 * tween.ratio + change2 * tween.ratio * tween.ratio;
      }

      lastScroll2 = lastScroll1;
      return lastScroll1 = _round(value);
    };

    vars.onComplete = function () {
      getTween.tween = 0;
      onComplete && onComplete.call(tween);
    };

    tween = getTween.tween = gsap.to(scroller, vars);
    return tween;
  };

  scroller[prop] = getScroll;

  _addListener(scroller, "wheel", function () {
    return getTween.tween && getTween.tween.kill() && (getTween.tween = 0);
  }); // Windows machines handle mousewheel scrolling in chunks (like "3 lines per scroll") meaning the typical strategy for cancelling the scroll isn't as sensitive. It's much more likely to match one of the previous 2 scroll event positions. So we kill any snapping as soon as there's a wheel event.


  return getTween;
};

_horizontal.op = _vertical;
var ScrollTrigger = /*#__PURE__*/function () {
  function ScrollTrigger(vars, animation) {
    _coreInitted || ScrollTrigger.register(gsap) || console.warn("Please gsap.registerPlugin(ScrollTrigger)");
    this.init(vars, animation);
  }

  var _proto = ScrollTrigger.prototype;

  _proto.init = function init(vars, animation) {
    this.progress = this.start = 0;
    this.vars && this.kill(1); // in case it's being initted again

    if (!_enabled) {
      this.update = this.refresh = this.kill = _passThrough;
      return;
    }

    vars = _setDefaults(_isString(vars) || _isNumber(vars) || vars.nodeType ? {
      trigger: vars
    } : vars, _defaults);

    var _vars = vars,
        onUpdate = _vars.onUpdate,
        toggleClass = _vars.toggleClass,
        id = _vars.id,
        onToggle = _vars.onToggle,
        onRefresh = _vars.onRefresh,
        scrub = _vars.scrub,
        trigger = _vars.trigger,
        pin = _vars.pin,
        pinSpacing = _vars.pinSpacing,
        invalidateOnRefresh = _vars.invalidateOnRefresh,
        anticipatePin = _vars.anticipatePin,
        onScrubComplete = _vars.onScrubComplete,
        onSnapComplete = _vars.onSnapComplete,
        once = _vars.once,
        snap = _vars.snap,
        pinReparent = _vars.pinReparent,
        pinSpacer = _vars.pinSpacer,
        containerAnimation = _vars.containerAnimation,
        fastScrollEnd = _vars.fastScrollEnd,
        preventOverlaps = _vars.preventOverlaps,
        direction = vars.horizontal || vars.containerAnimation && vars.horizontal !== false ? _horizontal : _vertical,
        isToggle = !scrub && scrub !== 0,
        scroller = _getTarget(vars.scroller || _win),
        scrollerCache = gsap.core.getCache(scroller),
        isViewport = _isViewport(scroller),
        useFixedPosition = ("pinType" in vars ? vars.pinType : _getProxyProp(scroller, "pinType") || isViewport && "fixed") === "fixed",
        callbacks = [vars.onEnter, vars.onLeave, vars.onEnterBack, vars.onLeaveBack],
        toggleActions = isToggle && vars.toggleActions.split(" "),
        markers = "markers" in vars ? vars.markers : _defaults.markers,
        borderWidth = isViewport ? 0 : parseFloat(_getComputedStyle(scroller)["border" + direction.p2 + _Width]) || 0,
        self = this,
        onRefreshInit = vars.onRefreshInit && function () {
      return vars.onRefreshInit(self);
    },
        getScrollerSize = _getSizeFunc(scroller, isViewport, direction),
        getScrollerOffsets = _getOffsetsFunc(scroller, isViewport),
        lastSnap = 0,
        scrollFunc = _getScrollFunc(scroller, direction),
        tweenTo,
        pinCache,
        snapFunc,
        scroll1,
        scroll2,
        start,
        end,
        markerStart,
        markerEnd,
        markerStartTrigger,
        markerEndTrigger,
        markerVars,
        change,
        pinOriginalState,
        pinActiveState,
        pinState,
        spacer,
        offset,
        pinGetter,
        pinSetter,
        pinStart,
        pinChange,
        spacingStart,
        spacerState,
        markerStartSetter,
        markerEndSetter,
        cs,
        snap1,
        snap2,
        scrubTween,
        scrubSmooth,
        snapDurClamp,
        snapDelayedCall,
        prevProgress,
        prevScroll,
        prevAnimProgress,
        caMarkerSetter;

    self.media = _creatingMedia;
    self._dir = direction;
    anticipatePin *= 45;
    self.scroller = scroller;
    self.scroll = containerAnimation ? containerAnimation.time.bind(containerAnimation) : scrollFunc;
    scroll1 = scrollFunc();
    self.vars = vars;
    animation = animation || vars.animation;
    "refreshPriority" in vars && (_sort = 1);
    scrollerCache.tweenScroll = scrollerCache.tweenScroll || {
      top: _getTweenCreator(scroller, _vertical),
      left: _getTweenCreator(scroller, _horizontal)
    };
    self.tweenTo = tweenTo = scrollerCache.tweenScroll[direction.p];

    if (animation) {
      animation.vars.lazy = false;
      animation._initted || animation.vars.immediateRender !== false && vars.immediateRender !== false && animation.render(0, true, true);
      self.animation = animation.pause();
      animation.scrollTrigger = self;
      scrubSmooth = _isNumber(scrub) && scrub;
      scrubSmooth && (scrubTween = gsap.to(animation, {
        ease: "power3",
        duration: scrubSmooth,
        onComplete: function onComplete() {
          return onScrubComplete && onScrubComplete(self);
        }
      }));
      snap1 = 0;
      id || (id = animation.vars.id);
    }

    _triggers.push(self);

    if (snap) {
      if (!_isObject(snap) || snap.push) {
        snap = {
          snapTo: snap
        };
      }

      "scrollBehavior" in _body.style && gsap.set(isViewport ? [_body, _docEl] : scroller, {
        scrollBehavior: "auto"
      }); // smooth scrolling doesn't work with snap.

      snapFunc = _isFunction(snap.snapTo) ? snap.snapTo : snap.snapTo === "labels" ? _getClosestLabel(animation) : snap.snapTo === "labelsDirectional" ? _getLabelAtDirection(animation) : snap.directional !== false ? function (value, st) {
        return _snapDirectional(snap.snapTo)(value, st.direction);
      } : gsap.utils.snap(snap.snapTo);
      snapDurClamp = snap.duration || {
        min: 0.1,
        max: 2
      };
      snapDurClamp = _isObject(snapDurClamp) ? _clamp(snapDurClamp.min, snapDurClamp.max) : _clamp(snapDurClamp, snapDurClamp);
      snapDelayedCall = gsap.delayedCall(snap.delay || scrubSmooth / 2 || 0.1, function () {
        if (Math.abs(self.getVelocity()) < 10 && !_pointerIsDown && lastSnap !== scrollFunc()) {
          var totalProgress = animation && !isToggle ? animation.totalProgress() : self.progress,
              velocity = (totalProgress - snap2) / (_getTime() - _time2) * 1000 || 0,
              change1 = gsap.utils.clamp(-self.progress, 1 - self.progress, _abs(velocity / 2) * velocity / 0.185),
              naturalEnd = self.progress + (snap.inertia === false ? 0 : change1),
              endValue = _clamp(0, 1, snapFunc(naturalEnd, self)),
              scroll = scrollFunc(),
              endScroll = Math.round(start + endValue * change),
              _snap = snap,
              onStart = _snap.onStart,
              _onInterrupt = _snap.onInterrupt,
              _onComplete = _snap.onComplete,
              tween = tweenTo.tween;

          if (scroll <= end && scroll >= start && endScroll !== scroll) {
            if (tween && !tween._initted && tween.data <= _abs(endScroll - scroll)) {
              // there's an overlapping snap! So we must figure out which one is closer and let that tween live.
              return;
            }

            if (snap.inertia === false) {
              change1 = endValue - self.progress;
            }

            tweenTo(endScroll, {
              duration: snapDurClamp(_abs(Math.max(_abs(naturalEnd - totalProgress), _abs(endValue - totalProgress)) * 0.185 / velocity / 0.05 || 0)),
              ease: snap.ease || "power3",
              data: _abs(endScroll - scroll),
              // record the distance so that if another snap tween occurs (conflict) we can prioritize the closest snap.
              onInterrupt: function onInterrupt() {
                return snapDelayedCall.restart(true) && _onInterrupt && _onInterrupt(self);
              },
              onComplete: function onComplete() {
                self.update();
                lastSnap = scrollFunc();
                snap1 = snap2 = animation && !isToggle ? animation.totalProgress() : self.progress;
                onSnapComplete && onSnapComplete(self);
                _onComplete && _onComplete(self);
              }
            }, scroll, change1 * change, endScroll - scroll - change1 * change);
            onStart && onStart(self, tweenTo.tween);
          }
        } else if (self.isActive) {
          snapDelayedCall.restart(true);
        }
      }).pause();
    }

    id && (_ids[id] = self);
    trigger = self.trigger = _getTarget(trigger || pin);
    pin = pin === true ? trigger : _getTarget(pin);
    _isString(toggleClass) && (toggleClass = {
      targets: trigger,
      className: toggleClass
    });

    if (pin) {
      pinSpacing === false || pinSpacing === _margin || (pinSpacing = !pinSpacing && _getComputedStyle(pin.parentNode).display === "flex" ? false : _padding); // if the parent is display: flex, don't apply pinSpacing by default.

      self.pin = pin;
      vars.force3D !== false && gsap.set(pin, {
        force3D: true
      });
      pinCache = gsap.core.getCache(pin);

      if (!pinCache.spacer) {
        // record the spacer and pinOriginalState on the cache in case someone tries pinning the same element with MULTIPLE ScrollTriggers - we don't want to have multiple spacers or record the "original" pin state after it has already been affected by another ScrollTrigger.
        if (pinSpacer) {
          pinSpacer = _getTarget(pinSpacer);
          pinSpacer && !pinSpacer.nodeType && (pinSpacer = pinSpacer.current || pinSpacer.nativeElement); // for React & Angular

          pinCache.spacerIsNative = !!pinSpacer;
          pinSpacer && (pinCache.spacerState = _getState(pinSpacer));
        }

        pinCache.spacer = spacer = pinSpacer || _doc.createElement("div");
        spacer.classList.add("pin-spacer");
        id && spacer.classList.add("pin-spacer-" + id);
        pinCache.pinState = pinOriginalState = _getState(pin);
      } else {
        pinOriginalState = pinCache.pinState;
      }

      self.spacer = spacer = pinCache.spacer;
      cs = _getComputedStyle(pin);
      spacingStart = cs[pinSpacing + direction.os2];
      pinGetter = gsap.getProperty(pin);
      pinSetter = gsap.quickSetter(pin, direction.a, _px); // pin.firstChild && !_maxScroll(pin, direction) && (pin.style.overflow = "hidden"); // protects from collapsing margins, but can have unintended consequences as demonstrated here: https://codepen.io/GreenSock/pen/1e42c7a73bfa409d2cf1e184e7a4248d so it was removed in favor of just telling people to set up their CSS to avoid the collapsing margins (overflow: hidden | auto is just one option. Another is border-top: 1px solid transparent).

      _swapPinIn(pin, spacer, cs);

      pinState = _getState(pin);
    }

    if (markers) {
      markerVars = _isObject(markers) ? _setDefaults(markers, _markerDefaults) : _markerDefaults;
      markerStartTrigger = _createMarker("scroller-start", id, scroller, direction, markerVars, 0);
      markerEndTrigger = _createMarker("scroller-end", id, scroller, direction, markerVars, 0, markerStartTrigger);
      offset = markerStartTrigger["offset" + direction.op.d2];
      markerStart = _createMarker("start", id, scroller, direction, markerVars, offset, 0, containerAnimation);
      markerEnd = _createMarker("end", id, scroller, direction, markerVars, offset, 0, containerAnimation);
      containerAnimation && (caMarkerSetter = gsap.quickSetter([markerStart, markerEnd], direction.a, _px));

      if (!useFixedPosition && !(_proxies.length && _getProxyProp(scroller, "fixedMarkers") === true)) {
        _makePositionable(isViewport ? _body : scroller);

        gsap.set([markerStartTrigger, markerEndTrigger], {
          force3D: true
        });
        markerStartSetter = gsap.quickSetter(markerStartTrigger, direction.a, _px);
        markerEndSetter = gsap.quickSetter(markerEndTrigger, direction.a, _px);
      }
    }

    if (containerAnimation) {
      var oldOnUpdate = containerAnimation.vars.onUpdate,
          oldParams = containerAnimation.vars.onUpdateParams;
      containerAnimation.eventCallback("onUpdate", function () {
        self.update(0, 0, 1);
        oldOnUpdate && oldOnUpdate.apply(oldParams || []);
      });
    }

    self.previous = function () {
      return _triggers[_triggers.indexOf(self) - 1];
    };

    self.next = function () {
      return _triggers[_triggers.indexOf(self) + 1];
    };

    self.revert = function (revert) {
      var r = revert !== false || !self.enabled,
          prevRefreshing = _refreshing;

      if (r !== self.isReverted) {
        if (r) {
          self.scroll.rec || (self.scroll.rec = scrollFunc());
          prevScroll = Math.max(scrollFunc(), self.scroll.rec || 0); // record the scroll so we can revert later (repositioning/pinning things can affect scroll position). In the static refresh() method, we first record all the scroll positions as a reference.

          prevProgress = self.progress;
          prevAnimProgress = animation && animation.progress();
        }

        markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {
          return m.style.display = r ? "none" : "block";
        });
        r && (_refreshing = 1);
        self.update(r); // make sure the pin is back in its original position so that all the measurements are correct.

        _refreshing = prevRefreshing;
        pin && (r ? _swapPinOut(pin, spacer, pinOriginalState) : (!pinReparent || !self.isActive) && _swapPinIn(pin, spacer, _getComputedStyle(pin), spacerState));
        self.isReverted = r;
      }
    };

    self.refresh = function (soft, force) {
      if ((_refreshing || !self.enabled) && !force) {
        return;
      }

      if (pin && soft && _lastScrollTime) {
        _addListener(ScrollTrigger, "scrollEnd", _softRefresh);

        return;
      }

      _refreshing = 1;
      scrubTween && scrubTween.pause();
      invalidateOnRefresh && animation && animation.time(-0.01, true).invalidate();
      self.isReverted || self.revert();

      var size = getScrollerSize(),
          scrollerBounds = getScrollerOffsets(),
          max = containerAnimation ? containerAnimation.duration() : _maxScroll(scroller, direction),
          offset = 0,
          otherPinOffset = 0,
          parsedEnd = vars.end,
          parsedEndTrigger = vars.endTrigger || trigger,
          parsedStart = vars.start || (vars.start === 0 || !trigger ? 0 : pin ? "0 0" : "0 100%"),
          pinnedContainer = vars.pinnedContainer && _getTarget(vars.pinnedContainer),
          triggerIndex = trigger && Math.max(0, _triggers.indexOf(self)) || 0,
          i = triggerIndex,
          cs,
          bounds,
          scroll,
          isVertical,
          override,
          curTrigger,
          curPin,
          oppositeScroll,
          initted,
          revertedPins;

      while (i--) {
        // user might try to pin the same element more than once, so we must find any prior triggers with the same pin, revert them, and determine how long they're pinning so that we can offset things appropriately. Make sure we revert from last to first so that things "rewind" properly.
        curTrigger = _triggers[i];
        curTrigger.end || curTrigger.refresh(0, 1) || (_refreshing = 1); // if it's a timeline-based trigger that hasn't been fully initialized yet because it's waiting for 1 tick, just force the refresh() here, otherwise if it contains a pin that's supposed to affect other ScrollTriggers further down the page, they won't be adjusted properly.

        curPin = curTrigger.pin;

        if (curPin && (curPin === trigger || curPin === pin) && !curTrigger.isReverted) {
          revertedPins || (revertedPins = []);
          revertedPins.unshift(curTrigger); // we'll revert from first to last to make sure things reach their end state properly

          curTrigger.revert();
        }
      }

      _isFunction(parsedStart) && (parsedStart = parsedStart(self));
      start = _parsePosition(parsedStart, trigger, size, direction, scrollFunc(), markerStart, markerStartTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation) || (pin ? -0.001 : 0);
      _isFunction(parsedEnd) && (parsedEnd = parsedEnd(self));

      if (_isString(parsedEnd) && !parsedEnd.indexOf("+=")) {
        if (~parsedEnd.indexOf(" ")) {
          parsedEnd = (_isString(parsedStart) ? parsedStart.split(" ")[0] : "") + parsedEnd;
        } else {
          offset = _offsetToPx(parsedEnd.substr(2), size);
          parsedEnd = _isString(parsedStart) ? parsedStart : start + offset; // _parsePosition won't factor in the offset if the start is a number, so do it here.

          parsedEndTrigger = trigger;
        }
      }

      end = Math.max(start, _parsePosition(parsedEnd || (parsedEndTrigger ? "100% 0" : max), parsedEndTrigger, size, direction, scrollFunc() + offset, markerEnd, markerEndTrigger, self, scrollerBounds, borderWidth, useFixedPosition, max, containerAnimation)) || -0.001;
      change = end - start || (start -= 0.01) && 0.001;
      offset = 0;
      i = triggerIndex;

      while (i--) {
        curTrigger = _triggers[i];
        curPin = curTrigger.pin;

        if (curPin && curTrigger.start - curTrigger._pinPush < start && !containerAnimation) {
          cs = curTrigger.end - curTrigger.start;

          if ((curPin === trigger || curPin === pinnedContainer) && !_isNumber(parsedStart)) {
            // numeric start values shouldn't be offset at all - treat them as absolute
            offset += cs * (1 - curTrigger.progress);
          }

          curPin === pin && (otherPinOffset += cs);
        }
      }

      start += offset;
      end += offset;
      self._pinPush = otherPinOffset;

      if (markerStart && offset) {
        // offset the markers if necessary
        cs = {};
        cs[direction.a] = "+=" + offset;
        pinnedContainer && (cs[direction.p] = "-=" + scrollFunc());
        gsap.set([markerStart, markerEnd], cs);
      }

      if (pin) {
        cs = _getComputedStyle(pin);
        isVertical = direction === _vertical;
        scroll = scrollFunc(); // recalculate because the triggers can affect the scroll

        pinStart = parseFloat(pinGetter(direction.a)) + otherPinOffset;
        !max && end > 1 && ((isViewport ? _body : scroller).style["overflow-" + direction.a] = "scroll"); // makes sure the scroller has a scrollbar, otherwise if something has width: 100%, for example, it would be too big (exclude the scrollbar). See https://greensock.com/forums/topic/25182-scrolltrigger-width-of-page-increase-where-markers-are-set-to-false/

        _swapPinIn(pin, spacer, cs);

        pinState = _getState(pin); // transforms will interfere with the top/left/right/bottom placement, so remove them temporarily. getBoundingClientRect() factors in transforms.

        bounds = _getBounds(pin, true);
        oppositeScroll = useFixedPosition && _getScrollFunc(scroller, isVertical ? _horizontal : _vertical)();

        if (pinSpacing) {
          spacerState = [pinSpacing + direction.os2, change + otherPinOffset + _px];
          spacerState.t = spacer;
          i = pinSpacing === _padding ? _getSize(pin, direction) + change + otherPinOffset : 0;
          i && spacerState.push(direction.d, i + _px); // for box-sizing: border-box (must include padding).

          _setState(spacerState);

          useFixedPosition && scrollFunc(prevScroll);
        }

        if (useFixedPosition) {
          override = {
            top: bounds.top + (isVertical ? scroll - start : oppositeScroll) + _px,
            left: bounds.left + (isVertical ? oppositeScroll : scroll - start) + _px,
            boxSizing: "border-box",
            position: "fixed"
          };
          override[_width] = override["max" + _Width] = Math.ceil(bounds.width) + _px;
          override[_height] = override["max" + _Height] = Math.ceil(bounds.height) + _px;
          override[_margin] = override[_margin + _Top] = override[_margin + _Right] = override[_margin + _Bottom] = override[_margin + _Left] = "0";
          override[_padding] = cs[_padding];
          override[_padding + _Top] = cs[_padding + _Top];
          override[_padding + _Right] = cs[_padding + _Right];
          override[_padding + _Bottom] = cs[_padding + _Bottom];
          override[_padding + _Left] = cs[_padding + _Left];
          pinActiveState = _copyState(pinOriginalState, override, pinReparent);
        }

        if (animation) {
          // the animation might be affecting the transform, so we must jump to the end, check the value, and compensate accordingly. Otherwise, when it becomes unpinned, the pinSetter() will get set to a value that doesn't include whatever the animation did.
          initted = animation._initted; // if not, we must invalidate() after this step, otherwise it could lock in starting values prematurely.

          _suppressOverwrites(1);

          animation.render(animation.duration(), true, true);
          pinChange = pinGetter(direction.a) - pinStart + change + otherPinOffset;
          change !== pinChange && pinActiveState.splice(pinActiveState.length - 2, 2); // transform is the last property/value set in the state Array. Since the animation is controlling that, we should omit it.

          animation.render(0, true, true);
          initted || animation.invalidate();

          _suppressOverwrites(0);
        } else {
          pinChange = change;
        }
      } else if (trigger && scrollFunc() && !containerAnimation) {
        // it may be INSIDE a pinned element, so walk up the tree and look for any elements with _pinOffset to compensate because anything with pinSpacing that's already scrolled would throw off the measurements in getBoundingClientRect()
        bounds = trigger.parentNode;

        while (bounds && bounds !== _body) {
          if (bounds._pinOffset) {
            start -= bounds._pinOffset;
            end -= bounds._pinOffset;
          }

          bounds = bounds.parentNode;
        }
      }

      revertedPins && revertedPins.forEach(function (t) {
        return t.revert(false);
      });
      self.start = start;
      self.end = end;
      scroll1 = scroll2 = scrollFunc(); // reset velocity

      if (!containerAnimation) {
        scroll1 < prevScroll && scrollFunc(prevScroll);
        self.scroll.rec = 0;
      }

      self.revert(false);
      _refreshing = 0;
      animation && isToggle && animation._initted && animation.progress() !== prevAnimProgress && animation.progress(prevAnimProgress, true).render(animation.time(), true, true); // must force a re-render because if saveStyles() was used on the target(s), the styles could have been wiped out during the refresh().

      if (prevProgress !== self.progress || containerAnimation) {
        // ensures that the direction is set properly (when refreshing, progress is set back to 0 initially, then back again to wherever it needs to be) and that callbacks are triggered.
        animation && !isToggle && animation.totalProgress(prevProgress, true); // to avoid issues where animation callbacks like onStart aren't triggered.

        self.progress = prevProgress;
        self.update(0, 0, 1);
      }

      pin && pinSpacing && (spacer._pinOffset = Math.round(self.progress * pinChange));
      onRefresh && onRefresh(self);
    };

    self.getVelocity = function () {
      return (scrollFunc() - scroll2) / (_getTime() - _time2) * 1000 || 0;
    };

    self.endAnimation = function () {
      _endAnimation(self.callbackAnimation);

      if (animation) {
        scrubTween ? scrubTween.progress(1) : !animation.paused() ? _endAnimation(animation, animation.reversed()) : isToggle || _endAnimation(animation, self.direction < 0, 1);
      }
    };

    self.labelToScroll = function (label) {
      return animation && animation.labels && (start || self.refresh() || start) + animation.labels[label] / animation.duration() * change || 0;
    };

    self.getTrailing = function (name) {
      var i = _triggers.indexOf(self),
          a = self.direction > 0 ? _triggers.slice(0, i).reverse() : _triggers.slice(i + 1);

      return _isString(name) ? a.filter(function (t) {
        return t.vars.preventOverlaps === name;
      }) : a;
    };

    self.update = function (reset, recordVelocity, forceFake) {
      if (containerAnimation && !forceFake && !reset) {
        return;
      }

      var scroll = self.scroll(),
          p = reset ? 0 : (scroll - start) / change,
          clipped = p < 0 ? 0 : p > 1 ? 1 : p || 0,
          prevProgress = self.progress,
          isActive,
          wasActive,
          toggleState,
          action,
          stateChanged,
          toggled,
          isAtMax,
          isTakingAction;

      if (recordVelocity) {
        scroll2 = scroll1;
        scroll1 = containerAnimation ? scrollFunc() : scroll;

        if (snap) {
          snap2 = snap1;
          snap1 = animation && !isToggle ? animation.totalProgress() : clipped;
        }
      } // anticipate the pinning a few ticks ahead of time based on velocity to avoid a visual glitch due to the fact that most browsers do scrolling on a separate thread (not synced with requestAnimationFrame).


      anticipatePin && !clipped && pin && !_refreshing && !_startup && _lastScrollTime && start < scroll + (scroll - scroll2) / (_getTime() - _time2) * anticipatePin && (clipped = 0.0001);

      if (clipped !== prevProgress && self.enabled) {
        isActive = self.isActive = !!clipped && clipped < 1;
        wasActive = !!prevProgress && prevProgress < 1;
        toggled = isActive !== wasActive;
        stateChanged = toggled || !!clipped !== !!prevProgress; // could go from start all the way to end, thus it didn't toggle but it did change state in a sense (may need to fire a callback)

        self.direction = clipped > prevProgress ? 1 : -1;
        self.progress = clipped;

        if (stateChanged && !_refreshing) {
          toggleState = clipped && !prevProgress ? 0 : clipped === 1 ? 1 : prevProgress === 1 ? 2 : 3; // 0 = enter, 1 = leave, 2 = enterBack, 3 = leaveBack (we prioritize the FIRST encounter, thus if you scroll really fast past the onEnter and onLeave in one tick, it'd prioritize onEnter.

          if (isToggle) {
            action = !toggled && toggleActions[toggleState + 1] !== "none" && toggleActions[toggleState + 1] || toggleActions[toggleState]; // if it didn't toggle, that means it shot right past and since we prioritize the "enter" action, we should switch to the "leave" in this case (but only if one is defined)

            isTakingAction = animation && (action === "complete" || action === "reset" || action in animation);
          }
        }

        preventOverlaps && toggled && (isTakingAction || scrub || !animation) && (_isFunction(preventOverlaps) ? preventOverlaps(self) : self.getTrailing(preventOverlaps).forEach(function (t) {
          return t.endAnimation();
        }));

        if (!isToggle) {
          if (scrubTween && !_refreshing && !_startup) {
            scrubTween.vars.totalProgress = clipped;
            scrubTween.invalidate().restart();
          } else if (animation) {
            animation.totalProgress(clipped, !!_refreshing);
          }
        }

        if (pin) {
          reset && pinSpacing && (spacer.style[pinSpacing + direction.os2] = spacingStart);

          if (!useFixedPosition) {
            pinSetter(pinStart + pinChange * clipped);
          } else if (stateChanged) {
            isAtMax = !reset && clipped > prevProgress && end + 1 > scroll && scroll + 1 >= _maxScroll(scroller, direction); // if it's at the VERY end of the page, don't switch away from position: fixed because it's pointless and it could cause a brief flash when the user scrolls back up (when it gets pinned again)

            if (pinReparent) {
              if (!reset && (isActive || isAtMax)) {
                var bounds = _getBounds(pin, true),
                    _offset = scroll - start;

                _reparent(pin, _body, bounds.top + (direction === _vertical ? _offset : 0) + _px, bounds.left + (direction === _vertical ? 0 : _offset) + _px);
              } else {
                _reparent(pin, spacer);
              }
            }

            _setState(isActive || isAtMax ? pinActiveState : pinState);

            pinChange !== change && clipped < 1 && isActive || pinSetter(pinStart + (clipped === 1 && !isAtMax ? pinChange : 0));
          }
        }

        snap && !tweenTo.tween && !_refreshing && !_startup && snapDelayedCall.restart(true);
        toggleClass && (toggled || once && clipped && (clipped < 1 || !_limitCallbacks)) && _toArray(toggleClass.targets).forEach(function (el) {
          return el.classList[isActive || once ? "add" : "remove"](toggleClass.className);
        }); // classes could affect positioning, so do it even if reset or refreshing is true.

        onUpdate && !isToggle && !reset && onUpdate(self);

        if (stateChanged && !_refreshing) {
          if (isToggle) {
            if (isTakingAction) {
              if (action === "complete") {
                animation.pause().totalProgress(1);
              } else if (action === "reset") {
                animation.restart(true).pause();
              } else if (action === "restart") {
                animation.restart(true);
              } else {
                animation[action]();
              }
            }

            onUpdate && onUpdate(self);
          }

          if (toggled || !_limitCallbacks) {
            // on startup, the page could be scrolled and we don't want to fire callbacks that didn't toggle. For example onEnter shouldn't fire if the ScrollTrigger isn't actually entered.
            onToggle && toggled && _callback(self, onToggle);
            callbacks[toggleState] && _callback(self, callbacks[toggleState]);
            once && (clipped === 1 ? self.kill(false, 1) : callbacks[toggleState] = 0); // a callback shouldn't be called again if once is true.

            if (!toggled) {
              // it's possible to go completely past, like from before the start to after the end (or vice-versa) in which case BOTH callbacks should be fired in that order
              toggleState = clipped === 1 ? 1 : 3;
              callbacks[toggleState] && _callback(self, callbacks[toggleState]);
            }
          }

          if (fastScrollEnd && !isActive && Math.abs(self.getVelocity()) > (_isNumber(fastScrollEnd) ? fastScrollEnd : 2500)) {
            _endAnimation(self.callbackAnimation);

            scrubTween ? scrubTween.progress(1) : _endAnimation(animation, !clipped, 1);
          }
        } else if (isToggle && onUpdate && !_refreshing) {
          onUpdate(self);
        }
      } // update absolutely-positioned markers (only if the scroller isn't the viewport)


      if (markerEndSetter) {
        var n = containerAnimation ? scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0) : scroll;
        markerStartSetter(n + (markerStartTrigger._isFlipped ? 1 : 0));
        markerEndSetter(n);
      }

      caMarkerSetter && caMarkerSetter(-scroll / containerAnimation.duration() * (containerAnimation._caScrollDist || 0));
    };

    self.enable = function (reset, refresh) {
      if (!self.enabled) {
        self.enabled = true;

        _addListener(scroller, "resize", _onResize);

        _addListener(scroller, "scroll", _onScroll);

        onRefreshInit && _addListener(ScrollTrigger, "refreshInit", onRefreshInit);

        if (reset !== false) {
          self.progress = prevProgress = 0;
          scroll1 = scroll2 = lastSnap = scrollFunc();
        }

        refresh !== false && self.refresh();
      }
    };

    self.getTween = function (snap) {
      return snap && tweenTo ? tweenTo.tween : scrubTween;
    };

    self.setPositions = function (newStart, newEnd) {
      // doesn't persist after refresh()! Intended to be a way to override values that were set during refresh(), like you could set it in onRefresh()
      if (pin) {
        pinStart += newStart - start;
        pinChange += newEnd - newStart - change;
      }

      self.start = start = newStart;
      self.end = end = newEnd;
      change = newEnd - newStart;
      self.update();
    };

    self.disable = function (reset, allowAnimation) {
      if (self.enabled) {
        reset !== false && self.revert();
        self.enabled = self.isActive = false;
        allowAnimation || scrubTween && scrubTween.pause();
        prevScroll = 0;
        pinCache && (pinCache.uncache = 1);
        onRefreshInit && _removeListener(ScrollTrigger, "refreshInit", onRefreshInit);

        if (snapDelayedCall) {
          snapDelayedCall.pause();
          tweenTo.tween && tweenTo.tween.kill() && (tweenTo.tween = 0);
        }

        if (!isViewport) {
          var i = _triggers.length;

          while (i--) {
            if (_triggers[i].scroller === scroller && _triggers[i] !== self) {
              return; //don't remove the listeners if there are still other triggers referencing it.
            }
          }

          _removeListener(scroller, "resize", _onResize);

          _removeListener(scroller, "scroll", _onScroll);
        }
      }
    };

    self.kill = function (revert, allowAnimation) {
      self.disable(revert, allowAnimation);
      scrubTween && scrubTween.kill();
      id && delete _ids[id];

      var i = _triggers.indexOf(self);

      i >= 0 && _triggers.splice(i, 1);
      i === _i && _direction > 0 && _i--; // if we're in the middle of a refresh() or update(), splicing would cause skips in the index, so adjust...
      // if no other ScrollTrigger instances of the same scroller are found, wipe out any recorded scroll position. Otherwise, in a single page application, for example, it could maintain scroll position when it really shouldn't.

      i = 0;

      _triggers.forEach(function (t) {
        return t.scroller === self.scroller && (i = 1);
      });

      i || (self.scroll.rec = 0);

      if (animation) {
        animation.scrollTrigger = null;
        revert && animation.render(-1);
        allowAnimation || animation.kill();
      }

      markerStart && [markerStart, markerEnd, markerStartTrigger, markerEndTrigger].forEach(function (m) {
        return m.parentNode && m.parentNode.removeChild(m);
      });

      if (pin) {
        pinCache && (pinCache.uncache = 1);
        i = 0;

        _triggers.forEach(function (t) {
          return t.pin === pin && i++;
        });

        i || (pinCache.spacer = 0); // if there aren't any more ScrollTriggers with the same pin, remove the spacer, otherwise it could be contaminated with old/stale values if the user re-creates a ScrollTrigger for the same element.
      }
    };

    self.enable(false, false);
    !animation || !animation.add || change ? self.refresh() : gsap.delayedCall(0.01, function () {
      return start || end || self.refresh();
    }) && (change = 0.01) && (start = end = 0); // if the animation is a timeline, it may not have been populated yet, so it wouldn't render at the proper place on the first refresh(), thus we should schedule one for the next tick. If "change" is defined, we know it must be re-enabling, thus we can refresh() right away.
  };

  ScrollTrigger.register = function register(core) {
    if (!_coreInitted) {
      gsap = core || _getGSAP();

      if (_windowExists() && window.document) {
        _win = window;
        _doc = document;
        _docEl = _doc.documentElement;
        _body = _doc.body;
      }

      if (gsap) {
        _toArray = gsap.utils.toArray;
        _clamp = gsap.utils.clamp;
        _suppressOverwrites = gsap.core.suppressOverwrites || _passThrough;
        gsap.core.globals("ScrollTrigger", ScrollTrigger); // must register the global manually because in Internet Explorer, functions (classes) don't have a "name" property.

        if (_body) {
          _addListener(_win, "wheel", _onScroll);

          _root = [_win, _doc, _docEl, _body];

          _addListener(_doc, "scroll", _onScroll); // some browsers (like Chrome), the window stops dispatching scroll events on the window if you scroll really fast, but it's consistent on the document!


          var bodyStyle = _body.style,
              border = bodyStyle.borderTopStyle,
              bounds;
          bodyStyle.borderTopStyle = "solid"; // works around an issue where a margin of a child element could throw off the bounds of the _body, making it seem like there's a margin when there actually isn't. The border ensures that the bounds are accurate.

          bounds = _getBounds(_body);
          _vertical.m = Math.round(bounds.top + _vertical.sc()) || 0; // accommodate the offset of the <body> caused by margins and/or padding

          _horizontal.m = Math.round(bounds.left + _horizontal.sc()) || 0;
          border ? bodyStyle.borderTopStyle = border : bodyStyle.removeProperty("border-top-style");
          _syncInterval = setInterval(_sync, 200);
          gsap.delayedCall(0.5, function () {
            return _startup = 0;
          });

          _addListener(_doc, "touchcancel", _passThrough); // some older Android devices intermittently stop dispatching "touchmove" events if we don't listen for "touchcancel" on the document.


          _addListener(_body, "touchstart", _passThrough); //works around Safari bug: https://greensock.com/forums/topic/21450-draggable-in-iframe-on-mobile-is-buggy/


          _multiListener(_addListener, _doc, "pointerdown,touchstart,mousedown", function () {
            return _pointerIsDown = 1;
          });

          _multiListener(_addListener, _doc, "pointerup,touchend,mouseup", function () {
            return _pointerIsDown = 0;
          });

          _transformProp = gsap.utils.checkPrefix("transform");

          _stateProps.push(_transformProp);

          _coreInitted = _getTime();
          _resizeDelay = gsap.delayedCall(0.2, _refreshAll).pause();
          _autoRefresh = [_doc, "visibilitychange", function () {
            var w = _win.innerWidth,
                h = _win.innerHeight;

            if (_doc.hidden) {
              _prevWidth = w;
              _prevHeight = h;
            } else if (_prevWidth !== w || _prevHeight !== h) {
              _onResize();
            }
          }, _doc, "DOMContentLoaded", _refreshAll, _win, "load", function () {
            return _lastScrollTime || _refreshAll();
          }, _win, "resize", _onResize];

          _iterateAutoRefresh(_addListener);
        }
      }
    }

    return _coreInitted;
  };

  ScrollTrigger.defaults = function defaults(config) {
    if (config) {
      for (var p in config) {
        _defaults[p] = config[p];
      }
    }

    return _defaults;
  };

  ScrollTrigger.kill = function kill() {
    _enabled = 0;

    _triggers.slice(0).forEach(function (trigger) {
      return trigger.kill(1);
    });
  };

  ScrollTrigger.config = function config(vars) {
    "limitCallbacks" in vars && (_limitCallbacks = !!vars.limitCallbacks);
    var ms = vars.syncInterval;
    ms && clearInterval(_syncInterval) || (_syncInterval = ms) && setInterval(_sync, ms);

    if ("autoRefreshEvents" in vars) {
      _iterateAutoRefresh(_removeListener) || _iterateAutoRefresh(_addListener, vars.autoRefreshEvents || "none");
      _ignoreResize = (vars.autoRefreshEvents + "").indexOf("resize") === -1;
    }
  };

  ScrollTrigger.scrollerProxy = function scrollerProxy(target, vars) {
    var t = _getTarget(target),
        i = _scrollers.indexOf(t),
        isViewport = _isViewport(t);

    if (~i) {
      _scrollers.splice(i, isViewport ? 6 : 2);
    }

    if (vars) {
      isViewport ? _proxies.unshift(_win, vars, _body, vars, _docEl, vars) : _proxies.unshift(t, vars);
    }
  };

  ScrollTrigger.matchMedia = function matchMedia(vars) {
    // _media is populated in the following order: mediaQueryString, onMatch, onUnmatch, isMatched. So if there are two media queries, the Array would have a length of 8
    var mq, p, i, func, result;

    for (p in vars) {
      i = _media.indexOf(p);
      func = vars[p];
      _creatingMedia = p;

      if (p === "all") {
        func();
      } else {
        mq = _win.matchMedia(p);

        if (mq) {
          mq.matches && (result = func());

          if (~i) {
            _media[i + 1] = _combineFunc(_media[i + 1], func);
            _media[i + 2] = _combineFunc(_media[i + 2], result);
          } else {
            i = _media.length;

            _media.push(p, func, result);

            mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
          }

          _media[i + 3] = mq.matches;
        }
      }

      _creatingMedia = 0;
    }

    return _media;
  };

  ScrollTrigger.clearMatchMedia = function clearMatchMedia(query) {
    query || (_media.length = 0);
    query = _media.indexOf(query);
    query >= 0 && _media.splice(query, 4);
  };

  ScrollTrigger.isInViewport = function isInViewport(element, ratio, horizontal) {
    var bounds = (_isString(element) ? _getTarget(element) : element).getBoundingClientRect(),
        offset = bounds[horizontal ? _width : _height] * ratio || 0;
    return horizontal ? bounds.right - offset > 0 && bounds.left + offset < _win.innerWidth : bounds.bottom - offset > 0 && bounds.top + offset < _win.innerHeight;
  };

  ScrollTrigger.positionInViewport = function positionInViewport(element, referencePoint, horizontal) {
    _isString(element) && (element = _getTarget(element));
    var bounds = element.getBoundingClientRect(),
        size = bounds[horizontal ? _width : _height],
        offset = referencePoint == null ? size / 2 : referencePoint in _keywords ? _keywords[referencePoint] * size : ~referencePoint.indexOf("%") ? parseFloat(referencePoint) * size / 100 : parseFloat(referencePoint) || 0;
    return horizontal ? (bounds.left + offset) / _win.innerWidth : (bounds.top + offset) / _win.innerHeight;
  };

  return ScrollTrigger;
}();
ScrollTrigger.version = "3.9.1";

ScrollTrigger.saveStyles = function (targets) {
  return targets ? _toArray(targets).forEach(function (target) {
    // saved styles are recorded in a consecutive alternating Array, like [element, cssText, transform attribute, cache, matchMedia, ...]
    if (target && target.style) {
      var i = _savedStyles.indexOf(target);

      i >= 0 && _savedStyles.splice(i, 5);

      _savedStyles.push(target, target.style.cssText, target.getBBox && target.getAttribute("transform"), gsap.core.getCache(target), _creatingMedia);
    }
  }) : _savedStyles;
};

ScrollTrigger.revert = function (soft, media) {
  return _revertAll(!soft, media);
};

ScrollTrigger.create = function (vars, animation) {
  return new ScrollTrigger(vars, animation);
};

ScrollTrigger.refresh = function (safe) {
  return safe ? _onResize() : (_coreInitted || ScrollTrigger.register()) && _refreshAll(true);
};

ScrollTrigger.update = _updateAll;
ScrollTrigger.clearScrollMemory = _clearScrollMemory;

ScrollTrigger.maxScroll = function (element, horizontal) {
  return _maxScroll(element, horizontal ? _horizontal : _vertical);
};

ScrollTrigger.getScrollFunc = function (element, horizontal) {
  return _getScrollFunc(_getTarget(element), horizontal ? _horizontal : _vertical);
};

ScrollTrigger.getById = function (id) {
  return _ids[id];
};

ScrollTrigger.getAll = function () {
  return _triggers.slice(0);
};

ScrollTrigger.isScrolling = function () {
  return !!_lastScrollTime;
};

ScrollTrigger.snapDirectional = _snapDirectional;

ScrollTrigger.addEventListener = function (type, callback) {
  var a = _listeners[type] || (_listeners[type] = []);
  ~a.indexOf(callback) || a.push(callback);
};

ScrollTrigger.removeEventListener = function (type, callback) {
  var a = _listeners[type],
      i = a && a.indexOf(callback);
  i >= 0 && a.splice(i, 1);
};

ScrollTrigger.batch = function (targets, vars) {
  var result = [],
      varsCopy = {},
      interval = vars.interval || 0.016,
      batchMax = vars.batchMax || 1e9,
      proxyCallback = function proxyCallback(type, callback) {
    var elements = [],
        triggers = [],
        delay = gsap.delayedCall(interval, function () {
      callback(elements, triggers);
      elements = [];
      triggers = [];
    }).pause();
    return function (self) {
      elements.length || delay.restart(true);
      elements.push(self.trigger);
      triggers.push(self);
      batchMax <= elements.length && delay.progress(1);
    };
  },
      p;

  for (p in vars) {
    varsCopy[p] = p.substr(0, 2) === "on" && _isFunction(vars[p]) && p !== "onRefreshInit" ? proxyCallback(p, vars[p]) : vars[p];
  }

  if (_isFunction(batchMax)) {
    batchMax = batchMax();

    _addListener(ScrollTrigger, "refresh", function () {
      return batchMax = vars.batchMax();
    });
  }

  _toArray(targets).forEach(function (target) {
    var config = {};

    for (p in varsCopy) {
      config[p] = varsCopy[p];
    }

    config.trigger = target;
    result.push(ScrollTrigger.create(config));
  });

  return result;
};

ScrollTrigger.sort = function (func) {
  return _triggers.sort(func || function (a, b) {
    return (a.vars.refreshPriority || 0) * -1e6 + a.start - (b.start + (b.vars.refreshPriority || 0) * -1e6);
  });
};

_getGSAP() && gsap.registerPlugin(ScrollTrigger);


/***/ }),

/***/ "./node_modules/gsap/TextPlugin.js":
/*!*****************************************!*\
  !*** ./node_modules/gsap/TextPlugin.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextPlugin": () => (/* binding */ TextPlugin),
/* harmony export */   "default": () => (/* binding */ TextPlugin)
/* harmony export */ });
/* harmony import */ var _utils_strings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/strings.js */ "./node_modules/gsap/utils/strings.js");
/*!
 * TextPlugin 3.9.1
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */


var gsap,
    _tempDiv,
    _getGSAP = function _getGSAP() {
  return gsap || typeof window !== "undefined" && (gsap = window.gsap) && gsap.registerPlugin && gsap;
};

var TextPlugin = {
  version: "3.9.1",
  name: "text",
  init: function init(target, value, tween) {
    var i = target.nodeName.toUpperCase(),
        data = this,
        _short,
        text,
        original,
        j,
        condensedText,
        condensedOriginal,
        aggregate,
        s;

    data.svg = target.getBBox && (i === "TEXT" || i === "TSPAN");

    if (!("innerHTML" in target) && !data.svg) {
      return false;
    }

    data.target = target;

    if (typeof value !== "object") {
      value = {
        value: value
      };
    }

    if (!("value" in value)) {
      data.text = data.original = [""];
      return;
    }

    data.delimiter = value.delimiter || "";
    original = (0,_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.splitInnerHTML)(target, data.delimiter, false, value.preserveSpaces);

    if (!_tempDiv) {
      _tempDiv = document.createElement("div");
    }

    _tempDiv.innerHTML = value.value;
    text = (0,_utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.splitInnerHTML)(_tempDiv, data.delimiter);
    data.from = tween._from;

    if (data.from) {
      i = original;
      original = text;
      text = i;
    }

    data.hasClass = !!(value.newClass || value.oldClass);
    data.newClass = value.newClass;
    data.oldClass = value.oldClass;
    i = original.length - text.length;
    _short = i < 0 ? original : text;
    data.fillChar = value.fillChar || (value.padSpace ? "&nbsp;" : "");

    if (i < 0) {
      i = -i;
    }

    while (--i > -1) {
      _short.push(data.fillChar);
    }

    if (value.type === "diff") {
      j = 0;
      condensedText = [];
      condensedOriginal = [];
      aggregate = "";

      for (i = 0; i < text.length; i++) {
        s = text[i];

        if (s === original[i]) {
          aggregate += s;
        } else {
          condensedText[j] = aggregate + s;
          condensedOriginal[j++] = aggregate + original[i];
          aggregate = "";
        }
      }

      text = condensedText;
      original = condensedOriginal;

      if (aggregate) {
        text.push(aggregate);
        original.push(aggregate);
      }
    }

    if (value.speed) {
      tween.duration(Math.min(0.05 / value.speed * _short.length, value.maxDuration || 9999));
    }

    this.original = original;
    this.text = text;

    this._props.push("text");
  },
  render: function render(ratio, data) {
    if (ratio > 1) {
      ratio = 1;
    } else if (ratio < 0) {
      ratio = 0;
    }

    if (data.from) {
      ratio = 1 - ratio;
    }

    var text = data.text,
        hasClass = data.hasClass,
        newClass = data.newClass,
        oldClass = data.oldClass,
        delimiter = data.delimiter,
        target = data.target,
        fillChar = data.fillChar,
        original = data.original,
        l = text.length,
        i = ratio * l + 0.5 | 0,
        applyNew,
        applyOld,
        str;

    if (hasClass && ratio) {
      applyNew = newClass && i;
      applyOld = oldClass && i !== l;
      str = (applyNew ? "<span class='" + newClass + "'>" : "") + text.slice(0, i).join(delimiter) + (applyNew ? "</span>" : "") + (applyOld ? "<span class='" + oldClass + "'>" : "") + delimiter + original.slice(i).join(delimiter) + (applyOld ? "</span>" : "");
    } else {
      str = text.slice(0, i).join(delimiter) + delimiter + original.slice(i).join(delimiter);
    }

    if (data.svg) {
      //SVG text elements don't have an "innerHTML" in Microsoft browsers.
      target.textContent = str;
    } else {
      target.innerHTML = fillChar === "&nbsp;" && ~str.indexOf("  ") ? str.split("  ").join("&nbsp;&nbsp;") : str;
    }
  }
};
TextPlugin.splitInnerHTML = _utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.splitInnerHTML;
TextPlugin.emojiSafeSplit = _utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.emojiSafeSplit;
TextPlugin.getText = _utils_strings_js__WEBPACK_IMPORTED_MODULE_0__.getText;
_getGSAP() && gsap.registerPlugin(TextPlugin);


/***/ }),

/***/ "./node_modules/gsap/all.js":
/*!**********************************!*\
  !*** ./node_modules/gsap/all.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Back": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Back),
/* harmony export */   "Bounce": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Bounce),
/* harmony export */   "CSSPlugin": () => (/* reexport safe */ _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "CSSRulePlugin": () => (/* reexport safe */ _CSSRulePlugin_js__WEBPACK_IMPORTED_MODULE_3__.CSSRulePlugin),
/* harmony export */   "Circ": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Circ),
/* harmony export */   "Cubic": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Cubic),
/* harmony export */   "CustomEase": () => (/* reexport safe */ _CustomEase_js__WEBPACK_IMPORTED_MODULE_2__.CustomEase),
/* harmony export */   "Draggable": () => (/* reexport safe */ _Draggable_js__WEBPACK_IMPORTED_MODULE_4__.Draggable),
/* harmony export */   "EasePack": () => (/* reexport safe */ _EasePack_js__WEBPACK_IMPORTED_MODULE_6__.EasePack),
/* harmony export */   "EaselPlugin": () => (/* reexport safe */ _EaselPlugin_js__WEBPACK_IMPORTED_MODULE_5__.EaselPlugin),
/* harmony export */   "Elastic": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Elastic),
/* harmony export */   "Expo": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Expo),
/* harmony export */   "ExpoScaleEase": () => (/* reexport safe */ _EasePack_js__WEBPACK_IMPORTED_MODULE_6__.ExpoScaleEase),
/* harmony export */   "Flip": () => (/* reexport safe */ _Flip_js__WEBPACK_IMPORTED_MODULE_7__.Flip),
/* harmony export */   "Linear": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Linear),
/* harmony export */   "MotionPathPlugin": () => (/* reexport safe */ _MotionPathPlugin_js__WEBPACK_IMPORTED_MODULE_8__.MotionPathPlugin),
/* harmony export */   "PixiPlugin": () => (/* reexport safe */ _PixiPlugin_js__WEBPACK_IMPORTED_MODULE_9__.PixiPlugin),
/* harmony export */   "Power0": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power0),
/* harmony export */   "Power1": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power1),
/* harmony export */   "Power2": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power2),
/* harmony export */   "Power3": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power3),
/* harmony export */   "Power4": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Power4),
/* harmony export */   "Quad": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quad),
/* harmony export */   "Quart": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quart),
/* harmony export */   "Quint": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Quint),
/* harmony export */   "RoughEase": () => (/* reexport safe */ _EasePack_js__WEBPACK_IMPORTED_MODULE_6__.RoughEase),
/* harmony export */   "ScrollToPlugin": () => (/* reexport safe */ _ScrollToPlugin_js__WEBPACK_IMPORTED_MODULE_10__.ScrollToPlugin),
/* harmony export */   "ScrollTrigger": () => (/* reexport safe */ _ScrollTrigger_js__WEBPACK_IMPORTED_MODULE_11__.ScrollTrigger),
/* harmony export */   "Sine": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Sine),
/* harmony export */   "SlowMo": () => (/* reexport safe */ _EasePack_js__WEBPACK_IMPORTED_MODULE_6__.SlowMo),
/* harmony export */   "SteppedEase": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.SteppedEase),
/* harmony export */   "Strong": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.Strong),
/* harmony export */   "TextPlugin": () => (/* reexport safe */ _TextPlugin_js__WEBPACK_IMPORTED_MODULE_12__.TextPlugin),
/* harmony export */   "TimelineLite": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineLite),
/* harmony export */   "TimelineMax": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TimelineMax),
/* harmony export */   "TweenLite": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.TweenLite),
/* harmony export */   "TweenMax": () => (/* binding */ TweenMaxWithCSS),
/* harmony export */   "clamp": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.clamp),
/* harmony export */   "default": () => (/* binding */ gsapWithCSS),
/* harmony export */   "distribute": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.distribute),
/* harmony export */   "getUnit": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.getUnit),
/* harmony export */   "gsap": () => (/* binding */ gsapWithCSS),
/* harmony export */   "interpolate": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.interpolate),
/* harmony export */   "mapRange": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.mapRange),
/* harmony export */   "normalize": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.normalize),
/* harmony export */   "pipe": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.pipe),
/* harmony export */   "random": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.random),
/* harmony export */   "selector": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.selector),
/* harmony export */   "shuffle": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.shuffle),
/* harmony export */   "snap": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.snap),
/* harmony export */   "splitColor": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.splitColor),
/* harmony export */   "toArray": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.toArray),
/* harmony export */   "unitize": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.unitize),
/* harmony export */   "wrap": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.wrap),
/* harmony export */   "wrapYoyo": () => (/* reexport safe */ _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__.wrapYoyo)
/* harmony export */ });
/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ "./node_modules/gsap/gsap-core.js");
/* harmony import */ var _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CSSPlugin.js */ "./node_modules/gsap/CSSPlugin.js");
/* harmony import */ var _CustomEase_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CustomEase.js */ "./node_modules/gsap/CustomEase.js");
/* harmony import */ var _CSSRulePlugin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CSSRulePlugin.js */ "./node_modules/gsap/CSSRulePlugin.js");
/* harmony import */ var _Draggable_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Draggable.js */ "./node_modules/gsap/Draggable.js");
/* harmony import */ var _EaselPlugin_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./EaselPlugin.js */ "./node_modules/gsap/EaselPlugin.js");
/* harmony import */ var _EasePack_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./EasePack.js */ "./node_modules/gsap/EasePack.js");
/* harmony import */ var _Flip_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Flip.js */ "./node_modules/gsap/Flip.js");
/* harmony import */ var _MotionPathPlugin_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./MotionPathPlugin.js */ "./node_modules/gsap/MotionPathPlugin.js");
/* harmony import */ var _PixiPlugin_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./PixiPlugin.js */ "./node_modules/gsap/PixiPlugin.js");
/* harmony import */ var _ScrollToPlugin_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ScrollToPlugin.js */ "./node_modules/gsap/ScrollToPlugin.js");
/* harmony import */ var _ScrollTrigger_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./ScrollTrigger.js */ "./node_modules/gsap/ScrollTrigger.js");
/* harmony import */ var _TextPlugin_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./TextPlugin.js */ "./node_modules/gsap/TextPlugin.js");


var gsapWithCSS = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["default"].registerPlugin(_CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__["default"]) || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["default"], // to protect from tree shaking
	TweenMaxWithCSS = gsapWithCSS.core.Tween;













 

//BONUS EXPORTS
//export * from "./DrawSVGPlugin.js";
//export * from "./Physics2DPlugin.js";
//export * from "./PhysicsPropsPlugin.js";
//export * from "./ScrambleTextPlugin.js";
//export * from "./CustomBounce.js";
//export * from "./CustomWiggle.js";
//export * from "./GSDevTools.js";
//export * from "./InertiaPlugin.js";
//export * from "./MorphSVGPlugin.js";
//export * from "./MotionPathHelper.js";
//export * from "./SplitText.js";

/***/ }),

/***/ "./node_modules/gsap/gsap-core.js":
/*!****************************************!*\
  !*** ./node_modules/gsap/gsap-core.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Animation": () => (/* binding */ Animation),
/* harmony export */   "Back": () => (/* binding */ Back),
/* harmony export */   "Bounce": () => (/* binding */ Bounce),
/* harmony export */   "Circ": () => (/* binding */ Circ),
/* harmony export */   "Cubic": () => (/* binding */ Cubic),
/* harmony export */   "Elastic": () => (/* binding */ Elastic),
/* harmony export */   "Expo": () => (/* binding */ Expo),
/* harmony export */   "GSCache": () => (/* binding */ GSCache),
/* harmony export */   "Linear": () => (/* binding */ Linear),
/* harmony export */   "Power0": () => (/* binding */ Power0),
/* harmony export */   "Power1": () => (/* binding */ Power1),
/* harmony export */   "Power2": () => (/* binding */ Power2),
/* harmony export */   "Power3": () => (/* binding */ Power3),
/* harmony export */   "Power4": () => (/* binding */ Power4),
/* harmony export */   "PropTween": () => (/* binding */ PropTween),
/* harmony export */   "Quad": () => (/* binding */ Quad),
/* harmony export */   "Quart": () => (/* binding */ Quart),
/* harmony export */   "Quint": () => (/* binding */ Quint),
/* harmony export */   "Sine": () => (/* binding */ Sine),
/* harmony export */   "SteppedEase": () => (/* binding */ SteppedEase),
/* harmony export */   "Strong": () => (/* binding */ Strong),
/* harmony export */   "Timeline": () => (/* binding */ Timeline),
/* harmony export */   "TimelineLite": () => (/* binding */ Timeline),
/* harmony export */   "TimelineMax": () => (/* binding */ Timeline),
/* harmony export */   "Tween": () => (/* binding */ Tween),
/* harmony export */   "TweenLite": () => (/* binding */ Tween),
/* harmony export */   "TweenMax": () => (/* binding */ Tween),
/* harmony export */   "_checkPlugin": () => (/* binding */ _checkPlugin),
/* harmony export */   "_colorExp": () => (/* binding */ _colorExp),
/* harmony export */   "_colorStringFilter": () => (/* binding */ _colorStringFilter),
/* harmony export */   "_config": () => (/* binding */ _config),
/* harmony export */   "_forEachName": () => (/* binding */ _forEachName),
/* harmony export */   "_getCache": () => (/* binding */ _getCache),
/* harmony export */   "_getProperty": () => (/* binding */ _getProperty),
/* harmony export */   "_getSetter": () => (/* binding */ _getSetter),
/* harmony export */   "_isString": () => (/* binding */ _isString),
/* harmony export */   "_isUndefined": () => (/* binding */ _isUndefined),
/* harmony export */   "_missingPlugin": () => (/* binding */ _missingPlugin),
/* harmony export */   "_numExp": () => (/* binding */ _numExp),
/* harmony export */   "_numWithUnitExp": () => (/* binding */ _numWithUnitExp),
/* harmony export */   "_plugins": () => (/* binding */ _plugins),
/* harmony export */   "_relExp": () => (/* binding */ _relExp),
/* harmony export */   "_removeLinkedListItem": () => (/* binding */ _removeLinkedListItem),
/* harmony export */   "_renderComplexString": () => (/* binding */ _renderComplexString),
/* harmony export */   "_replaceRandom": () => (/* binding */ _replaceRandom),
/* harmony export */   "_round": () => (/* binding */ _round),
/* harmony export */   "_roundModifier": () => (/* binding */ _roundModifier),
/* harmony export */   "_setDefaults": () => (/* binding */ _setDefaults),
/* harmony export */   "_sortPropTweensByPriority": () => (/* binding */ _sortPropTweensByPriority),
/* harmony export */   "_ticker": () => (/* binding */ _ticker),
/* harmony export */   "clamp": () => (/* binding */ clamp),
/* harmony export */   "default": () => (/* binding */ gsap),
/* harmony export */   "distribute": () => (/* binding */ distribute),
/* harmony export */   "getUnit": () => (/* binding */ getUnit),
/* harmony export */   "gsap": () => (/* binding */ gsap),
/* harmony export */   "interpolate": () => (/* binding */ interpolate),
/* harmony export */   "mapRange": () => (/* binding */ mapRange),
/* harmony export */   "normalize": () => (/* binding */ normalize),
/* harmony export */   "pipe": () => (/* binding */ pipe),
/* harmony export */   "random": () => (/* binding */ random),
/* harmony export */   "selector": () => (/* binding */ selector),
/* harmony export */   "shuffle": () => (/* binding */ shuffle),
/* harmony export */   "snap": () => (/* binding */ snap),
/* harmony export */   "splitColor": () => (/* binding */ splitColor),
/* harmony export */   "toArray": () => (/* binding */ toArray),
/* harmony export */   "unitize": () => (/* binding */ unitize),
/* harmony export */   "wrap": () => (/* binding */ wrap),
/* harmony export */   "wrapYoyo": () => (/* binding */ wrapYoyo)
/* harmony export */ });
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

/*!
 * GSAP 3.9.1
 * https://greensock.com
 *
 * @license Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */
var _config = {
  autoSleep: 120,
  force3D: "auto",
  nullTargetWarn: 1,
  units: {
    lineHeight: ""
  }
},
    _defaults = {
  duration: .5,
  overwrite: false,
  delay: 0
},
    _suppressOverwrites,
    _bigNum = 1e8,
    _tinyNum = 1 / _bigNum,
    _2PI = Math.PI * 2,
    _HALF_PI = _2PI / 4,
    _gsID = 0,
    _sqrt = Math.sqrt,
    _cos = Math.cos,
    _sin = Math.sin,
    _isString = function _isString(value) {
  return typeof value === "string";
},
    _isFunction = function _isFunction(value) {
  return typeof value === "function";
},
    _isNumber = function _isNumber(value) {
  return typeof value === "number";
},
    _isUndefined = function _isUndefined(value) {
  return typeof value === "undefined";
},
    _isObject = function _isObject(value) {
  return typeof value === "object";
},
    _isNotFalse = function _isNotFalse(value) {
  return value !== false;
},
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _isFuncOrString = function _isFuncOrString(value) {
  return _isFunction(value) || _isString(value);
},
    _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function () {},
    // note: IE10 has ArrayBuffer, but NOT ArrayBuffer.isView().
_isArray = Array.isArray,
    _strictNumExp = /(?:-?\.?\d|\.)+/gi,
    //only numbers (including negatives and decimals) but NOT relative values.
_numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
    //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.
_numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
    _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
    //duplicate so that while we're looping through matches from exec(), it doesn't contaminate the lastIndex of _numExp which we use to search for colors too.
_relExp = /[+-]=-?[.\d]+/,
    _delimitedValueExp = /[^,'"\[\]\s]+/gi,
    // previously /[#\-+.]*\b[a-z\d\-=+%.]+/gi but didn't catch special characters.
_unitExp = /[\d.+\-=]+(?:e[-+]\d*)*/i,
    _globalTimeline,
    _win,
    _coreInitted,
    _doc,
    _globals = {},
    _installScope = {},
    _coreReady,
    _install = function _install(scope) {
  return (_installScope = _merge(scope, _globals)) && gsap;
},
    _missingPlugin = function _missingPlugin(property, value) {
  return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
},
    _warn = function _warn(message, suppress) {
  return !suppress && console.warn(message);
},
    _addGlobal = function _addGlobal(name, obj) {
  return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
},
    _emptyFunc = function _emptyFunc() {
  return 0;
},
    _reservedProps = {},
    _lazyTweens = [],
    _lazyLookup = {},
    _lastRenderedFrame,
    _plugins = {},
    _effects = {},
    _nextGCFrame = 30,
    _harnessPlugins = [],
    _callbackNames = "",
    _harness = function _harness(targets) {
  var target = targets[0],
      harnessPlugin,
      i;
  _isObject(target) || _isFunction(target) || (targets = [targets]);

  if (!(harnessPlugin = (target._gsap || {}).harness)) {
    // find the first target with a harness. We assume targets passed into an animation will be of similar type, meaning the same kind of harness can be used for them all (performance optimization)
    i = _harnessPlugins.length;

    while (i-- && !_harnessPlugins[i].targetTest(target)) {}

    harnessPlugin = _harnessPlugins[i];
  }

  i = targets.length;

  while (i--) {
    targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);
  }

  return targets;
},
    _getCache = function _getCache(target) {
  return target._gsap || _harness(toArray(target))[0]._gsap;
},
    _getProperty = function _getProperty(target, property, v) {
  return (v = target[property]) && _isFunction(v) ? target[property]() : _isUndefined(v) && target.getAttribute && target.getAttribute(property) || v;
},
    _forEachName = function _forEachName(names, func) {
  return (names = names.split(",")).forEach(func) || names;
},
    //split a comma-delimited list of names into an array, then run a forEach() function and return the split array (this is just a way to consolidate/shorten some code).
_round = function _round(value) {
  return Math.round(value * 100000) / 100000 || 0;
},
    _roundPrecise = function _roundPrecise(value) {
  return Math.round(value * 10000000) / 10000000 || 0;
},
    // increased precision mostly for timing values.
_arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {
  //searches one array to find matches for any of the items in the toFind array. As soon as one is found, it returns true. It does NOT return all the matches; it's simply a boolean search.
  var l = toFind.length,
      i = 0;

  for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) {}

  return i < l;
},
    _lazyRender = function _lazyRender() {
  var l = _lazyTweens.length,
      a = _lazyTweens.slice(0),
      i,
      tween;

  _lazyLookup = {};
  _lazyTweens.length = 0;

  for (i = 0; i < l; i++) {
    tween = a[i];
    tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
  }
},
    _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {
  _lazyTweens.length && _lazyRender();
  animation.render(time, suppressEvents, force);
  _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
},
    _numericIfPossible = function _numericIfPossible(value) {
  var n = parseFloat(value);
  return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;
},
    _passThrough = function _passThrough(p) {
  return p;
},
    _setDefaults = function _setDefaults(obj, defaults) {
  for (var p in defaults) {
    p in obj || (obj[p] = defaults[p]);
  }

  return obj;
},
    _setKeyframeDefaults = function _setKeyframeDefaults(excludeDuration) {
  return function (obj, defaults) {
    for (var p in defaults) {
      p in obj || p === "duration" && excludeDuration || p === "ease" || (obj[p] = defaults[p]);
    }
  };
},
    _merge = function _merge(base, toMerge) {
  for (var p in toMerge) {
    base[p] = toMerge[p];
  }

  return base;
},
    _mergeDeep = function _mergeDeep(base, toMerge) {
  for (var p in toMerge) {
    p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);
  }

  return base;
},
    _copyExcluding = function _copyExcluding(obj, excluding) {
  var copy = {},
      p;

  for (p in obj) {
    p in excluding || (copy[p] = obj[p]);
  }

  return copy;
},
    _inheritDefaults = function _inheritDefaults(vars) {
  var parent = vars.parent || _globalTimeline,
      func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;

  if (_isNotFalse(vars.inherit)) {
    while (parent) {
      func(vars, parent.vars.defaults);
      parent = parent.parent || parent._dp;
    }
  }

  return vars;
},
    _arraysMatch = function _arraysMatch(a1, a2) {
  var i = a1.length,
      match = i === a2.length;

  while (match && i-- && a1[i] === a2[i]) {}

  return i < 0;
},
    _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {
  if (firstProp === void 0) {
    firstProp = "_first";
  }

  if (lastProp === void 0) {
    lastProp = "_last";
  }

  var prev = parent[lastProp],
      t;

  if (sortBy) {
    t = child[sortBy];

    while (prev && prev[sortBy] > t) {
      prev = prev._prev;
    }
  }

  if (prev) {
    child._next = prev._next;
    prev._next = child;
  } else {
    child._next = parent[firstProp];
    parent[firstProp] = child;
  }

  if (child._next) {
    child._next._prev = child;
  } else {
    parent[lastProp] = child;
  }

  child._prev = prev;
  child.parent = child._dp = parent;
  return child;
},
    _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {
  if (firstProp === void 0) {
    firstProp = "_first";
  }

  if (lastProp === void 0) {
    lastProp = "_last";
  }

  var prev = child._prev,
      next = child._next;

  if (prev) {
    prev._next = next;
  } else if (parent[firstProp] === child) {
    parent[firstProp] = next;
  }

  if (next) {
    next._prev = prev;
  } else if (parent[lastProp] === child) {
    parent[lastProp] = prev;
  }

  child._next = child._prev = child.parent = null; // don't delete the _dp just so we can revert if necessary. But parent should be null to indicate the item isn't in a linked list.
},
    _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {
  child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove(child);
  child._act = 0;
},
    _uncache = function _uncache(animation, child) {
  if (animation && (!child || child._end > animation._dur || child._start < 0)) {
    // performance optimization: if a child animation is passed in we should only uncache if that child EXTENDS the animation (its end time is beyond the end)
    var a = animation;

    while (a) {
      a._dirty = 1;
      a = a.parent;
    }
  }

  return animation;
},
    _recacheAncestors = function _recacheAncestors(animation) {
  var parent = animation.parent;

  while (parent && parent.parent) {
    //sometimes we must force a re-sort of all children and update the duration/totalDuration of all ancestor timelines immediately in case, for example, in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.
    parent._dirty = 1;
    parent.totalDuration();
    parent = parent.parent;
  }

  return animation;
},
    _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {
  return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);
},
    _elapsedCycleDuration = function _elapsedCycleDuration(animation) {
  return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
},
    // feed in the totalTime and cycleDuration and it'll return the cycle (iteration minus 1) and if the playhead is exactly at the very END, it will NOT bump up to the next cycle.
_animationCycle = function _animationCycle(tTime, cycleDuration) {
  var whole = Math.floor(tTime /= cycleDuration);
  return tTime && whole === tTime ? whole - 1 : whole;
},
    _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {
  return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
},
    _setEnd = function _setEnd(animation) {
  return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
},
    _alignPlayhead = function _alignPlayhead(animation, totalTime) {
  // adjusts the animation's _start and _end according to the provided totalTime (only if the parent's smoothChildTiming is true and the animation isn't paused). It doesn't do any rendering or forcing things back into parent timelines, etc. - that's what totalTime() is for.
  var parent = animation._dp;

  if (parent && parent.smoothChildTiming && animation._ts) {
    animation._start = _roundPrecise(parent._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));

    _setEnd(animation);

    parent._dirty || _uncache(parent, animation); //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
  }

  return animation;
},

/*
_totalTimeToTime = (clampedTotalTime, duration, repeat, repeatDelay, yoyo) => {
	let cycleDuration = duration + repeatDelay,
		time = _round(clampedTotalTime % cycleDuration);
	if (time > duration) {
		time = duration;
	}
	return (yoyo && (~~(clampedTotalTime / cycleDuration) & 1)) ? duration - time : time;
},
*/
_postAddChecks = function _postAddChecks(timeline, child) {
  var t;

  if (child._time || child._initted && !child._dur) {
    //in case, for example, the _start is moved on a tween that has already rendered. Imagine it's at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning.
    t = _parentToChildTotalTime(timeline.rawTime(), child);

    if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
      child.render(t, true);
    }
  } //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.


  if (_uncache(timeline, child)._dp && timeline._initted && timeline._time >= timeline._dur && timeline._ts) {
    //in case any of the ancestors had completed but should now be enabled...
    if (timeline._dur < timeline.duration()) {
      t = timeline;

      while (t._dp) {
        t.rawTime() >= 0 && t.totalTime(t._tTime); //moves the timeline (shifts its startTime) if necessary, and also enables it. If it's currently zero, though, it may not be scheduled to render until later so there's no need to force it to align with the current playhead position. Only move to catch up with the playhead.

        t = t._dp;
      }
    }

    timeline._zTime = -_tinyNum; // helps ensure that the next render() will be forced (crossingStart = true in render()), even if the duration hasn't changed (we're adding a child which would need to get rendered). Definitely an edge case. Note: we MUST do this AFTER the loop above where the totalTime() might trigger a render() because this _addToTimeline() method gets called from the Animation constructor, BEFORE tweens even record their targets, etc. so we wouldn't want things to get triggered in the wrong order.
  }
},
    _addToTimeline = function _addToTimeline(timeline, child, position, skipChecks) {
  child.parent && _removeFromParent(child);
  child._start = _roundPrecise((_isNumber(position) ? position : position || timeline !== _globalTimeline ? _parsePosition(timeline, position, child) : timeline._time) + child._delay);
  child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));

  _addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);

  _isFromOrFromStart(child) || (timeline._recent = child);
  skipChecks || _postAddChecks(timeline, child);
  return timeline;
},
    _scrollTrigger = function _scrollTrigger(animation, trigger) {
  return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
},
    _attemptInitTween = function _attemptInitTween(tween, totalTime, force, suppressEvents) {
  _initTween(tween, totalTime);

  if (!tween._initted) {
    return 1;
  }

  if (!force && tween._pt && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
    _lazyTweens.push(tween);

    tween._lazy = [totalTime, suppressEvents];
    return 1;
  }
},
    _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart(_ref) {
  var parent = _ref.parent;
  return parent && parent._ts && parent._initted && !parent._lock && (parent.rawTime() < 0 || _parentPlayheadIsBeforeStart(parent));
},
    // check parent's _lock because when a timeline repeats/yoyos and does its artificial wrapping, we shouldn't force the ratio back to 0
_isFromOrFromStart = function _isFromOrFromStart(_ref2) {
  var data = _ref2.data;
  return data === "isFromStart" || data === "isStart";
},
    _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {
  var prevRatio = tween.ratio,
      ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1,
      // if the tween or its parent is reversed and the totalTime is 0, we should go to a ratio of 0. Edge case: if a from() or fromTo() stagger tween is placed later in a timeline, the "startAt" zero-duration tween could initially render at a time when the parent timeline's playhead is technically BEFORE where this tween is, so make sure that any "from" and "fromTo" startAt tweens are rendered the first time at a ratio of 1.
  repeatDelay = tween._rDelay,
      tTime = 0,
      pt,
      iteration,
      prevIteration;

  if (repeatDelay && tween._repeat) {
    // in case there's a zero-duration tween that has a repeat with a repeatDelay
    tTime = _clamp(0, tween._tDur, totalTime);
    iteration = _animationCycle(tTime, repeatDelay);
    tween._yoyo && iteration & 1 && (ratio = 1 - ratio);

    if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
      // if iteration changed
      prevRatio = 1 - ratio;
      tween.vars.repeatRefresh && tween._initted && tween.invalidate();
    }
  }

  if (ratio !== prevRatio || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
    if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents)) {
      // if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
      return;
    }

    prevIteration = tween._zTime;
    tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0); // when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

    suppressEvents || (suppressEvents = totalTime && !prevIteration); // if it was rendered previously at exactly 0 (_zTime) and now the playhead is moving away, DON'T fire callbacks otherwise they'll seem like duplicates.

    tween.ratio = ratio;
    tween._from && (ratio = 1 - ratio);
    tween._time = 0;
    tween._tTime = tTime;
    pt = tween._pt;

    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }

    tween._startAt && totalTime < 0 && tween._startAt.render(totalTime, true, true);
    tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
    tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");

    if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
      ratio && _removeFromParent(tween, 1);

      if (!suppressEvents) {
        _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);

        tween._prom && tween._prom();
      }
    }
  } else if (!tween._zTime) {
    tween._zTime = totalTime;
  }
},
    _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {
  var child;

  if (time > prevTime) {
    child = animation._first;

    while (child && child._start <= time) {
      if (child.data === "isPause" && child._start > prevTime) {
        return child;
      }

      child = child._next;
    }
  } else {
    child = animation._last;

    while (child && child._start >= time) {
      if (child.data === "isPause" && child._start < prevTime) {
        return child;
      }

      child = child._prev;
    }
  }
},
    _setDuration = function _setDuration(animation, duration, skipUncache, leavePlayhead) {
  var repeat = animation._repeat,
      dur = _roundPrecise(duration) || 0,
      totalProgress = animation._tTime / animation._tDur;
  totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
  animation._dur = dur;
  animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
  totalProgress > 0 && !leavePlayhead ? _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress) : animation.parent && _setEnd(animation);
  skipUncache || _uncache(animation.parent, animation);
  return animation;
},
    _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {
  return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
},
    _zeroPosition = {
  _start: 0,
  endTime: _emptyFunc,
  totalDuration: _emptyFunc
},
    _parsePosition = function _parsePosition(animation, position, percentAnimation) {
  var labels = animation.labels,
      recent = animation._recent || _zeroPosition,
      clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur,
      //in case there's a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child's endTime should be used instead.
  i,
      offset,
      isPercent;

  if (_isString(position) && (isNaN(position) || position in labels)) {
    //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
    offset = position.charAt(0);
    isPercent = position.substr(-1) === "%";
    i = position.indexOf("=");

    if (offset === "<" || offset === ">") {
      i >= 0 && (position = position.replace(/=/, ""));
      return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
    }

    if (i < 0) {
      position in labels || (labels[position] = clippedDuration);
      return labels[position];
    }

    offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));

    if (isPercent && percentAnimation) {
      offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
    }

    return i > 1 ? _parsePosition(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;
  }

  return position == null ? clippedDuration : +position;
},
    _createTweenType = function _createTweenType(type, params, timeline) {
  var isLegacy = _isNumber(params[1]),
      varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),
      vars = params[varsIndex],
      irVars,
      parent;

  isLegacy && (vars.duration = params[1]);
  vars.parent = timeline;

  if (type) {
    irVars = vars;
    parent = timeline;

    while (parent && !("immediateRender" in irVars)) {
      // inheritance hasn't happened yet, but someone may have set a default in an ancestor timeline. We could do vars.immediateRender = _isNotFalse(_inheritDefaults(vars).immediateRender) but that'd exact a slight performance penalty because _inheritDefaults() also runs in the Tween constructor. We're paying a small kb price here to gain speed.
      irVars = parent.vars.defaults || {};
      parent = _isNotFalse(parent.vars.inherit) && parent.parent;
    }

    vars.immediateRender = _isNotFalse(irVars.immediateRender);
    type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1]; // "from" vars
  }

  return new Tween(params[0], vars, params[varsIndex + 1]);
},
    _conditionalReturn = function _conditionalReturn(value, func) {
  return value || value === 0 ? func(value) : func;
},
    _clamp = function _clamp(min, max, value) {
  return value < min ? min : value > max ? max : value;
},
    getUnit = function getUnit(value, v) {
  return !_isString(value) || !(v = _unitExp.exec(value)) ? "" : value.substr(v.index + v[0].length);
},
    // note: protect against padded numbers as strings, like "100.100". That shouldn't return "00" as the unit. If it's numeric, return no unit.
clamp = function clamp(min, max, value) {
  return _conditionalReturn(value, function (v) {
    return _clamp(min, max, v);
  });
},
    _slice = [].slice,
    _isArrayLike = function _isArrayLike(value, nonEmpty) {
  return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
},
    _flatten = function _flatten(ar, leaveStrings, accumulator) {
  if (accumulator === void 0) {
    accumulator = [];
  }

  return ar.forEach(function (value) {
    var _accumulator;

    return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
  }) || accumulator;
},
    //takes any value and returns an array. If it's a string (and leaveStrings isn't true), it'll use document.querySelectorAll() and convert that to an array. It'll also accept iterables like jQuery objects.
toArray = function toArray(value, scope, leaveStrings) {
  return _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
},
    selector = function selector(value) {
  value = toArray(value)[0] || _warn("Invalid scope") || {};
  return function (v) {
    var el = value.current || value.nativeElement || value;
    return toArray(v, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value);
  };
},
    shuffle = function shuffle(a) {
  return a.sort(function () {
    return .5 - Math.random();
  });
},
    // alternative that's a bit faster and more reliably diverse but bigger:   for (let j, v, i = a.length; i; j = Math.floor(Math.random() * i), v = a[--i], a[i] = a[j], a[j] = v); return a;
//for distributing values across an array. Can accept a number, a function or (most commonly) a function which can contain the following properties: {base, amount, from, ease, grid, axis, length, each}. Returns a function that expects the following parameters: index, target, array. Recognizes the following
distribute = function distribute(v) {
  if (_isFunction(v)) {
    return v;
  }

  var vars = _isObject(v) ? v : {
    each: v
  },
      //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total "amount" that's chunked out among them all.
  ease = _parseEase(vars.ease),
      from = vars.from || 0,
      base = parseFloat(vars.base) || 0,
      cache = {},
      isDecimal = from > 0 && from < 1,
      ratios = isNaN(from) || isDecimal,
      axis = vars.axis,
      ratioX = from,
      ratioY = from;

  if (_isString(from)) {
    ratioX = ratioY = {
      center: .5,
      edges: .5,
      end: 1
    }[from] || 0;
  } else if (!isDecimal && ratios) {
    ratioX = from[0];
    ratioY = from[1];
  }

  return function (i, target, a) {
    var l = (a || vars).length,
        distances = cache[l],
        originX,
        originY,
        x,
        y,
        d,
        j,
        max,
        min,
        wrapAt;

    if (!distances) {
      wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];

      if (!wrapAt) {
        max = -_bigNum;

        while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {}

        wrapAt--;
      }

      distances = cache[l] = [];
      originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;
      originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;
      max = 0;
      min = _bigNum;

      for (j = 0; j < l; j++) {
        x = j % wrapAt - originX;
        y = originY - (j / wrapAt | 0);
        distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
        d > max && (max = d);
        d < min && (min = d);
      }

      from === "random" && shuffle(distances);
      distances.max = max - min;
      distances.min = min;
      distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
      distances.b = l < 0 ? base - l : base;
      distances.u = getUnit(vars.amount || vars.each) || 0; //unit

      ease = ease && l < 0 ? _invertEase(ease) : ease;
    }

    l = (distances[i] - distances.min) / distances.max || 0;
    return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u; //round in order to work around floating point errors
  };
},
    _roundModifier = function _roundModifier(v) {
  //pass in 0.1 get a function that'll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.
  var p = Math.pow(10, ((v + "").split(".")[1] || "").length); //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed())

  return function (raw) {
    var n = Math.round(parseFloat(raw) / v) * v * p;
    return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw)); // n - n % 1 replaces Math.floor() in order to handle negative values properly. For example, Math.floor(-150.00000000000003) is 151!
  };
},
    snap = function snap(snapTo, value) {
  var isArray = _isArray(snapTo),
      radius,
      is2D;

  if (!isArray && _isObject(snapTo)) {
    radius = isArray = snapTo.radius || _bigNum;

    if (snapTo.values) {
      snapTo = toArray(snapTo.values);

      if (is2D = !_isNumber(snapTo[0])) {
        radius *= radius; //performance optimization so we don't have to Math.sqrt() in the loop.
      }
    } else {
      snapTo = _roundModifier(snapTo.increment);
    }
  }

  return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function (raw) {
    is2D = snapTo(raw);
    return Math.abs(is2D - raw) <= radius ? is2D : raw;
  } : function (raw) {
    var x = parseFloat(is2D ? raw.x : raw),
        y = parseFloat(is2D ? raw.y : 0),
        min = _bigNum,
        closest = 0,
        i = snapTo.length,
        dx,
        dy;

    while (i--) {
      if (is2D) {
        dx = snapTo[i].x - x;
        dy = snapTo[i].y - y;
        dx = dx * dx + dy * dy;
      } else {
        dx = Math.abs(snapTo[i] - x);
      }

      if (dx < min) {
        min = dx;
        closest = i;
      }
    }

    closest = !radius || min <= radius ? snapTo[closest] : raw;
    return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
  });
},
    random = function random(min, max, roundingIncrement, returnFunction) {
  return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function () {
    return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * .99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
  });
},
    pipe = function pipe() {
  for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
    functions[_key] = arguments[_key];
  }

  return function (value) {
    return functions.reduce(function (v, f) {
      return f(v);
    }, value);
  };
},
    unitize = function unitize(func, unit) {
  return function (value) {
    return func(parseFloat(value)) + (unit || getUnit(value));
  };
},
    normalize = function normalize(min, max, value) {
  return mapRange(min, max, 0, 1, value);
},
    _wrapArray = function _wrapArray(a, wrapper, value) {
  return _conditionalReturn(value, function (index) {
    return a[~~wrapper(index)];
  });
},
    wrap = function wrap(min, max, value) {
  // NOTE: wrap() CANNOT be an arrow function! A very odd compiling bug causes problems (unrelated to GSAP).
  var range = max - min;
  return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function (value) {
    return (range + (value - min) % range) % range + min;
  });
},
    wrapYoyo = function wrapYoyo(min, max, value) {
  var range = max - min,
      total = range * 2;
  return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function (value) {
    value = (total + (value - min) % total) % total || 0;
    return min + (value > range ? total - value : value);
  });
},
    _replaceRandom = function _replaceRandom(value) {
  //replaces all occurrences of random(...) in a string with the calculated random value. can be a range like random(-100, 100, 5) or an array like random([0, 100, 500])
  var prev = 0,
      s = "",
      i,
      nums,
      end,
      isArray;

  while (~(i = value.indexOf("random(", prev))) {
    end = value.indexOf(")", i);
    isArray = value.charAt(i + 7) === "[";
    nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
    s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
    prev = end + 1;
  }

  return s + value.substr(prev, value.length - prev);
},
    mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {
  var inRange = inMax - inMin,
      outRange = outMax - outMin;
  return _conditionalReturn(value, function (value) {
    return outMin + ((value - inMin) / inRange * outRange || 0);
  });
},
    interpolate = function interpolate(start, end, progress, mutate) {
  var func = isNaN(start + end) ? 0 : function (p) {
    return (1 - p) * start + p * end;
  };

  if (!func) {
    var isString = _isString(start),
        master = {},
        p,
        i,
        interpolators,
        l,
        il;

    progress === true && (mutate = 1) && (progress = null);

    if (isString) {
      start = {
        p: start
      };
      end = {
        p: end
      };
    } else if (_isArray(start) && !_isArray(end)) {
      interpolators = [];
      l = start.length;
      il = l - 2;

      for (i = 1; i < l; i++) {
        interpolators.push(interpolate(start[i - 1], start[i])); //build the interpolators up front as a performance optimization so that when the function is called many times, it can just reuse them.
      }

      l--;

      func = function func(p) {
        p *= l;
        var i = Math.min(il, ~~p);
        return interpolators[i](p - i);
      };

      progress = end;
    } else if (!mutate) {
      start = _merge(_isArray(start) ? [] : {}, start);
    }

    if (!interpolators) {
      for (p in end) {
        _addPropTween.call(master, start, p, "get", end[p]);
      }

      func = function func(p) {
        return _renderPropTweens(p, master) || (isString ? start.p : start);
      };
    }
  }

  return _conditionalReturn(progress, func);
},
    _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {
  //used for nextLabel() and previousLabel()
  var labels = timeline.labels,
      min = _bigNum,
      p,
      distance,
      label;

  for (p in labels) {
    distance = labels[p] - fromTime;

    if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
      label = p;
      min = distance;
    }
  }

  return label;
},
    _callback = function _callback(animation, type, executeLazyFirst) {
  var v = animation.vars,
      callback = v[type],
      params,
      scope;

  if (!callback) {
    return;
  }

  params = v[type + "Params"];
  scope = v.callbackScope || animation;
  executeLazyFirst && _lazyTweens.length && _lazyRender(); //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.

  return params ? callback.apply(scope, params) : callback.call(scope);
},
    _interrupt = function _interrupt(animation) {
  _removeFromParent(animation);

  animation.scrollTrigger && animation.scrollTrigger.kill(false);
  animation.progress() < 1 && _callback(animation, "onInterrupt");
  return animation;
},
    _quickTween,
    _createPlugin = function _createPlugin(config) {
  config = !config.name && config["default"] || config; //UMD packaging wraps things oddly, so for example MotionPathHelper becomes {MotionPathHelper:MotionPathHelper, default:MotionPathHelper}.

  var name = config.name,
      isFunc = _isFunction(config),
      Plugin = name && !isFunc && config.init ? function () {
    this._props = [];
  } : config,
      //in case someone passes in an object that's not a plugin, like CustomEase
  instanceDefaults = {
    init: _emptyFunc,
    render: _renderPropTweens,
    add: _addPropTween,
    kill: _killPropTweensOf,
    modifier: _addPluginModifier,
    rawVars: 0
  },
      statics = {
    targetTest: 0,
    get: 0,
    getSetter: _getSetter,
    aliases: {},
    register: 0
  };

  _wake();

  if (config !== Plugin) {
    if (_plugins[name]) {
      return;
    }

    _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics)); //static methods


    _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics))); //instance methods


    _plugins[Plugin.prop = name] = Plugin;

    if (config.targetTest) {
      _harnessPlugins.push(Plugin);

      _reservedProps[name] = 1;
    }

    name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin"; //for the global name. "motionPath" should become MotionPathPlugin
  }

  _addGlobal(name, Plugin);

  config.register && config.register(gsap, Plugin, PropTween);
},

/*
 * --------------------------------------------------------------------------------------
 * COLORS
 * --------------------------------------------------------------------------------------
 */
_255 = 255,
    _colorLookup = {
  aqua: [0, _255, _255],
  lime: [0, _255, 0],
  silver: [192, 192, 192],
  black: [0, 0, 0],
  maroon: [128, 0, 0],
  teal: [0, 128, 128],
  blue: [0, 0, _255],
  navy: [0, 0, 128],
  white: [_255, _255, _255],
  olive: [128, 128, 0],
  yellow: [_255, _255, 0],
  orange: [_255, 165, 0],
  gray: [128, 128, 128],
  purple: [128, 0, 128],
  green: [0, 128, 0],
  red: [_255, 0, 0],
  pink: [_255, 192, 203],
  cyan: [0, _255, _255],
  transparent: [_255, _255, _255, 0]
},
    // possible future idea to replace the hard-coded color name values - put this in the ticker.wake() where we set the _doc:
// let ctx = _doc.createElement("canvas").getContext("2d");
// _forEachName("aqua,lime,silver,black,maroon,teal,blue,navy,white,olive,yellow,orange,gray,purple,green,red,pink,cyan", color => {ctx.fillStyle = color; _colorLookup[color] = splitColor(ctx.fillStyle)});
_hue = function _hue(h, m1, m2) {
  h += h < 0 ? 1 : h > 1 ? -1 : 0;
  return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;
},
    splitColor = function splitColor(v, toHSL, forceAlpha) {
  var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,
      r,
      g,
      b,
      h,
      s,
      l,
      max,
      min,
      d,
      wasHSL;

  if (!a) {
    if (v.substr(-1) === ",") {
      //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
      v = v.substr(0, v.length - 1);
    }

    if (_colorLookup[v]) {
      a = _colorLookup[v];
    } else if (v.charAt(0) === "#") {
      if (v.length < 6) {
        //for shorthand like #9F0 or #9F0F (could have alpha)
        r = v.charAt(1);
        g = v.charAt(2);
        b = v.charAt(3);
        v = "#" + r + r + g + g + b + b + (v.length === 5 ? v.charAt(4) + v.charAt(4) : "");
      }

      if (v.length === 9) {
        // hex with alpha, like #fd5e53ff
        a = parseInt(v.substr(1, 6), 16);
        return [a >> 16, a >> 8 & _255, a & _255, parseInt(v.substr(7), 16) / 255];
      }

      v = parseInt(v.substr(1), 16);
      a = [v >> 16, v >> 8 & _255, v & _255];
    } else if (v.substr(0, 3) === "hsl") {
      a = wasHSL = v.match(_strictNumExp);

      if (!toHSL) {
        h = +a[0] % 360 / 360;
        s = +a[1] / 100;
        l = +a[2] / 100;
        g = l <= .5 ? l * (s + 1) : l + s - l * s;
        r = l * 2 - g;
        a.length > 3 && (a[3] *= 1); //cast as number

        a[0] = _hue(h + 1 / 3, r, g);
        a[1] = _hue(h, r, g);
        a[2] = _hue(h - 1 / 3, r, g);
      } else if (~v.indexOf("=")) {
        //if relative values are found, just return the raw strings with the relative prefixes in place.
        a = v.match(_numExp);
        forceAlpha && a.length < 4 && (a[3] = 1);
        return a;
      }
    } else {
      a = v.match(_strictNumExp) || _colorLookup.transparent;
    }

    a = a.map(Number);
  }

  if (toHSL && !wasHSL) {
    r = a[0] / _255;
    g = a[1] / _255;
    b = a[2] / _255;
    max = Math.max(r, g, b);
    min = Math.min(r, g, b);
    l = (max + min) / 2;

    if (max === min) {
      h = s = 0;
    } else {
      d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
      h *= 60;
    }

    a[0] = ~~(h + .5);
    a[1] = ~~(s * 100 + .5);
    a[2] = ~~(l * 100 + .5);
  }

  forceAlpha && a.length < 4 && (a[3] = 1);
  return a;
},
    _colorOrderData = function _colorOrderData(v) {
  // strips out the colors from the string, finds all the numeric slots (with units) and returns an array of those. The Array also has a "c" property which is an Array of the index values where the colors belong. This is to help work around issues where there's a mis-matched order of color/numeric data like drop-shadow(#f00 0px 1px 2px) and drop-shadow(0x 1px 2px #f00). This is basically a helper function used in _formatColors()
  var values = [],
      c = [],
      i = -1;
  v.split(_colorExp).forEach(function (v) {
    var a = v.match(_numWithUnitExp) || [];
    values.push.apply(values, a);
    c.push(i += a.length + 1);
  });
  values.c = c;
  return values;
},
    _formatColors = function _formatColors(s, toHSL, orderMatchData) {
  var result = "",
      colors = (s + result).match(_colorExp),
      type = toHSL ? "hsla(" : "rgba(",
      i = 0,
      c,
      shell,
      d,
      l;

  if (!colors) {
    return s;
  }

  colors = colors.map(function (color) {
    return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
  });

  if (orderMatchData) {
    d = _colorOrderData(s);
    c = orderMatchData.c;

    if (c.join(result) !== d.c.join(result)) {
      shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
      l = shell.length - 1;

      for (; i < l; i++) {
        result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
      }
    }
  }

  if (!shell) {
    shell = s.split(_colorExp);
    l = shell.length - 1;

    for (; i < l; i++) {
      result += shell[i] + colors[i];
    }
  }

  return result + shell[l];
},
    _colorExp = function () {
  var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
      //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.,
  p;

  for (p in _colorLookup) {
    s += "|" + p + "\\b";
  }

  return new RegExp(s + ")", "gi");
}(),
    _hslExp = /hsl[a]?\(/,
    _colorStringFilter = function _colorStringFilter(a) {
  var combined = a.join(" "),
      toHSL;
  _colorExp.lastIndex = 0;

  if (_colorExp.test(combined)) {
    toHSL = _hslExp.test(combined);
    a[1] = _formatColors(a[1], toHSL);
    a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1])); // make sure the order of numbers/colors match with the END value.

    return true;
  }
},

/*
 * --------------------------------------------------------------------------------------
 * TICKER
 * --------------------------------------------------------------------------------------
 */
_tickerActive,
    _ticker = function () {
  var _getTime = Date.now,
      _lagThreshold = 500,
      _adjustedLag = 33,
      _startTime = _getTime(),
      _lastUpdate = _startTime,
      _gap = 1000 / 240,
      _nextTime = _gap,
      _listeners = [],
      _id,
      _req,
      _raf,
      _self,
      _delta,
      _i,
      _tick = function _tick(v) {
    var elapsed = _getTime() - _lastUpdate,
        manual = v === true,
        overlap,
        dispatch,
        time,
        frame;

    elapsed > _lagThreshold && (_startTime += elapsed - _adjustedLag);
    _lastUpdate += elapsed;
    time = _lastUpdate - _startTime;
    overlap = time - _nextTime;

    if (overlap > 0 || manual) {
      frame = ++_self.frame;
      _delta = time - _self.time * 1000;
      _self.time = time = time / 1000;
      _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
      dispatch = 1;
    }

    manual || (_id = _req(_tick)); //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.

    if (dispatch) {
      for (_i = 0; _i < _listeners.length; _i++) {
        // use _i and check _listeners.length instead of a variable because a listener could get removed during the loop, and if that happens to an element less than the current index, it'd throw things off in the loop.
        _listeners[_i](time, _delta, frame, v);
      }
    }
  };

  _self = {
    time: 0,
    frame: 0,
    tick: function tick() {
      _tick(true);
    },
    deltaRatio: function deltaRatio(fps) {
      return _delta / (1000 / (fps || 60));
    },
    wake: function wake() {
      if (_coreReady) {
        if (!_coreInitted && _windowExists()) {
          _win = _coreInitted = window;
          _doc = _win.document || {};
          _globals.gsap = gsap;
          (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);

          _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});

          _raf = _win.requestAnimationFrame;
        }

        _id && _self.sleep();

        _req = _raf || function (f) {
          return setTimeout(f, _nextTime - _self.time * 1000 + 1 | 0);
        };

        _tickerActive = 1;

        _tick(2);
      }
    },
    sleep: function sleep() {
      (_raf ? _win.cancelAnimationFrame : clearTimeout)(_id);
      _tickerActive = 0;
      _req = _emptyFunc;
    },
    lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
      _lagThreshold = threshold || 1 / _tinyNum; //zero should be interpreted as basically unlimited

      _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
    },
    fps: function fps(_fps) {
      _gap = 1000 / (_fps || 240);
      _nextTime = _self.time * 1000 + _gap;
    },
    add: function add(callback) {
      _listeners.indexOf(callback) < 0 && _listeners.push(callback);

      _wake();
    },
    remove: function remove(callback, i) {
      ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1) && _i >= i && _i--;
    },
    _listeners: _listeners
  };
  return _self;
}(),
    _wake = function _wake() {
  return !_tickerActive && _ticker.wake();
},
    //also ensures the core classes are initialized.

/*
* -------------------------------------------------
* EASING
* -------------------------------------------------
*/
_easeMap = {},
    _customEaseExp = /^[\d.\-M][\d.\-,\s]/,
    _quotesExp = /["']/g,
    _parseObjectInString = function _parseObjectInString(value) {
  //takes a string like "{wiggles:10, type:anticipate})" and turns it into a real object. Notice it ends in ")" and includes the {} wrappers. This is because we only use this function for parsing ease configs and prioritized optimization rather than reusability.
  var obj = {},
      split = value.substr(1, value.length - 3).split(":"),
      key = split[0],
      i = 1,
      l = split.length,
      index,
      val,
      parsedVal;

  for (; i < l; i++) {
    val = split[i];
    index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
    parsedVal = val.substr(0, index);
    obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
    key = val.substr(index + 1).trim();
  }

  return obj;
},
    _valueInParentheses = function _valueInParentheses(value) {
  var open = value.indexOf("(") + 1,
      close = value.indexOf(")"),
      nested = value.indexOf("(", open);
  return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
},
    _configEaseFromString = function _configEaseFromString(name) {
  //name can be a string like "elastic.out(1,0.5)", and pass in _easeMap as obj and it'll parse it out and call the actual function like _easeMap.Elastic.easeOut.config(1,0.5). It will also parse custom ease strings as long as CustomEase is loaded and registered (internally as _easeMap._CE).
  var split = (name + "").split("("),
      ease = _easeMap[split[0]];
  return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
},
    _invertEase = function _invertEase(ease) {
  return function (p) {
    return 1 - ease(1 - p);
  };
},
    // allow yoyoEase to be set in children and have those affected when the parent/ancestor timeline yoyos.
_propagateYoyoEase = function _propagateYoyoEase(timeline, isYoyo) {
  var child = timeline._first,
      ease;

  while (child) {
    if (child instanceof Timeline) {
      _propagateYoyoEase(child, isYoyo);
    } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
      if (child.timeline) {
        _propagateYoyoEase(child.timeline, isYoyo);
      } else {
        ease = child._ease;
        child._ease = child._yEase;
        child._yEase = ease;
        child._yoyo = isYoyo;
      }
    }

    child = child._next;
  }
},
    _parseEase = function _parseEase(ease, defaultEase) {
  return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
},
    _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {
  if (easeOut === void 0) {
    easeOut = function easeOut(p) {
      return 1 - easeIn(1 - p);
    };
  }

  if (easeInOut === void 0) {
    easeInOut = function easeInOut(p) {
      return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
    };
  }

  var ease = {
    easeIn: easeIn,
    easeOut: easeOut,
    easeInOut: easeInOut
  },
      lowercaseName;

  _forEachName(names, function (name) {
    _easeMap[name] = _globals[name] = ease;
    _easeMap[lowercaseName = name.toLowerCase()] = easeOut;

    for (var p in ease) {
      _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
    }
  });

  return ease;
},
    _easeInOutFromOut = function _easeInOutFromOut(easeOut) {
  return function (p) {
    return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;
  };
},
    _configElastic = function _configElastic(type, amplitude, period) {
  var p1 = amplitude >= 1 ? amplitude : 1,
      //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
  p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),
      p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),
      easeOut = function easeOut(p) {
    return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
  },
      ease = type === "out" ? easeOut : type === "in" ? function (p) {
    return 1 - easeOut(1 - p);
  } : _easeInOutFromOut(easeOut);

  p2 = _2PI / p2; //precalculate to optimize

  ease.config = function (amplitude, period) {
    return _configElastic(type, amplitude, period);
  };

  return ease;
},
    _configBack = function _configBack(type, overshoot) {
  if (overshoot === void 0) {
    overshoot = 1.70158;
  }

  var easeOut = function easeOut(p) {
    return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
  },
      ease = type === "out" ? easeOut : type === "in" ? function (p) {
    return 1 - easeOut(1 - p);
  } : _easeInOutFromOut(easeOut);

  ease.config = function (overshoot) {
    return _configBack(type, overshoot);
  };

  return ease;
}; // a cheaper (kb and cpu) but more mild way to get a parameterized weighted ease by feeding in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
// _weightedEase = ratio => {
// 	let y = 0.5 + ratio / 2;
// 	return p => (2 * (1 - p) * p * y + p * p);
// },
// a stronger (but more expensive kb/cpu) parameterized weighted ease that lets you feed in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
// _weightedEaseStrong = ratio => {
// 	ratio = .5 + ratio / 2;
// 	let o = 1 / 3 * (ratio < .5 ? ratio : 1 - ratio),
// 		b = ratio - o,
// 		c = ratio + o;
// 	return p => p === 1 ? p : 3 * b * (1 - p) * (1 - p) * p + 3 * c * (1 - p) * p * p + p * p * p;
// };


_forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function (name, i) {
  var power = i < 5 ? i + 1 : i;

  _insertEase(name + ",Power" + (power - 1), i ? function (p) {
    return Math.pow(p, power);
  } : function (p) {
    return p;
  }, function (p) {
    return 1 - Math.pow(1 - p, power);
  }, function (p) {
    return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
  });
});

_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;

_insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());

(function (n, c) {
  var n1 = 1 / c,
      n2 = 2 * n1,
      n3 = 2.5 * n1,
      easeOut = function easeOut(p) {
    return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;
  };

  _insertEase("Bounce", function (p) {
    return 1 - easeOut(1 - p);
  }, easeOut);
})(7.5625, 2.75);

_insertEase("Expo", function (p) {
  return p ? Math.pow(2, 10 * (p - 1)) : 0;
});

_insertEase("Circ", function (p) {
  return -(_sqrt(1 - p * p) - 1);
});

_insertEase("Sine", function (p) {
  return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;
});

_insertEase("Back", _configBack("in"), _configBack("out"), _configBack());

_easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
  config: function config(steps, immediateStart) {
    if (steps === void 0) {
      steps = 1;
    }

    var p1 = 1 / steps,
        p2 = steps + (immediateStart ? 0 : 1),
        p3 = immediateStart ? 1 : 0,
        max = 1 - _tinyNum;
    return function (p) {
      return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;
    };
  }
};
_defaults.ease = _easeMap["quad.out"];

_forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (name) {
  return _callbackNames += name + "," + name + "Params,";
});
/*
 * --------------------------------------------------------------------------------------
 * CACHE
 * --------------------------------------------------------------------------------------
 */


var GSCache = function GSCache(target, harness) {
  this.id = _gsID++;
  target._gsap = this;
  this.target = target;
  this.harness = harness;
  this.get = harness ? harness.get : _getProperty;
  this.set = harness ? harness.getSetter : _getSetter;
};
/*
 * --------------------------------------------------------------------------------------
 * ANIMATION
 * --------------------------------------------------------------------------------------
 */

var Animation = /*#__PURE__*/function () {
  function Animation(vars) {
    this.vars = vars;
    this._delay = +vars.delay || 0;

    if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
      // TODO: repeat: Infinity on a timeline's children must flag that timeline internally and affect its totalDuration, otherwise it'll stop in the negative direction when reaching the start.
      this._rDelay = vars.repeatDelay || 0;
      this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
    }

    this._ts = 1;

    _setDuration(this, +vars.duration, 1, 1);

    this.data = vars.data;
    _tickerActive || _ticker.wake();
  }

  var _proto = Animation.prototype;

  _proto.delay = function delay(value) {
    if (value || value === 0) {
      this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
      this._delay = value;
      return this;
    }

    return this._delay;
  };

  _proto.duration = function duration(value) {
    return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
  };

  _proto.totalDuration = function totalDuration(value) {
    if (!arguments.length) {
      return this._tDur;
    }

    this._dirty = 0;
    return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
  };

  _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
    _wake();

    if (!arguments.length) {
      return this._tTime;
    }

    var parent = this._dp;

    if (parent && parent.smoothChildTiming && this._ts) {
      _alignPlayhead(this, _totalTime);

      !parent._dp || parent.parent || _postAddChecks(parent, this); // edge case: if this is a child of a timeline that already completed, for example, we must re-activate the parent.
      //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The start of that child would get pushed out, but one of the ancestors may have completed.

      while (parent && parent.parent) {
        if (parent.parent._time !== parent._start + (parent._ts >= 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
          parent.totalTime(parent._tTime, true);
        }

        parent = parent.parent;
      }

      if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
        //if the animation doesn't have a parent, put it back into its last parent (recorded as _dp for exactly cases like this). Limit to parents with autoRemoveChildren (like globalTimeline) so that if the user manually removes an animation from a timeline and then alters its playhead, it doesn't get added back in.
        _addToTimeline(this._dp, this, this._start - this._delay);
      }
    }

    if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
      // check for _ptLookup on a Tween instance to ensure it has actually finished being instantiated, otherwise if this.reverse() gets called in the Animation constructor, it could trigger a render() here even though the _targets weren't populated, thus when _init() is called there won't be any PropTweens (it'll act like the tween is non-functional)
      this._ts || (this._pTime = _totalTime); // otherwise, if an animation is paused, then the playhead is moved back to zero, then resumed, it'd revert back to the original time at the pause
      //if (!this._lock) { // avoid endless recursion (not sure we need this yet or if it's worth the performance hit)
      //   this._lock = 1;

      _lazySafeRender(this, _totalTime, suppressEvents); //   this._lock = 0;
      //}

    }

    return this;
  };

  _proto.time = function time(value, suppressEvents) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time; // note: if the modulus results in 0, the playhead could be exactly at the end or the beginning, and we always defer to the END with a non-zero value, otherwise if you set the time() to the very end (duration()), it would render at the START!
  };

  _proto.totalProgress = function totalProgress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio;
  };

  _proto.progress = function progress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio;
  };

  _proto.iteration = function iteration(value, suppressEvents) {
    var cycleDuration = this.duration() + this._rDelay;

    return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
  } // potential future addition:
  // isPlayingBackwards() {
  // 	let animation = this,
  // 		orientation = 1; // 1 = forward, -1 = backward
  // 	while (animation) {
  // 		orientation *= animation.reversed() || (animation.repeat() && !(animation.iteration() & 1)) ? -1 : 1;
  // 		animation = animation.parent;
  // 	}
  // 	return orientation < 0;
  // }
  ;

  _proto.timeScale = function timeScale(value) {
    if (!arguments.length) {
      return this._rts === -_tinyNum ? 0 : this._rts; // recorded timeScale. Special case: if someone calls reverse() on an animation with timeScale of 0, we assign it -_tinyNum to remember it's reversed.
    }

    if (this._rts === value) {
      return this;
    }

    var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime; // make sure to do the parentToChildTotalTime() BEFORE setting the new _ts because the old one must be used in that calculation.
    // future addition? Up side: fast and minimal file size. Down side: only works on this animation; if a timeline is reversed, for example, its childrens' onReverse wouldn't get called.
    //(+value < 0 && this._rts >= 0) && _callback(this, "onReverse", true);
    // prioritize rendering where the parent's playhead lines up instead of this._tTime because there could be a tween that's animating another tween's timeScale in the same rendering loop (same parent), thus if the timeScale tween renders first, it would alter _start BEFORE _tTime was set on that tick (in the rendering loop), effectively freezing it until the timeScale tween finishes.

    this._rts = +value || 0;
    this._ts = this._ps || value === -_tinyNum ? 0 : this._rts; // _ts is the functional timeScale which would be 0 if the animation is paused.

    _recacheAncestors(this.totalTime(_clamp(-this._delay, this._tDur, tTime), true));

    _setEnd(this); // if parent.smoothChildTiming was false, the end time didn't get updated in the _alignPlayhead() method, so do it here.


    return this;
  };

  _proto.paused = function paused(value) {
    if (!arguments.length) {
      return this._ps;
    }

    if (this._ps !== value) {
      this._ps = value;

      if (value) {
        this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()); // if the pause occurs during the delay phase, make sure that's factored in when resuming.

        this._ts = this._act = 0; // _ts is the functional timeScale, so a paused tween would effectively have a timeScale of 0. We record the "real" timeScale as _rts (recorded time scale)
      } else {
        _wake();

        this._ts = this._rts; //only defer to _pTime (pauseTime) if tTime is zero. Remember, someone could pause() an animation, then scrub the playhead and resume(). If the parent doesn't have smoothChildTiming, we render at the rawTime() because the startTime won't get updated.

        this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum)); // edge case: animation.progress(1).pause().play() wouldn't render again because the playhead is already at the end, but the call to totalTime() below will add it back to its parent...and not remove it again (since removing only happens upon rendering at a new time). Offsetting the _tTime slightly is done simply to cause the final render in totalTime() that'll pop it off its timeline (if autoRemoveChildren is true, of course). Check to make sure _zTime isn't -_tinyNum to avoid an edge case where the playhead is pushed to the end but INSIDE a tween/callback, the timeline itself is paused thus halting rendering and leaving a few unrendered. When resuming, it wouldn't render those otherwise.
      }
    }

    return this;
  };

  _proto.startTime = function startTime(value) {
    if (arguments.length) {
      this._start = value;
      var parent = this.parent || this._dp;
      parent && (parent._sort || !this.parent) && _addToTimeline(parent, this, value - this._delay);
      return this;
    }

    return this._start;
  };

  _proto.endTime = function endTime(includeRepeats) {
    return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
  };

  _proto.rawTime = function rawTime(wrapRepeats) {
    var parent = this.parent || this._dp; // _dp = detached parent

    return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
  };

  _proto.globalTime = function globalTime(rawTime) {
    var animation = this,
        time = arguments.length ? rawTime : animation.rawTime();

    while (animation) {
      time = animation._start + time / (animation._ts || 1);
      animation = animation._dp;
    }

    return time;
  };

  _proto.repeat = function repeat(value) {
    if (arguments.length) {
      this._repeat = value === Infinity ? -2 : value;
      return _onUpdateTotalDuration(this);
    }

    return this._repeat === -2 ? Infinity : this._repeat;
  };

  _proto.repeatDelay = function repeatDelay(value) {
    if (arguments.length) {
      var time = this._time;
      this._rDelay = value;

      _onUpdateTotalDuration(this);

      return time ? this.time(time) : this;
    }

    return this._rDelay;
  };

  _proto.yoyo = function yoyo(value) {
    if (arguments.length) {
      this._yoyo = value;
      return this;
    }

    return this._yoyo;
  };

  _proto.seek = function seek(position, suppressEvents) {
    return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
  };

  _proto.restart = function restart(includeDelay, suppressEvents) {
    return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
  };

  _proto.play = function play(from, suppressEvents) {
    from != null && this.seek(from, suppressEvents);
    return this.reversed(false).paused(false);
  };

  _proto.reverse = function reverse(from, suppressEvents) {
    from != null && this.seek(from || this.totalDuration(), suppressEvents);
    return this.reversed(true).paused(false);
  };

  _proto.pause = function pause(atTime, suppressEvents) {
    atTime != null && this.seek(atTime, suppressEvents);
    return this.paused(true);
  };

  _proto.resume = function resume() {
    return this.paused(false);
  };

  _proto.reversed = function reversed(value) {
    if (arguments.length) {
      !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0)); // in case timeScale is zero, reversing would have no effect so we use _tinyNum.

      return this;
    }

    return this._rts < 0;
  };

  _proto.invalidate = function invalidate() {
    this._initted = this._act = 0;
    this._zTime = -_tinyNum;
    return this;
  };

  _proto.isActive = function isActive() {
    var parent = this.parent || this._dp,
        start = this._start,
        rawTime;
    return !!(!parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
  };

  _proto.eventCallback = function eventCallback(type, callback, params) {
    var vars = this.vars;

    if (arguments.length > 1) {
      if (!callback) {
        delete vars[type];
      } else {
        vars[type] = callback;
        params && (vars[type + "Params"] = params);
        type === "onUpdate" && (this._onUpdate = callback);
      }

      return this;
    }

    return vars[type];
  };

  _proto.then = function then(onFulfilled) {
    var self = this;
    return new Promise(function (resolve) {
      var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough,
          _resolve = function _resolve() {
        var _then = self.then;
        self.then = null; // temporarily null the then() method to avoid an infinite loop (see https://github.com/greensock/GSAP/issues/322)

        _isFunction(f) && (f = f(self)) && (f.then || f === self) && (self.then = _then);
        resolve(f);
        self.then = _then;
      };

      if (self._initted && self.totalProgress() === 1 && self._ts >= 0 || !self._tTime && self._ts < 0) {
        _resolve();
      } else {
        self._prom = _resolve;
      }
    });
  };

  _proto.kill = function kill() {
    _interrupt(this);
  };

  return Animation;
}();

_setDefaults(Animation.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: false,
  parent: null,
  _initted: false,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -_tinyNum,
  _prom: 0,
  _ps: false,
  _rts: 1
});
/*
 * -------------------------------------------------
 * TIMELINE
 * -------------------------------------------------
 */


var Timeline = /*#__PURE__*/function (_Animation) {
  _inheritsLoose(Timeline, _Animation);

  function Timeline(vars, position) {
    var _this;

    if (vars === void 0) {
      vars = {};
    }

    _this = _Animation.call(this, vars) || this;
    _this.labels = {};
    _this.smoothChildTiming = !!vars.smoothChildTiming;
    _this.autoRemoveChildren = !!vars.autoRemoveChildren;
    _this._sort = _isNotFalse(vars.sortChildren);
    _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
    vars.reversed && _this.reverse();
    vars.paused && _this.paused(true);
    vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
    return _this;
  }

  var _proto2 = Timeline.prototype;

  _proto2.to = function to(targets, vars, position) {
    _createTweenType(0, arguments, this);

    return this;
  };

  _proto2.from = function from(targets, vars, position) {
    _createTweenType(1, arguments, this);

    return this;
  };

  _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
    _createTweenType(2, arguments, this);

    return this;
  };

  _proto2.set = function set(targets, vars, position) {
    vars.duration = 0;
    vars.parent = this;
    _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
    vars.immediateRender = !!vars.immediateRender;
    new Tween(targets, vars, _parsePosition(this, position), 1);
    return this;
  };

  _proto2.call = function call(callback, params, position) {
    return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
  } //ONLY for backward compatibility! Maybe delete?
  ;

  _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.duration = duration;
    vars.stagger = vars.stagger || stagger;
    vars.onComplete = onCompleteAll;
    vars.onCompleteParams = onCompleteAllParams;
    vars.parent = this;
    new Tween(targets, vars, _parsePosition(this, position));
    return this;
  };

  _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.runBackwards = 1;
    _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
    return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
  };

  _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
    toVars.startAt = fromVars;
    _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
    return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
  };

  _proto2.render = function render(totalTime, suppressEvents, force) {
    var prevTime = this._time,
        tDur = this._dirty ? this.totalDuration() : this._tDur,
        dur = this._dur,
        tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime),
        // if a paused timeline is resumed (or its _start is updated for another reason...which rounds it), that could result in the playhead shifting a **tiny** amount and a zero-duration child at that spot may get rendered at a different ratio, like its totalTime in render() may be 1e-17 instead of 0, for example.
    crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur),
        time,
        child,
        next,
        iteration,
        cycleDuration,
        prevPaused,
        pauseTween,
        timeScale,
        prevStart,
        prevIteration,
        yoyo,
        isYoyo;
    this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);

    if (tTime !== this._tTime || force || crossingStart) {
      if (prevTime !== this._time && dur) {
        //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).
        tTime += this._time - prevTime;
        totalTime += this._time - prevTime;
      }

      time = tTime;
      prevStart = this._start;
      timeScale = this._ts;
      prevPaused = !timeScale;

      if (crossingStart) {
        dur || (prevTime = this._zTime); //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.

        (totalTime || !suppressEvents) && (this._zTime = totalTime);
      }

      if (this._repeat) {
        //adjust the time for repeats and yoyos
        yoyo = this._yoyo;
        cycleDuration = dur + this._rDelay;

        if (this._repeat < -1 && totalTime < 0) {
          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
        }

        time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

        if (tTime === tDur) {
          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
          iteration = this._repeat;
          time = dur;
        } else {
          iteration = ~~(tTime / cycleDuration);

          if (iteration && iteration === tTime / cycleDuration) {
            time = dur;
            iteration--;
          }

          time > dur && (time = dur);
        }

        prevIteration = _animationCycle(this._tTime, cycleDuration);
        !prevTime && this._tTime && prevIteration !== iteration && (prevIteration = iteration); // edge case - if someone does addPause() at the very beginning of a repeating timeline, that pause is technically at the same spot as the end which causes this._time to get set to 0 when the totalTime would normally place the playhead at the end. See https://greensock.com/forums/topic/23823-closing-nav-animation-not-working-on-ie-and-iphone-6-maybe-other-older-browser/?tab=comments#comment-113005

        if (yoyo && iteration & 1) {
          time = dur - time;
          isYoyo = 1;
        }
        /*
        make sure children at the end/beginning of the timeline are rendered properly. If, for example,
        a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
        would get translated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
        could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
        we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
        ensure that zero-duration tweens at the very beginning or end of the Timeline work.
        */


        if (iteration !== prevIteration && !this._lock) {
          var rewinding = yoyo && prevIteration & 1,
              doesWrap = rewinding === (yoyo && iteration & 1);
          iteration < prevIteration && (rewinding = !rewinding);
          prevTime = rewinding ? 0 : dur;
          this._lock = 1;
          this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
          this._tTime = tTime; // if a user gets the iteration() inside the onRepeat, for example, it should be accurate.

          !suppressEvents && this.parent && _callback(this, "onRepeat");
          this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);

          if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
            // if prevTime is 0 and we render at the very end, _time will be the end, thus won't match. So in this edge case, prevTime won't match _time but that's okay. If it gets killed in the onRepeat, eject as well.
            return this;
          }

          dur = this._dur; // in case the duration changed in the onRepeat

          tDur = this._tDur;

          if (doesWrap) {
            this._lock = 2;
            prevTime = rewinding ? dur : -0.0001;
            this.render(prevTime, true);
            this.vars.repeatRefresh && !isYoyo && this.invalidate();
          }

          this._lock = 0;

          if (!this._ts && !prevPaused) {
            return this;
          } //in order for yoyoEase to work properly when there's a stagger, we must swap out the ease in each sub-tween.


          _propagateYoyoEase(this, isYoyo);
        }
      }

      if (this._hasPause && !this._forcing && this._lock < 2) {
        pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));

        if (pauseTween) {
          tTime -= time - (time = pauseTween._start);
        }
      }

      this._tTime = tTime;
      this._time = time;
      this._act = !timeScale; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

      if (!this._initted) {
        this._onUpdate = this.vars.onUpdate;
        this._initted = 1;
        this._zTime = totalTime;
        prevTime = 0; // upon init, the playhead should always go forward; someone could invalidate() a completed timeline and then if they restart(), that would make child tweens render in reverse order which could lock in the wrong starting values if they build on each other, like tl.to(obj, {x: 100}).to(obj, {x: 0}).
      }

      if (!prevTime && time && !suppressEvents) {
        _callback(this, "onStart");

        if (this._tTime !== tTime) {
          // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
          return this;
        }
      }

      if (time >= prevTime && totalTime >= 0) {
        child = this._first;

        while (child) {
          next = child._next;

          if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
              return this.render(totalTime, suppressEvents, force);
            }

            child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);

            if (time !== this._time || !this._ts && !prevPaused) {
              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
              pauseTween = 0;
              next && (tTime += this._zTime = -_tinyNum); // it didn't finish rendering, so flag zTime as negative so that so that the next time render() is called it'll be forced (to render any remaining children)

              break;
            }
          }

          child = next;
        }
      } else {
        child = this._last;
        var adjustedTime = totalTime < 0 ? totalTime : time; //when the playhead goes backward beyond the start of this timeline, we must pass that information down to the child animations so that zero-duration tweens know whether to render their starting or ending values.

        while (child) {
          next = child._prev;

          if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
              return this.render(totalTime, suppressEvents, force);
            }

            child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force);

            if (time !== this._time || !this._ts && !prevPaused) {
              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
              pauseTween = 0;
              next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum); // it didn't finish rendering, so adjust zTime so that so that the next time render() is called it'll be forced (to render any remaining children)

              break;
            }
          }

          child = next;
        }
      }

      if (pauseTween && !suppressEvents) {
        this.pause();
        pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;

        if (this._ts) {
          //the callback resumed playback! So since we may have held back the playhead due to where the pause is positioned, go ahead and jump to where it's SUPPOSED to be (if no pause happened).
          this._start = prevStart; //if the pause was at an earlier time and the user resumed in the callback, it could reposition the timeline (changing its startTime), throwing things off slightly, so we make sure the _start doesn't shift.

          _setEnd(this);

          return this.render(totalTime, suppressEvents, force);
        }
      }

      this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
      if (tTime === tDur && tDur >= this.totalDuration() || !tTime && prevTime) if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) if (!this._lock) {
        (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
          _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);

          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
        }
      }
    }

    return this;
  };

  _proto2.add = function add(child, position) {
    var _this2 = this;

    _isNumber(position) || (position = _parsePosition(this, position, child));

    if (!(child instanceof Animation)) {
      if (_isArray(child)) {
        child.forEach(function (obj) {
          return _this2.add(obj, position);
        });
        return this;
      }

      if (_isString(child)) {
        return this.addLabel(child, position);
      }

      if (_isFunction(child)) {
        child = Tween.delayedCall(0, child);
      } else {
        return this;
      }
    }

    return this !== child ? _addToTimeline(this, child, position) : this; //don't allow a timeline to be added to itself as a child!
  };

  _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
    if (nested === void 0) {
      nested = true;
    }

    if (tweens === void 0) {
      tweens = true;
    }

    if (timelines === void 0) {
      timelines = true;
    }

    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = -_bigNum;
    }

    var a = [],
        child = this._first;

    while (child) {
      if (child._start >= ignoreBeforeTime) {
        if (child instanceof Tween) {
          tweens && a.push(child);
        } else {
          timelines && a.push(child);
          nested && a.push.apply(a, child.getChildren(true, tweens, timelines));
        }
      }

      child = child._next;
    }

    return a;
  };

  _proto2.getById = function getById(id) {
    var animations = this.getChildren(1, 1, 1),
        i = animations.length;

    while (i--) {
      if (animations[i].vars.id === id) {
        return animations[i];
      }
    }
  };

  _proto2.remove = function remove(child) {
    if (_isString(child)) {
      return this.removeLabel(child);
    }

    if (_isFunction(child)) {
      return this.killTweensOf(child);
    }

    _removeLinkedListItem(this, child);

    if (child === this._recent) {
      this._recent = this._last;
    }

    return _uncache(this);
  };

  _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
    if (!arguments.length) {
      return this._tTime;
    }

    this._forcing = 1;

    if (!this._dp && this._ts) {
      //special case for the global timeline (or any other that has no parent or detached parent).
      this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
    }

    _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);

    this._forcing = 0;
    return this;
  };

  _proto2.addLabel = function addLabel(label, position) {
    this.labels[label] = _parsePosition(this, position);
    return this;
  };

  _proto2.removeLabel = function removeLabel(label) {
    delete this.labels[label];
    return this;
  };

  _proto2.addPause = function addPause(position, callback, params) {
    var t = Tween.delayedCall(0, callback || _emptyFunc, params);
    t.data = "isPause";
    this._hasPause = 1;
    return _addToTimeline(this, t, _parsePosition(this, position));
  };

  _proto2.removePause = function removePause(position) {
    var child = this._first;
    position = _parsePosition(this, position);

    while (child) {
      if (child._start === position && child.data === "isPause") {
        _removeFromParent(child);
      }

      child = child._next;
    }
  };

  _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    var tweens = this.getTweensOf(targets, onlyActive),
        i = tweens.length;

    while (i--) {
      _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);
    }

    return this;
  };

  _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {
    var a = [],
        parsedTargets = toArray(targets),
        child = this._first,
        isGlobalTime = _isNumber(onlyActive),
        // a number is interpreted as a global time. If the animation spans
    children;

    while (child) {
      if (child instanceof Tween) {
        if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
          // note: if this is for overwriting, it should only be for tweens that aren't paused and are initted.
          a.push(child);
        }
      } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
        a.push.apply(a, children);
      }

      child = child._next;
    }

    return a;
  } // potential future feature - targets() on timelines
  // targets() {
  // 	let result = [];
  // 	this.getChildren(true, true, false).forEach(t => result.push(...t.targets()));
  // 	return result.filter((v, i) => result.indexOf(v) === i);
  // }
  ;

  _proto2.tweenTo = function tweenTo(position, vars) {
    vars = vars || {};

    var tl = this,
        endTime = _parsePosition(tl, position),
        _vars = vars,
        startAt = _vars.startAt,
        _onStart = _vars.onStart,
        onStartParams = _vars.onStartParams,
        immediateRender = _vars.immediateRender,
        initted,
        tween = Tween.to(tl, _setDefaults({
      ease: vars.ease || "none",
      lazy: false,
      immediateRender: false,
      time: endTime,
      overwrite: "auto",
      duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
      onStart: function onStart() {
        tl.pause();

        if (!initted) {
          var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
          tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
          initted = 1;
        }

        _onStart && _onStart.apply(tween, onStartParams || []); //in case the user had an onStart in the vars - we don't want to overwrite it.
      }
    }, vars));

    return immediateRender ? tween.render(0) : tween;
  };

  _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
    return this.tweenTo(toPosition, _setDefaults({
      startAt: {
        time: _parsePosition(this, fromPosition)
      }
    }, vars));
  };

  _proto2.recent = function recent() {
    return this._recent;
  };

  _proto2.nextLabel = function nextLabel(afterTime) {
    if (afterTime === void 0) {
      afterTime = this._time;
    }

    return _getLabelInDirection(this, _parsePosition(this, afterTime));
  };

  _proto2.previousLabel = function previousLabel(beforeTime) {
    if (beforeTime === void 0) {
      beforeTime = this._time;
    }

    return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
  };

  _proto2.currentLabel = function currentLabel(value) {
    return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
  };

  _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = 0;
    }

    var child = this._first,
        labels = this.labels,
        p;

    while (child) {
      if (child._start >= ignoreBeforeTime) {
        child._start += amount;
        child._end += amount;
      }

      child = child._next;
    }

    if (adjustLabels) {
      for (p in labels) {
        if (labels[p] >= ignoreBeforeTime) {
          labels[p] += amount;
        }
      }
    }

    return _uncache(this);
  };

  _proto2.invalidate = function invalidate() {
    var child = this._first;
    this._lock = 0;

    while (child) {
      child.invalidate();
      child = child._next;
    }

    return _Animation.prototype.invalidate.call(this);
  };

  _proto2.clear = function clear(includeLabels) {
    if (includeLabels === void 0) {
      includeLabels = true;
    }

    var child = this._first,
        next;

    while (child) {
      next = child._next;
      this.remove(child);
      child = next;
    }

    this._dp && (this._time = this._tTime = this._pTime = 0);
    includeLabels && (this.labels = {});
    return _uncache(this);
  };

  _proto2.totalDuration = function totalDuration(value) {
    var max = 0,
        self = this,
        child = self._last,
        prevStart = _bigNum,
        prev,
        start,
        parent;

    if (arguments.length) {
      return self.timeScale((self._repeat < 0 ? self.duration() : self.totalDuration()) / (self.reversed() ? -value : value));
    }

    if (self._dirty) {
      parent = self.parent;

      while (child) {
        prev = child._prev; //record it here in case the tween changes position in the sequence...

        child._dirty && child.totalDuration(); //could change the tween._startTime, so make sure the animation's cache is clean before analyzing it.

        start = child._start;

        if (start > prevStart && self._sort && child._ts && !self._lock) {
          //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
          self._lock = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add().

          _addToTimeline(self, child, start - child._delay, 1)._lock = 0;
        } else {
          prevStart = start;
        }

        if (start < 0 && child._ts) {
          //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
          max -= start;

          if (!parent && !self._dp || parent && parent.smoothChildTiming) {
            self._start += start / self._ts;
            self._time -= start;
            self._tTime -= start;
          }

          self.shiftChildren(-start, false, -1e999);
          prevStart = 0;
        }

        child._end > max && child._ts && (max = child._end);
        child = prev;
      }

      _setDuration(self, self === _globalTimeline && self._time > max ? self._time : max, 1, 1);

      self._dirty = 0;
    }

    return self._tDur;
  };

  Timeline.updateRoot = function updateRoot(time) {
    if (_globalTimeline._ts) {
      _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));

      _lastRenderedFrame = _ticker.frame;
    }

    if (_ticker.frame >= _nextGCFrame) {
      _nextGCFrame += _config.autoSleep || 120;
      var child = _globalTimeline._first;
      if (!child || !child._ts) if (_config.autoSleep && _ticker._listeners.length < 2) {
        while (child && !child._ts) {
          child = child._next;
        }

        child || _ticker.sleep();
      }
    }
  };

  return Timeline;
}(Animation);

_setDefaults(Timeline.prototype, {
  _lock: 0,
  _hasPause: 0,
  _forcing: 0
});

var _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {
  //note: we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
  var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),
      index = 0,
      matchIndex = 0,
      result,
      startNums,
      color,
      endNum,
      chunk,
      startNum,
      hasRandom,
      a;
  pt.b = start;
  pt.e = end;
  start += ""; //ensure values are strings

  end += "";

  if (hasRandom = ~end.indexOf("random(")) {
    end = _replaceRandom(end);
  }

  if (stringFilter) {
    a = [start, end];
    stringFilter(a, target, prop); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.

    start = a[0];
    end = a[1];
  }

  startNums = start.match(_complexStringNumExp) || [];

  while (result = _complexStringNumExp.exec(end)) {
    endNum = result[0];
    chunk = end.substring(index, result.index);

    if (color) {
      color = (color + 1) % 5;
    } else if (chunk.substr(-5) === "rgba(") {
      color = 1;
    }

    if (endNum !== startNums[matchIndex++]) {
      startNum = parseFloat(startNums[matchIndex - 1]) || 0; //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.

      pt._pt = {
        _next: pt._pt,
        p: chunk || matchIndex === 1 ? chunk : ",",
        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
        s: startNum,
        c: endNum.charAt(1) === "=" ? parseFloat(endNum.substr(2)) * (endNum.charAt(0) === "-" ? -1 : 1) : parseFloat(endNum) - startNum,
        m: color && color < 4 ? Math.round : 0
      };
      index = _complexStringNumExp.lastIndex;
    }
  }

  pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)

  pt.fp = funcParam;

  if (_relExp.test(end) || hasRandom) {
    pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
  }

  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.

  return pt;
},
    _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam) {
  _isFunction(end) && (end = end(index || 0, target, targets));
  var currentValue = target[prop],
      parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](),
      setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,
      pt;

  if (_isString(end)) {
    if (~end.indexOf("random(")) {
      end = _replaceRandom(end);
    }

    if (end.charAt(1) === "=") {
      pt = parseFloat(parsedStart) + parseFloat(end.substr(2)) * (end.charAt(0) === "-" ? -1 : 1) + (getUnit(parsedStart) || 0);

      if (pt || pt === 0) {
        // to avoid isNaN, like if someone passes in a value like "!= whatever"
        end = pt;
      }
    }
  }

  if (parsedStart !== end) {
    if (!isNaN(parsedStart * end) && end !== "") {
      // fun fact: any number multiplied by "" is evaluated as the number 0!
      pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
      funcParam && (pt.fp = funcParam);
      modifier && pt.modifier(modifier, this, target);
      return this._pt = pt;
    }

    !currentValue && !(prop in target) && _missingPlugin(prop, end);
    return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
  }
},
    //creates a copy of the vars object and processes any function-based values (putting the resulting values directly into the copy) as well as strings with "random()" in them. It does NOT process relative values.
_processVars = function _processVars(vars, index, target, targets, tween) {
  _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));

  if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
    return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
  }

  var copy = {},
      p;

  for (p in vars) {
    copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
  }

  return copy;
},
    _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {
  var plugin, pt, ptLookup, i;

  if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
    tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);

    if (tween !== _quickTween) {
      ptLookup = tween._ptLookup[tween._targets.indexOf(target)]; //note: we can't use tween._ptLookup[index] because for staggered tweens, the index from the fullTargets array won't match what it is in each individual tween that spawns from the stagger.

      i = plugin._props.length;

      while (i--) {
        ptLookup[plugin._props[i]] = pt;
      }
    }
  }

  return plugin;
},
    _overwritingTween,
    //store a reference temporarily so we can avoid overwriting itself.
_initTween = function _initTween(tween, time) {
  var vars = tween.vars,
      ease = vars.ease,
      startAt = vars.startAt,
      immediateRender = vars.immediateRender,
      lazy = vars.lazy,
      onUpdate = vars.onUpdate,
      onUpdateParams = vars.onUpdateParams,
      callbackScope = vars.callbackScope,
      runBackwards = vars.runBackwards,
      yoyoEase = vars.yoyoEase,
      keyframes = vars.keyframes,
      autoRevert = vars.autoRevert,
      dur = tween._dur,
      prevStartAt = tween._startAt,
      targets = tween._targets,
      parent = tween.parent,
      fullTargets = parent && parent.data === "nested" ? parent.parent._targets : targets,
      autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites,
      tl = tween.timeline,
      cleanVars,
      i,
      p,
      pt,
      target,
      hasPriority,
      gsData,
      harness,
      plugin,
      ptLookup,
      index,
      harnessVars,
      overwritten;
  tl && (!keyframes || !ease) && (ease = "none");
  tween._ease = _parseEase(ease, _defaults.ease);
  tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;

  if (yoyoEase && tween._yoyo && !tween._repeat) {
    //there must have been a parent timeline with yoyo:true that is currently in its yoyo phase, so flip the eases.
    yoyoEase = tween._yEase;
    tween._yEase = tween._ease;
    tween._ease = yoyoEase;
  }

  tween._from = !tl && !!vars.runBackwards; //nested timelines should never run backwards - the backwards-ness is in the child tweens.

  if (!tl || keyframes && !vars.stagger) {
    //if there's an internal timeline, skip all the parsing because we passed that task down the chain.
    harness = targets[0] ? _getCache(targets[0]).harness : 0;
    harnessVars = harness && vars[harness.prop]; //someone may need to specify CSS-specific values AND non-CSS values, like if the element has an "x" property plus it's a standard DOM element. We allow people to distinguish by wrapping plugin-specific stuff in a css:{} object for example.

    cleanVars = _copyExcluding(vars, _reservedProps);
    prevStartAt && _removeFromParent(prevStartAt.render(-1, true));

    if (startAt) {
      _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
        data: "isStart",
        overwrite: false,
        parent: parent,
        immediateRender: true,
        lazy: _isNotFalse(lazy),
        startAt: null,
        delay: 0,
        onUpdate: onUpdate,
        onUpdateParams: onUpdateParams,
        callbackScope: callbackScope,
        stagger: 0
      }, startAt))); //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, from, to).fromTo(e, to, from);


      time < 0 && !immediateRender && !autoRevert && tween._startAt.render(-1, true); // rare edge case, like if a render is forced in the negative direction of a non-initted tween.

      if (immediateRender) {
        time > 0 && !autoRevert && (tween._startAt = 0); //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in Timeline instances where immediateRender was false or when autoRevert is explicitly set to true.

        if (dur && time <= 0) {
          time && (tween._zTime = time);
          return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
        } // if (time > 0) {
        // 	autoRevert || (tween._startAt = 0); //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in Timeline instances where immediateRender was false or when autoRevert is explicitly set to true.
        // } else if (dur && !(time < 0 && prevStartAt)) {
        // 	time && (tween._zTime = time);
        // 	return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
        // }

      } else if (autoRevert === false) {
        tween._startAt = 0;
      }
    } else if (runBackwards && dur) {
      //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
      if (prevStartAt) {
        !autoRevert && (tween._startAt = 0);
      } else {
        time && (immediateRender = false); //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0

        p = _setDefaults({
          overwrite: false,
          data: "isFromStart",
          //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
          lazy: immediateRender && _isNotFalse(lazy),
          immediateRender: immediateRender,
          //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
          stagger: 0,
          parent: parent //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y:gsap.utils.wrap([-100,100])})

        }, cleanVars);
        harnessVars && (p[harness.prop] = harnessVars); // in case someone does something like .from(..., {css:{}})

        _removeFromParent(tween._startAt = Tween.set(targets, p));

        time < 0 && tween._startAt.render(-1, true); // rare edge case, like if a render is forced in the negative direction of a non-initted from() tween.

        tween._zTime = time;

        if (!immediateRender) {
          _initTween(tween._startAt, _tinyNum); //ensures that the initial values are recorded

        } else if (!time) {
          return;
        }
      }
    }

    tween._pt = 0;
    lazy = dur && _isNotFalse(lazy) || lazy && !dur;

    for (i = 0; i < targets.length; i++) {
      target = targets[i];
      gsData = target._gsap || _harness(targets)[i]._gsap;
      tween._ptLookup[i] = ptLookup = {};
      _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)

      index = fullTargets === targets ? i : fullTargets.indexOf(target);

      if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
        tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);

        plugin._props.forEach(function (name) {
          ptLookup[name] = pt;
        });

        plugin.priority && (hasPriority = 1);
      }

      if (!harness || harnessVars) {
        for (p in cleanVars) {
          if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {
            plugin.priority && (hasPriority = 1);
          } else {
            ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
          }
        }
      }

      tween._op && tween._op[i] && tween.kill(target, tween._op[i]);

      if (autoOverwrite && tween._pt) {
        _overwritingTween = tween;

        _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time)); // make sure the overwriting doesn't overwrite THIS tween!!!


        overwritten = !tween.parent;
        _overwritingTween = 0;
      }

      tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
    }

    hasPriority && _sortPropTweensByPriority(tween);
    tween._onInit && tween._onInit(tween); //plugins like RoundProps must wait until ALL of the PropTweens are instantiated. In the plugin's init() function, it sets the _onInit on the tween instance. May not be pretty/intuitive, but it's fast and keeps file size down.
  }

  tween._onUpdate = onUpdate;
  tween._initted = (!tween._op || tween._pt) && !overwritten; // if overwrittenProps resulted in the entire tween being killed, do NOT flag it as initted or else it may render for one tick.

  keyframes && time <= 0 && tl.render(_bigNum, true, true); // if there's a 0% keyframe, it'll render in the "before" state for any staggered/delayed animations thus when the following tween initializes, it'll use the "before" state instead of the "after" state as the initial values.
},
    _addAliasesToVars = function _addAliasesToVars(targets, vars) {
  var harness = targets[0] ? _getCache(targets[0]).harness : 0,
      propertyAliases = harness && harness.aliases,
      copy,
      p,
      i,
      aliases;

  if (!propertyAliases) {
    return vars;
  }

  copy = _merge({}, vars);

  for (p in propertyAliases) {
    if (p in copy) {
      aliases = propertyAliases[p].split(",");
      i = aliases.length;

      while (i--) {
        copy[aliases[i]] = copy[p];
      }
    }
  }

  return copy;
},
    // parses multiple formats, like {"0%": {x: 100}, {"50%": {x: -20}} and { x: {"0%": 100, "50%": -20} }, and an "ease" can be set on any object. We populate an "allProps" object with an Array for each property, like {x: [{}, {}], y:[{}, {}]} with data for each property tween. The objects have a "t" (time), "v", (value), and "e" (ease) property. This allows us to piece together a timeline later.
_parseKeyframe = function _parseKeyframe(prop, obj, allProps, easeEach) {
  var ease = obj.ease || easeEach || "power1.inOut",
      p,
      a;

  if (_isArray(obj)) {
    a = allProps[prop] || (allProps[prop] = []); // t = time (out of 100), v = value, e = ease

    obj.forEach(function (value, i) {
      return a.push({
        t: i / (obj.length - 1) * 100,
        v: value,
        e: ease
      });
    });
  } else {
    for (p in obj) {
      a = allProps[p] || (allProps[p] = []);
      p === "ease" || a.push({
        t: parseFloat(prop),
        v: obj[p],
        e: ease
      });
    }
  }
},
    _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {
  return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
},
    _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
    _staggerPropsToSkip = {};

_forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function (name) {
  return _staggerPropsToSkip[name] = 1;
});
/*
 * --------------------------------------------------------------------------------------
 * TWEEN
 * --------------------------------------------------------------------------------------
 */


var Tween = /*#__PURE__*/function (_Animation2) {
  _inheritsLoose(Tween, _Animation2);

  function Tween(targets, vars, position, skipInherit) {
    var _this3;

    if (typeof vars === "number") {
      position.duration = vars;
      vars = position;
      position = null;
    }

    _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
    var _this3$vars = _this3.vars,
        duration = _this3$vars.duration,
        delay = _this3$vars.delay,
        immediateRender = _this3$vars.immediateRender,
        stagger = _this3$vars.stagger,
        overwrite = _this3$vars.overwrite,
        keyframes = _this3$vars.keyframes,
        defaults = _this3$vars.defaults,
        scrollTrigger = _this3$vars.scrollTrigger,
        yoyoEase = _this3$vars.yoyoEase,
        parent = vars.parent || _globalTimeline,
        parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets),
        tl,
        i,
        copy,
        l,
        p,
        curTarget,
        staggerFunc,
        staggerVarsToMerge;
    _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://greensock.com", !_config.nullTargetWarn) || [];
    _this3._ptLookup = []; //PropTween lookup. An array containing an object for each target, having keys for each tweening property

    _this3._overwrite = overwrite;

    if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
      vars = _this3.vars;
      tl = _this3.timeline = new Timeline({
        data: "nested",
        defaults: defaults || {}
      });
      tl.kill();
      tl.parent = tl._dp = _assertThisInitialized(_this3);
      tl._start = 0;

      if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
        l = parsedTargets.length;
        staggerFunc = stagger && distribute(stagger);

        if (_isObject(stagger)) {
          //users can pass in callbacks like onStart/onComplete in the stagger object. These should fire with each individual tween.
          for (p in stagger) {
            if (~_staggerTweenProps.indexOf(p)) {
              staggerVarsToMerge || (staggerVarsToMerge = {});
              staggerVarsToMerge[p] = stagger[p];
            }
          }
        }

        for (i = 0; i < l; i++) {
          copy = _copyExcluding(vars, _staggerPropsToSkip);
          copy.stagger = 0;
          yoyoEase && (copy.yoyoEase = yoyoEase);
          staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
          curTarget = parsedTargets[i]; //don't just copy duration or delay because if they're a string or function, we'd end up in an infinite loop because _isFuncOrString() would evaluate as true in the child tweens, entering this loop, etc. So we parse the value straight from vars and default to 0.

          copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);
          copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;

          if (!stagger && l === 1 && copy.delay) {
            // if someone does delay:"random(1, 5)", repeat:-1, for example, the delay shouldn't be inside the repeat.
            _this3._delay = delay = copy.delay;
            _this3._start += delay;
            copy.delay = 0;
          }

          tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);
          tl._ease = _easeMap.none;
        }

        tl.duration() ? duration = delay = 0 : _this3.timeline = 0; // if the timeline's duration is 0, we don't need a timeline internally!
      } else if (keyframes) {
        _inheritDefaults(_setDefaults(tl.vars.defaults, {
          ease: "none"
        }));

        tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
        var time = 0,
            a,
            kf,
            v;

        if (_isArray(keyframes)) {
          keyframes.forEach(function (frame) {
            return tl.to(parsedTargets, frame, ">");
          });
        } else {
          copy = {};

          for (p in keyframes) {
            p === "ease" || p === "easeEach" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);
          }

          for (p in copy) {
            a = copy[p].sort(function (a, b) {
              return a.t - b.t;
            });
            time = 0;

            for (i = 0; i < a.length; i++) {
              kf = a[i];
              v = {
                ease: kf.e,
                duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration
              };
              v[p] = kf.v;
              tl.to(parsedTargets, v, time);
              time += v.duration;
            }
          }

          tl.duration() < duration && tl.to({}, {
            duration: duration - tl.duration()
          }); // in case keyframes didn't go to 100%
        }
      }

      duration || _this3.duration(duration = tl.duration());
    } else {
      _this3.timeline = 0; //speed optimization, faster lookups (no going up the prototype chain)
    }

    if (overwrite === true && !_suppressOverwrites) {
      _overwritingTween = _assertThisInitialized(_this3);

      _globalTimeline.killTweensOf(parsedTargets);

      _overwritingTween = 0;
    }

    _addToTimeline(parent, _assertThisInitialized(_this3), position);

    vars.reversed && _this3.reverse();
    vars.paused && _this3.paused(true);

    if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent.data !== "nested") {
      _this3._tTime = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)

      _this3.render(Math.max(0, -delay)); //in case delay is negative

    }

    scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
    return _this3;
  }

  var _proto3 = Tween.prototype;

  _proto3.render = function render(totalTime, suppressEvents, force) {
    var prevTime = this._time,
        tDur = this._tDur,
        dur = this._dur,
        tTime = totalTime > tDur - _tinyNum && totalTime >= 0 ? tDur : totalTime < _tinyNum ? 0 : totalTime,
        time,
        pt,
        iteration,
        cycleDuration,
        prevIteration,
        isYoyo,
        ratio,
        timeline,
        yoyoEase;

    if (!dur) {
      _renderZeroDurationTween(this, totalTime, suppressEvents, force);
    } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== totalTime < 0) {
      //this senses if we're crossing over the start time, in which case we must record _zTime and force the render, but we do it in this lengthy conditional way for performance reasons (usually we can skip the calculations): this._initted && (this._zTime < 0) !== (totalTime < 0)
      time = tTime;
      timeline = this.timeline;

      if (this._repeat) {
        //adjust the time for repeats and yoyos
        cycleDuration = dur + this._rDelay;

        if (this._repeat < -1 && totalTime < 0) {
          return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
        }

        time = _roundPrecise(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

        if (tTime === tDur) {
          // the tDur === tTime is for edge cases where there's a lengthy decimal on the duration and it may reach the very end but the time is rendered as not-quite-there (remember, tDur is rounded to 4 decimals whereas dur isn't)
          iteration = this._repeat;
          time = dur;
        } else {
          iteration = ~~(tTime / cycleDuration);

          if (iteration && iteration === tTime / cycleDuration) {
            time = dur;
            iteration--;
          }

          time > dur && (time = dur);
        }

        isYoyo = this._yoyo && iteration & 1;

        if (isYoyo) {
          yoyoEase = this._yEase;
          time = dur - time;
        }

        prevIteration = _animationCycle(this._tTime, cycleDuration);

        if (time === prevTime && !force && this._initted) {
          //could be during the repeatDelay part. No need to render and fire callbacks.
          return this;
        }

        if (iteration !== prevIteration) {
          timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo); //repeatRefresh functionality

          if (this.vars.repeatRefresh && !isYoyo && !this._lock) {
            this._lock = force = 1; //force, otherwise if lazy is true, the _attemptInitTween() will return and we'll jump out and get caught bouncing on each tick.

            this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
          }
        }
      }

      if (!this._initted) {
        if (_attemptInitTween(this, totalTime < 0 ? totalTime : time, force, suppressEvents)) {
          this._tTime = 0; // in constructor if immediateRender is true, we set _tTime to -_tinyNum to have the playhead cross the starting point but we can't leave _tTime as a negative number.

          return this;
        }

        if (dur !== this._dur) {
          // while initting, a plugin like InertiaPlugin might alter the duration, so rerun from the start to ensure everything renders as it should.
          return this.render(totalTime, suppressEvents, force);
        }
      }

      this._tTime = tTime;
      this._time = time;

      if (!this._act && this._ts) {
        this._act = 1; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

        this._lazy = 0;
      }

      this.ratio = ratio = (yoyoEase || this._ease)(time / dur);

      if (this._from) {
        this.ratio = ratio = 1 - ratio;
      }

      if (time && !prevTime && !suppressEvents) {
        _callback(this, "onStart");

        if (this._tTime !== tTime) {
          // in case the onStart triggered a render at a different spot, eject. Like if someone did animation.pause(0.5) or something inside the onStart.
          return this;
        }
      }

      pt = this._pt;

      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }

      timeline && timeline.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline._dur * timeline._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);

      if (this._onUpdate && !suppressEvents) {
        totalTime < 0 && this._startAt && this._startAt.render(totalTime, true, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.

        _callback(this, "onUpdate");
      }

      this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");

      if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
        totalTime < 0 && this._startAt && !this._onUpdate && this._startAt.render(totalTime, true, true);
        (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1); // don't remove if we're rendering at exactly a time of 0, as there could be autoRevert values that should get set on the next tick (if the playhead goes backward beyond the startTime, negative totalTime). Don't remove if the timeline is reversed and the playhead isn't at 0, otherwise tl.progress(1).reverse() won't work. Only remove if the playhead is at the end and timeScale is positive, or if the playhead is at 0 and the timeScale is negative.

        if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime)) {
          // if prevTime and tTime are zero, we shouldn't fire the onReverseComplete. This could happen if you gsap.to(... {paused:true}).play();
          _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);

          this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
        }
      }
    }

    return this;
  };

  _proto3.targets = function targets() {
    return this._targets;
  };

  _proto3.invalidate = function invalidate() {
    this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0;
    this._ptLookup = [];
    this.timeline && this.timeline.invalidate();
    return _Animation2.prototype.invalidate.call(this);
  };

  _proto3.kill = function kill(targets, vars) {
    if (vars === void 0) {
      vars = "all";
    }

    if (!targets && (!vars || vars === "all")) {
      this._lazy = this._pt = 0;
      return this.parent ? _interrupt(this) : this;
    }

    if (this.timeline) {
      var tDur = this.timeline.totalDuration();
      this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this); // if nothing is left tweening, interrupt.

      this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1); // if a nested tween is killed that changes the duration, it should affect this tween's duration. We must use the ratio, though, because sometimes the internal timeline is stretched like for keyframes where they don't all add up to whatever the parent tween's duration was set to.

      return this;
    }

    var parsedTargets = this._targets,
        killingTargets = targets ? toArray(targets) : parsedTargets,
        propTweenLookup = this._ptLookup,
        firstPT = this._pt,
        overwrittenProps,
        curLookup,
        curOverwriteProps,
        props,
        p,
        pt,
        i;

    if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
      vars === "all" && (this._pt = 0);
      return _interrupt(this);
    }

    overwrittenProps = this._op = this._op || [];

    if (vars !== "all") {
      //so people can pass in a comma-delimited list of property names
      if (_isString(vars)) {
        p = {};

        _forEachName(vars, function (name) {
          return p[name] = 1;
        });

        vars = p;
      }

      vars = _addAliasesToVars(parsedTargets, vars);
    }

    i = parsedTargets.length;

    while (i--) {
      if (~killingTargets.indexOf(parsedTargets[i])) {
        curLookup = propTweenLookup[i];

        if (vars === "all") {
          overwrittenProps[i] = vars;
          props = curLookup;
          curOverwriteProps = {};
        } else {
          curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
          props = vars;
        }

        for (p in props) {
          pt = curLookup && curLookup[p];

          if (pt) {
            if (!("kill" in pt.d) || pt.d.kill(p) === true) {
              _removeLinkedListItem(this, pt, "_pt");
            }

            delete curLookup[p];
          }

          if (curOverwriteProps !== "all") {
            curOverwriteProps[p] = 1;
          }
        }
      }
    }

    this._initted && !this._pt && firstPT && _interrupt(this); //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.

    return this;
  };

  Tween.to = function to(targets, vars) {
    return new Tween(targets, vars, arguments[2]);
  };

  Tween.from = function from(targets, vars) {
    return _createTweenType(1, arguments);
  };

  Tween.delayedCall = function delayedCall(delay, callback, params, scope) {
    return new Tween(callback, 0, {
      immediateRender: false,
      lazy: false,
      overwrite: false,
      delay: delay,
      onComplete: callback,
      onReverseComplete: callback,
      onCompleteParams: params,
      onReverseCompleteParams: params,
      callbackScope: scope
    });
  };

  Tween.fromTo = function fromTo(targets, fromVars, toVars) {
    return _createTweenType(2, arguments);
  };

  Tween.set = function set(targets, vars) {
    vars.duration = 0;
    vars.repeatDelay || (vars.repeat = 0);
    return new Tween(targets, vars);
  };

  Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    return _globalTimeline.killTweensOf(targets, props, onlyActive);
  };

  return Tween;
}(Animation);

_setDefaults(Tween.prototype, {
  _targets: [],
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0
}); //add the pertinent timeline methods to Tween instances so that users can chain conveniently and create a timeline automatically. (removed due to concerns that it'd ultimately add to more confusion especially for beginners)
// _forEachName("to,from,fromTo,set,call,add,addLabel,addPause", name => {
// 	Tween.prototype[name] = function() {
// 		let tl = new Timeline();
// 		return _addToTimeline(tl, this)[name].apply(tl, toArray(arguments));
// 	}
// });
//for backward compatibility. Leverage the timeline calls.


_forEachName("staggerTo,staggerFrom,staggerFromTo", function (name) {
  Tween[name] = function () {
    var tl = new Timeline(),
        params = _slice.call(arguments, 0);

    params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
    return tl[name].apply(tl, params);
  };
});
/*
 * --------------------------------------------------------------------------------------
 * PROPTWEEN
 * --------------------------------------------------------------------------------------
 */


var _setterPlain = function _setterPlain(target, property, value) {
  return target[property] = value;
},
    _setterFunc = function _setterFunc(target, property, value) {
  return target[property](value);
},
    _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {
  return target[property](data.fp, value);
},
    _setterAttribute = function _setterAttribute(target, property, value) {
  return target.setAttribute(property, value);
},
    _getSetter = function _getSetter(target, property) {
  return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
},
    _renderPlain = function _renderPlain(ratio, data) {
  return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1000000) / 1000000, data);
},
    _renderBoolean = function _renderBoolean(ratio, data) {
  return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
},
    _renderComplexString = function _renderComplexString(ratio, data) {
  var pt = data._pt,
      s = "";

  if (!ratio && data.b) {
    //b = beginning string
    s = data.b;
  } else if (ratio === 1 && data.e) {
    //e = ending string
    s = data.e;
  } else {
    while (pt) {
      s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 10000) / 10000) + s; //we use the "p" property for the text inbetween (like a suffix). And in the context of a complex string, the modifier (m) is typically just Math.round(), like for RGB colors.

      pt = pt._next;
    }

    s += data.c; //we use the "c" of the PropTween to store the final chunk of non-numeric text.
  }

  data.set(data.t, data.p, s, data);
},
    _renderPropTweens = function _renderPropTweens(ratio, data) {
  var pt = data._pt;

  while (pt) {
    pt.r(ratio, pt.d);
    pt = pt._next;
  }
},
    _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {
  var pt = this._pt,
      next;

  while (pt) {
    next = pt._next;
    pt.p === property && pt.modifier(modifier, tween, target);
    pt = next;
  }
},
    _killPropTweensOf = function _killPropTweensOf(property) {
  var pt = this._pt,
      hasNonDependentRemaining,
      next;

  while (pt) {
    next = pt._next;

    if (pt.p === property && !pt.op || pt.op === property) {
      _removeLinkedListItem(this, pt, "_pt");
    } else if (!pt.dep) {
      hasNonDependentRemaining = 1;
    }

    pt = next;
  }

  return !hasNonDependentRemaining;
},
    _setterWithModifier = function _setterWithModifier(target, property, value, data) {
  data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
},
    _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {
  var pt = parent._pt,
      next,
      pt2,
      first,
      last; //sorts the PropTween linked list in order of priority because some plugins need to do their work after ALL of the PropTweens were created (like RoundPropsPlugin and ModifiersPlugin)

  while (pt) {
    next = pt._next;
    pt2 = first;

    while (pt2 && pt2.pr > pt.pr) {
      pt2 = pt2._next;
    }

    if (pt._prev = pt2 ? pt2._prev : last) {
      pt._prev._next = pt;
    } else {
      first = pt;
    }

    if (pt._next = pt2) {
      pt2._prev = pt;
    } else {
      last = pt;
    }

    pt = next;
  }

  parent._pt = first;
}; //PropTween key: t = target, p = prop, r = renderer, d = data, s = start, c = change, op = overwriteProperty (ONLY populated when it's different than p), pr = priority, _next/_prev for the linked list siblings, set = setter, m = modifier, mSet = modifierSetter (the original setter, before a modifier was added)


var PropTween = /*#__PURE__*/function () {
  function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {
    this.t = target;
    this.s = start;
    this.c = change;
    this.p = prop;
    this.r = renderer || _renderPlain;
    this.d = data || this;
    this.set = setter || _setterPlain;
    this.pr = priority || 0;
    this._next = next;

    if (next) {
      next._prev = this;
    }
  }

  var _proto4 = PropTween.prototype;

  _proto4.modifier = function modifier(func, tween, target) {
    this.mSet = this.mSet || this.set; //in case it was already set (a PropTween can only have one modifier)

    this.set = _setterWithModifier;
    this.m = func;
    this.mt = target; //modifier target

    this.tween = tween;
  };

  return PropTween;
}(); //Initialization tasks

_forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (name) {
  return _reservedProps[name] = 1;
});

_globals.TweenMax = _globals.TweenLite = Tween;
_globals.TimelineLite = _globals.TimelineMax = Timeline;
_globalTimeline = new Timeline({
  sortChildren: false,
  defaults: _defaults,
  autoRemoveChildren: true,
  id: "root",
  smoothChildTiming: true
});
_config.stringFilter = _colorStringFilter;
/*
 * --------------------------------------------------------------------------------------
 * GSAP
 * --------------------------------------------------------------------------------------
 */

var _gsap = {
  registerPlugin: function registerPlugin() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    args.forEach(function (config) {
      return _createPlugin(config);
    });
  },
  timeline: function timeline(vars) {
    return new Timeline(vars);
  },
  getTweensOf: function getTweensOf(targets, onlyActive) {
    return _globalTimeline.getTweensOf(targets, onlyActive);
  },
  getProperty: function getProperty(target, property, unit, uncache) {
    _isString(target) && (target = toArray(target)[0]); //in case selector text or an array is passed in

    var getter = _getCache(target || {}).get,
        format = unit ? _passThrough : _numericIfPossible;

    unit === "native" && (unit = "");
    return !target ? target : !property ? function (property, unit, uncache) {
      return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
    } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
  },
  quickSetter: function quickSetter(target, property, unit) {
    target = toArray(target);

    if (target.length > 1) {
      var setters = target.map(function (t) {
        return gsap.quickSetter(t, property, unit);
      }),
          l = setters.length;
      return function (value) {
        var i = l;

        while (i--) {
          setters[i](value);
        }
      };
    }

    target = target[0] || {};

    var Plugin = _plugins[property],
        cache = _getCache(target),
        p = cache.harness && (cache.harness.aliases || {})[property] || property,
        // in case it's an alias, like "rotate" for "rotation".
    setter = Plugin ? function (value) {
      var p = new Plugin();
      _quickTween._pt = 0;
      p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
      p.render(1, p);
      _quickTween._pt && _renderPropTweens(1, _quickTween);
    } : cache.set(target, p);

    return Plugin ? setter : function (value) {
      return setter(target, p, unit ? value + unit : value, cache, 1);
    };
  },
  isTweening: function isTweening(targets) {
    return _globalTimeline.getTweensOf(targets, true).length > 0;
  },
  defaults: function defaults(value) {
    value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
    return _mergeDeep(_defaults, value || {});
  },
  config: function config(value) {
    return _mergeDeep(_config, value || {});
  },
  registerEffect: function registerEffect(_ref3) {
    var name = _ref3.name,
        effect = _ref3.effect,
        plugins = _ref3.plugins,
        defaults = _ref3.defaults,
        extendTimeline = _ref3.extendTimeline;
    (plugins || "").split(",").forEach(function (pluginName) {
      return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
    });

    _effects[name] = function (targets, vars, tl) {
      return effect(toArray(targets), _setDefaults(vars || {}, defaults), tl);
    };

    if (extendTimeline) {
      Timeline.prototype[name] = function (targets, vars, position) {
        return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
      };
    }
  },
  registerEase: function registerEase(name, ease) {
    _easeMap[name] = _parseEase(ease);
  },
  parseEase: function parseEase(ease, defaultEase) {
    return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
  },
  getById: function getById(id) {
    return _globalTimeline.getById(id);
  },
  exportRoot: function exportRoot(vars, includeDelayedCalls) {
    if (vars === void 0) {
      vars = {};
    }

    var tl = new Timeline(vars),
        child,
        next;
    tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);

    _globalTimeline.remove(tl);

    tl._dp = 0; //otherwise it'll get re-activated when adding children and be re-introduced into _globalTimeline's linked list (then added to itself).

    tl._time = tl._tTime = _globalTimeline._time;
    child = _globalTimeline._first;

    while (child) {
      next = child._next;

      if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
        _addToTimeline(tl, child, child._start - child._delay);
      }

      child = next;
    }

    _addToTimeline(_globalTimeline, tl, 0);

    return tl;
  },
  utils: {
    wrap: wrap,
    wrapYoyo: wrapYoyo,
    distribute: distribute,
    random: random,
    snap: snap,
    normalize: normalize,
    getUnit: getUnit,
    clamp: clamp,
    splitColor: splitColor,
    toArray: toArray,
    selector: selector,
    mapRange: mapRange,
    pipe: pipe,
    unitize: unitize,
    interpolate: interpolate,
    shuffle: shuffle
  },
  install: _install,
  effects: _effects,
  ticker: _ticker,
  updateRoot: Timeline.updateRoot,
  plugins: _plugins,
  globalTimeline: _globalTimeline,
  core: {
    PropTween: PropTween,
    globals: _addGlobal,
    Tween: Tween,
    Timeline: Timeline,
    Animation: Animation,
    getCache: _getCache,
    _removeLinkedListItem: _removeLinkedListItem,
    suppressOverwrites: function suppressOverwrites(value) {
      return _suppressOverwrites = value;
    }
  }
};

_forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function (name) {
  return _gsap[name] = Tween[name];
});

_ticker.add(Timeline.updateRoot);

_quickTween = _gsap.to({}, {
  duration: 0
}); // ---- EXTRA PLUGINS --------------------------------------------------------

var _getPluginPropTween = function _getPluginPropTween(plugin, prop) {
  var pt = plugin._pt;

  while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
    pt = pt._next;
  }

  return pt;
},
    _addModifiers = function _addModifiers(tween, modifiers) {
  var targets = tween._targets,
      p,
      i,
      pt;

  for (p in modifiers) {
    i = targets.length;

    while (i--) {
      pt = tween._ptLookup[i][p];

      if (pt && (pt = pt.d)) {
        if (pt._pt) {
          // is a plugin
          pt = _getPluginPropTween(pt, p);
        }

        pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);
      }
    }
  }
},
    _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {
  return {
    name: name,
    rawVars: 1,
    //don't pre-process function-based values or "random()" strings.
    init: function init(target, vars, tween) {
      tween._onInit = function (tween) {
        var temp, p;

        if (_isString(vars)) {
          temp = {};

          _forEachName(vars, function (name) {
            return temp[name] = 1;
          }); //if the user passes in a comma-delimited list of property names to roundProps, like "x,y", we round to whole numbers.


          vars = temp;
        }

        if (modifier) {
          temp = {};

          for (p in vars) {
            temp[p] = modifier(vars[p]);
          }

          vars = temp;
        }

        _addModifiers(tween, vars);
      };
    }
  };
}; //register core plugins


var gsap = _gsap.registerPlugin({
  name: "attr",
  init: function init(target, vars, tween, index, targets) {
    var p, pt;

    for (p in vars) {
      pt = this.add(target, "setAttribute", (target.getAttribute(p) || 0) + "", vars[p], index, targets, 0, 0, p);
      pt && (pt.op = p);

      this._props.push(p);
    }
  }
}, {
  name: "endArray",
  init: function init(target, value) {
    var i = value.length;

    while (i--) {
      this.add(target, i, target[i] || 0, value[i]);
    }
  }
}, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap; //to prevent the core plugins from being dropped via aggressive tree shaking, we must include them in the variable declaration in this way.

Tween.version = Timeline.version = gsap.version = "3.9.1";
_coreReady = 1;
_windowExists() && _wake();
var Power0 = _easeMap.Power0,
    Power1 = _easeMap.Power1,
    Power2 = _easeMap.Power2,
    Power3 = _easeMap.Power3,
    Power4 = _easeMap.Power4,
    Linear = _easeMap.Linear,
    Quad = _easeMap.Quad,
    Cubic = _easeMap.Cubic,
    Quart = _easeMap.Quart,
    Quint = _easeMap.Quint,
    Strong = _easeMap.Strong,
    Elastic = _easeMap.Elastic,
    Back = _easeMap.Back,
    SteppedEase = _easeMap.SteppedEase,
    Bounce = _easeMap.Bounce,
    Sine = _easeMap.Sine,
    Expo = _easeMap.Expo,
    Circ = _easeMap.Circ;

 //export some internal methods/orojects for use in CSSPlugin so that we can externalize that file and allow custom builds that exclude it.



/***/ }),

/***/ "./node_modules/gsap/utils/matrix.js":
/*!*******************************************!*\
  !*** ./node_modules/gsap/utils/matrix.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Matrix2D": () => (/* binding */ Matrix2D),
/* harmony export */   "_getCTM": () => (/* binding */ _getCTM),
/* harmony export */   "_getDocScrollLeft": () => (/* binding */ _getDocScrollLeft),
/* harmony export */   "_getDocScrollTop": () => (/* binding */ _getDocScrollTop),
/* harmony export */   "_isFixed": () => (/* binding */ _isFixed),
/* harmony export */   "_setDoc": () => (/* binding */ _setDoc),
/* harmony export */   "getGlobalMatrix": () => (/* binding */ getGlobalMatrix)
/* harmony export */ });
/*!
 * matrix 3.9.1
 * https://greensock.com
 *
 * Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */
var _doc,
    _win,
    _docElement,
    _body,
    _divContainer,
    _svgContainer,
    _identityMatrix,
    _gEl,
    _transformProp = "transform",
    _transformOriginProp = _transformProp + "Origin",
    _hasOffsetBug,
    _setDoc = function _setDoc(element) {
  var doc = element.ownerDocument || element;

  if (!(_transformProp in element.style) && "msTransform" in element.style) {
    //to improve compatibility with old Microsoft browsers
    _transformProp = "msTransform";
    _transformOriginProp = _transformProp + "Origin";
  }

  while (doc.parentNode && (doc = doc.parentNode)) {}

  _win = window;
  _identityMatrix = new Matrix2D();

  if (doc) {
    _doc = doc;
    _docElement = doc.documentElement;
    _body = doc.body;
    _gEl = _doc.createElementNS("http://www.w3.org/2000/svg", "g"); // prevent any existing CSS from transforming it

    _gEl.style.transform = "none"; // now test for the offset reporting bug. Use feature detection instead of browser sniffing to make things more bulletproof and future-proof. Hopefully Safari will fix their bug soon but it's 2020 and it's still not fixed.

    var d1 = doc.createElement("div"),
        d2 = doc.createElement("div");

    _body.appendChild(d1);

    d1.appendChild(d2);
    d1.style.position = "static";
    d1.style[_transformProp] = "translate3d(0,0,1px)";
    _hasOffsetBug = d2.offsetParent !== d1;

    _body.removeChild(d1);
  }

  return doc;
},
    _forceNonZeroScale = function _forceNonZeroScale(e) {
  // walks up the element's ancestors and finds any that had their scale set to 0 via GSAP, and changes them to 0.0001 to ensure that measurements work. Firefox has a bug that causes it to incorrectly report getBoundingClientRect() when scale is 0.
  var a, cache;

  while (e && e !== _body) {
    cache = e._gsap;
    cache && cache.uncache && cache.get(e, "x"); // force re-parsing of transforms if necessary

    if (cache && !cache.scaleX && !cache.scaleY && cache.renderTransform) {
      cache.scaleX = cache.scaleY = 1e-4;
      cache.renderTransform(1, cache);
      a ? a.push(cache) : a = [cache];
    }

    e = e.parentNode;
  }

  return a;
},
    // possible future addition: pass an element to _forceDisplay() and it'll walk up all its ancestors and make sure anything with display: none is set to display: block, and if there's no parentNode, it'll add it to the body. It returns an Array that you can then feed to _revertDisplay() to have it revert all the changes it made.
// _forceDisplay = e => {
// 	let a = [],
// 		parent;
// 	while (e && e !== _body) {
// 		parent = e.parentNode;
// 		(_win.getComputedStyle(e).display === "none" || !parent) && a.push(e, e.style.display, parent) && (e.style.display = "block");
// 		parent || _body.appendChild(e);
// 		e = parent;
// 	}
// 	return a;
// },
// _revertDisplay = a => {
// 	for (let i = 0; i < a.length; i+=3) {
// 		a[i+1] ? (a[i].style.display = a[i+1]) : a[i].style.removeProperty("display");
// 		a[i+2] || a[i].parentNode.removeChild(a[i]);
// 	}
// },
_svgTemps = [],
    //we create 3 elements for SVG, and 3 for other DOM elements and cache them for performance reasons. They get nested in _divContainer and _svgContainer so that just one element is added to the DOM on each successive attempt. Again, performance is key.
_divTemps = [],
    _getDocScrollTop = function _getDocScrollTop() {
  return _win.pageYOffset || _doc.scrollTop || _docElement.scrollTop || _body.scrollTop || 0;
},
    _getDocScrollLeft = function _getDocScrollLeft() {
  return _win.pageXOffset || _doc.scrollLeft || _docElement.scrollLeft || _body.scrollLeft || 0;
},
    _svgOwner = function _svgOwner(element) {
  return element.ownerSVGElement || ((element.tagName + "").toLowerCase() === "svg" ? element : null);
},
    _isFixed = function _isFixed(element) {
  if (_win.getComputedStyle(element).position === "fixed") {
    return true;
  }

  element = element.parentNode;

  if (element && element.nodeType === 1) {
    // avoid document fragments which will throw an error.
    return _isFixed(element);
  }
},
    _createSibling = function _createSibling(element, i) {
  if (element.parentNode && (_doc || _setDoc(element))) {
    var svg = _svgOwner(element),
        ns = svg ? svg.getAttribute("xmlns") || "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml",
        type = svg ? i ? "rect" : "g" : "div",
        x = i !== 2 ? 0 : 100,
        y = i === 3 ? 100 : 0,
        css = "position:absolute;display:block;pointer-events:none;margin:0;padding:0;",
        e = _doc.createElementNS ? _doc.createElementNS(ns.replace(/^https/, "http"), type) : _doc.createElement(type);

    if (i) {
      if (!svg) {
        if (!_divContainer) {
          _divContainer = _createSibling(element);
          _divContainer.style.cssText = css;
        }

        e.style.cssText = css + "width:0.1px;height:0.1px;top:" + y + "px;left:" + x + "px";

        _divContainer.appendChild(e);
      } else {
        _svgContainer || (_svgContainer = _createSibling(element));
        e.setAttribute("width", 0.01);
        e.setAttribute("height", 0.01);
        e.setAttribute("transform", "translate(" + x + "," + y + ")");

        _svgContainer.appendChild(e);
      }
    }

    return e;
  }

  throw "Need document and parent.";
},
    _consolidate = function _consolidate(m) {
  // replaces SVGTransformList.consolidate() because a bug in Firefox causes it to break pointer events. See https://greensock.com/forums/topic/23248-touch-is-not-working-on-draggable-in-firefox-windows-v324/?tab=comments#comment-109800
  var c = new Matrix2D(),
      i = 0;

  for (; i < m.numberOfItems; i++) {
    c.multiply(m.getItem(i).matrix);
  }

  return c;
},
    _getCTM = function _getCTM(svg) {
  var m = svg.getCTM(),
      transform;

  if (!m) {
    // Firefox returns null for getCTM() on root <svg> elements, so this is a workaround using a <g> that we temporarily append.
    transform = svg.style[_transformProp];
    svg.style[_transformProp] = "none"; // a bug in Firefox causes css transforms to contaminate the getCTM()

    svg.appendChild(_gEl);
    m = _gEl.getCTM();
    svg.removeChild(_gEl);
    transform ? svg.style[_transformProp] = transform : svg.style.removeProperty(_transformProp.replace(/([A-Z])/g, "-$1").toLowerCase());
  }

  return m || _identityMatrix.clone(); // Firefox will still return null if the <svg> has a width/height of 0 in the browser.
},
    _placeSiblings = function _placeSiblings(element, adjustGOffset) {
  var svg = _svgOwner(element),
      isRootSVG = element === svg,
      siblings = svg ? _svgTemps : _divTemps,
      parent = element.parentNode,
      container,
      m,
      b,
      x,
      y,
      cs;

  if (element === _win) {
    return element;
  }

  siblings.length || siblings.push(_createSibling(element, 1), _createSibling(element, 2), _createSibling(element, 3));
  container = svg ? _svgContainer : _divContainer;

  if (svg) {
    if (isRootSVG) {
      b = _getCTM(element);
      x = -b.e / b.a;
      y = -b.f / b.d;
      m = _identityMatrix;
    } else {
      b = element.getBBox();
      m = element.transform ? element.transform.baseVal : {}; // IE11 doesn't follow the spec.

      m = !m.numberOfItems ? _identityMatrix : m.numberOfItems > 1 ? _consolidate(m) : m.getItem(0).matrix; // don't call m.consolidate().matrix because a bug in Firefox makes pointer events not work when consolidate() is called on the same tick as getBoundingClientRect()! See https://greensock.com/forums/topic/23248-touch-is-not-working-on-draggable-in-firefox-windows-v324/?tab=comments#comment-109800

      x = m.a * b.x + m.c * b.y;
      y = m.b * b.x + m.d * b.y;
    }

    if (adjustGOffset && element.tagName.toLowerCase() === "g") {
      x = y = 0;
    }

    (isRootSVG ? svg : parent).appendChild(container);
    container.setAttribute("transform", "matrix(" + m.a + "," + m.b + "," + m.c + "," + m.d + "," + (m.e + x) + "," + (m.f + y) + ")");
  } else {
    x = y = 0;

    if (_hasOffsetBug) {
      // some browsers (like Safari) have a bug that causes them to misreport offset values. When an ancestor element has a transform applied, it's supposed to treat it as if it's position: relative (new context). Safari botches this, so we need to find the closest ancestor (between the element and its offsetParent) that has a transform applied and if one is found, grab its offsetTop/Left and subtract them to compensate.
      m = element.offsetParent;
      b = element;

      while (b && (b = b.parentNode) && b !== m && b.parentNode) {
        if ((_win.getComputedStyle(b)[_transformProp] + "").length > 4) {
          x = b.offsetLeft;
          y = b.offsetTop;
          b = 0;
        }
      }
    }

    cs = _win.getComputedStyle(element);

    if (cs.position !== "absolute" && cs.position !== "fixed") {
      m = element.offsetParent;

      while (parent && parent !== m) {
        // if there's an ancestor element between the element and its offsetParent that's scrolled, we must factor that in.
        x += parent.scrollLeft || 0;
        y += parent.scrollTop || 0;
        parent = parent.parentNode;
      }
    }

    b = container.style;
    b.top = element.offsetTop - y + "px";
    b.left = element.offsetLeft - x + "px";
    b[_transformProp] = cs[_transformProp];
    b[_transformOriginProp] = cs[_transformOriginProp]; // b.border = m.border;
    // b.borderLeftStyle = m.borderLeftStyle;
    // b.borderTopStyle = m.borderTopStyle;
    // b.borderLeftWidth = m.borderLeftWidth;
    // b.borderTopWidth = m.borderTopWidth;

    b.position = cs.position === "fixed" ? "fixed" : "absolute";
    element.parentNode.appendChild(container);
  }

  return container;
},
    _setMatrix = function _setMatrix(m, a, b, c, d, e, f) {
  m.a = a;
  m.b = b;
  m.c = c;
  m.d = d;
  m.e = e;
  m.f = f;
  return m;
};

var Matrix2D = /*#__PURE__*/function () {
  function Matrix2D(a, b, c, d, e, f) {
    if (a === void 0) {
      a = 1;
    }

    if (b === void 0) {
      b = 0;
    }

    if (c === void 0) {
      c = 0;
    }

    if (d === void 0) {
      d = 1;
    }

    if (e === void 0) {
      e = 0;
    }

    if (f === void 0) {
      f = 0;
    }

    _setMatrix(this, a, b, c, d, e, f);
  }

  var _proto = Matrix2D.prototype;

  _proto.inverse = function inverse() {
    var a = this.a,
        b = this.b,
        c = this.c,
        d = this.d,
        e = this.e,
        f = this.f,
        determinant = a * d - b * c || 1e-10;
    return _setMatrix(this, d / determinant, -b / determinant, -c / determinant, a / determinant, (c * f - d * e) / determinant, -(a * f - b * e) / determinant);
  };

  _proto.multiply = function multiply(matrix) {
    var a = this.a,
        b = this.b,
        c = this.c,
        d = this.d,
        e = this.e,
        f = this.f,
        a2 = matrix.a,
        b2 = matrix.c,
        c2 = matrix.b,
        d2 = matrix.d,
        e2 = matrix.e,
        f2 = matrix.f;
    return _setMatrix(this, a2 * a + c2 * c, a2 * b + c2 * d, b2 * a + d2 * c, b2 * b + d2 * d, e + e2 * a + f2 * c, f + e2 * b + f2 * d);
  };

  _proto.clone = function clone() {
    return new Matrix2D(this.a, this.b, this.c, this.d, this.e, this.f);
  };

  _proto.equals = function equals(matrix) {
    var a = this.a,
        b = this.b,
        c = this.c,
        d = this.d,
        e = this.e,
        f = this.f;
    return a === matrix.a && b === matrix.b && c === matrix.c && d === matrix.d && e === matrix.e && f === matrix.f;
  };

  _proto.apply = function apply(point, decoratee) {
    if (decoratee === void 0) {
      decoratee = {};
    }

    var x = point.x,
        y = point.y,
        a = this.a,
        b = this.b,
        c = this.c,
        d = this.d,
        e = this.e,
        f = this.f;
    decoratee.x = x * a + y * c + e || 0;
    decoratee.y = x * b + y * d + f || 0;
    return decoratee;
  };

  return Matrix2D;
}(); // Feed in an element and it'll return a 2D matrix (optionally inverted) so that you can translate between coordinate spaces.
// Inverting lets you translate a global point into a local coordinate space. No inverting lets you go the other way.
// We needed this to work around various browser bugs, like Firefox doesn't accurately report getScreenCTM() when there
// are transforms applied to ancestor elements.
// The matrix math to convert any x/y coordinate is as follows, which is wrapped in a convenient apply() method of Matrix2D above:
//     tx = m.a * x + m.c * y + m.e
//     ty = m.b * x + m.d * y + m.f

function getGlobalMatrix(element, inverse, adjustGOffset, includeScrollInFixed) {
  // adjustGOffset is typically used only when grabbing an element's PARENT's global matrix, and it ignores the x/y offset of any SVG <g> elements because they behave in a special way.
  if (!element || !element.parentNode || (_doc || _setDoc(element)).documentElement === element) {
    return new Matrix2D();
  }

  var zeroScales = _forceNonZeroScale(element),
      svg = _svgOwner(element),
      temps = svg ? _svgTemps : _divTemps,
      container = _placeSiblings(element, adjustGOffset),
      b1 = temps[0].getBoundingClientRect(),
      b2 = temps[1].getBoundingClientRect(),
      b3 = temps[2].getBoundingClientRect(),
      parent = container.parentNode,
      isFixed = !includeScrollInFixed && _isFixed(element),
      m = new Matrix2D((b2.left - b1.left) / 100, (b2.top - b1.top) / 100, (b3.left - b1.left) / 100, (b3.top - b1.top) / 100, b1.left + (isFixed ? 0 : _getDocScrollLeft()), b1.top + (isFixed ? 0 : _getDocScrollTop()));

  parent.removeChild(container);

  if (zeroScales) {
    b1 = zeroScales.length;

    while (b1--) {
      b2 = zeroScales[b1];
      b2.scaleX = b2.scaleY = 0;
      b2.renderTransform(1, b2);
    }
  }

  return inverse ? m.inverse() : m;
}
 // export function getMatrix(element) {
// 	_doc || _setDoc(element);
// 	let m = (_win.getComputedStyle(element)[_transformProp] + "").substr(7).match(/[-.]*\d+[.e\-+]*\d*[e\-\+]*\d*/g),
// 		is2D = m && m.length === 6;
// 	return !m || m.length < 6 ? new Matrix2D() : new Matrix2D(+m[0], +m[1], +m[is2D ? 2 : 4], +m[is2D ? 3 : 5], +m[is2D ? 4 : 12], +m[is2D ? 5 : 13]);
// }

/***/ }),

/***/ "./node_modules/gsap/utils/paths.js":
/*!******************************************!*\
  !*** ./node_modules/gsap/utils/paths.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "bezierToPoints": () => (/* binding */ bezierToPoints),
/* harmony export */   "cacheRawPathMeasurements": () => (/* binding */ cacheRawPathMeasurements),
/* harmony export */   "convertToPath": () => (/* binding */ convertToPath),
/* harmony export */   "copyRawPath": () => (/* binding */ copyRawPath),
/* harmony export */   "flatPointsToSegment": () => (/* binding */ flatPointsToSegment),
/* harmony export */   "getClosestData": () => (/* binding */ getClosestData),
/* harmony export */   "getPositionOnPath": () => (/* binding */ getPositionOnPath),
/* harmony export */   "getRawPath": () => (/* binding */ getRawPath),
/* harmony export */   "getRotationAtProgress": () => (/* binding */ getRotationAtProgress),
/* harmony export */   "pointsToSegment": () => (/* binding */ pointsToSegment),
/* harmony export */   "rawPathToString": () => (/* binding */ rawPathToString),
/* harmony export */   "reverseSegment": () => (/* binding */ reverseSegment),
/* harmony export */   "simplifyPoints": () => (/* binding */ simplifyPoints),
/* harmony export */   "sliceRawPath": () => (/* binding */ sliceRawPath),
/* harmony export */   "stringToRawPath": () => (/* binding */ stringToRawPath),
/* harmony export */   "subdivideSegment": () => (/* binding */ subdivideSegment),
/* harmony export */   "subdivideSegmentNear": () => (/* binding */ subdivideSegmentNear),
/* harmony export */   "transformRawPath": () => (/* binding */ transformRawPath)
/* harmony export */ });
/*!
 * paths 3.9.1
 * https://greensock.com
 *
 * Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */
var _svgPathExp = /[achlmqstvz]|(-?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
    _numbersExp = /(?:(-)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/ig,
    _scientific = /[\+\-]?\d*\.?\d+e[\+\-]?\d+/ig,
    _selectorExp = /(^[#\.][a-z]|[a-y][a-z])/i,
    _DEG2RAD = Math.PI / 180,
    _RAD2DEG = 180 / Math.PI,
    _sin = Math.sin,
    _cos = Math.cos,
    _abs = Math.abs,
    _sqrt = Math.sqrt,
    _atan2 = Math.atan2,
    _largeNum = 1e8,
    _isString = function _isString(value) {
  return typeof value === "string";
},
    _isNumber = function _isNumber(value) {
  return typeof value === "number";
},
    _isUndefined = function _isUndefined(value) {
  return typeof value === "undefined";
},
    _temp = {},
    _temp2 = {},
    _roundingNum = 1e5,
    _wrapProgress = function _wrapProgress(progress) {
  return Math.round((progress + _largeNum) % 1 * _roundingNum) / _roundingNum || (progress < 0 ? 0 : 1);
},
    //if progress lands on 1, the % will make it 0 which is why we || 1, but not if it's negative because it makes more sense for motion to end at 0 in that case.
_round = function _round(value) {
  return Math.round(value * _roundingNum) / _roundingNum || 0;
},
    _roundPrecise = function _roundPrecise(value) {
  return Math.round(value * 1e10) / 1e10 || 0;
},
    _splitSegment = function _splitSegment(rawPath, segIndex, i, t) {
  var segment = rawPath[segIndex],
      shift = t === 1 ? 6 : subdivideSegment(segment, i, t);

  if (shift && shift + i + 2 < segment.length) {
    rawPath.splice(segIndex, 0, segment.slice(0, i + shift + 2));
    segment.splice(0, i + shift);
    return 1;
  }
},
    _getSampleIndex = function _getSampleIndex(samples, length, progress) {
  // slightly slower way than doing this (when there's no lookup): segment.lookup[progress < 1 ? ~~(length / segment.minLength) : segment.lookup.length - 1] || 0;
  var l = samples.length,
      i = ~~(progress * l);

  if (samples[i] > length) {
    while (--i && samples[i] > length) {}
  } else {
    while (samples[++i] < length && i < l) {}
  }

  return i < l ? i : l - 1;
},
    _reverseRawPath = function _reverseRawPath(rawPath, skipOuter) {
  var i = rawPath.length;
  skipOuter || rawPath.reverse();

  while (i--) {
    rawPath[i].reversed || reverseSegment(rawPath[i]);
  }
},
    _copyMetaData = function _copyMetaData(source, copy) {
  copy.totalLength = source.totalLength;

  if (source.samples) {
    //segment
    copy.samples = source.samples.slice(0);
    copy.lookup = source.lookup.slice(0);
    copy.minLength = source.minLength;
    copy.resolution = source.resolution;
  } else if (source.totalPoints) {
    //rawPath
    copy.totalPoints = source.totalPoints;
  }

  return copy;
},
    //pushes a new segment into a rawPath, but if its starting values match the ending values of the last segment, it'll merge it into that same segment (to reduce the number of segments)
_appendOrMerge = function _appendOrMerge(rawPath, segment) {
  var index = rawPath.length,
      prevSeg = rawPath[index - 1] || [],
      l = prevSeg.length;

  if (index && segment[0] === prevSeg[l - 2] && segment[1] === prevSeg[l - 1]) {
    segment = prevSeg.concat(segment.slice(2));
    index--;
  }

  rawPath[index] = segment;
},
    _bestDistance;
/* TERMINOLOGY
 - RawPath - an array of arrays, one for each Segment. A single RawPath could have multiple "M" commands, defining Segments (paths aren't always connected).
 - Segment - an array containing a sequence of Cubic Bezier coordinates in alternating x, y, x, y format. Starting anchor, then control point 1, control point 2, and ending anchor, then the next control point 1, control point 2, anchor, etc. Uses less memory than an array with a bunch of {x, y} points.
 - Bezier - a single cubic Bezier with a starting anchor, two control points, and an ending anchor.
 - the variable "t" is typically the position along an individual Bezier path (time) and it's NOT linear, meaning it could accelerate/decelerate based on the control points whereas the "p" or "progress" value is linearly mapped to the whole path, so it shouldn't really accelerate/decelerate based on control points. So a progress of 0.2 would be almost exactly 20% along the path. "t" is ONLY in an individual Bezier piece.
 */
//accepts basic selector text, a path instance, a RawPath instance, or a Segment and returns a RawPath (makes it easy to homogenize things). If an element or selector text is passed in, it'll also cache the value so that if it's queried again, it'll just take the path data from there instead of parsing it all over again (as long as the path data itself hasn't changed - it'll check).


function getRawPath(value) {
  value = _isString(value) && _selectorExp.test(value) ? document.querySelector(value) || value : value;
  var e = value.getAttribute ? value : 0,
      rawPath;

  if (e && (value = value.getAttribute("d"))) {
    //implements caching
    if (!e._gsPath) {
      e._gsPath = {};
    }

    rawPath = e._gsPath[value];
    return rawPath && !rawPath._dirty ? rawPath : e._gsPath[value] = stringToRawPath(value);
  }

  return !value ? console.warn("Expecting a <path> element or an SVG path data string") : _isString(value) ? stringToRawPath(value) : _isNumber(value[0]) ? [value] : value;
} //copies a RawPath WITHOUT the length meta data (for speed)

function copyRawPath(rawPath) {
  var a = [],
      i = 0;

  for (; i < rawPath.length; i++) {
    a[i] = _copyMetaData(rawPath[i], rawPath[i].slice(0));
  }

  return _copyMetaData(rawPath, a);
}
function reverseSegment(segment) {
  var i = 0,
      y;
  segment.reverse(); //this will invert the order y, x, y, x so we must flip it back.

  for (; i < segment.length; i += 2) {
    y = segment[i];
    segment[i] = segment[i + 1];
    segment[i + 1] = y;
  }

  segment.reversed = !segment.reversed;
}

var _createPath = function _createPath(e, ignore) {
  var path = document.createElementNS("http://www.w3.org/2000/svg", "path"),
      attr = [].slice.call(e.attributes),
      i = attr.length,
      name;
  ignore = "," + ignore + ",";

  while (--i > -1) {
    name = attr[i].nodeName.toLowerCase(); //in Microsoft Edge, if you don't set the attribute with a lowercase name, it doesn't render correctly! Super weird.

    if (ignore.indexOf("," + name + ",") < 0) {
      path.setAttributeNS(null, name, attr[i].nodeValue);
    }
  }

  return path;
},
    _typeAttrs = {
  rect: "rx,ry,x,y,width,height",
  circle: "r,cx,cy",
  ellipse: "rx,ry,cx,cy",
  line: "x1,x2,y1,y2"
},
    _attrToObj = function _attrToObj(e, attrs) {
  var props = attrs ? attrs.split(",") : [],
      obj = {},
      i = props.length;

  while (--i > -1) {
    obj[props[i]] = +e.getAttribute(props[i]) || 0;
  }

  return obj;
}; //converts an SVG shape like <circle>, <rect>, <polygon>, <polyline>, <ellipse>, etc. to a <path>, swapping it in and copying the attributes to match.


function convertToPath(element, swap) {
  var type = element.tagName.toLowerCase(),
      circ = 0.552284749831,
      data,
      x,
      y,
      r,
      ry,
      path,
      rcirc,
      rycirc,
      points,
      w,
      h,
      x2,
      x3,
      x4,
      x5,
      x6,
      y2,
      y3,
      y4,
      y5,
      y6,
      attr;

  if (type === "path" || !element.getBBox) {
    return element;
  }

  path = _createPath(element, "x,y,width,height,cx,cy,rx,ry,r,x1,x2,y1,y2,points");
  attr = _attrToObj(element, _typeAttrs[type]);

  if (type === "rect") {
    r = attr.rx;
    ry = attr.ry || r;
    x = attr.x;
    y = attr.y;
    w = attr.width - r * 2;
    h = attr.height - ry * 2;

    if (r || ry) {
      //if there are rounded corners, render cubic beziers
      x2 = x + r * (1 - circ);
      x3 = x + r;
      x4 = x3 + w;
      x5 = x4 + r * circ;
      x6 = x4 + r;
      y2 = y + ry * (1 - circ);
      y3 = y + ry;
      y4 = y3 + h;
      y5 = y4 + ry * circ;
      y6 = y4 + ry;
      data = "M" + x6 + "," + y3 + " V" + y4 + " C" + [x6, y5, x5, y6, x4, y6, x4 - (x4 - x3) / 3, y6, x3 + (x4 - x3) / 3, y6, x3, y6, x2, y6, x, y5, x, y4, x, y4 - (y4 - y3) / 3, x, y3 + (y4 - y3) / 3, x, y3, x, y2, x2, y, x3, y, x3 + (x4 - x3) / 3, y, x4 - (x4 - x3) / 3, y, x4, y, x5, y, x6, y2, x6, y3].join(",") + "z";
    } else {
      data = "M" + (x + w) + "," + y + " v" + h + " h" + -w + " v" + -h + " h" + w + "z";
    }
  } else if (type === "circle" || type === "ellipse") {
    if (type === "circle") {
      r = ry = attr.r;
      rycirc = r * circ;
    } else {
      r = attr.rx;
      ry = attr.ry;
      rycirc = ry * circ;
    }

    x = attr.cx;
    y = attr.cy;
    rcirc = r * circ;
    data = "M" + (x + r) + "," + y + " C" + [x + r, y + rycirc, x + rcirc, y + ry, x, y + ry, x - rcirc, y + ry, x - r, y + rycirc, x - r, y, x - r, y - rycirc, x - rcirc, y - ry, x, y - ry, x + rcirc, y - ry, x + r, y - rycirc, x + r, y].join(",") + "z";
  } else if (type === "line") {
    data = "M" + attr.x1 + "," + attr.y1 + " L" + attr.x2 + "," + attr.y2; //previously, we just converted to "Mx,y Lx,y" but Safari has bugs that cause that not to render properly when using a stroke-dasharray that's not fully visible! Using a cubic bezier fixes that issue.
  } else if (type === "polyline" || type === "polygon") {
    points = (element.getAttribute("points") + "").match(_numbersExp) || [];
    x = points.shift();
    y = points.shift();
    data = "M" + x + "," + y + " L" + points.join(",");

    if (type === "polygon") {
      data += "," + x + "," + y + "z";
    }
  }

  path.setAttribute("d", rawPathToString(path._gsRawPath = stringToRawPath(data)));

  if (swap && element.parentNode) {
    element.parentNode.insertBefore(path, element);
    element.parentNode.removeChild(element);
  }

  return path;
} //returns the rotation (in degrees) at a particular progress on a rawPath (the slope of the tangent)

function getRotationAtProgress(rawPath, progress) {
  var d = getProgressData(rawPath, progress >= 1 ? 1 - 1e-9 : progress ? progress : 1e-9);
  return getRotationAtBezierT(d.segment, d.i, d.t);
}

function getRotationAtBezierT(segment, i, t) {
  var a = segment[i],
      b = segment[i + 2],
      c = segment[i + 4],
      x;
  a += (b - a) * t;
  b += (c - b) * t;
  a += (b - a) * t;
  x = b + (c + (segment[i + 6] - c) * t - b) * t - a;
  a = segment[i + 1];
  b = segment[i + 3];
  c = segment[i + 5];
  a += (b - a) * t;
  b += (c - b) * t;
  a += (b - a) * t;
  return _round(_atan2(b + (c + (segment[i + 7] - c) * t - b) * t - a, x) * _RAD2DEG);
}

function sliceRawPath(rawPath, start, end) {
  end = _isUndefined(end) ? 1 : _roundPrecise(end) || 0; // we must round to avoid issues like 4.15 / 8 = 0.8300000000000001 instead of 0.83 or 2.8 / 5 = 0.5599999999999999 instead of 0.56 and if someone is doing a loop like start: 2.8 / 0.5, end: 2.8 / 0.5 + 1.

  start = _roundPrecise(start) || 0;
  var loops = Math.max(0, ~~(_abs(end - start) - 1e-8)),
      path = copyRawPath(rawPath);

  if (start > end) {
    start = 1 - start;
    end = 1 - end;

    _reverseRawPath(path);

    path.totalLength = 0;
  }

  if (start < 0 || end < 0) {
    var offset = Math.abs(~~Math.min(start, end)) + 1;
    start += offset;
    end += offset;
  }

  path.totalLength || cacheRawPathMeasurements(path);
  var wrap = end > 1,
      s = getProgressData(path, start, _temp, true),
      e = getProgressData(path, end, _temp2),
      eSeg = e.segment,
      sSeg = s.segment,
      eSegIndex = e.segIndex,
      sSegIndex = s.segIndex,
      ei = e.i,
      si = s.i,
      sameSegment = sSegIndex === eSegIndex,
      sameBezier = ei === si && sameSegment,
      wrapsBehind,
      sShift,
      eShift,
      i,
      copy,
      totalSegments,
      l,
      j;

  if (wrap || loops) {
    wrapsBehind = eSegIndex < sSegIndex || sameSegment && ei < si || sameBezier && e.t < s.t;

    if (_splitSegment(path, sSegIndex, si, s.t)) {
      sSegIndex++;

      if (!wrapsBehind) {
        eSegIndex++;

        if (sameBezier) {
          e.t = (e.t - s.t) / (1 - s.t);
          ei = 0;
        } else if (sameSegment) {
          ei -= si;
        }
      }
    }

    if (Math.abs(1 - (end - start)) < 1e-5) {
      eSegIndex = sSegIndex - 1;
    } else if (!e.t && eSegIndex) {
      eSegIndex--;
    } else if (_splitSegment(path, eSegIndex, ei, e.t) && wrapsBehind) {
      sSegIndex++;
    }

    if (s.t === 1) {
      sSegIndex = (sSegIndex + 1) % path.length;
    }

    copy = [];
    totalSegments = path.length;
    l = 1 + totalSegments * loops;
    j = sSegIndex;
    l += (totalSegments - sSegIndex + eSegIndex) % totalSegments;

    for (i = 0; i < l; i++) {
      _appendOrMerge(copy, path[j++ % totalSegments]);
    }

    path = copy;
  } else {
    eShift = e.t === 1 ? 6 : subdivideSegment(eSeg, ei, e.t);

    if (start !== end) {
      sShift = subdivideSegment(sSeg, si, sameBezier ? s.t / e.t : s.t);
      sameSegment && (eShift += sShift);
      eSeg.splice(ei + eShift + 2);
      (sShift || si) && sSeg.splice(0, si + sShift);
      i = path.length;

      while (i--) {
        //chop off any extra segments
        (i < sSegIndex || i > eSegIndex) && path.splice(i, 1);
      }
    } else {
      eSeg.angle = getRotationAtBezierT(eSeg, ei + eShift, 0); //record the value before we chop because it'll be impossible to determine the angle after its length is 0!

      ei += eShift;
      s = eSeg[ei];
      e = eSeg[ei + 1];
      eSeg.length = eSeg.totalLength = 0;
      eSeg.totalPoints = path.totalPoints = 8;
      eSeg.push(s, e, s, e, s, e, s, e);
    }
  }

  path.totalLength = 0;
  return path;
} //measures a Segment according to its resolution (so if segment.resolution is 6, for example, it'll take 6 samples equally across each Bezier) and create/populate a "samples" Array that has the length up to each of those sample points (always increasing from the start) as well as a "lookup" array that's broken up according to the smallest distance between 2 samples. This gives us a very fast way of looking up a progress position rather than looping through all the points/Beziers. You can optionally have it only measure a subset, starting at startIndex and going for a specific number of beziers (remember, there are 3 x/y pairs each, for a total of 6 elements for each Bezier). It will also populate a "totalLength" property, but that's not generally super accurate because by default it'll only take 6 samples per Bezier. But for performance reasons, it's perfectly adequate for measuring progress values along the path. If you need a more accurate totalLength, either increase the resolution or use the more advanced bezierToPoints() method which keeps adding points until they don't deviate by more than a certain precision value.

function measureSegment(segment, startIndex, bezierQty) {
  startIndex = startIndex || 0;

  if (!segment.samples) {
    segment.samples = [];
    segment.lookup = [];
  }

  var resolution = ~~segment.resolution || 12,
      inc = 1 / resolution,
      endIndex = bezierQty ? startIndex + bezierQty * 6 + 1 : segment.length,
      x1 = segment[startIndex],
      y1 = segment[startIndex + 1],
      samplesIndex = startIndex ? startIndex / 6 * resolution : 0,
      samples = segment.samples,
      lookup = segment.lookup,
      min = (startIndex ? segment.minLength : _largeNum) || _largeNum,
      prevLength = samples[samplesIndex + bezierQty * resolution - 1],
      length = startIndex ? samples[samplesIndex - 1] : 0,
      i,
      j,
      x4,
      x3,
      x2,
      xd,
      xd1,
      y4,
      y3,
      y2,
      yd,
      yd1,
      inv,
      t,
      lengthIndex,
      l,
      segLength;
  samples.length = lookup.length = 0;

  for (j = startIndex + 2; j < endIndex; j += 6) {
    x4 = segment[j + 4] - x1;
    x3 = segment[j + 2] - x1;
    x2 = segment[j] - x1;
    y4 = segment[j + 5] - y1;
    y3 = segment[j + 3] - y1;
    y2 = segment[j + 1] - y1;
    xd = xd1 = yd = yd1 = 0;

    if (_abs(x4) < .01 && _abs(y4) < .01 && _abs(x2) + _abs(y2) < .01) {
      //dump points that are sufficiently close (basically right on top of each other, making a bezier super tiny or 0 length)
      if (segment.length > 8) {
        segment.splice(j, 6);
        j -= 6;
        endIndex -= 6;
      }
    } else {
      for (i = 1; i <= resolution; i++) {
        t = inc * i;
        inv = 1 - t;
        xd = xd1 - (xd1 = (t * t * x4 + 3 * inv * (t * x3 + inv * x2)) * t);
        yd = yd1 - (yd1 = (t * t * y4 + 3 * inv * (t * y3 + inv * y2)) * t);
        l = _sqrt(yd * yd + xd * xd);

        if (l < min) {
          min = l;
        }

        length += l;
        samples[samplesIndex++] = length;
      }
    }

    x1 += x4;
    y1 += y4;
  }

  if (prevLength) {
    prevLength -= length;

    for (; samplesIndex < samples.length; samplesIndex++) {
      samples[samplesIndex] += prevLength;
    }
  }

  if (samples.length && min) {
    segment.totalLength = segLength = samples[samples.length - 1] || 0;
    segment.minLength = min;

    if (segLength / min < 9999) {
      // if the lookup would require too many values (memory problem), we skip this and instead we use a loop to lookup values directly in the samples Array
      l = lengthIndex = 0;

      for (i = 0; i < segLength; i += min) {
        lookup[l++] = samples[lengthIndex] < i ? ++lengthIndex : lengthIndex;
      }
    }
  } else {
    segment.totalLength = samples[0] = 0;
  }

  return startIndex ? length - samples[startIndex / 2 - 1] : length;
}

function cacheRawPathMeasurements(rawPath, resolution) {
  var pathLength, points, i;

  for (i = pathLength = points = 0; i < rawPath.length; i++) {
    rawPath[i].resolution = ~~resolution || 12; //steps per Bezier curve (anchor, 2 control points, to anchor)

    points += rawPath[i].length;
    pathLength += measureSegment(rawPath[i]);
  }

  rawPath.totalPoints = points;
  rawPath.totalLength = pathLength;
  return rawPath;
} //divide segment[i] at position t (value between 0 and 1, progress along that particular cubic bezier segment that starts at segment[i]). Returns how many elements were spliced into the segment array (either 0 or 6)

function subdivideSegment(segment, i, t) {
  if (t <= 0 || t >= 1) {
    return 0;
  }

  var ax = segment[i],
      ay = segment[i + 1],
      cp1x = segment[i + 2],
      cp1y = segment[i + 3],
      cp2x = segment[i + 4],
      cp2y = segment[i + 5],
      bx = segment[i + 6],
      by = segment[i + 7],
      x1a = ax + (cp1x - ax) * t,
      x2 = cp1x + (cp2x - cp1x) * t,
      y1a = ay + (cp1y - ay) * t,
      y2 = cp1y + (cp2y - cp1y) * t,
      x1 = x1a + (x2 - x1a) * t,
      y1 = y1a + (y2 - y1a) * t,
      x2a = cp2x + (bx - cp2x) * t,
      y2a = cp2y + (by - cp2y) * t;
  x2 += (x2a - x2) * t;
  y2 += (y2a - y2) * t;
  segment.splice(i + 2, 4, _round(x1a), //first control point
  _round(y1a), _round(x1), //second control point
  _round(y1), _round(x1 + (x2 - x1) * t), //new fabricated anchor on line
  _round(y1 + (y2 - y1) * t), _round(x2), //third control point
  _round(y2), _round(x2a), //fourth control point
  _round(y2a));
  segment.samples && segment.samples.splice(i / 6 * segment.resolution | 0, 0, 0, 0, 0, 0, 0, 0);
  return 6;
} // returns an object {path, segment, segIndex, i, t}

function getProgressData(rawPath, progress, decoratee, pushToNextIfAtEnd) {
  decoratee = decoratee || {};
  rawPath.totalLength || cacheRawPathMeasurements(rawPath);

  if (progress < 0 || progress > 1) {
    progress = _wrapProgress(progress);
  }

  var segIndex = 0,
      segment = rawPath[0],
      samples,
      resolution,
      length,
      min,
      max,
      i,
      t;

  if (!progress) {
    t = i = segIndex = 0;
    segment = rawPath[0];
  } else if (progress === 1) {
    t = 1;
    segIndex = rawPath.length - 1;
    segment = rawPath[segIndex];
    i = segment.length - 8;
  } else {
    if (rawPath.length > 1) {
      //speed optimization: most of the time, there's only one segment so skip the recursion.
      length = rawPath.totalLength * progress;
      max = i = 0;

      while ((max += rawPath[i++].totalLength) < length) {
        segIndex = i;
      }

      segment = rawPath[segIndex];
      min = max - segment.totalLength;
      progress = (length - min) / (max - min) || 0;
    }

    samples = segment.samples;
    resolution = segment.resolution; //how many samples per cubic bezier chunk

    length = segment.totalLength * progress;
    i = segment.lookup.length ? segment.lookup[~~(length / segment.minLength)] || 0 : _getSampleIndex(samples, length, progress);
    min = i ? samples[i - 1] : 0;
    max = samples[i];

    if (max < length) {
      min = max;
      max = samples[++i];
    }

    t = 1 / resolution * ((length - min) / (max - min) + i % resolution);
    i = ~~(i / resolution) * 6;

    if (pushToNextIfAtEnd && t === 1) {
      if (i + 6 < segment.length) {
        i += 6;
        t = 0;
      } else if (segIndex + 1 < rawPath.length) {
        i = t = 0;
        segment = rawPath[++segIndex];
      }
    }
  }

  decoratee.t = t;
  decoratee.i = i;
  decoratee.path = rawPath;
  decoratee.segment = segment;
  decoratee.segIndex = segIndex;
  return decoratee;
}

function getPositionOnPath(rawPath, progress, includeAngle, point) {
  var segment = rawPath[0],
      result = point || {},
      samples,
      resolution,
      length,
      min,
      max,
      i,
      t,
      a,
      inv;

  if (progress < 0 || progress > 1) {
    progress = _wrapProgress(progress);
  }

  if (rawPath.length > 1) {
    //speed optimization: most of the time, there's only one segment so skip the recursion.
    length = rawPath.totalLength * progress;
    max = i = 0;

    while ((max += rawPath[i++].totalLength) < length) {
      segment = rawPath[i];
    }

    min = max - segment.totalLength;
    progress = (length - min) / (max - min) || 0;
  }

  samples = segment.samples;
  resolution = segment.resolution;
  length = segment.totalLength * progress;
  i = segment.lookup.length ? segment.lookup[progress < 1 ? ~~(length / segment.minLength) : segment.lookup.length - 1] || 0 : _getSampleIndex(samples, length, progress);
  min = i ? samples[i - 1] : 0;
  max = samples[i];

  if (max < length) {
    min = max;
    max = samples[++i];
  }

  t = 1 / resolution * ((length - min) / (max - min) + i % resolution) || 0;
  inv = 1 - t;
  i = ~~(i / resolution) * 6;
  a = segment[i];
  result.x = _round((t * t * (segment[i + 6] - a) + 3 * inv * (t * (segment[i + 4] - a) + inv * (segment[i + 2] - a))) * t + a);
  result.y = _round((t * t * (segment[i + 7] - (a = segment[i + 1])) + 3 * inv * (t * (segment[i + 5] - a) + inv * (segment[i + 3] - a))) * t + a);

  if (includeAngle) {
    result.angle = segment.totalLength ? getRotationAtBezierT(segment, i, t >= 1 ? 1 - 1e-9 : t ? t : 1e-9) : segment.angle || 0;
  }

  return result;
} //applies a matrix transform to RawPath (or a segment in a RawPath) and returns whatever was passed in (it transforms the values in the array(s), not a copy).

function transformRawPath(rawPath, a, b, c, d, tx, ty) {
  var j = rawPath.length,
      segment,
      l,
      i,
      x,
      y;

  while (--j > -1) {
    segment = rawPath[j];
    l = segment.length;

    for (i = 0; i < l; i += 2) {
      x = segment[i];
      y = segment[i + 1];
      segment[i] = x * a + y * c + tx;
      segment[i + 1] = x * b + y * d + ty;
    }
  }

  rawPath._dirty = 1;
  return rawPath;
} // translates SVG arc data into a segment (cubic beziers). Angle is in degrees.

function arcToSegment(lastX, lastY, rx, ry, angle, largeArcFlag, sweepFlag, x, y) {
  if (lastX === x && lastY === y) {
    return;
  }

  rx = _abs(rx);
  ry = _abs(ry);

  var angleRad = angle % 360 * _DEG2RAD,
      cosAngle = _cos(angleRad),
      sinAngle = _sin(angleRad),
      PI = Math.PI,
      TWOPI = PI * 2,
      dx2 = (lastX - x) / 2,
      dy2 = (lastY - y) / 2,
      x1 = cosAngle * dx2 + sinAngle * dy2,
      y1 = -sinAngle * dx2 + cosAngle * dy2,
      x1_sq = x1 * x1,
      y1_sq = y1 * y1,
      radiiCheck = x1_sq / (rx * rx) + y1_sq / (ry * ry);

  if (radiiCheck > 1) {
    rx = _sqrt(radiiCheck) * rx;
    ry = _sqrt(radiiCheck) * ry;
  }

  var rx_sq = rx * rx,
      ry_sq = ry * ry,
      sq = (rx_sq * ry_sq - rx_sq * y1_sq - ry_sq * x1_sq) / (rx_sq * y1_sq + ry_sq * x1_sq);

  if (sq < 0) {
    sq = 0;
  }

  var coef = (largeArcFlag === sweepFlag ? -1 : 1) * _sqrt(sq),
      cx1 = coef * (rx * y1 / ry),
      cy1 = coef * -(ry * x1 / rx),
      sx2 = (lastX + x) / 2,
      sy2 = (lastY + y) / 2,
      cx = sx2 + (cosAngle * cx1 - sinAngle * cy1),
      cy = sy2 + (sinAngle * cx1 + cosAngle * cy1),
      ux = (x1 - cx1) / rx,
      uy = (y1 - cy1) / ry,
      vx = (-x1 - cx1) / rx,
      vy = (-y1 - cy1) / ry,
      temp = ux * ux + uy * uy,
      angleStart = (uy < 0 ? -1 : 1) * Math.acos(ux / _sqrt(temp)),
      angleExtent = (ux * vy - uy * vx < 0 ? -1 : 1) * Math.acos((ux * vx + uy * vy) / _sqrt(temp * (vx * vx + vy * vy)));

  isNaN(angleExtent) && (angleExtent = PI); //rare edge case. Math.cos(-1) is NaN.

  if (!sweepFlag && angleExtent > 0) {
    angleExtent -= TWOPI;
  } else if (sweepFlag && angleExtent < 0) {
    angleExtent += TWOPI;
  }

  angleStart %= TWOPI;
  angleExtent %= TWOPI;

  var segments = Math.ceil(_abs(angleExtent) / (TWOPI / 4)),
      rawPath = [],
      angleIncrement = angleExtent / segments,
      controlLength = 4 / 3 * _sin(angleIncrement / 2) / (1 + _cos(angleIncrement / 2)),
      ma = cosAngle * rx,
      mb = sinAngle * rx,
      mc = sinAngle * -ry,
      md = cosAngle * ry,
      i;

  for (i = 0; i < segments; i++) {
    angle = angleStart + i * angleIncrement;
    x1 = _cos(angle);
    y1 = _sin(angle);
    ux = _cos(angle += angleIncrement);
    uy = _sin(angle);
    rawPath.push(x1 - controlLength * y1, y1 + controlLength * x1, ux + controlLength * uy, uy - controlLength * ux, ux, uy);
  } //now transform according to the actual size of the ellipse/arc (the beziers were noramlized, between 0 and 1 on a circle).


  for (i = 0; i < rawPath.length; i += 2) {
    x1 = rawPath[i];
    y1 = rawPath[i + 1];
    rawPath[i] = x1 * ma + y1 * mc + cx;
    rawPath[i + 1] = x1 * mb + y1 * md + cy;
  }

  rawPath[i - 2] = x; //always set the end to exactly where it's supposed to be

  rawPath[i - 1] = y;
  return rawPath;
} //Spits back a RawPath with absolute coordinates. Each segment starts with a "moveTo" command (x coordinate, then y) and then 2 control points (x, y, x, y), then anchor. The goal is to minimize memory and maximize speed.


function stringToRawPath(d) {
  var a = (d + "").replace(_scientific, function (m) {
    var n = +m;
    return n < 0.0001 && n > -0.0001 ? 0 : n;
  }).match(_svgPathExp) || [],
      //some authoring programs spit out very small numbers in scientific notation like "1e-5", so make sure we round that down to 0 first.
  path = [],
      relativeX = 0,
      relativeY = 0,
      twoThirds = 2 / 3,
      elements = a.length,
      points = 0,
      errorMessage = "ERROR: malformed path: " + d,
      i,
      j,
      x,
      y,
      command,
      isRelative,
      segment,
      startX,
      startY,
      difX,
      difY,
      beziers,
      prevCommand,
      flag1,
      flag2,
      line = function line(sx, sy, ex, ey) {
    difX = (ex - sx) / 3;
    difY = (ey - sy) / 3;
    segment.push(sx + difX, sy + difY, ex - difX, ey - difY, ex, ey);
  };

  if (!d || !isNaN(a[0]) || isNaN(a[1])) {
    console.log(errorMessage);
    return path;
  }

  for (i = 0; i < elements; i++) {
    prevCommand = command;

    if (isNaN(a[i])) {
      command = a[i].toUpperCase();
      isRelative = command !== a[i]; //lower case means relative
    } else {
      //commands like "C" can be strung together without any new command characters between.
      i--;
    }

    x = +a[i + 1];
    y = +a[i + 2];

    if (isRelative) {
      x += relativeX;
      y += relativeY;
    }

    if (!i) {
      startX = x;
      startY = y;
    } // "M" (move)


    if (command === "M") {
      if (segment) {
        if (segment.length < 8) {
          //if the path data was funky and just had a M with no actual drawing anywhere, skip it.
          path.length -= 1;
        } else {
          points += segment.length;
        }
      }

      relativeX = startX = x;
      relativeY = startY = y;
      segment = [x, y];
      path.push(segment);
      i += 2;
      command = "L"; //an "M" with more than 2 values gets interpreted as "lineTo" commands ("L").
      // "C" (cubic bezier)
    } else if (command === "C") {
      if (!segment) {
        segment = [0, 0];
      }

      if (!isRelative) {
        relativeX = relativeY = 0;
      } //note: "*1" is just a fast/short way to cast the value as a Number. WAAAY faster in Chrome, slightly slower in Firefox.


      segment.push(x, y, relativeX + a[i + 3] * 1, relativeY + a[i + 4] * 1, relativeX += a[i + 5] * 1, relativeY += a[i + 6] * 1);
      i += 6; // "S" (continuation of cubic bezier)
    } else if (command === "S") {
      difX = relativeX;
      difY = relativeY;

      if (prevCommand === "C" || prevCommand === "S") {
        difX += relativeX - segment[segment.length - 4];
        difY += relativeY - segment[segment.length - 3];
      }

      if (!isRelative) {
        relativeX = relativeY = 0;
      }

      segment.push(difX, difY, x, y, relativeX += a[i + 3] * 1, relativeY += a[i + 4] * 1);
      i += 4; // "Q" (quadratic bezier)
    } else if (command === "Q") {
      difX = relativeX + (x - relativeX) * twoThirds;
      difY = relativeY + (y - relativeY) * twoThirds;

      if (!isRelative) {
        relativeX = relativeY = 0;
      }

      relativeX += a[i + 3] * 1;
      relativeY += a[i + 4] * 1;
      segment.push(difX, difY, relativeX + (x - relativeX) * twoThirds, relativeY + (y - relativeY) * twoThirds, relativeX, relativeY);
      i += 4; // "T" (continuation of quadratic bezier)
    } else if (command === "T") {
      difX = relativeX - segment[segment.length - 4];
      difY = relativeY - segment[segment.length - 3];
      segment.push(relativeX + difX, relativeY + difY, x + (relativeX + difX * 1.5 - x) * twoThirds, y + (relativeY + difY * 1.5 - y) * twoThirds, relativeX = x, relativeY = y);
      i += 2; // "H" (horizontal line)
    } else if (command === "H") {
      line(relativeX, relativeY, relativeX = x, relativeY);
      i += 1; // "V" (vertical line)
    } else if (command === "V") {
      //adjust values because the first (and only one) isn't x in this case, it's y.
      line(relativeX, relativeY, relativeX, relativeY = x + (isRelative ? relativeY - relativeX : 0));
      i += 1; // "L" (line) or "Z" (close)
    } else if (command === "L" || command === "Z") {
      if (command === "Z") {
        x = startX;
        y = startY;
        segment.closed = true;
      }

      if (command === "L" || _abs(relativeX - x) > 0.5 || _abs(relativeY - y) > 0.5) {
        line(relativeX, relativeY, x, y);

        if (command === "L") {
          i += 2;
        }
      }

      relativeX = x;
      relativeY = y; // "A" (arc)
    } else if (command === "A") {
      flag1 = a[i + 4];
      flag2 = a[i + 5];
      difX = a[i + 6];
      difY = a[i + 7];
      j = 7;

      if (flag1.length > 1) {
        // for cases when the flags are merged, like "a8 8 0 018 8" (the 0 and 1 flags are WITH the x value of 8, but it could also be "a8 8 0 01-8 8" so it may include x or not)
        if (flag1.length < 3) {
          difY = difX;
          difX = flag2;
          j--;
        } else {
          difY = flag2;
          difX = flag1.substr(2);
          j -= 2;
        }

        flag2 = flag1.charAt(1);
        flag1 = flag1.charAt(0);
      }

      beziers = arcToSegment(relativeX, relativeY, +a[i + 1], +a[i + 2], +a[i + 3], +flag1, +flag2, (isRelative ? relativeX : 0) + difX * 1, (isRelative ? relativeY : 0) + difY * 1);
      i += j;

      if (beziers) {
        for (j = 0; j < beziers.length; j++) {
          segment.push(beziers[j]);
        }
      }

      relativeX = segment[segment.length - 2];
      relativeY = segment[segment.length - 1];
    } else {
      console.log(errorMessage);
    }
  }

  i = segment.length;

  if (i < 6) {
    //in case there's odd SVG like a M0,0 command at the very end.
    path.pop();
    i = 0;
  } else if (segment[0] === segment[i - 2] && segment[1] === segment[i - 1]) {
    segment.closed = true;
  }

  path.totalPoints = points + i;
  return path;
} //populates the points array in alternating x/y values (like [x, y, x, y...] instead of individual point objects [{x, y}, {x, y}...] to conserve memory and stay in line with how we're handling segment arrays

function bezierToPoints(x1, y1, x2, y2, x3, y3, x4, y4, threshold, points, index) {
  var x12 = (x1 + x2) / 2,
      y12 = (y1 + y2) / 2,
      x23 = (x2 + x3) / 2,
      y23 = (y2 + y3) / 2,
      x34 = (x3 + x4) / 2,
      y34 = (y3 + y4) / 2,
      x123 = (x12 + x23) / 2,
      y123 = (y12 + y23) / 2,
      x234 = (x23 + x34) / 2,
      y234 = (y23 + y34) / 2,
      x1234 = (x123 + x234) / 2,
      y1234 = (y123 + y234) / 2,
      dx = x4 - x1,
      dy = y4 - y1,
      d2 = _abs((x2 - x4) * dy - (y2 - y4) * dx),
      d3 = _abs((x3 - x4) * dy - (y3 - y4) * dx),
      length;

  if (!points) {
    points = [x1, y1, x4, y4];
    index = 2;
  }

  points.splice(index || points.length - 2, 0, x1234, y1234);

  if ((d2 + d3) * (d2 + d3) > threshold * (dx * dx + dy * dy)) {
    length = points.length;
    bezierToPoints(x1, y1, x12, y12, x123, y123, x1234, y1234, threshold, points, index);
    bezierToPoints(x1234, y1234, x234, y234, x34, y34, x4, y4, threshold, points, index + 2 + (points.length - length));
  }

  return points;
}
/*
function getAngleBetweenPoints(x0, y0, x1, y1, x2, y2) { //angle between 3 points in radians
	var dx1 = x1 - x0,
		dy1 = y1 - y0,
		dx2 = x2 - x1,
		dy2 = y2 - y1,
		dx3 = x2 - x0,
		dy3 = y2 - y0,
		a = dx1 * dx1 + dy1 * dy1,
		b = dx2 * dx2 + dy2 * dy2,
		c = dx3 * dx3 + dy3 * dy3;
	return Math.acos( (a + b - c) / _sqrt(4 * a * b) );
},
*/
//pointsToSegment() doesn't handle flat coordinates (where y is always 0) the way we need (the resulting control points are always right on top of the anchors), so this function basically makes the control points go directly up and down, varying in length based on the curviness (more curvy, further control points)

function flatPointsToSegment(points, curviness) {
  if (curviness === void 0) {
    curviness = 1;
  }

  var x = points[0],
      y = 0,
      segment = [x, y],
      i = 2;

  for (; i < points.length; i += 2) {
    segment.push(x, y, points[i], y = (points[i] - x) * curviness / 2, x = points[i], -y);
  }

  return segment;
} //points is an array of x/y points, like [x, y, x, y, x, y]

function pointsToSegment(points, curviness, cornerThreshold) {
  //points = simplifyPoints(points, tolerance);
  _abs(points[0] - points[2]) < 1e-4 && _abs(points[1] - points[3]) < 1e-4 && (points = points.slice(2)); // if the first two points are super close, dump the first one.

  var l = points.length - 2,
      x = +points[0],
      y = +points[1],
      nextX = +points[2],
      nextY = +points[3],
      segment = [x, y, x, y],
      dx2 = nextX - x,
      dy2 = nextY - y,
      closed = Math.abs(points[l] - x) < 0.001 && Math.abs(points[l + 1] - y) < 0.001,
      prevX,
      prevY,
      angle,
      slope,
      i,
      dx1,
      dx3,
      dy1,
      dy3,
      d1,
      d2,
      a,
      b,
      c;

  if (isNaN(cornerThreshold)) {
    cornerThreshold = Math.PI / 10;
  }

  if (closed) {
    // if the start and end points are basically on top of each other, close the segment by adding the 2nd point to the end, and the 2nd-to-last point to the beginning (we'll remove them at the end, but this allows the curvature to look perfect)
    points.push(nextX, nextY);
    nextX = x;
    nextY = y;
    x = points[l - 2];
    y = points[l - 1];
    points.unshift(x, y);
    l += 4;
  }

  curviness = curviness || curviness === 0 ? +curviness : 1;

  for (i = 2; i < l; i += 2) {
    prevX = x;
    prevY = y;
    x = nextX;
    y = nextY;
    nextX = +points[i + 2];
    nextY = +points[i + 3];

    if (x === nextX && y === nextY) {
      continue;
    }

    dx1 = dx2;
    dy1 = dy2;
    dx2 = nextX - x;
    dy2 = nextY - y;
    dx3 = nextX - prevX;
    dy3 = nextY - prevY;
    a = dx1 * dx1 + dy1 * dy1;
    b = dx2 * dx2 + dy2 * dy2;
    c = dx3 * dx3 + dy3 * dy3;
    angle = Math.acos((a + b - c) / _sqrt(4 * a * b)); //angle between the 3 points

    d2 = angle / Math.PI * curviness; //temporary precalculation for speed (reusing d2 variable)

    d1 = _sqrt(a) * d2; //the tighter the angle, the shorter we make the handles in proportion.

    d2 *= _sqrt(b);

    if (x !== prevX || y !== prevY) {
      if (angle > cornerThreshold) {
        slope = _atan2(dy3, dx3);
        segment.push(_round(x - _cos(slope) * d1), //first control point
        _round(y - _sin(slope) * d1), _round(x), //anchor
        _round(y), _round(x + _cos(slope) * d2), //second control point
        _round(y + _sin(slope) * d2));
      } else {
        slope = _atan2(dy1, dx1);
        segment.push(_round(x - _cos(slope) * d1), //first control point
        _round(y - _sin(slope) * d1));
        slope = _atan2(dy2, dx2);
        segment.push(_round(x), //anchor
        _round(y), _round(x + _cos(slope) * d2), //second control point
        _round(y + _sin(slope) * d2));
      }
    }
  }

  x !== nextX || y !== nextY || segment.length < 4 ? segment.push(_round(nextX), _round(nextY), _round(nextX), _round(nextY)) : segment.length -= 2;

  if (closed) {
    segment.splice(0, 6);
    segment.length = segment.length - 6;
  }

  return segment;
} //returns the squared distance between an x/y coordinate and a segment between x1/y1 and x2/y2

function pointToSegDist(x, y, x1, y1, x2, y2) {
  var dx = x2 - x1,
      dy = y2 - y1,
      t;

  if (dx || dy) {
    t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);

    if (t > 1) {
      x1 = x2;
      y1 = y2;
    } else if (t > 0) {
      x1 += dx * t;
      y1 += dy * t;
    }
  }

  return Math.pow(x - x1, 2) + Math.pow(y - y1, 2);
}

function simplifyStep(points, first, last, tolerance, simplified) {
  var maxSqDist = tolerance,
      firstX = points[first],
      firstY = points[first + 1],
      lastX = points[last],
      lastY = points[last + 1],
      index,
      i,
      d;

  for (i = first + 2; i < last; i += 2) {
    d = pointToSegDist(points[i], points[i + 1], firstX, firstY, lastX, lastY);

    if (d > maxSqDist) {
      index = i;
      maxSqDist = d;
    }
  }

  if (maxSqDist > tolerance) {
    index - first > 2 && simplifyStep(points, first, index, tolerance, simplified);
    simplified.push(points[index], points[index + 1]);
    last - index > 2 && simplifyStep(points, index, last, tolerance, simplified);
  }
} //points is an array of x/y values like [x, y, x, y, x, y]


function simplifyPoints(points, tolerance) {
  var prevX = parseFloat(points[0]),
      prevY = parseFloat(points[1]),
      temp = [prevX, prevY],
      l = points.length - 2,
      i,
      x,
      y,
      dx,
      dy,
      result,
      last;
  tolerance = Math.pow(tolerance || 1, 2);

  for (i = 2; i < l; i += 2) {
    x = parseFloat(points[i]);
    y = parseFloat(points[i + 1]);
    dx = prevX - x;
    dy = prevY - y;

    if (dx * dx + dy * dy > tolerance) {
      temp.push(x, y);
      prevX = x;
      prevY = y;
    }
  }

  temp.push(parseFloat(points[l]), parseFloat(points[l + 1]));
  last = temp.length - 2;
  result = [temp[0], temp[1]];
  simplifyStep(temp, 0, last, tolerance, result);
  result.push(temp[last], temp[last + 1]);
  return result;
}

function getClosestProgressOnBezier(iterations, px, py, start, end, slices, x0, y0, x1, y1, x2, y2, x3, y3) {
  var inc = (end - start) / slices,
      best = 0,
      t = start,
      x,
      y,
      d,
      dx,
      dy,
      inv;
  _bestDistance = _largeNum;

  while (t <= end) {
    inv = 1 - t;
    x = inv * inv * inv * x0 + 3 * inv * inv * t * x1 + 3 * inv * t * t * x2 + t * t * t * x3;
    y = inv * inv * inv * y0 + 3 * inv * inv * t * y1 + 3 * inv * t * t * y2 + t * t * t * y3;
    dx = x - px;
    dy = y - py;
    d = dx * dx + dy * dy;

    if (d < _bestDistance) {
      _bestDistance = d;
      best = t;
    }

    t += inc;
  }

  return iterations > 1 ? getClosestProgressOnBezier(iterations - 1, px, py, Math.max(best - inc, 0), Math.min(best + inc, 1), slices, x0, y0, x1, y1, x2, y2, x3, y3) : best;
}

function getClosestData(rawPath, x, y, slices) {
  //returns an object with the closest j, i, and t (j is the segment index, i is the index of the point in that segment, and t is the time/progress along that bezier)
  var closest = {
    j: 0,
    i: 0,
    t: 0
  },
      bestDistance = _largeNum,
      i,
      j,
      t,
      segment;

  for (j = 0; j < rawPath.length; j++) {
    segment = rawPath[j];

    for (i = 0; i < segment.length; i += 6) {
      t = getClosestProgressOnBezier(1, x, y, 0, 1, slices || 20, segment[i], segment[i + 1], segment[i + 2], segment[i + 3], segment[i + 4], segment[i + 5], segment[i + 6], segment[i + 7]);

      if (bestDistance > _bestDistance) {
        bestDistance = _bestDistance;
        closest.j = j;
        closest.i = i;
        closest.t = t;
      }
    }
  }

  return closest;
} //subdivide a Segment closest to a specific x,y coordinate

function subdivideSegmentNear(x, y, segment, slices, iterations) {
  var l = segment.length,
      bestDistance = _largeNum,
      bestT = 0,
      bestSegmentIndex = 0,
      t,
      i;
  slices = slices || 20;
  iterations = iterations || 3;

  for (i = 0; i < l; i += 6) {
    t = getClosestProgressOnBezier(1, x, y, 0, 1, slices, segment[i], segment[i + 1], segment[i + 2], segment[i + 3], segment[i + 4], segment[i + 5], segment[i + 6], segment[i + 7]);

    if (bestDistance > _bestDistance) {
      bestDistance = _bestDistance;
      bestT = t;
      bestSegmentIndex = i;
    }
  }

  t = getClosestProgressOnBezier(iterations, x, y, bestT - 0.05, bestT + 0.05, slices, segment[bestSegmentIndex], segment[bestSegmentIndex + 1], segment[bestSegmentIndex + 2], segment[bestSegmentIndex + 3], segment[bestSegmentIndex + 4], segment[bestSegmentIndex + 5], segment[bestSegmentIndex + 6], segment[bestSegmentIndex + 7]);
  subdivideSegment(segment, bestSegmentIndex, t);
  return bestSegmentIndex + 6;
}
/*
Takes any of the following and converts it to an all Cubic Bezier SVG data string:
- A <path> data string like "M0,0 L2,4 v20,15 H100"
- A RawPath, like [[x, y, x, y, x, y, x, y][[x, y, x, y, x, y, x, y]]
- A Segment, like [x, y, x, y, x, y, x, y]

Note: all numbers are rounded down to the closest 0.001 to minimize memory, maximize speed, and avoid odd numbers like 1e-13
*/

function rawPathToString(rawPath) {
  if (_isNumber(rawPath[0])) {
    //in case a segment is passed in instead
    rawPath = [rawPath];
  }

  var result = "",
      l = rawPath.length,
      sl,
      s,
      i,
      segment;

  for (s = 0; s < l; s++) {
    segment = rawPath[s];
    result += "M" + _round(segment[0]) + "," + _round(segment[1]) + " C";
    sl = segment.length;

    for (i = 2; i < sl; i++) {
      result += _round(segment[i++]) + "," + _round(segment[i++]) + " " + _round(segment[i++]) + "," + _round(segment[i++]) + " " + _round(segment[i++]) + "," + _round(segment[i]) + " ";
    }

    if (segment.closed) {
      result += "z";
    }
  }

  return result;
}
/*
// takes a segment with coordinates [x, y, x, y, ...] and converts the control points into angles and lengths [x, y, angle, length, angle, length, x, y, angle, length, ...] so that it animates more cleanly and avoids odd breaks/kinks. For example, if you animate from 1 o'clock to 6 o'clock, it'd just go directly/linearly rather than around. So the length would be very short in the middle of the tween.
export function cpCoordsToAngles(segment, copy) {
	var result = copy ? segment.slice(0) : segment,
		x, y, i;
	for (i = 0; i < segment.length; i+=6) {
		x = segment[i+2] - segment[i];
		y = segment[i+3] - segment[i+1];
		result[i+2] = Math.atan2(y, x);
		result[i+3] = Math.sqrt(x * x + y * y);
		x = segment[i+6] - segment[i+4];
		y = segment[i+7] - segment[i+5];
		result[i+4] = Math.atan2(y, x);
		result[i+5] = Math.sqrt(x * x + y * y);
	}
	return result;
}

// takes a segment that was converted with cpCoordsToAngles() to have angles and lengths instead of coordinates for the control points, and converts it BACK into coordinates.
export function cpAnglesToCoords(segment, copy) {
	var result = copy ? segment.slice(0) : segment,
		length = segment.length,
		rnd = 1000,
		angle, l, i, j;
	for (i = 0; i < length; i+=6) {
		angle = segment[i+2];
		l = segment[i+3]; //length
		result[i+2] = (((segment[i] + Math.cos(angle) * l) * rnd) | 0) / rnd;
		result[i+3] = (((segment[i+1] + Math.sin(angle) * l) * rnd) | 0) / rnd;
		angle = segment[i+4];
		l = segment[i+5]; //length
		result[i+4] = (((segment[i+6] - Math.cos(angle) * l) * rnd) | 0) / rnd;
		result[i+5] = (((segment[i+7] - Math.sin(angle) * l) * rnd) | 0) / rnd;
	}
	return result;
}

//adds an "isSmooth" array to each segment and populates it with a boolean value indicating whether or not it's smooth (the control points have basically the same slope). For any smooth control points, it converts the coordinates into angle (x, in radians) and length (y) and puts them into the same index value in a smoothData array.
export function populateSmoothData(rawPath) {
	let j = rawPath.length,
		smooth, segment, x, y, x2, y2, i, l, a, a2, isSmooth, smoothData;
	while (--j > -1) {
		segment = rawPath[j];
		isSmooth = segment.isSmooth = segment.isSmooth || [0, 0, 0, 0];
		smoothData = segment.smoothData = segment.smoothData || [0, 0, 0, 0];
		isSmooth.length = 4;
		l = segment.length - 2;
		for (i = 6; i < l; i += 6) {
			x = segment[i] - segment[i - 2];
			y = segment[i + 1] - segment[i - 1];
			x2 = segment[i + 2] - segment[i];
			y2 = segment[i + 3] - segment[i + 1];
			a = _atan2(y, x);
			a2 = _atan2(y2, x2);
			smooth = (Math.abs(a - a2) < 0.09);
			if (smooth) {
				smoothData[i - 2] = a;
				smoothData[i + 2] = a2;
				smoothData[i - 1] = _sqrt(x * x + y * y);
				smoothData[i + 3] = _sqrt(x2 * x2 + y2 * y2);
			}
			isSmooth.push(smooth, smooth, 0, 0, smooth, smooth);
		}
		//if the first and last points are identical, check to see if there's a smooth transition. We must handle this a bit differently due to their positions in the array.
		if (segment[l] === segment[0] && segment[l+1] === segment[1]) {
			x = segment[0] - segment[l-2];
			y = segment[1] - segment[l-1];
			x2 = segment[2] - segment[0];
			y2 = segment[3] - segment[1];
			a = _atan2(y, x);
			a2 = _atan2(y2, x2);
			if (Math.abs(a - a2) < 0.09) {
				smoothData[l-2] = a;
				smoothData[2] = a2;
				smoothData[l-1] = _sqrt(x * x + y * y);
				smoothData[3] = _sqrt(x2 * x2 + y2 * y2);
				isSmooth[l-2] = isSmooth[l-1] = true; //don't change indexes 2 and 3 because we'll trigger everything from the END, and this will optimize file size a bit.
			}
		}
	}
	return rawPath;
}
export function pointToScreen(svgElement, point) {
	if (arguments.length < 2) { //by default, take the first set of coordinates in the path as the point
		let rawPath = getRawPath(svgElement);
		point = svgElement.ownerSVGElement.createSVGPoint();
		point.x = rawPath[0][0];
		point.y = rawPath[0][1];
	}
	return point.matrixTransform(svgElement.getScreenCTM());
}

*/

/***/ }),

/***/ "./node_modules/gsap/utils/strings.js":
/*!********************************************!*\
  !*** ./node_modules/gsap/utils/strings.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "emojiExp": () => (/* binding */ emojiExp),
/* harmony export */   "emojiSafeSplit": () => (/* binding */ emojiSafeSplit),
/* harmony export */   "getText": () => (/* binding */ getText),
/* harmony export */   "splitInnerHTML": () => (/* binding */ splitInnerHTML)
/* harmony export */ });
/*!
 * strings: 3.9.1
 * https://greensock.com
 *
 * Copyright 2008-2021, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */
var _trimExp = /(^\s+|\s+$)/g;
var emojiExp = /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;
function getText(e) {
  var type = e.nodeType,
      result = "";

  if (type === 1 || type === 9 || type === 11) {
    if (typeof e.textContent === "string") {
      return e.textContent;
    } else {
      for (e = e.firstChild; e; e = e.nextSibling) {
        result += getText(e);
      }
    }
  } else if (type === 3 || type === 4) {
    return e.nodeValue;
  }

  return result;
}
function splitInnerHTML(element, delimiter, trim, preserveSpaces) {
  var node = element.firstChild,
      result = [],
      s;

  while (node) {
    if (node.nodeType === 3) {
      s = (node.nodeValue + "").replace(/^\n+/g, "");

      if (!preserveSpaces) {
        s = s.replace(/\s+/g, " ");
      }

      result.push.apply(result, emojiSafeSplit(s, delimiter, trim, preserveSpaces));
    } else if ((node.nodeName + "").toLowerCase() === "br") {
      result[result.length - 1] += "<br>";
    } else {
      result.push(node.outerHTML);
    }

    node = node.nextSibling;
  }

  s = result.length;

  while (s--) {
    result[s] === "&" && result.splice(s, 1, "&amp;");
  }

  return result;
}
/*
//smaller kb version that only handles the simpler emoji's, which is often perfectly adequate.

let _emoji = "[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2694-\u2697]|\uD83E[\uDD10-\uDD5D]|[\uD800-\uDBFF][\uDC00-\uDFFF]",
	_emojiExp = new RegExp(_emoji),
	_emojiAndCharsExp = new RegExp(_emoji + "|.", "g"),
	_emojiSafeSplit = (text, delimiter, trim) => {
		if (trim) {
			text = text.replace(_trimExp, "");
		}
		return ((delimiter === "" || !delimiter) && _emojiExp.test(text)) ? text.match(_emojiAndCharsExp) : text.split(delimiter || "");
	};
 */

function emojiSafeSplit(text, delimiter, trim, preserveSpaces) {
  text += ""; // make sure it's cast as a string. Someone may pass in a number.

  if (trim) {
    text = text.replace(_trimExp, "");
  }

  if (delimiter && delimiter !== "") {
    return text.replace(/>/g, "&gt;").replace(/</g, "&lt;").split(delimiter);
  }

  var result = [],
      l = text.length,
      i = 0,
      j,
      character;

  for (; i < l; i++) {
    character = text.charAt(i);

    if (character.charCodeAt(0) >= 0xD800 && character.charCodeAt(0) <= 0xDBFF || text.charCodeAt(i + 1) >= 0xFE00 && text.charCodeAt(i + 1) <= 0xFE0F) {
      //special emoji characters use 2 or 4 unicode characters that we must keep together.
      j = ((text.substr(i, 12).split(emojiExp) || [])[1] || "").length || 2;
      character = text.substr(i, j);
      result.emoji = 1;
      i += j - 1;
    }

    result.push(character === ">" ? "&gt;" : character === "<" ? "&lt;" : preserveSpaces && character === " " && (text.charAt(i - 1) === " " || text.charAt(i + 1) === " ") ? "&nbsp;" : character);
  }

  return result;
}

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl + "../";
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other entry modules.
(() => {
var __webpack_exports__ = {};
/*!*************************!*\
  !*** ./src/js/index.js ***!
  \*************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var gsap_all__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gsap/all */ "./node_modules/gsap/all.js");

gsap_all__WEBPACK_IMPORTED_MODULE_0__.gsap.from('.navigation', {
  opacity: 0,
  y: '-100%',
  duration: 1,
  ease: 'Bounce.easeOut'
});
gsap_all__WEBPACK_IMPORTED_MODULE_0__.gsap.registerEffect({
  name: "fade",
  defaults: {
    duration: 2
  },
  //defaults get applied to the "config" object passed to the effect below
  effect: function effect(targets, config) {
    return gsap_all__WEBPACK_IMPORTED_MODULE_0__.gsap.to(targets, {
      duration: config.duration,
      opacity: 0
    });
  }
}); //now we can use it like this:
//gsap.effects.fade(".box");

var i = 0.1;
document.querySelectorAll(".box").forEach(function (box) {
  i++;
  console.log(1);
  gsap_all__WEBPACK_IMPORTED_MODULE_0__.gsap.from(box, {
    opacity: 0,
    y: '-100%',
    duration: i,
    ease: 'Bounce.easeOut'
  });
  box.addEventListener("mouseenter", function () {
    gsap_all__WEBPACK_IMPORTED_MODULE_0__.gsap.effects.fade(this);
  });
});
})();

// This entry need to be wrapped in an IIFE because it need to be isolated against other entry modules.
(() => {
/*!****************************!*\
  !*** ./src/sass/main.scss ***!
  \****************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "css/main.css");
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDOztBQUVoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSwwREFBMEQ7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZFQUE2RTs7QUFFN0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUVBQXVFOztBQUV2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiw2REFBNkQsK0VBQStFLHlDQUF5QyxJQUFJOztBQUV6TDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RDtBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlFQUFlOztBQUU5QixzRUFBc0Usc0RBQVE7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQzs7QUFFakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlFQUFlOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpREFBaUQsaUVBQWU7QUFDaEU7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDs7QUFFckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1FQUFtRTs7QUFFbkU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4RkFBOEY7O0FBRTlGOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsUUFBUTtBQUNSOztBQUVBLHFEQUFxRDs7QUFFckQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1RUFBdUU7QUFDdkU7O0FBRUE7O0FBRUE7QUFDQSxxREFBcUQ7OztBQUdyRDs7QUFFQTs7QUFFQSx3Q0FBd0M7OztBQUd4QztBQUNBO0FBQ0E7O0FBRUEseU5BQXlOOztBQUV6Tjs7QUFFQTtBQUNBOztBQUVBLGlFQUFpRTs7QUFFakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsK0JBQStCO0FBQy9CLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBLGlDQUFpQzs7O0FBR2pDLCtDQUErQzs7QUFFL0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFOztBQUVqRTtBQUNBO0FBQ0EsT0FBTyxTQUFTOztBQUVoQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUVBQW1FOztBQUVuRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnR0FBZ0c7OztBQUdoRztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxRUFBcUU7O0FBRXJFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTs7QUFFbkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdEQUF3RDs7QUFFeEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isa0RBQWtEOztBQUVsRDtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4RUFBOEU7O0FBRTlFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHOzs7QUFHaEc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpRUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsaUJBQWlCLGlFQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjs7QUFFdEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlSQUF5Ujs7O0FBR3pSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx5REFBeUQ7OztBQUd6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLFVBQVU7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtEQUErRDs7QUFFL0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFtRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLHNCQUFzQjs7QUFFdEI7QUFDTztBQUNQO0FBQ087QUFDUCw0QkFBNEI7O0FBRTVCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7OztBQ2xOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsT0FBTztBQUNyQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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R0FBMEc7O0FBRTFHO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNEJBQTRCO0FBQ2hDO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsYUFBYSxpRUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywwREFBMEQsYUFBYTs7O0FBR2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPLEdBQUc7O0FBRVY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCOzs7QUFHQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxxREFBcUQsaUVBQWUsMkJBQTJCOztBQUUvRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwyQkFBMkIsaUVBQWU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU8sR0FBRztBQUNWOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7O0FBR0E7QUFDQTtBQUNBLEtBQUssR0FBRzs7O0FBR1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSTtBQUNKLG1FQUFtRTs7QUFFbkU7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7O0FBRXBDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGtDQUFrQztBQUNsQywwQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw4REFBOEQ7QUFDbkc7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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LEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFTTtBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxpRUFBZSxpQ0FB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsT0FBTztBQUNyQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLENBQUM7QUFDRDtBQUNBLE9BQU87OztBQUdQLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLHdHQUF3RztBQUN4RztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNGQUFzRjtBQUN0RjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsMkRBQTJEOztBQUUzRDtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDbmNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsT0FBTztBQUNQLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDclFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjs7QUFFMUIsa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsMkJBQTJCLG9CQUFvQiwrQkFBK0Isb0JBQW9CLG1CQUFtQiw2QkFBNkIsYUFBYSxnQkFBZ0IsZUFBZSxtQkFBbUI7O0FBRXpQLHdGQUF3RixjQUFjO0FBQ3RHLDhKQUE4SjtBQUM5SixpREFBaUQsZ0JBQWdCLHlDQUF5QztBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxXQUFXLG1CQUFtQjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2R0FBNkc7QUFDN0c7QUFDQTs7QUFFQSx1QkFBdUI7OztBQUd2QixnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBLGVBQWUsdUJBQXVCO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUcsR0FBRzs7O0FBR047QUFDQTtBQUNBLEdBQUcsR0FBRzs7O0FBR047QUFDQTtBQUNBLEdBQUcsR0FBRzs7QUFFTjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTs7QUFFaEUsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDZDQUE2Qyx5Q0FBeUM7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDOztBQUV2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQsNkJBQTZCLDBCQUEwQixXQUFXLG9CQUFvQjtBQUN0RjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHLEdBQUc7OztBQUdOO0FBQ0E7O0FBRUE7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTyxHQUFHOztBQUVWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSwrSkFBK0o7O0FBRS9KO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRzs7QUFFMUc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQscUZBQXFGOztBQUVoSjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7O0FBRXJFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0JBQXdCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUVBQXlFOztBQUV6RTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDZFQUE2RTs7QUFFN0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBLDBHQUEwRzs7QUFFMUc7O0FBRUEsbUNBQW1DOztBQUVuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEOztBQUV2RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7O0FBRUE7QUFDQTtBQUNBLHVGQUF1Rjs7QUFFdkY7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUxBQW1MOztBQUVuTDtBQUNBO0FBQ0EsK0VBQStFOztBQUUvRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7O0FBRWhFO0FBQ0E7O0FBRUE7QUFDQSx1R0FBdUc7O0FBRXZHO0FBQ0EsNElBQTRJOztBQUU1STtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWiw2SEFBNkg7O0FBRTdIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUyxHQUFHOztBQUVaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7O0FBRXhGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMENBQTBDO0FBQzFDOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVULG9DQUFvQztBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUssMkNBQTJDO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7O0FBRTNEO0FBQ0E7O0FBRUE7O0FBRUEsbURBQW1EOzs7QUFHbkQ7QUFDQTtBQUNBO0FBQ0EsOENBQThDOztBQUU5QztBQUNBLHNFQUFzRTs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVgsMkRBQTJEOzs7QUFHM0QsMkRBQTJEOzs7QUFHM0Q7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFdBQVc7O0FBRVg7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDajREQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDNkU7O0FBRTdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNB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QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLCtKQUErSjtBQUMvSjtBQUNBOztBQUVBLFNBQVMsMkNBQTJDOztBQUVwRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsMklBQTJJO0FBQzNJOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLG1EQUFtRDtBQUNuRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxrREFBa0Q7QUFDbEQ7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpRUFBaUU7O0FBRWpFLHNFQUFzRTs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZFQUE2RTtBQUM3RTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsb0VBQW9FO0FBQ3BFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLDJCQUEyQjtBQUMzQjs7QUFFQSx5REFBeUQ7QUFDekQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdNQUF3TTtBQUN4TTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwR0FBMEc7QUFDMUcsc0dBQXNHO0FBQ3RHO0FBQ0E7O0FBRUE7QUFDQSxnRUFBZ0U7O0FBRWhFOztBQUVBLG1CQUFtQjs7O0FBR25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDZFQUE2RTs7QUFFN0Usa0NBQWtDO0FBQ2xDLFFBQVE7QUFDUjs7QUFFQSw4QkFBOEI7O0FBRTlCLCtNQUErTTtBQUMvTTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRGQUE0Rjs7QUFFNUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscURBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0dBQWdHOztBQUVoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCOztBQUUvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjs7QUFFM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxZQUFZOzs7QUFHWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxREFBcUQsNk5BQTZOLE9BQU8sV0FBVyxLQUFLO0FBQy9UOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7O0FBRTFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNkRBQTZEOztBQUU3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GOztBQUVwRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlIQUF5SDs7QUFFekg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUEsMEVBQTBFO0FBQzFFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0VBQWdFO0FBQ2hFO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7O0FBRTVCLCtDQUErQzs7QUFFL0M7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVB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RUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRJQUE0STs7QUFFNUksaUlBQWlJOztBQUVqSTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrREFBK0Q7O0FBRS9EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsNkdBQTZHOztBQUU3RztBQUNBOztBQUVBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7OztBQUdJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1Q0FBdUM7O0FBRXZDO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLElBQUk7O0FBRUw7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJFQUEyRSxlQUFlO0FBQzFGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0RBQXdEOztBQUV4RCx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLEdBQUc7QUFDSDtBQUNBLDBDQUEwQztBQUMxQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSw2REFBNkQ7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjs7QUFFaEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0EsQ0FBQyxHQUFHOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7OztBQUdkO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdJO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx1SUFBdUk7O0FBRXhJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNtSjtBQUNxSCxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcjRIelE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FOztBQUVwRSxtQ0FBbUM7O0FBRW5DO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsY0FBYyxvQkFBb0IsU0FBUyxVQUFVO0FBQ3RGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsYUFBYSxnQkFBZ0I7O0FBRTFFO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMscUJBQXFCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7QUFDdkMsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsOERBQThEOztBQUU5RCw0R0FBNEc7O0FBRTVHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDLElBQUk7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQzJFLENBQUM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9aQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRCxjQUFjO0FBQ2QsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxrU0FBa1MsTUFBTTtBQUN4UztBQUNBO0FBQ0E7QUFDQTs7O0FBR087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVLO0FBQ1A7QUFDQTs7QUFFQSxTQUFTLG9CQUFvQjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCLFNBQVMsb0JBQW9CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0k7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osMkVBQTJFO0FBQzNFLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUs7QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQLHlEQUF5RDs7QUFFekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLCtEQUErRDs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxXQUFXLCtCQUErQjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsZUFBZTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ1A7O0FBRUEsb0NBQW9DLG9CQUFvQjtBQUN4RCxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVLO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLHNCQUFzQjs7QUFFeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFSztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEM7O0FBRTVDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0osY0FBYyxvQkFBb0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQSxFQUFFOzs7QUFHSztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLGNBQWM7QUFDNUI7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0EsY0FBYztBQUNkLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZCxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsTUFBTTtBQUNOO0FBQ0EsY0FBYztBQUNkLE1BQU07QUFDTjtBQUNBO0FBQ0EsY0FBYztBQUNkLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRSxtSEFBbUgsS0FBSyxHQUFHLEtBQUs7O0FBRTNIO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsbUJBQW1CO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVLO0FBQ1A7QUFDQSwwR0FBMEc7O0FBRTFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDs7QUFFdkQsc0NBQXNDOztBQUV0Qyx3QkFBd0I7O0FBRXhCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsVUFBVTtBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHSztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QUNDLEdBQVIsQ0FBWSxDQUFaO0FBQ0F0QixFQUFBQSwrQ0FBQSxDQUFVb0IsR0FBVixFQUFlO0FBQUVmLElBQUFBLE9BQU8sRUFBRSxDQUFYO0FBQWNDLElBQUFBLENBQUMsRUFBRSxPQUFqQjtBQUEwQkMsSUFBQUEsUUFBUSxFQUFFUyxDQUFwQztBQUF1Q1IsSUFBQUEsSUFBSSxFQUFFO0FBQTdDLEdBQWY7QUFDQVksRUFBQUEsR0FBRyxDQUFDRyxnQkFBSixDQUFxQixZQUFyQixFQUFtQyxZQUFXO0FBQzFDdkIsSUFBQUEsdURBQUEsQ0FBa0IsSUFBbEI7QUFDSCxHQUZEO0FBR0gsQ0FQRCxFOzs7Ozs7Ozs7Ozs7QUNmQSxpRUFBZSxxQkFBdUIsaUJBQWlCLEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9nc2FwMDEvLi9ub2RlX21vZHVsZXMvZ3NhcC9DU1NQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vZ3NhcDAxLy4vbm9kZV9tb2R1bGVzL2dzYXAvQ1NTUnVsZVBsdWdpbi5qcyIsIndlYnBhY2s6Ly9nc2FwMDEvLi9ub2RlX21vZHVsZXMvZ3NhcC9DdXN0b21FYXNlLmpzIiwid2VicGFjazovL2dzYXAwMS8uL25vZGVfbW9kdWxlcy9nc2FwL0RyYWdnYWJsZS5qcyIsIndlYnBhY2s6Ly9nc2FwMDEvLi9ub2RlX21vZHVsZXMvZ3NhcC9FYXNlUGFjay5qcyIsIndlYnBhY2s6Ly9nc2FwMDEvLi9ub2RlX21vZHVsZXMvZ3NhcC9FYXNlbFBsdWdpbi5qcyIsIndlYnBhY2s6Ly9nc2FwMDEvLi9ub2RlX21vZHVsZXMvZ3NhcC9GbGlwLmpzIiwid2VicGFjazovL2dzYXAwMS8uL25vZGVfbW9kdWxlcy9nc2FwL01vdGlvblBhdGhQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vZ3NhcDAxLy4vbm9kZV9tb2R1bGVzL2dzYXAvUGl4aVBsdWdpbi5qcyIsIndlYnBhY2s6Ly9nc2FwMDEvLi9ub2RlX21vZHVsZXMvZ3NhcC9TY3JvbGxUb1BsdWdpbi5qcyIsIndlYnBhY2s6Ly9nc2FwMDEvLi9ub2RlX21vZHVsZXMvZ3NhcC9TY3JvbGxUcmlnZ2VyLmpzIiwid2VicGFjazovL2dzYXAwMS8uL25vZGVfbW9kdWxlcy9nc2FwL1RleHRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vZ3NhcDAxLy4vbm9kZV9tb2R1bGVzL2dzYXAvYWxsLmpzIiwid2VicGFjazovL2dzYXAwMS8uL25vZGVfbW9kdWxlcy9nc2FwL2dzYXAtY29yZS5qcyIsIndlYnBhY2s6Ly9nc2FwMDEvLi9ub2RlX21vZHVsZXMvZ3NhcC91dGlscy9tYXRyaXguanMiLCJ3ZWJwYWNrOi8vZ3NhcDAxLy4vbm9kZV9tb2R1bGVzL2dzYXAvdXRpbHMvcGF0aHMuanMiLCJ3ZWJwYWNrOi8vZ3NhcDAxLy4vbm9kZV9tb2R1bGVzL2dzYXAvdXRpbHMvc3RyaW5ncy5qcyIsIndlYnBhY2s6Ly9nc2FwMDEvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vZ3NhcDAxL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9nc2FwMDEvd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9nc2FwMDEvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9nc2FwMDEvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9nc2FwMDEvd2VicGFjay9ydW50aW1lL3B1YmxpY1BhdGgiLCJ3ZWJwYWNrOi8vZ3NhcDAxLy4vc3JjL2pzL2luZGV4LmpzIiwid2VicGFjazovL2dzYXAwMS8uL3NyYy9zYXNzL21haW4uc2NzcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENTU1BsdWdpbiAzLjkuMVxuICogaHR0cHM6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMDgtMjAyMSwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmltcG9ydCB7IGdzYXAsIF9nZXRQcm9wZXJ0eSwgX251bUV4cCwgX251bVdpdGhVbml0RXhwLCBnZXRVbml0LCBfaXNTdHJpbmcsIF9pc1VuZGVmaW5lZCwgX3JlbmRlckNvbXBsZXhTdHJpbmcsIF9yZWxFeHAsIF9mb3JFYWNoTmFtZSwgX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSwgX2NvbG9yU3RyaW5nRmlsdGVyLCBfY2hlY2tQbHVnaW4sIF9yZXBsYWNlUmFuZG9tLCBfcGx1Z2lucywgR1NDYWNoZSwgUHJvcFR3ZWVuLCBfY29uZmlnLCBfdGlja2VyLCBfcm91bmQsIF9taXNzaW5nUGx1Z2luLCBfZ2V0U2V0dGVyLCBfZ2V0Q2FjaGUsIF9jb2xvckV4cCwgX3NldERlZmF1bHRzLCBfcmVtb3ZlTGlua2VkTGlzdEl0ZW0gLy9mb3IgdGhlIGNvbW1lbnRlZC1vdXQgY2xhc3NOYW1lIGZlYXR1cmUuXG59IGZyb20gXCIuL2dzYXAtY29yZS5qc1wiO1xuXG52YXIgX3dpbixcbiAgICBfZG9jLFxuICAgIF9kb2NFbGVtZW50LFxuICAgIF9wbHVnaW5Jbml0dGVkLFxuICAgIF90ZW1wRGl2LFxuICAgIF90ZW1wRGl2U3R5bGVyLFxuICAgIF9yZWNlbnRTZXR0ZXJQbHVnaW4sXG4gICAgX3dpbmRvd0V4aXN0cyA9IGZ1bmN0aW9uIF93aW5kb3dFeGlzdHMoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xufSxcbiAgICBfdHJhbnNmb3JtUHJvcHMgPSB7fSxcbiAgICBfUkFEMkRFRyA9IDE4MCAvIE1hdGguUEksXG4gICAgX0RFRzJSQUQgPSBNYXRoLlBJIC8gMTgwLFxuICAgIF9hdGFuMiA9IE1hdGguYXRhbjIsXG4gICAgX2JpZ051bSA9IDFlOCxcbiAgICBfY2Fwc0V4cCA9IC8oW0EtWl0pL2csXG4gICAgX2hvcml6b250YWxFeHAgPSAvKD86bGVmdHxyaWdodHx3aWR0aHxtYXJnaW58cGFkZGluZ3x4KS9pLFxuICAgIF9jb21wbGV4RXhwID0gL1tcXHMsXFwoXVxcUy8sXG4gICAgX3Byb3BlcnR5QWxpYXNlcyA9IHtcbiAgYXV0b0FscGhhOiBcIm9wYWNpdHksdmlzaWJpbGl0eVwiLFxuICBzY2FsZTogXCJzY2FsZVgsc2NhbGVZXCIsXG4gIGFscGhhOiBcIm9wYWNpdHlcIlxufSxcbiAgICBfcmVuZGVyQ1NTUHJvcCA9IGZ1bmN0aW9uIF9yZW5kZXJDU1NQcm9wKHJhdGlvLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgTWF0aC5yb3VuZCgoZGF0YS5zICsgZGF0YS5jICogcmF0aW8pICogMTAwMDApIC8gMTAwMDAgKyBkYXRhLnUsIGRhdGEpO1xufSxcbiAgICBfcmVuZGVyUHJvcFdpdGhFbmQgPSBmdW5jdGlvbiBfcmVuZGVyUHJvcFdpdGhFbmQocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCByYXRpbyA9PT0gMSA/IGRhdGEuZSA6IE1hdGgucm91bmQoKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSAqIDEwMDAwKSAvIDEwMDAwICsgZGF0YS51LCBkYXRhKTtcbn0sXG4gICAgX3JlbmRlckNTU1Byb3BXaXRoQmVnaW5uaW5nID0gZnVuY3Rpb24gX3JlbmRlckNTU1Byb3BXaXRoQmVnaW5uaW5nKHJhdGlvLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgcmF0aW8gPyBNYXRoLnJvdW5kKChkYXRhLnMgKyBkYXRhLmMgKiByYXRpbykgKiAxMDAwMCkgLyAxMDAwMCArIGRhdGEudSA6IGRhdGEuYiwgZGF0YSk7XG59LFxuICAgIC8vaWYgdW5pdHMgY2hhbmdlLCB3ZSBuZWVkIGEgd2F5IHRvIHJlbmRlciB0aGUgb3JpZ2luYWwgdW5pdC92YWx1ZSB3aGVuIHRoZSB0d2VlbiBnb2VzIGFsbCB0aGUgd2F5IGJhY2sgdG8gdGhlIGJlZ2lubmluZyAocmF0aW86MClcbl9yZW5kZXJSb3VuZGVkQ1NTUHJvcCA9IGZ1bmN0aW9uIF9yZW5kZXJSb3VuZGVkQ1NTUHJvcChyYXRpbywgZGF0YSkge1xuICB2YXIgdmFsdWUgPSBkYXRhLnMgKyBkYXRhLmMgKiByYXRpbztcbiAgZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIH5+KHZhbHVlICsgKHZhbHVlIDwgMCA/IC0uNSA6IC41KSkgKyBkYXRhLnUsIGRhdGEpO1xufSxcbiAgICBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZSA9IGZ1bmN0aW9uIF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlKHJhdGlvLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgcmF0aW8gPyBkYXRhLmUgOiBkYXRhLmIsIGRhdGEpO1xufSxcbiAgICBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZU9ubHlBdEVuZCA9IGZ1bmN0aW9uIF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlT25seUF0RW5kKHJhdGlvLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgcmF0aW8gIT09IDEgPyBkYXRhLmIgOiBkYXRhLmUsIGRhdGEpO1xufSxcbiAgICBfc2V0dGVyQ1NTU3R5bGUgPSBmdW5jdGlvbiBfc2V0dGVyQ1NTU3R5bGUodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgcmV0dXJuIHRhcmdldC5zdHlsZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbn0sXG4gICAgX3NldHRlckNTU1Byb3AgPSBmdW5jdGlvbiBfc2V0dGVyQ1NTUHJvcCh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdGFyZ2V0LnN0eWxlLnNldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSk7XG59LFxuICAgIF9zZXR0ZXJUcmFuc2Zvcm0gPSBmdW5jdGlvbiBfc2V0dGVyVHJhbnNmb3JtKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiB0YXJnZXQuX2dzYXBbcHJvcGVydHldID0gdmFsdWU7XG59LFxuICAgIF9zZXR0ZXJTY2FsZSA9IGZ1bmN0aW9uIF9zZXR0ZXJTY2FsZSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdGFyZ2V0Ll9nc2FwLnNjYWxlWCA9IHRhcmdldC5fZ3NhcC5zY2FsZVkgPSB2YWx1ZTtcbn0sXG4gICAgX3NldHRlclNjYWxlV2l0aFJlbmRlciA9IGZ1bmN0aW9uIF9zZXR0ZXJTY2FsZVdpdGhSZW5kZXIodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIGRhdGEsIHJhdGlvKSB7XG4gIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcDtcbiAgY2FjaGUuc2NhbGVYID0gY2FjaGUuc2NhbGVZID0gdmFsdWU7XG4gIGNhY2hlLnJlbmRlclRyYW5zZm9ybShyYXRpbywgY2FjaGUpO1xufSxcbiAgICBfc2V0dGVyVHJhbnNmb3JtV2l0aFJlbmRlciA9IGZ1bmN0aW9uIF9zZXR0ZXJUcmFuc2Zvcm1XaXRoUmVuZGVyKHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCBkYXRhLCByYXRpbykge1xuICB2YXIgY2FjaGUgPSB0YXJnZXQuX2dzYXA7XG4gIGNhY2hlW3Byb3BlcnR5XSA9IHZhbHVlO1xuICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0ocmF0aW8sIGNhY2hlKTtcbn0sXG4gICAgX3RyYW5zZm9ybVByb3AgPSBcInRyYW5zZm9ybVwiLFxuICAgIF90cmFuc2Zvcm1PcmlnaW5Qcm9wID0gX3RyYW5zZm9ybVByb3AgKyBcIk9yaWdpblwiLFxuICAgIF9zdXBwb3J0czNELFxuICAgIF9jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQodHlwZSwgbnMpIHtcbiAgdmFyIGUgPSBfZG9jLmNyZWF0ZUVsZW1lbnROUyA/IF9kb2MuY3JlYXRlRWxlbWVudE5TKChucyB8fCBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIikucmVwbGFjZSgvXmh0dHBzLywgXCJodHRwXCIpLCB0eXBlKSA6IF9kb2MuY3JlYXRlRWxlbWVudCh0eXBlKTsgLy9zb21lIHNlcnZlcnMgc3dhcCBpbiBodHRwcyBmb3IgaHR0cCBpbiB0aGUgbmFtZXNwYWNlIHdoaWNoIGNhbiBicmVhayB0aGluZ3MsIG1ha2luZyBcInN0eWxlXCIgaW5hY2Nlc3NpYmxlLlxuXG4gIHJldHVybiBlLnN0eWxlID8gZSA6IF9kb2MuY3JlYXRlRWxlbWVudCh0eXBlKTsgLy9zb21lIGVudmlyb25tZW50cyB3b24ndCBhbGxvdyBhY2Nlc3MgdG8gdGhlIGVsZW1lbnQncyBzdHlsZSB3aGVuIGNyZWF0ZWQgd2l0aCBhIG5hbWVzcGFjZSBpbiB3aGljaCBjYXNlIHdlIGRlZmF1bHQgdG8gdGhlIHN0YW5kYXJkIGNyZWF0ZUVsZW1lbnQoKSB0byB3b3JrIGFyb3VuZCB0aGUgaXNzdWUuIEFsc28gbm90ZSB0aGF0IHdoZW4gR1NBUCBpcyBlbWJlZGRlZCBkaXJlY3RseSBpbnNpZGUgYW4gU1ZHIGZpbGUsIGNyZWF0ZUVsZW1lbnQoKSB3b24ndCBhbGxvdyBhY2Nlc3MgdG8gdGhlIHN0eWxlIG9iamVjdCBpbiBGaXJlZm94IChzZWUgaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8yMDIxNS1wcm9ibGVtLXVzaW5nLXR3ZWVubWF4LWluLXN0YW5kYWxvbmUtc2VsZi1jb250YWluaW5nLXN2Zy1maWxlLWVyci1jYW5ub3Qtc2V0LXByb3BlcnR5LWNzc3RleHQtb2YtdW5kZWZpbmVkLykuXG59LFxuICAgIF9nZXRDb21wdXRlZFByb3BlcnR5ID0gZnVuY3Rpb24gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSwgc2tpcFByZWZpeEZhbGxiYWNrKSB7XG4gIHZhciBjcyA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KTtcbiAgcmV0dXJuIGNzW3Byb3BlcnR5XSB8fCBjcy5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5LnJlcGxhY2UoX2NhcHNFeHAsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpIHx8IGNzLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpIHx8ICFza2lwUHJlZml4RmFsbGJhY2sgJiYgX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBfY2hlY2tQcm9wUHJlZml4KHByb3BlcnR5KSB8fCBwcm9wZXJ0eSwgMSkgfHwgXCJcIjsgLy9jc3MgdmFyaWFibGVzIG1heSBub3QgbmVlZCBjYXBzIHN3YXBwZWQgb3V0IGZvciBkYXNoZXMgYW5kIGxvd2VyY2FzZS5cbn0sXG4gICAgX3ByZWZpeGVzID0gXCJPLE1veixtcyxNcyxXZWJraXRcIi5zcGxpdChcIixcIiksXG4gICAgX2NoZWNrUHJvcFByZWZpeCA9IGZ1bmN0aW9uIF9jaGVja1Byb3BQcmVmaXgocHJvcGVydHksIGVsZW1lbnQsIHByZWZlclByZWZpeCkge1xuICB2YXIgZSA9IGVsZW1lbnQgfHwgX3RlbXBEaXYsXG4gICAgICBzID0gZS5zdHlsZSxcbiAgICAgIGkgPSA1O1xuXG4gIGlmIChwcm9wZXJ0eSBpbiBzICYmICFwcmVmZXJQcmVmaXgpIHtcbiAgICByZXR1cm4gcHJvcGVydHk7XG4gIH1cblxuICBwcm9wZXJ0eSA9IHByb3BlcnR5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc3Vic3RyKDEpO1xuXG4gIHdoaWxlIChpLS0gJiYgIShfcHJlZml4ZXNbaV0gKyBwcm9wZXJ0eSBpbiBzKSkge31cblxuICByZXR1cm4gaSA8IDAgPyBudWxsIDogKGkgPT09IDMgPyBcIm1zXCIgOiBpID49IDAgPyBfcHJlZml4ZXNbaV0gOiBcIlwiKSArIHByb3BlcnR5O1xufSxcbiAgICBfaW5pdENvcmUgPSBmdW5jdGlvbiBfaW5pdENvcmUoKSB7XG4gIGlmIChfd2luZG93RXhpc3RzKCkgJiYgd2luZG93LmRvY3VtZW50KSB7XG4gICAgX3dpbiA9IHdpbmRvdztcbiAgICBfZG9jID0gX3dpbi5kb2N1bWVudDtcbiAgICBfZG9jRWxlbWVudCA9IF9kb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIF90ZW1wRGl2ID0gX2NyZWF0ZUVsZW1lbnQoXCJkaXZcIikgfHwge1xuICAgICAgc3R5bGU6IHt9XG4gICAgfTtcbiAgICBfdGVtcERpdlN0eWxlciA9IF9jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIF90cmFuc2Zvcm1Qcm9wID0gX2NoZWNrUHJvcFByZWZpeChfdHJhbnNmb3JtUHJvcCk7XG4gICAgX3RyYW5zZm9ybU9yaWdpblByb3AgPSBfdHJhbnNmb3JtUHJvcCArIFwiT3JpZ2luXCI7XG4gICAgX3RlbXBEaXYuc3R5bGUuY3NzVGV4dCA9IFwiYm9yZGVyLXdpZHRoOjA7bGluZS1oZWlnaHQ6MDtwb3NpdGlvbjphYnNvbHV0ZTtwYWRkaW5nOjBcIjsgLy9tYWtlIHN1cmUgdG8gb3ZlcnJpZGUgY2VydGFpbiBwcm9wZXJ0aWVzIHRoYXQgbWF5IGNvbnRhbWluYXRlIG1lYXN1cmVtZW50cywgaW4gY2FzZSB0aGUgdXNlciBoYXMgb3ZlcnJlYWNoaW5nIHN0eWxlIHNoZWV0cy5cblxuICAgIF9zdXBwb3J0czNEID0gISFfY2hlY2tQcm9wUHJlZml4KFwicGVyc3BlY3RpdmVcIik7XG4gICAgX3BsdWdpbkluaXR0ZWQgPSAxO1xuICB9XG59LFxuICAgIF9nZXRCQm94SGFjayA9IGZ1bmN0aW9uIF9nZXRCQm94SGFjayhzd2FwSWZQb3NzaWJsZSkge1xuICAvL3dvcmtzIGFyb3VuZCBpc3N1ZXMgaW4gc29tZSBicm93c2VycyAobGlrZSBGaXJlZm94KSB0aGF0IGRvbid0IGNvcnJlY3RseSByZXBvcnQgZ2V0QkJveCgpIG9uIFNWRyBlbGVtZW50cyBpbnNpZGUgYSA8ZGVmcz4gZWxlbWVudCBhbmQvb3IgPG1hc2s+LiBXZSB0cnkgY3JlYXRpbmcgYW4gU1ZHLCBhZGRpbmcgaXQgdG8gdGhlIGRvY3VtZW50RWxlbWVudCBhbmQgdG9zcyB0aGUgZWxlbWVudCBpbiB0aGVyZSBzbyB0aGF0IGl0J3MgZGVmaW5pdGVseSBwYXJ0IG9mIHRoZSByZW5kZXJpbmcgdHJlZSwgdGhlbiBncmFiIHRoZSBiYm94IGFuZCBpZiBpdCB3b3Jrcywgd2UgYWN0dWFsbHkgc3dhcCBvdXQgdGhlIG9yaWdpbmFsIGdldEJCb3goKSBtZXRob2QgZm9yIG91ciBvd24gdGhhdCBkb2VzIHRoZXNlIGV4dHJhIHN0ZXBzIHdoZW5ldmVyIGdldEJCb3ggaXMgbmVlZGVkLiBUaGlzIGhlbHBzIGVuc3VyZSB0aGF0IHBlcmZvcm1hbmNlIGlzIG9wdGltYWwgKG9ubHkgZG8gYWxsIHRoZXNlIGV4dHJhIHN0ZXBzIHdoZW4gYWJzb2x1dGVseSBuZWNlc3NhcnkuLi5tb3N0IGVsZW1lbnRzIGRvbid0IG5lZWQgaXQpLlxuICB2YXIgc3ZnID0gX2NyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgdGhpcy5vd25lclNWR0VsZW1lbnQgJiYgdGhpcy5vd25lclNWR0VsZW1lbnQuZ2V0QXR0cmlidXRlKFwieG1sbnNcIikgfHwgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiKSxcbiAgICAgIG9sZFBhcmVudCA9IHRoaXMucGFyZW50Tm9kZSxcbiAgICAgIG9sZFNpYmxpbmcgPSB0aGlzLm5leHRTaWJsaW5nLFxuICAgICAgb2xkQ1NTID0gdGhpcy5zdHlsZS5jc3NUZXh0LFxuICAgICAgYmJveDtcblxuICBfZG9jRWxlbWVudC5hcHBlbmRDaGlsZChzdmcpO1xuXG4gIHN2Zy5hcHBlbmRDaGlsZCh0aGlzKTtcbiAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXG4gIGlmIChzd2FwSWZQb3NzaWJsZSkge1xuICAgIHRyeSB7XG4gICAgICBiYm94ID0gdGhpcy5nZXRCQm94KCk7XG4gICAgICB0aGlzLl9nc2FwQkJveCA9IHRoaXMuZ2V0QkJveDsgLy9zdG9yZSB0aGUgb3JpZ2luYWxcblxuICAgICAgdGhpcy5nZXRCQm94ID0gX2dldEJCb3hIYWNrO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH0gZWxzZSBpZiAodGhpcy5fZ3NhcEJCb3gpIHtcbiAgICBiYm94ID0gdGhpcy5fZ3NhcEJCb3goKTtcbiAgfVxuXG4gIGlmIChvbGRQYXJlbnQpIHtcbiAgICBpZiAob2xkU2libGluZykge1xuICAgICAgb2xkUGFyZW50Lmluc2VydEJlZm9yZSh0aGlzLCBvbGRTaWJsaW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2xkUGFyZW50LmFwcGVuZENoaWxkKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIF9kb2NFbGVtZW50LnJlbW92ZUNoaWxkKHN2Zyk7XG5cbiAgdGhpcy5zdHlsZS5jc3NUZXh0ID0gb2xkQ1NTO1xuICByZXR1cm4gYmJveDtcbn0sXG4gICAgX2dldEF0dHJpYnV0ZUZhbGxiYWNrcyA9IGZ1bmN0aW9uIF9nZXRBdHRyaWJ1dGVGYWxsYmFja3ModGFyZ2V0LCBhdHRyaWJ1dGVzQXJyYXkpIHtcbiAgdmFyIGkgPSBhdHRyaWJ1dGVzQXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAodGFyZ2V0Lmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVzQXJyYXlbaV0pKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVzQXJyYXlbaV0pO1xuICAgIH1cbiAgfVxufSxcbiAgICBfZ2V0QkJveCA9IGZ1bmN0aW9uIF9nZXRCQm94KHRhcmdldCkge1xuICB2YXIgYm91bmRzO1xuXG4gIHRyeSB7XG4gICAgYm91bmRzID0gdGFyZ2V0LmdldEJCb3goKTsgLy9GaXJlZm94IHRocm93cyBlcnJvcnMgaWYgeW91IHRyeSBjYWxsaW5nIGdldEJCb3goKSBvbiBhbiBTVkcgZWxlbWVudCB0aGF0J3Mgbm90IHJlbmRlcmVkIChsaWtlIGluIGEgPHN5bWJvbD4gb3IgPGRlZnM+KS4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NjEyMTE4XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgYm91bmRzID0gX2dldEJCb3hIYWNrLmNhbGwodGFyZ2V0LCB0cnVlKTtcbiAgfVxuXG4gIGJvdW5kcyAmJiAoYm91bmRzLndpZHRoIHx8IGJvdW5kcy5oZWlnaHQpIHx8IHRhcmdldC5nZXRCQm94ID09PSBfZ2V0QkJveEhhY2sgfHwgKGJvdW5kcyA9IF9nZXRCQm94SGFjay5jYWxsKHRhcmdldCwgdHJ1ZSkpOyAvL3NvbWUgYnJvd3NlcnMgKGxpa2UgRmlyZWZveCkgbWlzcmVwb3J0IHRoZSBib3VuZHMgaWYgdGhlIGVsZW1lbnQgaGFzIHplcm8gd2lkdGggYW5kIGhlaWdodCAoaXQganVzdCBhc3N1bWVzIGl0J3MgYXQgeDowLCB5OjApLCB0aHVzIHdlIG5lZWQgdG8gbWFudWFsbHkgZ3JhYiB0aGUgcG9zaXRpb24gaW4gdGhhdCBjYXNlLlxuXG4gIHJldHVybiBib3VuZHMgJiYgIWJvdW5kcy53aWR0aCAmJiAhYm91bmRzLnggJiYgIWJvdW5kcy55ID8ge1xuICAgIHg6ICtfZ2V0QXR0cmlidXRlRmFsbGJhY2tzKHRhcmdldCwgW1wieFwiLCBcImN4XCIsIFwieDFcIl0pIHx8IDAsXG4gICAgeTogK19nZXRBdHRyaWJ1dGVGYWxsYmFja3ModGFyZ2V0LCBbXCJ5XCIsIFwiY3lcIiwgXCJ5MVwiXSkgfHwgMCxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfSA6IGJvdW5kcztcbn0sXG4gICAgX2lzU1ZHID0gZnVuY3Rpb24gX2lzU1ZHKGUpIHtcbiAgcmV0dXJuICEhKGUuZ2V0Q1RNICYmICghZS5wYXJlbnROb2RlIHx8IGUub3duZXJTVkdFbGVtZW50KSAmJiBfZ2V0QkJveChlKSk7XG59LFxuICAgIC8vcmVwb3J0cyBpZiB0aGUgZWxlbWVudCBpcyBhbiBTVkcgb24gd2hpY2ggZ2V0QkJveCgpIGFjdHVhbGx5IHdvcmtzXG5fcmVtb3ZlUHJvcGVydHkgPSBmdW5jdGlvbiBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eSkge1xuICBpZiAocHJvcGVydHkpIHtcbiAgICB2YXIgc3R5bGUgPSB0YXJnZXQuc3R5bGU7XG5cbiAgICBpZiAocHJvcGVydHkgaW4gX3RyYW5zZm9ybVByb3BzICYmIHByb3BlcnR5ICE9PSBfdHJhbnNmb3JtT3JpZ2luUHJvcCkge1xuICAgICAgcHJvcGVydHkgPSBfdHJhbnNmb3JtUHJvcDtcbiAgICB9XG5cbiAgICBpZiAoc3R5bGUucmVtb3ZlUHJvcGVydHkpIHtcbiAgICAgIGlmIChwcm9wZXJ0eS5zdWJzdHIoMCwgMikgPT09IFwibXNcIiB8fCBwcm9wZXJ0eS5zdWJzdHIoMCwgNikgPT09IFwid2Via2l0XCIpIHtcbiAgICAgICAgLy9NaWNyb3NvZnQgYW5kIHNvbWUgV2Via2l0IGJyb3dzZXJzIGRvbid0IGNvbmZvcm0gdG8gdGhlIHN0YW5kYXJkIG9mIGNhcGl0YWxpemluZyB0aGUgZmlyc3QgcHJlZml4IGNoYXJhY3Rlciwgc28gd2UgYWRqdXN0IHNvIHRoYXQgd2hlbiB3ZSBwcmVmaXggdGhlIGNhcHMgd2l0aCBhIGRhc2gsIGl0J3MgY29ycmVjdCAob3RoZXJ3aXNlIGl0J2QgYmUgXCJtcy10cmFuc2Zvcm1cIiBpbnN0ZWFkIG9mIFwiLW1zLXRyYW5zZm9ybVwiIGZvciBJRTksIGZvciBleGFtcGxlKVxuICAgICAgICBwcm9wZXJ0eSA9IFwiLVwiICsgcHJvcGVydHk7XG4gICAgICB9XG5cbiAgICAgIHN0eWxlLnJlbW92ZVByb3BlcnR5KHByb3BlcnR5LnJlcGxhY2UoX2NhcHNFeHAsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvL25vdGU6IG9sZCB2ZXJzaW9ucyBvZiBJRSB1c2UgXCJyZW1vdmVBdHRyaWJ1dGUoKVwiIGluc3RlYWQgb2YgXCJyZW1vdmVQcm9wZXJ0eSgpXCJcbiAgICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZShwcm9wZXJ0eSk7XG4gICAgfVxuICB9XG59LFxuICAgIF9hZGROb25Ud2VlbmluZ1BUID0gZnVuY3Rpb24gX2FkZE5vblR3ZWVuaW5nUFQocGx1Z2luLCB0YXJnZXQsIHByb3BlcnR5LCBiZWdpbm5pbmcsIGVuZCwgb25seVNldEF0RW5kKSB7XG4gIHZhciBwdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgdGFyZ2V0LCBwcm9wZXJ0eSwgMCwgMSwgb25seVNldEF0RW5kID8gX3JlbmRlck5vblR3ZWVuaW5nVmFsdWVPbmx5QXRFbmQgOiBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZSk7XG4gIHBsdWdpbi5fcHQgPSBwdDtcbiAgcHQuYiA9IGJlZ2lubmluZztcbiAgcHQuZSA9IGVuZDtcblxuICBwbHVnaW4uX3Byb3BzLnB1c2gocHJvcGVydHkpO1xuXG4gIHJldHVybiBwdDtcbn0sXG4gICAgX25vbkNvbnZlcnRpYmxlVW5pdHMgPSB7XG4gIGRlZzogMSxcbiAgcmFkOiAxLFxuICB0dXJuOiAxXG59LFxuICAgIC8vdGFrZXMgYSBzaW5nbGUgdmFsdWUgbGlrZSAyMHB4IGFuZCBjb252ZXJ0cyBpdCB0byB0aGUgdW5pdCBzcGVjaWZpZWQsIGxpa2UgXCIlXCIsIHJldHVybmluZyBvbmx5IHRoZSBudW1lcmljIGFtb3VudC5cbl9jb252ZXJ0VG9Vbml0ID0gZnVuY3Rpb24gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIHVuaXQpIHtcbiAgdmFyIGN1clZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSkgfHwgMCxcbiAgICAgIGN1clVuaXQgPSAodmFsdWUgKyBcIlwiKS50cmltKCkuc3Vic3RyKChjdXJWYWx1ZSArIFwiXCIpLmxlbmd0aCkgfHwgXCJweFwiLFxuICAgICAgLy8gc29tZSBicm93c2VycyBsZWF2ZSBleHRyYSB3aGl0ZXNwYWNlIGF0IHRoZSBiZWdpbm5pbmcgb2YgQ1NTIHZhcmlhYmxlcywgaGVuY2UgdGhlIG5lZWQgdG8gdHJpbSgpXG4gIHN0eWxlID0gX3RlbXBEaXYuc3R5bGUsXG4gICAgICBob3Jpem9udGFsID0gX2hvcml6b250YWxFeHAudGVzdChwcm9wZXJ0eSksXG4gICAgICBpc1Jvb3RTVkcgPSB0YXJnZXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInN2Z1wiLFxuICAgICAgbWVhc3VyZVByb3BlcnR5ID0gKGlzUm9vdFNWRyA/IFwiY2xpZW50XCIgOiBcIm9mZnNldFwiKSArIChob3Jpem9udGFsID8gXCJXaWR0aFwiIDogXCJIZWlnaHRcIiksXG4gICAgICBhbW91bnQgPSAxMDAsXG4gICAgICB0b1BpeGVscyA9IHVuaXQgPT09IFwicHhcIixcbiAgICAgIHRvUGVyY2VudCA9IHVuaXQgPT09IFwiJVwiLFxuICAgICAgcHgsXG4gICAgICBwYXJlbnQsXG4gICAgICBjYWNoZSxcbiAgICAgIGlzU1ZHO1xuXG4gIGlmICh1bml0ID09PSBjdXJVbml0IHx8ICFjdXJWYWx1ZSB8fCBfbm9uQ29udmVydGlibGVVbml0c1t1bml0XSB8fCBfbm9uQ29udmVydGlibGVVbml0c1tjdXJVbml0XSkge1xuICAgIHJldHVybiBjdXJWYWx1ZTtcbiAgfVxuXG4gIGN1clVuaXQgIT09IFwicHhcIiAmJiAhdG9QaXhlbHMgJiYgKGN1clZhbHVlID0gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUsIFwicHhcIikpO1xuICBpc1NWRyA9IHRhcmdldC5nZXRDVE0gJiYgX2lzU1ZHKHRhcmdldCk7XG5cbiAgaWYgKCh0b1BlcmNlbnQgfHwgY3VyVW5pdCA9PT0gXCIlXCIpICYmIChfdHJhbnNmb3JtUHJvcHNbcHJvcGVydHldIHx8IH5wcm9wZXJ0eS5pbmRleE9mKFwiYWRpdXNcIikpKSB7XG4gICAgcHggPSBpc1NWRyA/IHRhcmdldC5nZXRCQm94KClbaG9yaXpvbnRhbCA/IFwid2lkdGhcIiA6IFwiaGVpZ2h0XCJdIDogdGFyZ2V0W21lYXN1cmVQcm9wZXJ0eV07XG4gICAgcmV0dXJuIF9yb3VuZCh0b1BlcmNlbnQgPyBjdXJWYWx1ZSAvIHB4ICogYW1vdW50IDogY3VyVmFsdWUgLyAxMDAgKiBweCk7XG4gIH1cblxuICBzdHlsZVtob3Jpem9udGFsID8gXCJ3aWR0aFwiIDogXCJoZWlnaHRcIl0gPSBhbW91bnQgKyAodG9QaXhlbHMgPyBjdXJVbml0IDogdW5pdCk7XG4gIHBhcmVudCA9IH5wcm9wZXJ0eS5pbmRleE9mKFwiYWRpdXNcIikgfHwgdW5pdCA9PT0gXCJlbVwiICYmIHRhcmdldC5hcHBlbmRDaGlsZCAmJiAhaXNSb290U1ZHID8gdGFyZ2V0IDogdGFyZ2V0LnBhcmVudE5vZGU7XG5cbiAgaWYgKGlzU1ZHKSB7XG4gICAgcGFyZW50ID0gKHRhcmdldC5vd25lclNWR0VsZW1lbnQgfHwge30pLnBhcmVudE5vZGU7XG4gIH1cblxuICBpZiAoIXBhcmVudCB8fCBwYXJlbnQgPT09IF9kb2MgfHwgIXBhcmVudC5hcHBlbmRDaGlsZCkge1xuICAgIHBhcmVudCA9IF9kb2MuYm9keTtcbiAgfVxuXG4gIGNhY2hlID0gcGFyZW50Ll9nc2FwO1xuXG4gIGlmIChjYWNoZSAmJiB0b1BlcmNlbnQgJiYgY2FjaGUud2lkdGggJiYgaG9yaXpvbnRhbCAmJiBjYWNoZS50aW1lID09PSBfdGlja2VyLnRpbWUpIHtcbiAgICByZXR1cm4gX3JvdW5kKGN1clZhbHVlIC8gY2FjaGUud2lkdGggKiBhbW91bnQpO1xuICB9IGVsc2Uge1xuICAgICh0b1BlcmNlbnQgfHwgY3VyVW5pdCA9PT0gXCIlXCIpICYmIChzdHlsZS5wb3NpdGlvbiA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgXCJwb3NpdGlvblwiKSk7XG4gICAgcGFyZW50ID09PSB0YXJnZXQgJiYgKHN0eWxlLnBvc2l0aW9uID0gXCJzdGF0aWNcIik7IC8vIGxpa2UgZm9yIGJvcmRlclJhZGl1cywgaWYgaXQncyBhICUgd2UgbXVzdCBoYXZlIGl0IHJlbGF0aXZlIHRvIHRoZSB0YXJnZXQgaXRzZWxmIGJ1dCB0aGF0IG1heSBub3QgaGF2ZSBwb3NpdGlvbjogcmVsYXRpdmUgb3IgcG9zaXRpb246IGFic29sdXRlIGluIHdoaWNoIGNhc2UgaXQnZCBnbyB1cCB0aGUgY2hhaW4gdW50aWwgaXQgZmluZHMgaXRzIG9mZnNldFBhcmVudCAoYmFkKS4gcG9zaXRpb246IHN0YXRpYyBwcm90ZWN0cyBhZ2FpbnN0IHRoYXQuXG5cbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoX3RlbXBEaXYpO1xuICAgIHB4ID0gX3RlbXBEaXZbbWVhc3VyZVByb3BlcnR5XTtcbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoX3RlbXBEaXYpO1xuICAgIHN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXG4gICAgaWYgKGhvcml6b250YWwgJiYgdG9QZXJjZW50KSB7XG4gICAgICBjYWNoZSA9IF9nZXRDYWNoZShwYXJlbnQpO1xuICAgICAgY2FjaGUudGltZSA9IF90aWNrZXIudGltZTtcbiAgICAgIGNhY2hlLndpZHRoID0gcGFyZW50W21lYXN1cmVQcm9wZXJ0eV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9yb3VuZCh0b1BpeGVscyA/IHB4ICogY3VyVmFsdWUgLyBhbW91bnQgOiBweCAmJiBjdXJWYWx1ZSA/IGFtb3VudCAvIHB4ICogY3VyVmFsdWUgOiAwKTtcbn0sXG4gICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdW5pdCwgdW5jYWNoZSkge1xuICB2YXIgdmFsdWU7XG4gIF9wbHVnaW5Jbml0dGVkIHx8IF9pbml0Q29yZSgpO1xuXG4gIGlmIChwcm9wZXJ0eSBpbiBfcHJvcGVydHlBbGlhc2VzICYmIHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgcHJvcGVydHkgPSBfcHJvcGVydHlBbGlhc2VzW3Byb3BlcnR5XTtcblxuICAgIGlmICh+cHJvcGVydHkuaW5kZXhPZihcIixcIikpIHtcbiAgICAgIHByb3BlcnR5ID0gcHJvcGVydHkuc3BsaXQoXCIsXCIpWzBdO1xuICAgIH1cbiAgfVxuXG4gIGlmIChfdHJhbnNmb3JtUHJvcHNbcHJvcGVydHldICYmIHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgdmFsdWUgPSBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCB1bmNhY2hlKTtcbiAgICB2YWx1ZSA9IHByb3BlcnR5ICE9PSBcInRyYW5zZm9ybU9yaWdpblwiID8gdmFsdWVbcHJvcGVydHldIDogdmFsdWUuc3ZnID8gdmFsdWUub3JpZ2luIDogX2ZpcnN0VHdvT25seShfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1PcmlnaW5Qcm9wKSkgKyBcIiBcIiArIHZhbHVlLnpPcmlnaW4gKyBcInB4XCI7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSB0YXJnZXQuc3R5bGVbcHJvcGVydHldO1xuXG4gICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZSA9PT0gXCJhdXRvXCIgfHwgdW5jYWNoZSB8fCB+KHZhbHVlICsgXCJcIikuaW5kZXhPZihcImNhbGMoXCIpKSB7XG4gICAgICB2YWx1ZSA9IF9zcGVjaWFsUHJvcHNbcHJvcGVydHldICYmIF9zcGVjaWFsUHJvcHNbcHJvcGVydHldKHRhcmdldCwgcHJvcGVydHksIHVuaXQpIHx8IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgcHJvcGVydHkpIHx8IF9nZXRQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5KSB8fCAocHJvcGVydHkgPT09IFwib3BhY2l0eVwiID8gMSA6IDApOyAvLyBub3RlOiBzb21lIGJyb3dzZXJzLCBsaWtlIEZpcmVmb3gsIGRvbid0IHJlcG9ydCBib3JkZXJSYWRpdXMgY29ycmVjdGx5ISBJbnN0ZWFkLCBpdCBvbmx5IHJlcG9ydHMgZXZlcnkgY29ybmVyIGxpa2UgIGJvcmRlclRvcExlZnRSYWRpdXNcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5pdCAmJiAhfih2YWx1ZSArIFwiXCIpLnRyaW0oKS5pbmRleE9mKFwiIFwiKSA/IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCB1bml0KSArIHVuaXQgOiB2YWx1ZTtcbn0sXG4gICAgX3R3ZWVuQ29tcGxleENTU1N0cmluZyA9IGZ1bmN0aW9uIF90d2VlbkNvbXBsZXhDU1NTdHJpbmcodGFyZ2V0LCBwcm9wLCBzdGFydCwgZW5kKSB7XG4gIC8vbm90ZTogd2UgY2FsbCBfdHdlZW5Db21wbGV4Q1NTU3RyaW5nLmNhbGwocGx1Z2luSW5zdGFuY2UuLi4pIHRvIGVuc3VyZSB0aGF0IGl0J3Mgc2NvcGVkIHByb3Blcmx5LiBXZSBtYXkgY2FsbCBpdCBmcm9tIHdpdGhpbiBhIHBsdWdpbiB0b28sIHRodXMgXCJ0aGlzXCIgd291bGQgcmVmZXIgdG8gdGhlIHBsdWdpbi5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA9PT0gXCJub25lXCIpIHtcbiAgICAvLyBzb21lIGJyb3dzZXJzIGxpa2UgU2FmYXJpIGFjdHVhbGx5IFBSRUZFUiB0aGUgcHJlZml4ZWQgcHJvcGVydHkgYW5kIG1pcy1yZXBvcnQgdGhlIHVucHJlZml4ZWQgdmFsdWUgbGlrZSBjbGlwUGF0aCAoQlVHKS4gSW4gb3RoZXIgd29yZHMsIGV2ZW4gdGhvdWdoIGNsaXBQYXRoIGV4aXN0cyBpbiB0aGUgc3R5bGUgKFwiY2xpcFBhdGhcIiBpbiB0YXJnZXQuc3R5bGUpIGFuZCBpdCdzIHNldCBpbiB0aGUgQ1NTIHByb3Blcmx5IChhbG9uZyB3aXRoIC13ZWJraXQtY2xpcC1wYXRoKSwgU2FmYXJpIHJlcG9ydHMgY2xpcFBhdGggYXMgXCJub25lXCIgd2hlcmVhcyBXZWJraXRDbGlwUGF0aCByZXBvcnRzIGFjY3VyYXRlbHkgbGlrZSBcImVsbGlwc2UoMTAwJSAwJSBhdCA1MCUgMCUpXCIsIHNvIGluIHRoaXMgY2FzZSB3ZSBtdXN0IFNXSVRDSCB0byB1c2luZyB0aGUgcHJlZml4ZWQgcHJvcGVydHkgaW5zdGVhZC4gU2VlIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9mb3J1bXMvdG9waWMvMTgzMTAtY2xpcHBhdGgtZG9lc250LXdvcmstb24taW9zL1xuICAgIHZhciBwID0gX2NoZWNrUHJvcFByZWZpeChwcm9wLCB0YXJnZXQsIDEpLFxuICAgICAgICBzID0gcCAmJiBfZ2V0Q29tcHV0ZWRQcm9wZXJ0eSh0YXJnZXQsIHAsIDEpO1xuXG4gICAgaWYgKHMgJiYgcyAhPT0gc3RhcnQpIHtcbiAgICAgIHByb3AgPSBwO1xuICAgICAgc3RhcnQgPSBzO1xuICAgIH0gZWxzZSBpZiAocHJvcCA9PT0gXCJib3JkZXJDb2xvclwiKSB7XG4gICAgICBzdGFydCA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgXCJib3JkZXJUb3BDb2xvclwiKTsgLy8gRmlyZWZveCBidWc6IGFsd2F5cyByZXBvcnRzIFwiYm9yZGVyQ29sb3JcIiBhcyBcIlwiLCBzbyB3ZSBtdXN0IGZhbGwgYmFjayB0byBib3JkZXJUb3BDb2xvci4gU2VlIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9mb3J1bXMvdG9waWMvMjQ1ODMtaG93LXRvLXJldHVybi1jb2xvcnMtdGhhdC1pLWhhZC1hZnRlci1yZXZlcnNlL1xuICAgIH1cbiAgfVxuXG4gIHZhciBwdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIHRhcmdldC5zdHlsZSwgcHJvcCwgMCwgMSwgX3JlbmRlckNvbXBsZXhTdHJpbmcpLFxuICAgICAgaW5kZXggPSAwLFxuICAgICAgbWF0Y2hJbmRleCA9IDAsXG4gICAgICBhLFxuICAgICAgcmVzdWx0LFxuICAgICAgc3RhcnRWYWx1ZXMsXG4gICAgICBzdGFydE51bSxcbiAgICAgIGNvbG9yLFxuICAgICAgc3RhcnRWYWx1ZSxcbiAgICAgIGVuZFZhbHVlLFxuICAgICAgZW5kTnVtLFxuICAgICAgY2h1bmssXG4gICAgICBlbmRVbml0LFxuICAgICAgc3RhcnRVbml0LFxuICAgICAgcmVsYXRpdmUsXG4gICAgICBlbmRWYWx1ZXM7XG4gIHB0LmIgPSBzdGFydDtcbiAgcHQuZSA9IGVuZDtcbiAgc3RhcnQgKz0gXCJcIjsgLy9lbnN1cmUgdmFsdWVzIGFyZSBzdHJpbmdzXG5cbiAgZW5kICs9IFwiXCI7XG5cbiAgaWYgKGVuZCA9PT0gXCJhdXRvXCIpIHtcbiAgICB0YXJnZXQuc3R5bGVbcHJvcF0gPSBlbmQ7XG4gICAgZW5kID0gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBwcm9wKSB8fCBlbmQ7XG4gICAgdGFyZ2V0LnN0eWxlW3Byb3BdID0gc3RhcnQ7XG4gIH1cblxuICBhID0gW3N0YXJ0LCBlbmRdO1xuXG4gIF9jb2xvclN0cmluZ0ZpbHRlcihhKTsgLy9wYXNzIGFuIGFycmF5IHdpdGggdGhlIHN0YXJ0aW5nIGFuZCBlbmRpbmcgdmFsdWVzIGFuZCBsZXQgdGhlIGZpbHRlciBkbyB3aGF0ZXZlciBpdCBuZWVkcyB0byB0aGUgdmFsdWVzLiBJZiBjb2xvcnMgYXJlIGZvdW5kLCBpdCByZXR1cm5zIHRydWUgYW5kIHRoZW4gd2UgbXVzdCBtYXRjaCB3aGVyZSB0aGUgY29sb3Igc2hvd3MgdXAgb3JkZXItd2lzZSBiZWNhdXNlIGZvciB0aGluZ3MgbGlrZSBib3hTaGFkb3csIHNvbWV0aW1lcyB0aGUgYnJvd3NlciBwcm92aWRlcyB0aGUgY29tcHV0ZWQgdmFsdWVzIHdpdGggdGhlIGNvbG9yIEZJUlNULCBidXQgdGhlIHVzZXIgcHJvdmlkZXMgaXQgd2l0aCB0aGUgY29sb3IgTEFTVCwgc28gZmxpcCB0aGVtIGlmIG5lY2Vzc2FyeS4gU2FtZSBmb3IgZHJvcC1zaGFkb3coKS5cblxuXG4gIHN0YXJ0ID0gYVswXTtcbiAgZW5kID0gYVsxXTtcbiAgc3RhcnRWYWx1ZXMgPSBzdGFydC5tYXRjaChfbnVtV2l0aFVuaXRFeHApIHx8IFtdO1xuICBlbmRWYWx1ZXMgPSBlbmQubWF0Y2goX251bVdpdGhVbml0RXhwKSB8fCBbXTtcblxuICBpZiAoZW5kVmFsdWVzLmxlbmd0aCkge1xuICAgIHdoaWxlIChyZXN1bHQgPSBfbnVtV2l0aFVuaXRFeHAuZXhlYyhlbmQpKSB7XG4gICAgICBlbmRWYWx1ZSA9IHJlc3VsdFswXTtcbiAgICAgIGNodW5rID0gZW5kLnN1YnN0cmluZyhpbmRleCwgcmVzdWx0LmluZGV4KTtcblxuICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgIGNvbG9yID0gKGNvbG9yICsgMSkgJSA1O1xuICAgICAgfSBlbHNlIGlmIChjaHVuay5zdWJzdHIoLTUpID09PSBcInJnYmEoXCIgfHwgY2h1bmsuc3Vic3RyKC01KSA9PT0gXCJoc2xhKFwiKSB7XG4gICAgICAgIGNvbG9yID0gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuZFZhbHVlICE9PSAoc3RhcnRWYWx1ZSA9IHN0YXJ0VmFsdWVzW21hdGNoSW5kZXgrK10gfHwgXCJcIikpIHtcbiAgICAgICAgc3RhcnROdW0gPSBwYXJzZUZsb2F0KHN0YXJ0VmFsdWUpIHx8IDA7XG4gICAgICAgIHN0YXJ0VW5pdCA9IHN0YXJ0VmFsdWUuc3Vic3RyKChzdGFydE51bSArIFwiXCIpLmxlbmd0aCk7XG4gICAgICAgIHJlbGF0aXZlID0gZW5kVmFsdWUuY2hhckF0KDEpID09PSBcIj1cIiA/ICsoZW5kVmFsdWUuY2hhckF0KDApICsgXCIxXCIpIDogMDtcblxuICAgICAgICBpZiAocmVsYXRpdmUpIHtcbiAgICAgICAgICBlbmRWYWx1ZSA9IGVuZFZhbHVlLnN1YnN0cigyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVuZE51bSA9IHBhcnNlRmxvYXQoZW5kVmFsdWUpO1xuICAgICAgICBlbmRVbml0ID0gZW5kVmFsdWUuc3Vic3RyKChlbmROdW0gKyBcIlwiKS5sZW5ndGgpO1xuICAgICAgICBpbmRleCA9IF9udW1XaXRoVW5pdEV4cC5sYXN0SW5kZXggLSBlbmRVbml0Lmxlbmd0aDtcblxuICAgICAgICBpZiAoIWVuZFVuaXQpIHtcbiAgICAgICAgICAvL2lmIHNvbWV0aGluZyBsaWtlIFwicGVyc3BlY3RpdmU6MzAwXCIgaXMgcGFzc2VkIGluIGFuZCB3ZSBtdXN0IGFkZCBhIHVuaXQgdG8gdGhlIGVuZFxuICAgICAgICAgIGVuZFVuaXQgPSBlbmRVbml0IHx8IF9jb25maWcudW5pdHNbcHJvcF0gfHwgc3RhcnRVbml0O1xuXG4gICAgICAgICAgaWYgKGluZGV4ID09PSBlbmQubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbmQgKz0gZW5kVW5pdDtcbiAgICAgICAgICAgIHB0LmUgKz0gZW5kVW5pdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhcnRVbml0ICE9PSBlbmRVbml0KSB7XG4gICAgICAgICAgc3RhcnROdW0gPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIHByb3AsIHN0YXJ0VmFsdWUsIGVuZFVuaXQpIHx8IDA7XG4gICAgICAgIH0gLy90aGVzZSBuZXN0ZWQgUHJvcFR3ZWVucyBhcmUgaGFuZGxlZCBpbiBhIHNwZWNpYWwgd2F5IC0gd2UnbGwgbmV2ZXIgYWN0dWFsbHkgY2FsbCBhIHJlbmRlciBvciBzZXR0ZXIgbWV0aG9kIG9uIHRoZW0uIFdlJ2xsIGp1c3QgbG9vcCB0aHJvdWdoIHRoZW0gaW4gdGhlIHBhcmVudCBjb21wbGV4IHN0cmluZyBQcm9wVHdlZW4ncyByZW5kZXIgbWV0aG9kLlxuXG5cbiAgICAgICAgcHQuX3B0ID0ge1xuICAgICAgICAgIF9uZXh0OiBwdC5fcHQsXG4gICAgICAgICAgcDogY2h1bmsgfHwgbWF0Y2hJbmRleCA9PT0gMSA/IGNodW5rIDogXCIsXCIsXG4gICAgICAgICAgLy9ub3RlOiBTVkcgc3BlYyBhbGxvd3Mgb21pc3Npb24gb2YgY29tbWEvc3BhY2Ugd2hlbiBhIG5lZ2F0aXZlIHNpZ24gaXMgd2VkZ2VkIGJldHdlZW4gdHdvIG51bWJlcnMsIGxpa2UgMi41LTUuMyBpbnN0ZWFkIG9mIDIuNSwtNS4zIGJ1dCB3aGVuIHR3ZWVuaW5nLCB0aGUgbmVnYXRpdmUgdmFsdWUgbWF5IHN3aXRjaCB0byBwb3NpdGl2ZSwgc28gd2UgaW5zZXJ0IHRoZSBjb21tYSBqdXN0IGluIGNhc2UuXG4gICAgICAgICAgczogc3RhcnROdW0sXG4gICAgICAgICAgYzogcmVsYXRpdmUgPyByZWxhdGl2ZSAqIGVuZE51bSA6IGVuZE51bSAtIHN0YXJ0TnVtLFxuICAgICAgICAgIG06IGNvbG9yICYmIGNvbG9yIDwgNCB8fCBwcm9wID09PSBcInpJbmRleFwiID8gTWF0aC5yb3VuZCA6IDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwdC5jID0gaW5kZXggPCBlbmQubGVuZ3RoID8gZW5kLnN1YnN0cmluZyhpbmRleCwgZW5kLmxlbmd0aCkgOiBcIlwiOyAvL3dlIHVzZSB0aGUgXCJjXCIgb2YgdGhlIFByb3BUd2VlbiB0byBzdG9yZSB0aGUgZmluYWwgcGFydCBvZiB0aGUgc3RyaW5nIChhZnRlciB0aGUgbGFzdCBudW1iZXIpXG4gIH0gZWxzZSB7XG4gICAgcHQuciA9IHByb3AgPT09IFwiZGlzcGxheVwiICYmIGVuZCA9PT0gXCJub25lXCIgPyBfcmVuZGVyTm9uVHdlZW5pbmdWYWx1ZU9ubHlBdEVuZCA6IF9yZW5kZXJOb25Ud2VlbmluZ1ZhbHVlO1xuICB9XG5cbiAgX3JlbEV4cC50ZXN0KGVuZCkgJiYgKHB0LmUgPSAwKTsgLy9pZiB0aGUgZW5kIHN0cmluZyBjb250YWlucyByZWxhdGl2ZSB2YWx1ZXMgb3IgZHluYW1pYyByYW5kb20oLi4uKSB2YWx1ZXMsIGRlbGV0ZSB0aGUgZW5kIGl0IHNvIHRoYXQgb24gdGhlIGZpbmFsIHJlbmRlciB3ZSBkb24ndCBhY3R1YWxseSBzZXQgaXQgdG8gdGhlIHN0cmluZyB3aXRoICs9IG9yIC09IGNoYXJhY3RlcnMgKGZvcmNlcyBpdCB0byB1c2UgdGhlIGNhbGN1bGF0ZWQgdmFsdWUpLlxuXG4gIHRoaXMuX3B0ID0gcHQ7IC8vc3RhcnQgdGhlIGxpbmtlZCBsaXN0IHdpdGggdGhpcyBuZXcgUHJvcFR3ZWVuLiBSZW1lbWJlciwgd2UgY2FsbCBfdHdlZW5Db21wbGV4Q1NTU3RyaW5nLmNhbGwocGx1Z2luSW5zdGFuY2UuLi4pIHRvIGVuc3VyZSB0aGF0IGl0J3Mgc2NvcGVkIHByb3Blcmx5LiBXZSBtYXkgY2FsbCBpdCBmcm9tIHdpdGhpbiBhbm90aGVyIHBsdWdpbiB0b28sIHRodXMgXCJ0aGlzXCIgd291bGQgcmVmZXIgdG8gdGhlIHBsdWdpbi5cblxuICByZXR1cm4gcHQ7XG59LFxuICAgIF9rZXl3b3JkVG9QZXJjZW50ID0ge1xuICB0b3A6IFwiMCVcIixcbiAgYm90dG9tOiBcIjEwMCVcIixcbiAgbGVmdDogXCIwJVwiLFxuICByaWdodDogXCIxMDAlXCIsXG4gIGNlbnRlcjogXCI1MCVcIlxufSxcbiAgICBfY29udmVydEtleXdvcmRzVG9QZXJjZW50YWdlcyA9IGZ1bmN0aW9uIF9jb252ZXJ0S2V5d29yZHNUb1BlcmNlbnRhZ2VzKHZhbHVlKSB7XG4gIHZhciBzcGxpdCA9IHZhbHVlLnNwbGl0KFwiIFwiKSxcbiAgICAgIHggPSBzcGxpdFswXSxcbiAgICAgIHkgPSBzcGxpdFsxXSB8fCBcIjUwJVwiO1xuXG4gIGlmICh4ID09PSBcInRvcFwiIHx8IHggPT09IFwiYm90dG9tXCIgfHwgeSA9PT0gXCJsZWZ0XCIgfHwgeSA9PT0gXCJyaWdodFwiKSB7XG4gICAgLy90aGUgdXNlciBwcm92aWRlZCB0aGVtIGluIHRoZSB3cm9uZyBvcmRlciwgc28gZmxpcCB0aGVtXG4gICAgdmFsdWUgPSB4O1xuICAgIHggPSB5O1xuICAgIHkgPSB2YWx1ZTtcbiAgfVxuXG4gIHNwbGl0WzBdID0gX2tleXdvcmRUb1BlcmNlbnRbeF0gfHwgeDtcbiAgc3BsaXRbMV0gPSBfa2V5d29yZFRvUGVyY2VudFt5XSB8fCB5O1xuICByZXR1cm4gc3BsaXQuam9pbihcIiBcIik7XG59LFxuICAgIF9yZW5kZXJDbGVhclByb3BzID0gZnVuY3Rpb24gX3JlbmRlckNsZWFyUHJvcHMocmF0aW8sIGRhdGEpIHtcbiAgaWYgKGRhdGEudHdlZW4gJiYgZGF0YS50d2Vlbi5fdGltZSA9PT0gZGF0YS50d2Vlbi5fZHVyKSB7XG4gICAgdmFyIHRhcmdldCA9IGRhdGEudCxcbiAgICAgICAgc3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gICAgICAgIHByb3BzID0gZGF0YS51LFxuICAgICAgICBjYWNoZSA9IHRhcmdldC5fZ3NhcCxcbiAgICAgICAgcHJvcCxcbiAgICAgICAgY2xlYXJUcmFuc2Zvcm1zLFxuICAgICAgICBpO1xuXG4gICAgaWYgKHByb3BzID09PSBcImFsbFwiIHx8IHByb3BzID09PSB0cnVlKSB7XG4gICAgICBzdHlsZS5jc3NUZXh0ID0gXCJcIjtcbiAgICAgIGNsZWFyVHJhbnNmb3JtcyA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3BzID0gcHJvcHMuc3BsaXQoXCIsXCIpO1xuICAgICAgaSA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgICAgIHByb3AgPSBwcm9wc1tpXTtcblxuICAgICAgICBpZiAoX3RyYW5zZm9ybVByb3BzW3Byb3BdKSB7XG4gICAgICAgICAgY2xlYXJUcmFuc2Zvcm1zID0gMTtcbiAgICAgICAgICBwcm9wID0gcHJvcCA9PT0gXCJ0cmFuc2Zvcm1PcmlnaW5cIiA/IF90cmFuc2Zvcm1PcmlnaW5Qcm9wIDogX3RyYW5zZm9ybVByb3A7XG4gICAgICAgIH1cblxuICAgICAgICBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBwcm9wKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2xlYXJUcmFuc2Zvcm1zKSB7XG4gICAgICBfcmVtb3ZlUHJvcGVydHkodGFyZ2V0LCBfdHJhbnNmb3JtUHJvcCk7XG5cbiAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICBjYWNoZS5zdmcgJiYgdGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcblxuICAgICAgICBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCAxKTsgLy8gZm9yY2UgYWxsIHRoZSBjYWNoZWQgdmFsdWVzIGJhY2sgdG8gXCJub3JtYWxcIi9pZGVudGl0eSwgb3RoZXJ3aXNlIGlmIHRoZXJlJ3MgYW5vdGhlciB0d2VlbiB0aGF0J3MgYWxyZWFkeSBzZXQgdG8gcmVuZGVyIHRyYW5zZm9ybXMgb24gdGhpcyBlbGVtZW50LCBpdCBjb3VsZCBkaXNwbGF5IHRoZSB3cm9uZyB2YWx1ZXMuXG5cblxuICAgICAgICBjYWNoZS51bmNhY2hlID0gMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sXG4gICAgLy8gbm90ZTogc3BlY2lhbFByb3BzIHNob3VsZCByZXR1cm4gMSBpZiAoYW5kIG9ubHkgaWYpIHRoZXkgaGF2ZSBhIG5vbi16ZXJvIHByaW9yaXR5LiBJdCBpbmRpY2F0ZXMgd2UgbmVlZCB0byBzb3J0IHRoZSBsaW5rZWQgbGlzdC5cbl9zcGVjaWFsUHJvcHMgPSB7XG4gIGNsZWFyUHJvcHM6IGZ1bmN0aW9uIGNsZWFyUHJvcHMocGx1Z2luLCB0YXJnZXQsIHByb3BlcnR5LCBlbmRWYWx1ZSwgdHdlZW4pIHtcbiAgICBpZiAodHdlZW4uZGF0YSAhPT0gXCJpc0Zyb21TdGFydFwiKSB7XG4gICAgICB2YXIgcHQgPSBwbHVnaW4uX3B0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIHByb3BlcnR5LCAwLCAwLCBfcmVuZGVyQ2xlYXJQcm9wcyk7XG4gICAgICBwdC51ID0gZW5kVmFsdWU7XG4gICAgICBwdC5wciA9IC0xMDtcbiAgICAgIHB0LnR3ZWVuID0gdHdlZW47XG5cbiAgICAgIHBsdWdpbi5fcHJvcHMucHVzaChwcm9wZXJ0eSk7XG5cbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfVxuICAvKiBjbGFzc05hbWUgZmVhdHVyZSAoYWJvdXQgMC40a2IgZ3ppcHBlZCkuXG4gICwgY2xhc3NOYW1lKHBsdWdpbiwgdGFyZ2V0LCBwcm9wZXJ0eSwgZW5kVmFsdWUsIHR3ZWVuKSB7XG4gIFx0bGV0IF9yZW5kZXJDbGFzc05hbWUgPSAocmF0aW8sIGRhdGEpID0+IHtcbiAgXHRcdFx0ZGF0YS5jc3MucmVuZGVyKHJhdGlvLCBkYXRhLmNzcyk7XG4gIFx0XHRcdGlmICghcmF0aW8gfHwgcmF0aW8gPT09IDEpIHtcbiAgXHRcdFx0XHRsZXQgaW5saW5lID0gZGF0YS5ybXYsXG4gIFx0XHRcdFx0XHR0YXJnZXQgPSBkYXRhLnQsXG4gIFx0XHRcdFx0XHRwO1xuICBcdFx0XHRcdHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCByYXRpbyA/IGRhdGEuZSA6IGRhdGEuYik7XG4gIFx0XHRcdFx0Zm9yIChwIGluIGlubGluZSkge1xuICBcdFx0XHRcdFx0X3JlbW92ZVByb3BlcnR5KHRhcmdldCwgcCk7XG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9XG4gIFx0XHR9LFxuICBcdFx0X2dldEFsbFN0eWxlcyA9ICh0YXJnZXQpID0+IHtcbiAgXHRcdFx0bGV0IHN0eWxlcyA9IHt9LFxuICBcdFx0XHRcdGNvbXB1dGVkID0gZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLFxuICBcdFx0XHRcdHA7XG4gIFx0XHRcdGZvciAocCBpbiBjb21wdXRlZCkge1xuICBcdFx0XHRcdGlmIChpc05hTihwKSAmJiBwICE9PSBcImNzc1RleHRcIiAmJiBwICE9PSBcImxlbmd0aFwiKSB7XG4gIFx0XHRcdFx0XHRzdHlsZXNbcF0gPSBjb21wdXRlZFtwXTtcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH1cbiAgXHRcdFx0X3NldERlZmF1bHRzKHN0eWxlcywgX3BhcnNlVHJhbnNmb3JtKHRhcmdldCwgMSkpO1xuICBcdFx0XHRyZXR1cm4gc3R5bGVzO1xuICBcdFx0fSxcbiAgXHRcdHN0YXJ0Q2xhc3NMaXN0ID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpLFxuICBcdFx0c3R5bGUgPSB0YXJnZXQuc3R5bGUsXG4gIFx0XHRjc3NUZXh0ID0gc3R5bGUuY3NzVGV4dCxcbiAgXHRcdGNhY2hlID0gdGFyZ2V0Ll9nc2FwLFxuICBcdFx0Y2xhc3NQVCA9IGNhY2hlLmNsYXNzUFQsXG4gIFx0XHRpbmxpbmVUb1JlbW92ZUF0RW5kID0ge30sXG4gIFx0XHRkYXRhID0ge3Q6dGFyZ2V0LCBwbHVnaW46cGx1Z2luLCBybXY6aW5saW5lVG9SZW1vdmVBdEVuZCwgYjpzdGFydENsYXNzTGlzdCwgZTooZW5kVmFsdWUuY2hhckF0KDEpICE9PSBcIj1cIikgPyBlbmRWYWx1ZSA6IHN0YXJ0Q2xhc3NMaXN0LnJlcGxhY2UobmV3IFJlZ0V4cChcIig/OlxcXFxzfF4pXCIgKyBlbmRWYWx1ZS5zdWJzdHIoMikgKyBcIig/IVtcXFxcdy1dKVwiKSwgXCJcIikgKyAoKGVuZFZhbHVlLmNoYXJBdCgwKSA9PT0gXCIrXCIpID8gXCIgXCIgKyBlbmRWYWx1ZS5zdWJzdHIoMikgOiBcIlwiKX0sXG4gIFx0XHRjaGFuZ2luZ1ZhcnMgPSB7fSxcbiAgXHRcdHN0YXJ0VmFycyA9IF9nZXRBbGxTdHlsZXModGFyZ2V0KSxcbiAgXHRcdHRyYW5zZm9ybVJlbGF0ZWQgPSAvKHRyYW5zZm9ybXxwZXJzcGVjdGl2ZSkvaSxcbiAgXHRcdGVuZFZhcnMsIHA7XG4gIFx0aWYgKGNsYXNzUFQpIHtcbiAgXHRcdGNsYXNzUFQucigxLCBjbGFzc1BULmQpO1xuICBcdFx0X3JlbW92ZUxpbmtlZExpc3RJdGVtKGNsYXNzUFQuZC5wbHVnaW4sIGNsYXNzUFQsIFwiX3B0XCIpO1xuICBcdH1cbiAgXHR0YXJnZXQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgZGF0YS5lKTtcbiAgXHRlbmRWYXJzID0gX2dldEFsbFN0eWxlcyh0YXJnZXQsIHRydWUpO1xuICBcdHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBzdGFydENsYXNzTGlzdCk7XG4gIFx0Zm9yIChwIGluIGVuZFZhcnMpIHtcbiAgXHRcdGlmIChlbmRWYXJzW3BdICE9PSBzdGFydFZhcnNbcF0gJiYgIXRyYW5zZm9ybVJlbGF0ZWQudGVzdChwKSkge1xuICBcdFx0XHRjaGFuZ2luZ1ZhcnNbcF0gPSBlbmRWYXJzW3BdO1xuICBcdFx0XHRpZiAoIXN0eWxlW3BdICYmIHN0eWxlW3BdICE9PSBcIjBcIikge1xuICBcdFx0XHRcdGlubGluZVRvUmVtb3ZlQXRFbmRbcF0gPSAxO1xuICBcdFx0XHR9XG4gIFx0XHR9XG4gIFx0fVxuICBcdGNhY2hlLmNsYXNzUFQgPSBwbHVnaW4uX3B0ID0gbmV3IFByb3BUd2VlbihwbHVnaW4uX3B0LCB0YXJnZXQsIFwiY2xhc3NOYW1lXCIsIDAsIDAsIF9yZW5kZXJDbGFzc05hbWUsIGRhdGEsIDAsIC0xMSk7XG4gIFx0aWYgKHN0eWxlLmNzc1RleHQgIT09IGNzc1RleHQpIHsgLy9vbmx5IGFwcGx5IGlmIHRoaW5ncyBjaGFuZ2UuIE90aGVyd2lzZSwgaW4gY2FzZXMgbGlrZSBhIGJhY2tncm91bmQtaW1hZ2UgdGhhdCdzIHB1bGxlZCBkeW5hbWljYWxseSwgaXQgY291bGQgY2F1c2UgYSByZWZyZXNoLiBTZWUgaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8yMDM2OC1wb3NzaWJsZS1nc2FwLWJ1Zy1zd2l0Y2hpbmctY2xhc3NuYW1lcy1pbi1jaHJvbWUvLlxuICBcdFx0c3R5bGUuY3NzVGV4dCA9IGNzc1RleHQ7IC8vd2UgcmVjb3JkZWQgY3NzVGV4dCBiZWZvcmUgd2Ugc3dhcHBlZCBjbGFzc2VzIGFuZCByYW4gX2dldEFsbFN0eWxlcygpIGJlY2F1c2UgaW4gY2FzZXMgd2hlbiBhIGNsYXNzTmFtZSB0d2VlbiBpcyBvdmVyd3JpdHRlbiwgd2UgcmVtb3ZlIGFsbCB0aGUgcmVsYXRlZCB0d2VlbmluZyBwcm9wZXJ0aWVzIGZyb20gdGhhdCBjbGFzcyBjaGFuZ2UgKG90aGVyd2lzZSBjbGFzcy1zcGVjaWZpYyBzdHVmZiBjYW4ndCBvdmVycmlkZSBwcm9wZXJ0aWVzIHdlJ3ZlIGRpcmVjdGx5IHNldCBvbiB0aGUgdGFyZ2V0J3Mgc3R5bGUgb2JqZWN0IGR1ZSB0byBzcGVjaWZpY2l0eSkuXG4gIFx0fVxuICBcdF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIHRydWUpOyAvL3RvIGNsZWFyIHRoZSBjYWNoaW5nIG9mIHRyYW5zZm9ybXNcbiAgXHRkYXRhLmNzcyA9IG5ldyBnc2FwLnBsdWdpbnMuY3NzKCk7XG4gIFx0ZGF0YS5jc3MuaW5pdCh0YXJnZXQsIGNoYW5naW5nVmFycywgdHdlZW4pO1xuICBcdHBsdWdpbi5fcHJvcHMucHVzaCguLi5kYXRhLmNzcy5fcHJvcHMpO1xuICBcdHJldHVybiAxO1xuICB9XG4gICovXG5cbn0sXG5cbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVFJBTlNGT1JNU1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuX2lkZW50aXR5MkRNYXRyaXggPSBbMSwgMCwgMCwgMSwgMCwgMF0sXG4gICAgX3JvdGF0aW9uYWxQcm9wZXJ0aWVzID0ge30sXG4gICAgX2lzTnVsbFRyYW5zZm9ybSA9IGZ1bmN0aW9uIF9pc051bGxUcmFuc2Zvcm0odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBcIm1hdHJpeCgxLCAwLCAwLCAxLCAwLCAwKVwiIHx8IHZhbHVlID09PSBcIm5vbmVcIiB8fCAhdmFsdWU7XG59LFxuICAgIF9nZXRDb21wdXRlZFRyYW5zZm9ybU1hdHJpeEFzQXJyYXkgPSBmdW5jdGlvbiBfZ2V0Q29tcHV0ZWRUcmFuc2Zvcm1NYXRyaXhBc0FycmF5KHRhcmdldCkge1xuICB2YXIgbWF0cml4U3RyaW5nID0gX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBfdHJhbnNmb3JtUHJvcCk7XG5cbiAgcmV0dXJuIF9pc051bGxUcmFuc2Zvcm0obWF0cml4U3RyaW5nKSA/IF9pZGVudGl0eTJETWF0cml4IDogbWF0cml4U3RyaW5nLnN1YnN0cig3KS5tYXRjaChfbnVtRXhwKS5tYXAoX3JvdW5kKTtcbn0sXG4gICAgX2dldE1hdHJpeCA9IGZ1bmN0aW9uIF9nZXRNYXRyaXgodGFyZ2V0LCBmb3JjZTJEKSB7XG4gIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcCB8fCBfZ2V0Q2FjaGUodGFyZ2V0KSxcbiAgICAgIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgbWF0cml4ID0gX2dldENvbXB1dGVkVHJhbnNmb3JtTWF0cml4QXNBcnJheSh0YXJnZXQpLFxuICAgICAgcGFyZW50LFxuICAgICAgbmV4dFNpYmxpbmcsXG4gICAgICB0ZW1wLFxuICAgICAgYWRkZWRUb0RPTTtcblxuICBpZiAoY2FjaGUuc3ZnICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIikpIHtcbiAgICB0ZW1wID0gdGFyZ2V0LnRyYW5zZm9ybS5iYXNlVmFsLmNvbnNvbGlkYXRlKCkubWF0cml4OyAvL2Vuc3VyZXMgdGhhdCBldmVuIGNvbXBsZXggdmFsdWVzIGxpa2UgXCJ0cmFuc2xhdGUoNTAsNjApIHJvdGF0ZSgxMzUsMCwwKVwiIGFyZSBwYXJzZWQgYmVjYXVzZSBpdCBtYXNoZXMgaXQgaW50byBhIG1hdHJpeC5cblxuICAgIG1hdHJpeCA9IFt0ZW1wLmEsIHRlbXAuYiwgdGVtcC5jLCB0ZW1wLmQsIHRlbXAuZSwgdGVtcC5mXTtcbiAgICByZXR1cm4gbWF0cml4LmpvaW4oXCIsXCIpID09PSBcIjEsMCwwLDEsMCwwXCIgPyBfaWRlbnRpdHkyRE1hdHJpeCA6IG1hdHJpeDtcbiAgfSBlbHNlIGlmIChtYXRyaXggPT09IF9pZGVudGl0eTJETWF0cml4ICYmICF0YXJnZXQub2Zmc2V0UGFyZW50ICYmIHRhcmdldCAhPT0gX2RvY0VsZW1lbnQgJiYgIWNhY2hlLnN2Zykge1xuICAgIC8vbm90ZTogaWYgb2Zmc2V0UGFyZW50IGlzIG51bGwsIHRoYXQgbWVhbnMgdGhlIGVsZW1lbnQgaXNuJ3QgaW4gdGhlIG5vcm1hbCBkb2N1bWVudCBmbG93LCBsaWtlIGlmIGl0IGhhcyBkaXNwbGF5Om5vbmUgb3Igb25lIG9mIGl0cyBhbmNlc3RvcnMgaGFzIGRpc3BsYXk6bm9uZSkuIEZpcmVmb3ggcmV0dXJucyBudWxsIGZvciBnZXRDb21wdXRlZFN0eWxlKCkgaWYgdGhlIGVsZW1lbnQgaXMgaW4gYW4gaWZyYW1lIHRoYXQgaGFzIGRpc3BsYXk6bm9uZS4gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTQ4Mzk3XG4gICAgLy9icm93c2VycyBkb24ndCByZXBvcnQgdHJhbnNmb3JtcyBhY2N1cmF0ZWx5IHVubGVzcyB0aGUgZWxlbWVudCBpcyBpbiB0aGUgRE9NIGFuZCBoYXMgYSBkaXNwbGF5IHZhbHVlIHRoYXQncyBub3QgXCJub25lXCIuIEZpcmVmb3ggYW5kIE1pY3Jvc29mdCBicm93c2VycyBoYXZlIGEgcGFydGlhbCBidWcgd2hlcmUgdGhleSdsbCByZXBvcnQgdHJhbnNmb3JtcyBldmVuIGlmIGRpc3BsYXk6bm9uZSBCVVQgbm90IGFueSBwZXJjZW50YWdlLWJhc2VkIHZhbHVlcyBsaWtlIHRyYW5zbGF0ZSgtNTAlLCA4cHgpIHdpbGwgYmUgcmVwb3J0ZWQgYXMgaWYgaXQncyB0cmFuc2xhdGUoMCwgOHB4KS5cbiAgICB0ZW1wID0gc3R5bGUuZGlzcGxheTtcbiAgICBzdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIHBhcmVudCA9IHRhcmdldC5wYXJlbnROb2RlO1xuXG4gICAgaWYgKCFwYXJlbnQgfHwgIXRhcmdldC5vZmZzZXRQYXJlbnQpIHtcbiAgICAgIC8vIG5vdGU6IGluIDMuMy4wIHdlIHN3aXRjaGVkIHRhcmdldC5vZmZzZXRQYXJlbnQgdG8gX2RvYy5ib2R5LmNvbnRhaW5zKHRhcmdldCkgdG8gYXZvaWQgW3NvbWV0aW1lcyB1bm5lY2Vzc2FyeV0gTXV0YXRpb25PYnNlcnZlciBjYWxscyBidXQgdGhhdCB3YXNuJ3QgYWRlcXVhdGUgYmVjYXVzZSB0aGVyZSBhcmUgZWRnZSBjYXNlcyB3aGVyZSBuZXN0ZWQgcG9zaXRpb246IGZpeGVkIGVsZW1lbnRzIG5lZWQgdG8gZ2V0IHJlcGFyZW50ZWQgdG8gYWNjdXJhdGVseSBzZW5zZSB0cmFuc2Zvcm1zLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2dyZWVuc29jay9HU0FQL2lzc3Vlcy8zODggYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmVlbnNvY2svR1NBUC9pc3N1ZXMvMzc1XG4gICAgICBhZGRlZFRvRE9NID0gMTsgLy9mbGFnXG5cbiAgICAgIG5leHRTaWJsaW5nID0gdGFyZ2V0Lm5leHRTaWJsaW5nO1xuXG4gICAgICBfZG9jRWxlbWVudC5hcHBlbmRDaGlsZCh0YXJnZXQpOyAvL3dlIG11c3QgYWRkIGl0IHRvIHRoZSBET00gaW4gb3JkZXIgdG8gZ2V0IHZhbHVlcyBwcm9wZXJseVxuXG4gICAgfVxuXG4gICAgbWF0cml4ID0gX2dldENvbXB1dGVkVHJhbnNmb3JtTWF0cml4QXNBcnJheSh0YXJnZXQpO1xuICAgIHRlbXAgPyBzdHlsZS5kaXNwbGF5ID0gdGVtcCA6IF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIFwiZGlzcGxheVwiKTtcblxuICAgIGlmIChhZGRlZFRvRE9NKSB7XG4gICAgICBuZXh0U2libGluZyA/IHBhcmVudC5pbnNlcnRCZWZvcmUodGFyZ2V0LCBuZXh0U2libGluZykgOiBwYXJlbnQgPyBwYXJlbnQuYXBwZW5kQ2hpbGQodGFyZ2V0KSA6IF9kb2NFbGVtZW50LnJlbW92ZUNoaWxkKHRhcmdldCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZvcmNlMkQgJiYgbWF0cml4Lmxlbmd0aCA+IDYgPyBbbWF0cml4WzBdLCBtYXRyaXhbMV0sIG1hdHJpeFs0XSwgbWF0cml4WzVdLCBtYXRyaXhbMTJdLCBtYXRyaXhbMTNdXSA6IG1hdHJpeDtcbn0sXG4gICAgX2FwcGx5U1ZHT3JpZ2luID0gZnVuY3Rpb24gX2FwcGx5U1ZHT3JpZ2luKHRhcmdldCwgb3JpZ2luLCBvcmlnaW5Jc0Fic29sdXRlLCBzbW9vdGgsIG1hdHJpeEFycmF5LCBwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbykge1xuICB2YXIgY2FjaGUgPSB0YXJnZXQuX2dzYXAsXG4gICAgICBtYXRyaXggPSBtYXRyaXhBcnJheSB8fCBfZ2V0TWF0cml4KHRhcmdldCwgdHJ1ZSksXG4gICAgICB4T3JpZ2luT2xkID0gY2FjaGUueE9yaWdpbiB8fCAwLFxuICAgICAgeU9yaWdpbk9sZCA9IGNhY2hlLnlPcmlnaW4gfHwgMCxcbiAgICAgIHhPZmZzZXRPbGQgPSBjYWNoZS54T2Zmc2V0IHx8IDAsXG4gICAgICB5T2Zmc2V0T2xkID0gY2FjaGUueU9mZnNldCB8fCAwLFxuICAgICAgYSA9IG1hdHJpeFswXSxcbiAgICAgIGIgPSBtYXRyaXhbMV0sXG4gICAgICBjID0gbWF0cml4WzJdLFxuICAgICAgZCA9IG1hdHJpeFszXSxcbiAgICAgIHR4ID0gbWF0cml4WzRdLFxuICAgICAgdHkgPSBtYXRyaXhbNV0sXG4gICAgICBvcmlnaW5TcGxpdCA9IG9yaWdpbi5zcGxpdChcIiBcIiksXG4gICAgICB4T3JpZ2luID0gcGFyc2VGbG9hdChvcmlnaW5TcGxpdFswXSkgfHwgMCxcbiAgICAgIHlPcmlnaW4gPSBwYXJzZUZsb2F0KG9yaWdpblNwbGl0WzFdKSB8fCAwLFxuICAgICAgYm91bmRzLFxuICAgICAgZGV0ZXJtaW5hbnQsXG4gICAgICB4LFxuICAgICAgeTtcblxuICBpZiAoIW9yaWdpbklzQWJzb2x1dGUpIHtcbiAgICBib3VuZHMgPSBfZ2V0QkJveCh0YXJnZXQpO1xuICAgIHhPcmlnaW4gPSBib3VuZHMueCArICh+b3JpZ2luU3BsaXRbMF0uaW5kZXhPZihcIiVcIikgPyB4T3JpZ2luIC8gMTAwICogYm91bmRzLndpZHRoIDogeE9yaWdpbik7XG4gICAgeU9yaWdpbiA9IGJvdW5kcy55ICsgKH4ob3JpZ2luU3BsaXRbMV0gfHwgb3JpZ2luU3BsaXRbMF0pLmluZGV4T2YoXCIlXCIpID8geU9yaWdpbiAvIDEwMCAqIGJvdW5kcy5oZWlnaHQgOiB5T3JpZ2luKTtcbiAgfSBlbHNlIGlmIChtYXRyaXggIT09IF9pZGVudGl0eTJETWF0cml4ICYmIChkZXRlcm1pbmFudCA9IGEgKiBkIC0gYiAqIGMpKSB7XG4gICAgLy9pZiBpdCdzIHplcm8gKGxpa2UgaWYgc2NhbGVYIGFuZCBzY2FsZVkgYXJlIHplcm8pLCBza2lwIGl0IHRvIGF2b2lkIGVycm9ycyB3aXRoIGRpdmlkaW5nIGJ5IHplcm8uXG4gICAgeCA9IHhPcmlnaW4gKiAoZCAvIGRldGVybWluYW50KSArIHlPcmlnaW4gKiAoLWMgLyBkZXRlcm1pbmFudCkgKyAoYyAqIHR5IC0gZCAqIHR4KSAvIGRldGVybWluYW50O1xuICAgIHkgPSB4T3JpZ2luICogKC1iIC8gZGV0ZXJtaW5hbnQpICsgeU9yaWdpbiAqIChhIC8gZGV0ZXJtaW5hbnQpIC0gKGEgKiB0eSAtIGIgKiB0eCkgLyBkZXRlcm1pbmFudDtcbiAgICB4T3JpZ2luID0geDtcbiAgICB5T3JpZ2luID0geTtcbiAgfVxuXG4gIGlmIChzbW9vdGggfHwgc21vb3RoICE9PSBmYWxzZSAmJiBjYWNoZS5zbW9vdGgpIHtcbiAgICB0eCA9IHhPcmlnaW4gLSB4T3JpZ2luT2xkO1xuICAgIHR5ID0geU9yaWdpbiAtIHlPcmlnaW5PbGQ7XG4gICAgY2FjaGUueE9mZnNldCA9IHhPZmZzZXRPbGQgKyAodHggKiBhICsgdHkgKiBjKSAtIHR4O1xuICAgIGNhY2hlLnlPZmZzZXQgPSB5T2Zmc2V0T2xkICsgKHR4ICogYiArIHR5ICogZCkgLSB0eTtcbiAgfSBlbHNlIHtcbiAgICBjYWNoZS54T2Zmc2V0ID0gY2FjaGUueU9mZnNldCA9IDA7XG4gIH1cblxuICBjYWNoZS54T3JpZ2luID0geE9yaWdpbjtcbiAgY2FjaGUueU9yaWdpbiA9IHlPcmlnaW47XG4gIGNhY2hlLnNtb290aCA9ICEhc21vb3RoO1xuICBjYWNoZS5vcmlnaW4gPSBvcmlnaW47XG4gIGNhY2hlLm9yaWdpbklzQWJzb2x1dGUgPSAhIW9yaWdpbklzQWJzb2x1dGU7XG4gIHRhcmdldC5zdHlsZVtfdHJhbnNmb3JtT3JpZ2luUHJvcF0gPSBcIjBweCAwcHhcIjsgLy9vdGhlcndpc2UsIGlmIHNvbWVvbmUgc2V0cyAgYW4gb3JpZ2luIHZpYSBDU1MsIGl0IHdpbGwgbGlrZWx5IGludGVyZmVyZSB3aXRoIHRoZSBTVkcgdHJhbnNmb3JtIGF0dHJpYnV0ZSBvbmVzIChiZWNhdXNlIHJlbWVtYmVyLCB3ZSdyZSBiYWtpbmcgdGhlIG9yaWdpbiBpbnRvIHRoZSBtYXRyaXgoKSB2YWx1ZSkuXG5cbiAgaWYgKHBsdWdpblRvQWRkUHJvcFR3ZWVuc1RvKSB7XG4gICAgX2FkZE5vblR3ZWVuaW5nUFQocGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8sIGNhY2hlLCBcInhPcmlnaW5cIiwgeE9yaWdpbk9sZCwgeE9yaWdpbik7XG5cbiAgICBfYWRkTm9uVHdlZW5pbmdQVChwbHVnaW5Ub0FkZFByb3BUd2VlbnNUbywgY2FjaGUsIFwieU9yaWdpblwiLCB5T3JpZ2luT2xkLCB5T3JpZ2luKTtcblxuICAgIF9hZGROb25Ud2VlbmluZ1BUKHBsdWdpblRvQWRkUHJvcFR3ZWVuc1RvLCBjYWNoZSwgXCJ4T2Zmc2V0XCIsIHhPZmZzZXRPbGQsIGNhY2hlLnhPZmZzZXQpO1xuXG4gICAgX2FkZE5vblR3ZWVuaW5nUFQocGx1Z2luVG9BZGRQcm9wVHdlZW5zVG8sIGNhY2hlLCBcInlPZmZzZXRcIiwgeU9mZnNldE9sZCwgY2FjaGUueU9mZnNldCk7XG4gIH1cblxuICB0YXJnZXQuc2V0QXR0cmlidXRlKFwiZGF0YS1zdmctb3JpZ2luXCIsIHhPcmlnaW4gKyBcIiBcIiArIHlPcmlnaW4pO1xufSxcbiAgICBfcGFyc2VUcmFuc2Zvcm0gPSBmdW5jdGlvbiBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCB1bmNhY2hlKSB7XG4gIHZhciBjYWNoZSA9IHRhcmdldC5fZ3NhcCB8fCBuZXcgR1NDYWNoZSh0YXJnZXQpO1xuXG4gIGlmIChcInhcIiBpbiBjYWNoZSAmJiAhdW5jYWNoZSAmJiAhY2FjaGUudW5jYWNoZSkge1xuICAgIHJldHVybiBjYWNoZTtcbiAgfVxuXG4gIHZhciBzdHlsZSA9IHRhcmdldC5zdHlsZSxcbiAgICAgIGludmVydGVkU2NhbGVYID0gY2FjaGUuc2NhbGVYIDwgMCxcbiAgICAgIHB4ID0gXCJweFwiLFxuICAgICAgZGVnID0gXCJkZWdcIixcbiAgICAgIG9yaWdpbiA9IF9nZXRDb21wdXRlZFByb3BlcnR5KHRhcmdldCwgX3RyYW5zZm9ybU9yaWdpblByb3ApIHx8IFwiMFwiLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB6LFxuICAgICAgc2NhbGVYLFxuICAgICAgc2NhbGVZLFxuICAgICAgcm90YXRpb24sXG4gICAgICByb3RhdGlvblgsXG4gICAgICByb3RhdGlvblksXG4gICAgICBza2V3WCxcbiAgICAgIHNrZXdZLFxuICAgICAgcGVyc3BlY3RpdmUsXG4gICAgICB4T3JpZ2luLFxuICAgICAgeU9yaWdpbixcbiAgICAgIG1hdHJpeCxcbiAgICAgIGFuZ2xlLFxuICAgICAgY29zLFxuICAgICAgc2luLFxuICAgICAgYSxcbiAgICAgIGIsXG4gICAgICBjLFxuICAgICAgZCxcbiAgICAgIGExMixcbiAgICAgIGEyMixcbiAgICAgIHQxLFxuICAgICAgdDIsXG4gICAgICB0MyxcbiAgICAgIGExMyxcbiAgICAgIGEyMyxcbiAgICAgIGEzMyxcbiAgICAgIGE0MixcbiAgICAgIGE0MyxcbiAgICAgIGEzMjtcbiAgeCA9IHkgPSB6ID0gcm90YXRpb24gPSByb3RhdGlvblggPSByb3RhdGlvblkgPSBza2V3WCA9IHNrZXdZID0gcGVyc3BlY3RpdmUgPSAwO1xuICBzY2FsZVggPSBzY2FsZVkgPSAxO1xuICBjYWNoZS5zdmcgPSAhISh0YXJnZXQuZ2V0Q1RNICYmIF9pc1NWRyh0YXJnZXQpKTtcbiAgbWF0cml4ID0gX2dldE1hdHJpeCh0YXJnZXQsIGNhY2hlLnN2Zyk7XG5cbiAgaWYgKGNhY2hlLnN2Zykge1xuICAgIHQxID0gKCFjYWNoZS51bmNhY2hlIHx8IG9yaWdpbiA9PT0gXCIwcHggMHB4XCIpICYmICF1bmNhY2hlICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXN2Zy1vcmlnaW5cIik7IC8vIGlmIG9yaWdpbiBpcyAwLDAgYW5kIGNhY2hlLnVuY2FjaGUgaXMgdHJ1ZSwgbGV0IHRoZSByZWNvcmRlZCBkYXRhLXN2Zy1vcmlnaW4gc3RheS4gT3RoZXJ3aXNlLCB3aGVuZXZlciB3ZSBzZXQgY2FjaGUudW5jYWNoZSB0byB0cnVlLCB3ZSdkIG5lZWQgdG8gc2V0IGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gKGNhY2hlLnhPcmlnaW4gLSBiYm94LngpICsgXCJweCBcIiArIChjYWNoZS55T3JpZ2luIC0gYmJveC55KSArIFwicHhcIi4gUmVtZW1iZXIsIHRvIHdvcmsgYXJvdW5kIGJyb3dzZXIgaW5jb25zaXN0ZW5jaWVzIHdlIGFsd2F5cyBmb3JjZSBTVkcgZWxlbWVudHMnIHRyYW5zZm9ybU9yaWdpbiB0byAwLDAgYW5kIG9mZnNldCB0aGUgdHJhbnNsYXRpb24gYWNjb3JkaW5nbHkuXG5cbiAgICBfYXBwbHlTVkdPcmlnaW4odGFyZ2V0LCB0MSB8fCBvcmlnaW4sICEhdDEgfHwgY2FjaGUub3JpZ2luSXNBYnNvbHV0ZSwgY2FjaGUuc21vb3RoICE9PSBmYWxzZSwgbWF0cml4KTtcbiAgfVxuXG4gIHhPcmlnaW4gPSBjYWNoZS54T3JpZ2luIHx8IDA7XG4gIHlPcmlnaW4gPSBjYWNoZS55T3JpZ2luIHx8IDA7XG5cbiAgaWYgKG1hdHJpeCAhPT0gX2lkZW50aXR5MkRNYXRyaXgpIHtcbiAgICBhID0gbWF0cml4WzBdOyAvL2ExMVxuXG4gICAgYiA9IG1hdHJpeFsxXTsgLy9hMjFcblxuICAgIGMgPSBtYXRyaXhbMl07IC8vYTMxXG5cbiAgICBkID0gbWF0cml4WzNdOyAvL2E0MVxuXG4gICAgeCA9IGExMiA9IG1hdHJpeFs0XTtcbiAgICB5ID0gYTIyID0gbWF0cml4WzVdOyAvLzJEIG1hdHJpeFxuXG4gICAgaWYgKG1hdHJpeC5sZW5ndGggPT09IDYpIHtcbiAgICAgIHNjYWxlWCA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcbiAgICAgIHNjYWxlWSA9IE1hdGguc3FydChkICogZCArIGMgKiBjKTtcbiAgICAgIHJvdGF0aW9uID0gYSB8fCBiID8gX2F0YW4yKGIsIGEpICogX1JBRDJERUcgOiAwOyAvL25vdGU6IGlmIHNjYWxlWCBpcyAwLCB3ZSBjYW5ub3QgYWNjdXJhdGVseSBtZWFzdXJlIHJvdGF0aW9uLiBTYW1lIGZvciBza2V3WCB3aXRoIGEgc2NhbGVZIG9mIDAuIFRoZXJlZm9yZSwgd2UgZGVmYXVsdCB0byB0aGUgcHJldmlvdXNseSByZWNvcmRlZCB2YWx1ZSAob3IgemVybyBpZiB0aGF0IGRvZXNuJ3QgZXhpc3QpLlxuXG4gICAgICBza2V3WCA9IGMgfHwgZCA/IF9hdGFuMihjLCBkKSAqIF9SQUQyREVHICsgcm90YXRpb24gOiAwO1xuICAgICAgc2tld1ggJiYgKHNjYWxlWSAqPSBNYXRoLmFicyhNYXRoLmNvcyhza2V3WCAqIF9ERUcyUkFEKSkpO1xuXG4gICAgICBpZiAoY2FjaGUuc3ZnKSB7XG4gICAgICAgIHggLT0geE9yaWdpbiAtICh4T3JpZ2luICogYSArIHlPcmlnaW4gKiBjKTtcbiAgICAgICAgeSAtPSB5T3JpZ2luIC0gKHhPcmlnaW4gKiBiICsgeU9yaWdpbiAqIGQpO1xuICAgICAgfSAvLzNEIG1hdHJpeFxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGEzMiA9IG1hdHJpeFs2XTtcbiAgICAgIGE0MiA9IG1hdHJpeFs3XTtcbiAgICAgIGExMyA9IG1hdHJpeFs4XTtcbiAgICAgIGEyMyA9IG1hdHJpeFs5XTtcbiAgICAgIGEzMyA9IG1hdHJpeFsxMF07XG4gICAgICBhNDMgPSBtYXRyaXhbMTFdO1xuICAgICAgeCA9IG1hdHJpeFsxMl07XG4gICAgICB5ID0gbWF0cml4WzEzXTtcbiAgICAgIHogPSBtYXRyaXhbMTRdO1xuICAgICAgYW5nbGUgPSBfYXRhbjIoYTMyLCBhMzMpO1xuICAgICAgcm90YXRpb25YID0gYW5nbGUgKiBfUkFEMkRFRzsgLy9yb3RhdGlvblhcblxuICAgICAgaWYgKGFuZ2xlKSB7XG4gICAgICAgIGNvcyA9IE1hdGguY29zKC1hbmdsZSk7XG4gICAgICAgIHNpbiA9IE1hdGguc2luKC1hbmdsZSk7XG4gICAgICAgIHQxID0gYTEyICogY29zICsgYTEzICogc2luO1xuICAgICAgICB0MiA9IGEyMiAqIGNvcyArIGEyMyAqIHNpbjtcbiAgICAgICAgdDMgPSBhMzIgKiBjb3MgKyBhMzMgKiBzaW47XG4gICAgICAgIGExMyA9IGExMiAqIC1zaW4gKyBhMTMgKiBjb3M7XG4gICAgICAgIGEyMyA9IGEyMiAqIC1zaW4gKyBhMjMgKiBjb3M7XG4gICAgICAgIGEzMyA9IGEzMiAqIC1zaW4gKyBhMzMgKiBjb3M7XG4gICAgICAgIGE0MyA9IGE0MiAqIC1zaW4gKyBhNDMgKiBjb3M7XG4gICAgICAgIGExMiA9IHQxO1xuICAgICAgICBhMjIgPSB0MjtcbiAgICAgICAgYTMyID0gdDM7XG4gICAgICB9IC8vcm90YXRpb25ZXG5cblxuICAgICAgYW5nbGUgPSBfYXRhbjIoLWMsIGEzMyk7XG4gICAgICByb3RhdGlvblkgPSBhbmdsZSAqIF9SQUQyREVHO1xuXG4gICAgICBpZiAoYW5nbGUpIHtcbiAgICAgICAgY29zID0gTWF0aC5jb3MoLWFuZ2xlKTtcbiAgICAgICAgc2luID0gTWF0aC5zaW4oLWFuZ2xlKTtcbiAgICAgICAgdDEgPSBhICogY29zIC0gYTEzICogc2luO1xuICAgICAgICB0MiA9IGIgKiBjb3MgLSBhMjMgKiBzaW47XG4gICAgICAgIHQzID0gYyAqIGNvcyAtIGEzMyAqIHNpbjtcbiAgICAgICAgYTQzID0gZCAqIHNpbiArIGE0MyAqIGNvcztcbiAgICAgICAgYSA9IHQxO1xuICAgICAgICBiID0gdDI7XG4gICAgICAgIGMgPSB0MztcbiAgICAgIH0gLy9yb3RhdGlvblpcblxuXG4gICAgICBhbmdsZSA9IF9hdGFuMihiLCBhKTtcbiAgICAgIHJvdGF0aW9uID0gYW5nbGUgKiBfUkFEMkRFRztcblxuICAgICAgaWYgKGFuZ2xlKSB7XG4gICAgICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICB0MSA9IGEgKiBjb3MgKyBiICogc2luO1xuICAgICAgICB0MiA9IGExMiAqIGNvcyArIGEyMiAqIHNpbjtcbiAgICAgICAgYiA9IGIgKiBjb3MgLSBhICogc2luO1xuICAgICAgICBhMjIgPSBhMjIgKiBjb3MgLSBhMTIgKiBzaW47XG4gICAgICAgIGEgPSB0MTtcbiAgICAgICAgYTEyID0gdDI7XG4gICAgICB9XG5cbiAgICAgIGlmIChyb3RhdGlvblggJiYgTWF0aC5hYnMocm90YXRpb25YKSArIE1hdGguYWJzKHJvdGF0aW9uKSA+IDM1OS45KSB7XG4gICAgICAgIC8vd2hlbiByb3RhdGlvblkgaXMgc2V0LCBpdCB3aWxsIG9mdGVuIGJlIHBhcnNlZCBhcyAxODAgZGVncmVlcyBkaWZmZXJlbnQgdGhhbiBpdCBzaG91bGQgYmUsIGFuZCByb3RhdGlvblggYW5kIHJvdGF0aW9uIGJvdGggYmVpbmcgMTgwIChpdCBsb29rcyB0aGUgc2FtZSksIHNvIHdlIGFkanVzdCBmb3IgdGhhdCBoZXJlLlxuICAgICAgICByb3RhdGlvblggPSByb3RhdGlvbiA9IDA7XG4gICAgICAgIHJvdGF0aW9uWSA9IDE4MCAtIHJvdGF0aW9uWTtcbiAgICAgIH1cblxuICAgICAgc2NhbGVYID0gX3JvdW5kKE1hdGguc3FydChhICogYSArIGIgKiBiICsgYyAqIGMpKTtcbiAgICAgIHNjYWxlWSA9IF9yb3VuZChNYXRoLnNxcnQoYTIyICogYTIyICsgYTMyICogYTMyKSk7XG4gICAgICBhbmdsZSA9IF9hdGFuMihhMTIsIGEyMik7XG4gICAgICBza2V3WCA9IE1hdGguYWJzKGFuZ2xlKSA+IDAuMDAwMiA/IGFuZ2xlICogX1JBRDJERUcgOiAwO1xuICAgICAgcGVyc3BlY3RpdmUgPSBhNDMgPyAxIC8gKGE0MyA8IDAgPyAtYTQzIDogYTQzKSA6IDA7XG4gICAgfVxuXG4gICAgaWYgKGNhY2hlLnN2Zykge1xuICAgICAgLy9zZW5zZSBpZiB0aGVyZSBhcmUgQ1NTIHRyYW5zZm9ybXMgYXBwbGllZCBvbiBhbiBTVkcgZWxlbWVudCBpbiB3aGljaCBjYXNlIHdlIG11c3Qgb3ZlcndyaXRlIHRoZW0gd2hlbiByZW5kZXJpbmcuIFRoZSB0cmFuc2Zvcm0gYXR0cmlidXRlIGlzIG1vcmUgcmVsaWFibGUgY3Jvc3MtYnJvd3NlciwgYnV0IHdlIGNhbid0IGp1c3QgcmVtb3ZlIHRoZSBDU1Mgb25lcyBiZWNhdXNlIHRoZXkgbWF5IGJlIGFwcGxpZWQgaW4gYSBDU1MgcnVsZSBzb21ld2hlcmUgKG5vdCBqdXN0IGlubGluZSkuXG4gICAgICB0MSA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIik7XG4gICAgICBjYWNoZS5mb3JjZUNTUyA9IHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJcIikgfHwgIV9pc051bGxUcmFuc2Zvcm0oX2dldENvbXB1dGVkUHJvcGVydHkodGFyZ2V0LCBfdHJhbnNmb3JtUHJvcCkpO1xuICAgICAgdDEgJiYgdGFyZ2V0LnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB0MSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKE1hdGguYWJzKHNrZXdYKSA+IDkwICYmIE1hdGguYWJzKHNrZXdYKSA8IDI3MCkge1xuICAgIGlmIChpbnZlcnRlZFNjYWxlWCkge1xuICAgICAgc2NhbGVYICo9IC0xO1xuICAgICAgc2tld1ggKz0gcm90YXRpb24gPD0gMCA/IDE4MCA6IC0xODA7XG4gICAgICByb3RhdGlvbiArPSByb3RhdGlvbiA8PSAwID8gMTgwIDogLTE4MDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGVZICo9IC0xO1xuICAgICAgc2tld1ggKz0gc2tld1ggPD0gMCA/IDE4MCA6IC0xODA7XG4gICAgfVxuICB9XG5cbiAgY2FjaGUueCA9IHggLSAoKGNhY2hlLnhQZXJjZW50ID0geCAmJiAoY2FjaGUueFBlcmNlbnQgfHwgKE1hdGgucm91bmQodGFyZ2V0Lm9mZnNldFdpZHRoIC8gMikgPT09IE1hdGgucm91bmQoLXgpID8gLTUwIDogMCkpKSA/IHRhcmdldC5vZmZzZXRXaWR0aCAqIGNhY2hlLnhQZXJjZW50IC8gMTAwIDogMCkgKyBweDtcbiAgY2FjaGUueSA9IHkgLSAoKGNhY2hlLnlQZXJjZW50ID0geSAmJiAoY2FjaGUueVBlcmNlbnQgfHwgKE1hdGgucm91bmQodGFyZ2V0Lm9mZnNldEhlaWdodCAvIDIpID09PSBNYXRoLnJvdW5kKC15KSA/IC01MCA6IDApKSkgPyB0YXJnZXQub2Zmc2V0SGVpZ2h0ICogY2FjaGUueVBlcmNlbnQgLyAxMDAgOiAwKSArIHB4O1xuICBjYWNoZS56ID0geiArIHB4O1xuICBjYWNoZS5zY2FsZVggPSBfcm91bmQoc2NhbGVYKTtcbiAgY2FjaGUuc2NhbGVZID0gX3JvdW5kKHNjYWxlWSk7XG4gIGNhY2hlLnJvdGF0aW9uID0gX3JvdW5kKHJvdGF0aW9uKSArIGRlZztcbiAgY2FjaGUucm90YXRpb25YID0gX3JvdW5kKHJvdGF0aW9uWCkgKyBkZWc7XG4gIGNhY2hlLnJvdGF0aW9uWSA9IF9yb3VuZChyb3RhdGlvblkpICsgZGVnO1xuICBjYWNoZS5za2V3WCA9IHNrZXdYICsgZGVnO1xuICBjYWNoZS5za2V3WSA9IHNrZXdZICsgZGVnO1xuICBjYWNoZS50cmFuc2Zvcm1QZXJzcGVjdGl2ZSA9IHBlcnNwZWN0aXZlICsgcHg7XG5cbiAgaWYgKGNhY2hlLnpPcmlnaW4gPSBwYXJzZUZsb2F0KG9yaWdpbi5zcGxpdChcIiBcIilbMl0pIHx8IDApIHtcbiAgICBzdHlsZVtfdHJhbnNmb3JtT3JpZ2luUHJvcF0gPSBfZmlyc3RUd29Pbmx5KG9yaWdpbik7XG4gIH1cblxuICBjYWNoZS54T2Zmc2V0ID0gY2FjaGUueU9mZnNldCA9IDA7XG4gIGNhY2hlLmZvcmNlM0QgPSBfY29uZmlnLmZvcmNlM0Q7XG4gIGNhY2hlLnJlbmRlclRyYW5zZm9ybSA9IGNhY2hlLnN2ZyA/IF9yZW5kZXJTVkdUcmFuc2Zvcm1zIDogX3N1cHBvcnRzM0QgPyBfcmVuZGVyQ1NTVHJhbnNmb3JtcyA6IF9yZW5kZXJOb24zRFRyYW5zZm9ybXM7XG4gIGNhY2hlLnVuY2FjaGUgPSAwO1xuICByZXR1cm4gY2FjaGU7XG59LFxuICAgIF9maXJzdFR3b09ubHkgPSBmdW5jdGlvbiBfZmlyc3RUd29Pbmx5KHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUgPSB2YWx1ZS5zcGxpdChcIiBcIikpWzBdICsgXCIgXCIgKyB2YWx1ZVsxXTtcbn0sXG4gICAgLy9mb3IgaGFuZGxpbmcgdHJhbnNmb3JtT3JpZ2luIHZhbHVlcywgc3RyaXBwaW5nIG91dCB0aGUgM3JkIGRpbWVuc2lvblxuX2FkZFB4VHJhbnNsYXRlID0gZnVuY3Rpb24gX2FkZFB4VHJhbnNsYXRlKHRhcmdldCwgc3RhcnQsIHZhbHVlKSB7XG4gIHZhciB1bml0ID0gZ2V0VW5pdChzdGFydCk7XG4gIHJldHVybiBfcm91bmQocGFyc2VGbG9hdChzdGFydCkgKyBwYXJzZUZsb2F0KF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgXCJ4XCIsIHZhbHVlICsgXCJweFwiLCB1bml0KSkpICsgdW5pdDtcbn0sXG4gICAgX3JlbmRlck5vbjNEVHJhbnNmb3JtcyA9IGZ1bmN0aW9uIF9yZW5kZXJOb24zRFRyYW5zZm9ybXMocmF0aW8sIGNhY2hlKSB7XG4gIGNhY2hlLnogPSBcIjBweFwiO1xuICBjYWNoZS5yb3RhdGlvblkgPSBjYWNoZS5yb3RhdGlvblggPSBcIjBkZWdcIjtcbiAgY2FjaGUuZm9yY2UzRCA9IDA7XG5cbiAgX3JlbmRlckNTU1RyYW5zZm9ybXMocmF0aW8sIGNhY2hlKTtcbn0sXG4gICAgX3plcm9EZWcgPSBcIjBkZWdcIixcbiAgICBfemVyb1B4ID0gXCIwcHhcIixcbiAgICBfZW5kUGFyZW50aGVzaXMgPSBcIikgXCIsXG4gICAgX3JlbmRlckNTU1RyYW5zZm9ybXMgPSBmdW5jdGlvbiBfcmVuZGVyQ1NTVHJhbnNmb3JtcyhyYXRpbywgY2FjaGUpIHtcbiAgdmFyIF9yZWYgPSBjYWNoZSB8fCB0aGlzLFxuICAgICAgeFBlcmNlbnQgPSBfcmVmLnhQZXJjZW50LFxuICAgICAgeVBlcmNlbnQgPSBfcmVmLnlQZXJjZW50LFxuICAgICAgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnksXG4gICAgICB6ID0gX3JlZi56LFxuICAgICAgcm90YXRpb24gPSBfcmVmLnJvdGF0aW9uLFxuICAgICAgcm90YXRpb25ZID0gX3JlZi5yb3RhdGlvblksXG4gICAgICByb3RhdGlvblggPSBfcmVmLnJvdGF0aW9uWCxcbiAgICAgIHNrZXdYID0gX3JlZi5za2V3WCxcbiAgICAgIHNrZXdZID0gX3JlZi5za2V3WSxcbiAgICAgIHNjYWxlWCA9IF9yZWYuc2NhbGVYLFxuICAgICAgc2NhbGVZID0gX3JlZi5zY2FsZVksXG4gICAgICB0cmFuc2Zvcm1QZXJzcGVjdGl2ZSA9IF9yZWYudHJhbnNmb3JtUGVyc3BlY3RpdmUsXG4gICAgICBmb3JjZTNEID0gX3JlZi5mb3JjZTNELFxuICAgICAgdGFyZ2V0ID0gX3JlZi50YXJnZXQsXG4gICAgICB6T3JpZ2luID0gX3JlZi56T3JpZ2luLFxuICAgICAgdHJhbnNmb3JtcyA9IFwiXCIsXG4gICAgICB1c2UzRCA9IGZvcmNlM0QgPT09IFwiYXV0b1wiICYmIHJhdGlvICYmIHJhdGlvICE9PSAxIHx8IGZvcmNlM0QgPT09IHRydWU7IC8vIFNhZmFyaSBoYXMgYSBidWcgdGhhdCBjYXVzZXMgaXQgbm90IHRvIHJlbmRlciAzRCB0cmFuc2Zvcm0tb3JpZ2luIHZhbHVlcyBwcm9wZXJseSwgc28gd2UgZm9yY2UgdGhlIHogb3JpZ2luIHRvIDAsIHJlY29yZCBpdCBpbiB0aGUgY2FjaGUsIGFuZCB0aGVuIGRvIHRoZSBtYXRoIGhlcmUgdG8gb2Zmc2V0IHRoZSB0cmFuc2xhdGUgdmFsdWVzIGFjY29yZGluZ2x5IChiYXNpY2FsbHkgZG8gdGhlIDNEIHRyYW5zZm9ybS1vcmlnaW4gcGFydCBtYW51YWxseSlcblxuXG4gIGlmICh6T3JpZ2luICYmIChyb3RhdGlvblggIT09IF96ZXJvRGVnIHx8IHJvdGF0aW9uWSAhPT0gX3plcm9EZWcpKSB7XG4gICAgdmFyIGFuZ2xlID0gcGFyc2VGbG9hdChyb3RhdGlvblkpICogX0RFRzJSQUQsXG4gICAgICAgIGExMyA9IE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgYTMzID0gTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICBjb3M7XG5cbiAgICBhbmdsZSA9IHBhcnNlRmxvYXQocm90YXRpb25YKSAqIF9ERUcyUkFEO1xuICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICB4ID0gX2FkZFB4VHJhbnNsYXRlKHRhcmdldCwgeCwgYTEzICogY29zICogLXpPcmlnaW4pO1xuICAgIHkgPSBfYWRkUHhUcmFuc2xhdGUodGFyZ2V0LCB5LCAtTWF0aC5zaW4oYW5nbGUpICogLXpPcmlnaW4pO1xuICAgIHogPSBfYWRkUHhUcmFuc2xhdGUodGFyZ2V0LCB6LCBhMzMgKiBjb3MgKiAtek9yaWdpbiArIHpPcmlnaW4pO1xuICB9XG5cbiAgaWYgKHRyYW5zZm9ybVBlcnNwZWN0aXZlICE9PSBfemVyb1B4KSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInBlcnNwZWN0aXZlKFwiICsgdHJhbnNmb3JtUGVyc3BlY3RpdmUgKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICBpZiAoeFBlcmNlbnQgfHwgeVBlcmNlbnQpIHtcbiAgICB0cmFuc2Zvcm1zICs9IFwidHJhbnNsYXRlKFwiICsgeFBlcmNlbnQgKyBcIiUsIFwiICsgeVBlcmNlbnQgKyBcIiUpIFwiO1xuICB9XG5cbiAgaWYgKHVzZTNEIHx8IHggIT09IF96ZXJvUHggfHwgeSAhPT0gX3plcm9QeCB8fCB6ICE9PSBfemVyb1B4KSB7XG4gICAgdHJhbnNmb3JtcyArPSB6ICE9PSBfemVyb1B4IHx8IHVzZTNEID8gXCJ0cmFuc2xhdGUzZChcIiArIHggKyBcIiwgXCIgKyB5ICsgXCIsIFwiICsgeiArIFwiKSBcIiA6IFwidHJhbnNsYXRlKFwiICsgeCArIFwiLCBcIiArIHkgKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICBpZiAocm90YXRpb24gIT09IF96ZXJvRGVnKSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInJvdGF0ZShcIiArIHJvdGF0aW9uICsgX2VuZFBhcmVudGhlc2lzO1xuICB9XG5cbiAgaWYgKHJvdGF0aW9uWSAhPT0gX3plcm9EZWcpIHtcbiAgICB0cmFuc2Zvcm1zICs9IFwicm90YXRlWShcIiArIHJvdGF0aW9uWSArIF9lbmRQYXJlbnRoZXNpcztcbiAgfVxuXG4gIGlmIChyb3RhdGlvblggIT09IF96ZXJvRGVnKSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInJvdGF0ZVgoXCIgKyByb3RhdGlvblggKyBfZW5kUGFyZW50aGVzaXM7XG4gIH1cblxuICBpZiAoc2tld1ggIT09IF96ZXJvRGVnIHx8IHNrZXdZICE9PSBfemVyb0RlZykge1xuICAgIHRyYW5zZm9ybXMgKz0gXCJza2V3KFwiICsgc2tld1ggKyBcIiwgXCIgKyBza2V3WSArIF9lbmRQYXJlbnRoZXNpcztcbiAgfVxuXG4gIGlmIChzY2FsZVggIT09IDEgfHwgc2NhbGVZICE9PSAxKSB7XG4gICAgdHJhbnNmb3JtcyArPSBcInNjYWxlKFwiICsgc2NhbGVYICsgXCIsIFwiICsgc2NhbGVZICsgX2VuZFBhcmVudGhlc2lzO1xuICB9XG5cbiAgdGFyZ2V0LnN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybXMgfHwgXCJ0cmFuc2xhdGUoMCwgMClcIjtcbn0sXG4gICAgX3JlbmRlclNWR1RyYW5zZm9ybXMgPSBmdW5jdGlvbiBfcmVuZGVyU1ZHVHJhbnNmb3JtcyhyYXRpbywgY2FjaGUpIHtcbiAgdmFyIF9yZWYyID0gY2FjaGUgfHwgdGhpcyxcbiAgICAgIHhQZXJjZW50ID0gX3JlZjIueFBlcmNlbnQsXG4gICAgICB5UGVyY2VudCA9IF9yZWYyLnlQZXJjZW50LFxuICAgICAgeCA9IF9yZWYyLngsXG4gICAgICB5ID0gX3JlZjIueSxcbiAgICAgIHJvdGF0aW9uID0gX3JlZjIucm90YXRpb24sXG4gICAgICBza2V3WCA9IF9yZWYyLnNrZXdYLFxuICAgICAgc2tld1kgPSBfcmVmMi5za2V3WSxcbiAgICAgIHNjYWxlWCA9IF9yZWYyLnNjYWxlWCxcbiAgICAgIHNjYWxlWSA9IF9yZWYyLnNjYWxlWSxcbiAgICAgIHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIHhPcmlnaW4gPSBfcmVmMi54T3JpZ2luLFxuICAgICAgeU9yaWdpbiA9IF9yZWYyLnlPcmlnaW4sXG4gICAgICB4T2Zmc2V0ID0gX3JlZjIueE9mZnNldCxcbiAgICAgIHlPZmZzZXQgPSBfcmVmMi55T2Zmc2V0LFxuICAgICAgZm9yY2VDU1MgPSBfcmVmMi5mb3JjZUNTUyxcbiAgICAgIHR4ID0gcGFyc2VGbG9hdCh4KSxcbiAgICAgIHR5ID0gcGFyc2VGbG9hdCh5KSxcbiAgICAgIGExMSxcbiAgICAgIGEyMSxcbiAgICAgIGExMixcbiAgICAgIGEyMixcbiAgICAgIHRlbXA7XG5cbiAgcm90YXRpb24gPSBwYXJzZUZsb2F0KHJvdGF0aW9uKTtcbiAgc2tld1ggPSBwYXJzZUZsb2F0KHNrZXdYKTtcbiAgc2tld1kgPSBwYXJzZUZsb2F0KHNrZXdZKTtcblxuICBpZiAoc2tld1kpIHtcbiAgICAvL2ZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSBjb21iaW5lIGFsbCBza2V3aW5nIGludG8gdGhlIHNrZXdYIGFuZCByb3RhdGlvbiB2YWx1ZXMuIFJlbWVtYmVyLCBhIHNrZXdZIG9mIDEwIGRlZ3JlZXMgbG9va3MgdGhlIHNhbWUgYXMgYSByb3RhdGlvbiBvZiAxMCBkZWdyZWVzIHBsdXMgYSBza2V3WCBvZiAxMCBkZWdyZWVzLlxuICAgIHNrZXdZID0gcGFyc2VGbG9hdChza2V3WSk7XG4gICAgc2tld1ggKz0gc2tld1k7XG4gICAgcm90YXRpb24gKz0gc2tld1k7XG4gIH1cblxuICBpZiAocm90YXRpb24gfHwgc2tld1gpIHtcbiAgICByb3RhdGlvbiAqPSBfREVHMlJBRDtcbiAgICBza2V3WCAqPSBfREVHMlJBRDtcbiAgICBhMTEgPSBNYXRoLmNvcyhyb3RhdGlvbikgKiBzY2FsZVg7XG4gICAgYTIxID0gTWF0aC5zaW4ocm90YXRpb24pICogc2NhbGVYO1xuICAgIGExMiA9IE1hdGguc2luKHJvdGF0aW9uIC0gc2tld1gpICogLXNjYWxlWTtcbiAgICBhMjIgPSBNYXRoLmNvcyhyb3RhdGlvbiAtIHNrZXdYKSAqIHNjYWxlWTtcblxuICAgIGlmIChza2V3WCkge1xuICAgICAgc2tld1kgKj0gX0RFRzJSQUQ7XG4gICAgICB0ZW1wID0gTWF0aC50YW4oc2tld1ggLSBza2V3WSk7XG4gICAgICB0ZW1wID0gTWF0aC5zcXJ0KDEgKyB0ZW1wICogdGVtcCk7XG4gICAgICBhMTIgKj0gdGVtcDtcbiAgICAgIGEyMiAqPSB0ZW1wO1xuXG4gICAgICBpZiAoc2tld1kpIHtcbiAgICAgICAgdGVtcCA9IE1hdGgudGFuKHNrZXdZKTtcbiAgICAgICAgdGVtcCA9IE1hdGguc3FydCgxICsgdGVtcCAqIHRlbXApO1xuICAgICAgICBhMTEgKj0gdGVtcDtcbiAgICAgICAgYTIxICo9IHRlbXA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYTExID0gX3JvdW5kKGExMSk7XG4gICAgYTIxID0gX3JvdW5kKGEyMSk7XG4gICAgYTEyID0gX3JvdW5kKGExMik7XG4gICAgYTIyID0gX3JvdW5kKGEyMik7XG4gIH0gZWxzZSB7XG4gICAgYTExID0gc2NhbGVYO1xuICAgIGEyMiA9IHNjYWxlWTtcbiAgICBhMjEgPSBhMTIgPSAwO1xuICB9XG5cbiAgaWYgKHR4ICYmICF+KHggKyBcIlwiKS5pbmRleE9mKFwicHhcIikgfHwgdHkgJiYgIX4oeSArIFwiXCIpLmluZGV4T2YoXCJweFwiKSkge1xuICAgIHR4ID0gX2NvbnZlcnRUb1VuaXQodGFyZ2V0LCBcInhcIiwgeCwgXCJweFwiKTtcbiAgICB0eSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgXCJ5XCIsIHksIFwicHhcIik7XG4gIH1cblxuICBpZiAoeE9yaWdpbiB8fCB5T3JpZ2luIHx8IHhPZmZzZXQgfHwgeU9mZnNldCkge1xuICAgIHR4ID0gX3JvdW5kKHR4ICsgeE9yaWdpbiAtICh4T3JpZ2luICogYTExICsgeU9yaWdpbiAqIGExMikgKyB4T2Zmc2V0KTtcbiAgICB0eSA9IF9yb3VuZCh0eSArIHlPcmlnaW4gLSAoeE9yaWdpbiAqIGEyMSArIHlPcmlnaW4gKiBhMjIpICsgeU9mZnNldCk7XG4gIH1cblxuICBpZiAoeFBlcmNlbnQgfHwgeVBlcmNlbnQpIHtcbiAgICAvL1RoZSBTVkcgc3BlYyBkb2Vzbid0IHN1cHBvcnQgcGVyY2VudGFnZS1iYXNlZCB0cmFuc2xhdGlvbiBpbiB0aGUgXCJ0cmFuc2Zvcm1cIiBhdHRyaWJ1dGUsIHNvIHdlIG1lcmdlIGl0IGludG8gdGhlIHRyYW5zbGF0aW9uIHRvIHNpbXVsYXRlIGl0LlxuICAgIHRlbXAgPSB0YXJnZXQuZ2V0QkJveCgpO1xuICAgIHR4ID0gX3JvdW5kKHR4ICsgeFBlcmNlbnQgLyAxMDAgKiB0ZW1wLndpZHRoKTtcbiAgICB0eSA9IF9yb3VuZCh0eSArIHlQZXJjZW50IC8gMTAwICogdGVtcC5oZWlnaHQpO1xuICB9XG5cbiAgdGVtcCA9IFwibWF0cml4KFwiICsgYTExICsgXCIsXCIgKyBhMjEgKyBcIixcIiArIGExMiArIFwiLFwiICsgYTIyICsgXCIsXCIgKyB0eCArIFwiLFwiICsgdHkgKyBcIilcIjtcbiAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCB0ZW1wKTtcbiAgZm9yY2VDU1MgJiYgKHRhcmdldC5zdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0ZW1wKTsgLy9zb21lIGJyb3dzZXJzIHByaW9yaXRpemUgQ1NTIHRyYW5zZm9ybXMgb3ZlciB0aGUgdHJhbnNmb3JtIGF0dHJpYnV0ZS4gV2hlbiB3ZSBzZW5zZSB0aGF0IHRoZSB1c2VyIGhhcyBDU1MgdHJhbnNmb3JtcyBhcHBsaWVkLCB3ZSBtdXN0IG92ZXJ3cml0ZSB0aGVtIHRoaXMgd2F5IChvdGhlcndpc2Ugc29tZSBicm93c2VyIHNpbXBseSB3b24ndCByZW5kZXIgdGhlICB0cmFuc2Zvcm0gYXR0cmlidXRlIGNoYW5nZXMhKVxufSxcbiAgICBfYWRkUm90YXRpb25hbFByb3BUd2VlbiA9IGZ1bmN0aW9uIF9hZGRSb3RhdGlvbmFsUHJvcFR3ZWVuKHBsdWdpbiwgdGFyZ2V0LCBwcm9wZXJ0eSwgc3RhcnROdW0sIGVuZFZhbHVlLCByZWxhdGl2ZSkge1xuICB2YXIgY2FwID0gMzYwLFxuICAgICAgaXNTdHJpbmcgPSBfaXNTdHJpbmcoZW5kVmFsdWUpLFxuICAgICAgZW5kTnVtID0gcGFyc2VGbG9hdChlbmRWYWx1ZSkgKiAoaXNTdHJpbmcgJiYgfmVuZFZhbHVlLmluZGV4T2YoXCJyYWRcIikgPyBfUkFEMkRFRyA6IDEpLFxuICAgICAgY2hhbmdlID0gcmVsYXRpdmUgPyBlbmROdW0gKiByZWxhdGl2ZSA6IGVuZE51bSAtIHN0YXJ0TnVtLFxuICAgICAgZmluYWxWYWx1ZSA9IHN0YXJ0TnVtICsgY2hhbmdlICsgXCJkZWdcIixcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIHB0O1xuXG4gIGlmIChpc1N0cmluZykge1xuICAgIGRpcmVjdGlvbiA9IGVuZFZhbHVlLnNwbGl0KFwiX1wiKVsxXTtcblxuICAgIGlmIChkaXJlY3Rpb24gPT09IFwic2hvcnRcIikge1xuICAgICAgY2hhbmdlICU9IGNhcDtcblxuICAgICAgaWYgKGNoYW5nZSAhPT0gY2hhbmdlICUgKGNhcCAvIDIpKSB7XG4gICAgICAgIGNoYW5nZSArPSBjaGFuZ2UgPCAwID8gY2FwIDogLWNhcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGlyZWN0aW9uID09PSBcImN3XCIgJiYgY2hhbmdlIDwgMCkge1xuICAgICAgY2hhbmdlID0gKGNoYW5nZSArIGNhcCAqIF9iaWdOdW0pICUgY2FwIC0gfn4oY2hhbmdlIC8gY2FwKSAqIGNhcDtcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gXCJjY3dcIiAmJiBjaGFuZ2UgPiAwKSB7XG4gICAgICBjaGFuZ2UgPSAoY2hhbmdlIC0gY2FwICogX2JpZ051bSkgJSBjYXAgLSB+fihjaGFuZ2UgLyBjYXApICogY2FwO1xuICAgIH1cbiAgfVxuXG4gIHBsdWdpbi5fcHQgPSBwdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgdGFyZ2V0LCBwcm9wZXJ0eSwgc3RhcnROdW0sIGNoYW5nZSwgX3JlbmRlclByb3BXaXRoRW5kKTtcbiAgcHQuZSA9IGZpbmFsVmFsdWU7XG4gIHB0LnUgPSBcImRlZ1wiO1xuXG4gIHBsdWdpbi5fcHJvcHMucHVzaChwcm9wZXJ0eSk7XG5cbiAgcmV0dXJuIHB0O1xufSxcbiAgICBfYXNzaWduID0gZnVuY3Rpb24gX2Fzc2lnbih0YXJnZXQsIHNvdXJjZSkge1xuICAvLyBJbnRlcm5ldCBFeHBsb3JlciBkb2Vzbid0IGhhdmUgT2JqZWN0LmFzc2lnbigpLCBzbyB3ZSByZWNyZWF0ZSBpdCBoZXJlLlxuICBmb3IgKHZhciBwIGluIHNvdXJjZSkge1xuICAgIHRhcmdldFtwXSA9IHNvdXJjZVtwXTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59LFxuICAgIF9hZGRSYXdUcmFuc2Zvcm1QVHMgPSBmdW5jdGlvbiBfYWRkUmF3VHJhbnNmb3JtUFRzKHBsdWdpbiwgdHJhbnNmb3JtcywgdGFyZ2V0KSB7XG4gIC8vZm9yIGhhbmRsaW5nIGNhc2VzIHdoZXJlIHNvbWVvbmUgcGFzc2VzIGluIGEgd2hvbGUgdHJhbnNmb3JtIHN0cmluZywgbGlrZSB0cmFuc2Zvcm06IFwic2NhbGUoMiwgMykgcm90YXRlKDIwZGVnKSB0cmFuc2xhdGVZKDMwZW0pXCJcbiAgdmFyIHN0YXJ0Q2FjaGUgPSBfYXNzaWduKHt9LCB0YXJnZXQuX2dzYXApLFxuICAgICAgZXhjbHVkZSA9IFwicGVyc3BlY3RpdmUsZm9yY2UzRCx0cmFuc2Zvcm1PcmlnaW4sc3ZnT3JpZ2luXCIsXG4gICAgICBzdHlsZSA9IHRhcmdldC5zdHlsZSxcbiAgICAgIGVuZENhY2hlLFxuICAgICAgcCxcbiAgICAgIHN0YXJ0VmFsdWUsXG4gICAgICBlbmRWYWx1ZSxcbiAgICAgIHN0YXJ0TnVtLFxuICAgICAgZW5kTnVtLFxuICAgICAgc3RhcnRVbml0LFxuICAgICAgZW5kVW5pdDtcblxuICBpZiAoc3RhcnRDYWNoZS5zdmcpIHtcbiAgICBzdGFydFZhbHVlID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTtcbiAgICB0YXJnZXQuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwiXCIpO1xuICAgIHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybXM7XG4gICAgZW5kQ2FjaGUgPSBfcGFyc2VUcmFuc2Zvcm0odGFyZ2V0LCAxKTtcblxuICAgIF9yZW1vdmVQcm9wZXJ0eSh0YXJnZXQsIF90cmFuc2Zvcm1Qcm9wKTtcblxuICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgc3RhcnRWYWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRWYWx1ZSA9IGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KVtfdHJhbnNmb3JtUHJvcF07XG4gICAgc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtcztcbiAgICBlbmRDYWNoZSA9IF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIDEpO1xuICAgIHN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHN0YXJ0VmFsdWU7XG4gIH1cblxuICBmb3IgKHAgaW4gX3RyYW5zZm9ybVByb3BzKSB7XG4gICAgc3RhcnRWYWx1ZSA9IHN0YXJ0Q2FjaGVbcF07XG4gICAgZW5kVmFsdWUgPSBlbmRDYWNoZVtwXTtcblxuICAgIGlmIChzdGFydFZhbHVlICE9PSBlbmRWYWx1ZSAmJiBleGNsdWRlLmluZGV4T2YocCkgPCAwKSB7XG4gICAgICAvL3R3ZWVuaW5nIHRvIG5vIHBlcnNwZWN0aXZlIGdpdmVzIHZlcnkgdW5pbnR1aXRpdmUgcmVzdWx0cyAtIGp1c3Qga2VlcCB0aGUgc2FtZSBwZXJzcGVjdGl2ZSBpbiB0aGF0IGNhc2UuXG4gICAgICBzdGFydFVuaXQgPSBnZXRVbml0KHN0YXJ0VmFsdWUpO1xuICAgICAgZW5kVW5pdCA9IGdldFVuaXQoZW5kVmFsdWUpO1xuICAgICAgc3RhcnROdW0gPSBzdGFydFVuaXQgIT09IGVuZFVuaXQgPyBfY29udmVydFRvVW5pdCh0YXJnZXQsIHAsIHN0YXJ0VmFsdWUsIGVuZFVuaXQpIDogcGFyc2VGbG9hdChzdGFydFZhbHVlKTtcbiAgICAgIGVuZE51bSA9IHBhcnNlRmxvYXQoZW5kVmFsdWUpO1xuICAgICAgcGx1Z2luLl9wdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgZW5kQ2FjaGUsIHAsIHN0YXJ0TnVtLCBlbmROdW0gLSBzdGFydE51bSwgX3JlbmRlckNTU1Byb3ApO1xuICAgICAgcGx1Z2luLl9wdC51ID0gZW5kVW5pdCB8fCAwO1xuXG4gICAgICBwbHVnaW4uX3Byb3BzLnB1c2gocCk7XG4gICAgfVxuICB9XG5cbiAgX2Fzc2lnbihlbmRDYWNoZSwgc3RhcnRDYWNoZSk7XG59OyAvLyBoYW5kbGUgc3BsaXR0aW5nIGFwYXJ0IHBhZGRpbmcsIG1hcmdpbiwgYm9yZGVyV2lkdGgsIGFuZCBib3JkZXJSYWRpdXMgaW50byB0aGVpciA0IGNvbXBvbmVudHMuIEZpcmVmb3gsIGZvciBleGFtcGxlLCB3b24ndCByZXBvcnQgYm9yZGVyUmFkaXVzIGNvcnJlY3RseSAtIGl0IHdpbGwgb25seSBkbyBib3JkZXJUb3BMZWZ0UmFkaXVzIGFuZCB0aGUgb3RoZXIgY29ybmVycy4gV2UgYWxzbyB3YW50IHRvIGhhbmRsZSBwYWRkaW5nVG9wLCBtYXJnaW5MZWZ0LCBib3JkZXJSaWdodFdpZHRoLCBldGMuXG5cblxuX2ZvckVhY2hOYW1lKFwicGFkZGluZyxtYXJnaW4sV2lkdGgsUmFkaXVzXCIsIGZ1bmN0aW9uIChuYW1lLCBpbmRleCkge1xuICB2YXIgdCA9IFwiVG9wXCIsXG4gICAgICByID0gXCJSaWdodFwiLFxuICAgICAgYiA9IFwiQm90dG9tXCIsXG4gICAgICBsID0gXCJMZWZ0XCIsXG4gICAgICBwcm9wcyA9IChpbmRleCA8IDMgPyBbdCwgciwgYiwgbF0gOiBbdCArIGwsIHQgKyByLCBiICsgciwgYiArIGxdKS5tYXAoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICByZXR1cm4gaW5kZXggPCAyID8gbmFtZSArIHNpZGUgOiBcImJvcmRlclwiICsgc2lkZSArIG5hbWU7XG4gIH0pO1xuXG4gIF9zcGVjaWFsUHJvcHNbaW5kZXggPiAxID8gXCJib3JkZXJcIiArIG5hbWUgOiBuYW1lXSA9IGZ1bmN0aW9uIChwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIGVuZFZhbHVlLCB0d2Vlbikge1xuICAgIHZhciBhLCB2YXJzO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCA0KSB7XG4gICAgICAvLyBnZXR0ZXIsIHBhc3NlZCB0YXJnZXQsIHByb3BlcnR5LCBhbmQgdW5pdCAoZnJvbSBfZ2V0KCkpXG4gICAgICBhID0gcHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIHJldHVybiBfZ2V0KHBsdWdpbiwgcHJvcCwgcHJvcGVydHkpO1xuICAgICAgfSk7XG4gICAgICB2YXJzID0gYS5qb2luKFwiIFwiKTtcbiAgICAgIHJldHVybiB2YXJzLnNwbGl0KGFbMF0pLmxlbmd0aCA9PT0gNSA/IGFbMF0gOiB2YXJzO1xuICAgIH1cblxuICAgIGEgPSAoZW5kVmFsdWUgKyBcIlwiKS5zcGxpdChcIiBcIik7XG4gICAgdmFycyA9IHt9O1xuICAgIHByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3AsIGkpIHtcbiAgICAgIHJldHVybiB2YXJzW3Byb3BdID0gYVtpXSA9IGFbaV0gfHwgYVsoaSAtIDEpIC8gMiB8IDBdO1xuICAgIH0pO1xuICAgIHBsdWdpbi5pbml0KHRhcmdldCwgdmFycywgdHdlZW4pO1xuICB9O1xufSk7XG5cbmV4cG9ydCB2YXIgQ1NTUGx1Z2luID0ge1xuICBuYW1lOiBcImNzc1wiLFxuICByZWdpc3RlcjogX2luaXRDb3JlLFxuICB0YXJnZXRUZXN0OiBmdW5jdGlvbiB0YXJnZXRUZXN0KHRhcmdldCkge1xuICAgIHJldHVybiB0YXJnZXQuc3R5bGUgJiYgdGFyZ2V0Lm5vZGVUeXBlO1xuICB9LFxuICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXRzKSB7XG4gICAgdmFyIHByb3BzID0gdGhpcy5fcHJvcHMsXG4gICAgICAgIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgICBzdGFydEF0ID0gdHdlZW4udmFycy5zdGFydEF0LFxuICAgICAgICBzdGFydFZhbHVlLFxuICAgICAgICBlbmRWYWx1ZSxcbiAgICAgICAgZW5kTnVtLFxuICAgICAgICBzdGFydE51bSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgc3BlY2lhbFByb3AsXG4gICAgICAgIHAsXG4gICAgICAgIHN0YXJ0VW5pdCxcbiAgICAgICAgZW5kVW5pdCxcbiAgICAgICAgcmVsYXRpdmUsXG4gICAgICAgIGlzVHJhbnNmb3JtUmVsYXRlZCxcbiAgICAgICAgdHJhbnNmb3JtUHJvcFR3ZWVuLFxuICAgICAgICBjYWNoZSxcbiAgICAgICAgc21vb3RoLFxuICAgICAgICBoYXNQcmlvcml0eTtcbiAgICBfcGx1Z2luSW5pdHRlZCB8fCBfaW5pdENvcmUoKTtcblxuICAgIGZvciAocCBpbiB2YXJzKSB7XG4gICAgICBpZiAocCA9PT0gXCJhdXRvUm91bmRcIikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZW5kVmFsdWUgPSB2YXJzW3BdO1xuXG4gICAgICBpZiAoX3BsdWdpbnNbcF0gJiYgX2NoZWNrUGx1Z2luKHAsIHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSkge1xuICAgICAgICAvLyBwbHVnaW5zXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB0eXBlID0gdHlwZW9mIGVuZFZhbHVlO1xuICAgICAgc3BlY2lhbFByb3AgPSBfc3BlY2lhbFByb3BzW3BdO1xuXG4gICAgICBpZiAodHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGVuZFZhbHVlID0gZW5kVmFsdWUuY2FsbCh0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cyk7XG4gICAgICAgIHR5cGUgPSB0eXBlb2YgZW5kVmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlID09PSBcInN0cmluZ1wiICYmIH5lbmRWYWx1ZS5pbmRleE9mKFwicmFuZG9tKFwiKSkge1xuICAgICAgICBlbmRWYWx1ZSA9IF9yZXBsYWNlUmFuZG9tKGVuZFZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNwZWNpYWxQcm9wKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wKHRoaXMsIHRhcmdldCwgcCwgZW5kVmFsdWUsIHR3ZWVuKSAmJiAoaGFzUHJpb3JpdHkgPSAxKTtcbiAgICAgIH0gZWxzZSBpZiAocC5zdWJzdHIoMCwgMikgPT09IFwiLS1cIikge1xuICAgICAgICAvL0NTUyB2YXJpYWJsZVxuICAgICAgICBzdGFydFZhbHVlID0gKGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KS5nZXRQcm9wZXJ0eVZhbHVlKHApICsgXCJcIikudHJpbSgpO1xuICAgICAgICBlbmRWYWx1ZSArPSBcIlwiO1xuICAgICAgICBfY29sb3JFeHAubGFzdEluZGV4ID0gMDtcblxuICAgICAgICBpZiAoIV9jb2xvckV4cC50ZXN0KHN0YXJ0VmFsdWUpKSB7XG4gICAgICAgICAgLy8gY29sb3JzIGRvbid0IGhhdmUgdW5pdHNcbiAgICAgICAgICBzdGFydFVuaXQgPSBnZXRVbml0KHN0YXJ0VmFsdWUpO1xuICAgICAgICAgIGVuZFVuaXQgPSBnZXRVbml0KGVuZFZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVuZFVuaXQgPyBzdGFydFVuaXQgIT09IGVuZFVuaXQgJiYgKHN0YXJ0VmFsdWUgPSBfY29udmVydFRvVW5pdCh0YXJnZXQsIHAsIHN0YXJ0VmFsdWUsIGVuZFVuaXQpICsgZW5kVW5pdCkgOiBzdGFydFVuaXQgJiYgKGVuZFZhbHVlICs9IHN0YXJ0VW5pdCk7XG4gICAgICAgIHRoaXMuYWRkKHN0eWxlLCBcInNldFByb3BlcnR5XCIsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBpbmRleCwgdGFyZ2V0cywgMCwgMCwgcCk7XG4gICAgICAgIHByb3BzLnB1c2gocCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHN0YXJ0QXQgJiYgcCBpbiBzdGFydEF0KSB7XG4gICAgICAgICAgLy8gaW4gY2FzZSBzb21lb25lIGhhcmQtY29kZXMgYSBjb21wbGV4IHZhbHVlIGFzIHRoZSBzdGFydCwgbGlrZSB0b3A6IFwiY2FsYygydmggLyAyKVwiLiBXaXRob3V0IHRoaXMsIGl0J2QgdXNlIHRoZSBjb21wdXRlZCB2YWx1ZSAoYWx3YXlzIGluIHB4KVxuICAgICAgICAgIHN0YXJ0VmFsdWUgPSB0eXBlb2Ygc3RhcnRBdFtwXSA9PT0gXCJmdW5jdGlvblwiID8gc3RhcnRBdFtwXS5jYWxsKHR3ZWVuLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSA6IHN0YXJ0QXRbcF07XG4gICAgICAgICAgX2lzU3RyaW5nKHN0YXJ0VmFsdWUpICYmIH5zdGFydFZhbHVlLmluZGV4T2YoXCJyYW5kb20oXCIpICYmIChzdGFydFZhbHVlID0gX3JlcGxhY2VSYW5kb20oc3RhcnRWYWx1ZSkpO1xuICAgICAgICAgIGdldFVuaXQoc3RhcnRWYWx1ZSArIFwiXCIpIHx8IChzdGFydFZhbHVlICs9IF9jb25maWcudW5pdHNbcF0gfHwgZ2V0VW5pdChfZ2V0KHRhcmdldCwgcCkpIHx8IFwiXCIpOyAvLyBmb3IgY2FzZXMgd2hlbiBzb21lb25lIHBhc3NlcyBpbiBhIHVuaXRsZXNzIHZhbHVlIGxpa2Uge3g6IDEwMH07IGlmIHdlIHRyeSBzZXR0aW5nIHRyYW5zbGF0ZSgxMDAsIDBweCkgaXQgd29uJ3Qgd29yay5cblxuICAgICAgICAgIChzdGFydFZhbHVlICsgXCJcIikuY2hhckF0KDEpID09PSBcIj1cIiAmJiAoc3RhcnRWYWx1ZSA9IF9nZXQodGFyZ2V0LCBwKSk7IC8vIGNhbid0IHdvcmsgd2l0aCByZWxhdGl2ZSB2YWx1ZXNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFydFZhbHVlID0gX2dldCh0YXJnZXQsIHApO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnROdW0gPSBwYXJzZUZsb2F0KHN0YXJ0VmFsdWUpO1xuICAgICAgICByZWxhdGl2ZSA9IHR5cGUgPT09IFwic3RyaW5nXCIgJiYgZW5kVmFsdWUuY2hhckF0KDEpID09PSBcIj1cIiA/ICsoZW5kVmFsdWUuY2hhckF0KDApICsgXCIxXCIpIDogMDtcbiAgICAgICAgcmVsYXRpdmUgJiYgKGVuZFZhbHVlID0gZW5kVmFsdWUuc3Vic3RyKDIpKTtcbiAgICAgICAgZW5kTnVtID0gcGFyc2VGbG9hdChlbmRWYWx1ZSk7XG5cbiAgICAgICAgaWYgKHAgaW4gX3Byb3BlcnR5QWxpYXNlcykge1xuICAgICAgICAgIGlmIChwID09PSBcImF1dG9BbHBoYVwiKSB7XG4gICAgICAgICAgICAvL3NwZWNpYWwgY2FzZSB3aGVyZSB3ZSBjb250cm9sIHRoZSB2aXNpYmlsaXR5IGFsb25nIHdpdGggb3BhY2l0eS4gV2Ugc3RpbGwgYWxsb3cgdGhlIG9wYWNpdHkgdmFsdWUgdG8gcGFzcyB0aHJvdWdoIGFuZCBnZXQgdHdlZW5lZC5cbiAgICAgICAgICAgIGlmIChzdGFydE51bSA9PT0gMSAmJiBfZ2V0KHRhcmdldCwgXCJ2aXNpYmlsaXR5XCIpID09PSBcImhpZGRlblwiICYmIGVuZE51bSkge1xuICAgICAgICAgICAgICAvL2lmIHZpc2liaWxpdHkgaXMgaW5pdGlhbGx5IHNldCB0byBcImhpZGRlblwiLCB3ZSBzaG91bGQgaW50ZXJwcmV0IHRoYXQgYXMgaW50ZW50IHRvIG1ha2Ugb3BhY2l0eSAwIChhIGNvbnZlbmllbmNlKVxuICAgICAgICAgICAgICBzdGFydE51bSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9hZGROb25Ud2VlbmluZ1BUKHRoaXMsIHN0eWxlLCBcInZpc2liaWxpdHlcIiwgc3RhcnROdW0gPyBcImluaGVyaXRcIiA6IFwiaGlkZGVuXCIsIGVuZE51bSA/IFwiaW5oZXJpdFwiIDogXCJoaWRkZW5cIiwgIWVuZE51bSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHAgIT09IFwic2NhbGVcIiAmJiBwICE9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICAgICAgICBwID0gX3Byb3BlcnR5QWxpYXNlc1twXTtcbiAgICAgICAgICAgIH5wLmluZGV4T2YoXCIsXCIpICYmIChwID0gcC5zcGxpdChcIixcIilbMF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlzVHJhbnNmb3JtUmVsYXRlZCA9IHAgaW4gX3RyYW5zZm9ybVByb3BzOyAvLy0tLSBUUkFOU0ZPUk0tUkVMQVRFRCAtLS1cblxuICAgICAgICBpZiAoaXNUcmFuc2Zvcm1SZWxhdGVkKSB7XG4gICAgICAgICAgaWYgKCF0cmFuc2Zvcm1Qcm9wVHdlZW4pIHtcbiAgICAgICAgICAgIGNhY2hlID0gdGFyZ2V0Ll9nc2FwO1xuICAgICAgICAgICAgY2FjaGUucmVuZGVyVHJhbnNmb3JtICYmICF2YXJzLnBhcnNlVHJhbnNmb3JtIHx8IF9wYXJzZVRyYW5zZm9ybSh0YXJnZXQsIHZhcnMucGFyc2VUcmFuc2Zvcm0pOyAvLyBpZiwgZm9yIGV4YW1wbGUsIGdzYXAuc2V0KC4uLiB7dHJhbnNmb3JtOlwidHJhbnNsYXRlWCg1MHZ3KVwifSksIHRoZSBfZ2V0KCkgY2FsbCBkb2Vzbid0IHBhcnNlIHRoZSB0cmFuc2Zvcm0sIHRodXMgY2FjaGUucmVuZGVyVHJhbnNmb3JtIHdvbid0IGJlIHNldCB5ZXQgc28gZm9yY2UgdGhlIHBhcnNpbmcgb2YgdGhlIHRyYW5zZm9ybSBoZXJlLlxuXG4gICAgICAgICAgICBzbW9vdGggPSB2YXJzLnNtb290aE9yaWdpbiAhPT0gZmFsc2UgJiYgY2FjaGUuc21vb3RoO1xuICAgICAgICAgICAgdHJhbnNmb3JtUHJvcFR3ZWVuID0gdGhpcy5fcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCBzdHlsZSwgX3RyYW5zZm9ybVByb3AsIDAsIDEsIGNhY2hlLnJlbmRlclRyYW5zZm9ybSwgY2FjaGUsIDAsIC0xKTsgLy90aGUgZmlyc3QgdGltZSB0aHJvdWdoLCBjcmVhdGUgdGhlIHJlbmRlcmluZyBQcm9wVHdlZW4gc28gdGhhdCBpdCBydW5zIExBU1QgKGluIHRoZSBsaW5rZWQgbGlzdCwgd2Uga2VlcCBhZGRpbmcgdG8gdGhlIGJlZ2lubmluZylcblxuICAgICAgICAgICAgdHJhbnNmb3JtUHJvcFR3ZWVuLmRlcCA9IDE7IC8vZmxhZyBpdCBhcyBkZXBlbmRlbnQgc28gdGhhdCBpZiB0aGluZ3MgZ2V0IGtpbGxlZC9vdmVyd3JpdHRlbiBhbmQgdGhpcyBpcyB0aGUgb25seSBQcm9wVHdlZW4gbGVmdCwgd2UgY2FuIHNhZmVseSBraWxsIHRoZSB3aG9sZSB0d2Vlbi5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocCA9PT0gXCJzY2FsZVwiKSB7XG4gICAgICAgICAgICB0aGlzLl9wdCA9IG5ldyBQcm9wVHdlZW4odGhpcy5fcHQsIGNhY2hlLCBcInNjYWxlWVwiLCBjYWNoZS5zY2FsZVksIChyZWxhdGl2ZSA/IHJlbGF0aXZlICogZW5kTnVtIDogZW5kTnVtIC0gY2FjaGUuc2NhbGVZKSB8fCAwKTtcbiAgICAgICAgICAgIHByb3BzLnB1c2goXCJzY2FsZVlcIiwgcCk7XG4gICAgICAgICAgICBwICs9IFwiWFwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJ0cmFuc2Zvcm1PcmlnaW5cIikge1xuICAgICAgICAgICAgZW5kVmFsdWUgPSBfY29udmVydEtleXdvcmRzVG9QZXJjZW50YWdlcyhlbmRWYWx1ZSk7IC8vaW4gY2FzZSBzb21ldGhpbmcgbGlrZSBcImxlZnQgdG9wXCIgb3IgXCJib3R0b20gcmlnaHRcIiBpcyBwYXNzZWQgaW4uIENvbnZlcnQgdG8gcGVyY2VudGFnZXMuXG5cbiAgICAgICAgICAgIGlmIChjYWNoZS5zdmcpIHtcbiAgICAgICAgICAgICAgX2FwcGx5U1ZHT3JpZ2luKHRhcmdldCwgZW5kVmFsdWUsIDAsIHNtb290aCwgMCwgdGhpcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbmRVbml0ID0gcGFyc2VGbG9hdChlbmRWYWx1ZS5zcGxpdChcIiBcIilbMl0pIHx8IDA7IC8vaGFuZGxlIHRoZSB6T3JpZ2luIHNlcGFyYXRlbHkhXG5cbiAgICAgICAgICAgICAgZW5kVW5pdCAhPT0gY2FjaGUuek9yaWdpbiAmJiBfYWRkTm9uVHdlZW5pbmdQVCh0aGlzLCBjYWNoZSwgXCJ6T3JpZ2luXCIsIGNhY2hlLnpPcmlnaW4sIGVuZFVuaXQpO1xuXG4gICAgICAgICAgICAgIF9hZGROb25Ud2VlbmluZ1BUKHRoaXMsIHN0eWxlLCBwLCBfZmlyc3RUd29Pbmx5KHN0YXJ0VmFsdWUpLCBfZmlyc3RUd29Pbmx5KGVuZFZhbHVlKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJzdmdPcmlnaW5cIikge1xuICAgICAgICAgICAgX2FwcGx5U1ZHT3JpZ2luKHRhcmdldCwgZW5kVmFsdWUsIDEsIHNtb290aCwgMCwgdGhpcyk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAocCBpbiBfcm90YXRpb25hbFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIF9hZGRSb3RhdGlvbmFsUHJvcFR3ZWVuKHRoaXMsIGNhY2hlLCBwLCBzdGFydE51bSwgZW5kVmFsdWUsIHJlbGF0aXZlKTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChwID09PSBcInNtb290aE9yaWdpblwiKSB7XG4gICAgICAgICAgICBfYWRkTm9uVHdlZW5pbmdQVCh0aGlzLCBjYWNoZSwgXCJzbW9vdGhcIiwgY2FjaGUuc21vb3RoLCBlbmRWYWx1ZSk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJmb3JjZTNEXCIpIHtcbiAgICAgICAgICAgIGNhY2hlW3BdID0gZW5kVmFsdWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHAgPT09IFwidHJhbnNmb3JtXCIpIHtcbiAgICAgICAgICAgIF9hZGRSYXdUcmFuc2Zvcm1QVHModGhpcywgZW5kVmFsdWUsIHRhcmdldCk7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghKHAgaW4gc3R5bGUpKSB7XG4gICAgICAgICAgcCA9IF9jaGVja1Byb3BQcmVmaXgocCkgfHwgcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1RyYW5zZm9ybVJlbGF0ZWQgfHwgKGVuZE51bSB8fCBlbmROdW0gPT09IDApICYmIChzdGFydE51bSB8fCBzdGFydE51bSA9PT0gMCkgJiYgIV9jb21wbGV4RXhwLnRlc3QoZW5kVmFsdWUpICYmIHAgaW4gc3R5bGUpIHtcbiAgICAgICAgICBzdGFydFVuaXQgPSAoc3RhcnRWYWx1ZSArIFwiXCIpLnN1YnN0cigoc3RhcnROdW0gKyBcIlwiKS5sZW5ndGgpO1xuICAgICAgICAgIGVuZE51bSB8fCAoZW5kTnVtID0gMCk7IC8vIHByb3RlY3QgYWdhaW5zdCBOYU5cblxuICAgICAgICAgIGVuZFVuaXQgPSBnZXRVbml0KGVuZFZhbHVlKSB8fCAocCBpbiBfY29uZmlnLnVuaXRzID8gX2NvbmZpZy51bml0c1twXSA6IHN0YXJ0VW5pdCk7XG4gICAgICAgICAgc3RhcnRVbml0ICE9PSBlbmRVbml0ICYmIChzdGFydE51bSA9IF9jb252ZXJ0VG9Vbml0KHRhcmdldCwgcCwgc3RhcnRWYWx1ZSwgZW5kVW5pdCkpO1xuICAgICAgICAgIHRoaXMuX3B0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgaXNUcmFuc2Zvcm1SZWxhdGVkID8gY2FjaGUgOiBzdHlsZSwgcCwgc3RhcnROdW0sIHJlbGF0aXZlID8gcmVsYXRpdmUgKiBlbmROdW0gOiBlbmROdW0gLSBzdGFydE51bSwgIWlzVHJhbnNmb3JtUmVsYXRlZCAmJiAoZW5kVW5pdCA9PT0gXCJweFwiIHx8IHAgPT09IFwiekluZGV4XCIpICYmIHZhcnMuYXV0b1JvdW5kICE9PSBmYWxzZSA/IF9yZW5kZXJSb3VuZGVkQ1NTUHJvcCA6IF9yZW5kZXJDU1NQcm9wKTtcbiAgICAgICAgICB0aGlzLl9wdC51ID0gZW5kVW5pdCB8fCAwO1xuXG4gICAgICAgICAgaWYgKHN0YXJ0VW5pdCAhPT0gZW5kVW5pdCAmJiBlbmRVbml0ICE9PSBcIiVcIikge1xuICAgICAgICAgICAgLy93aGVuIHRoZSB0d2VlbiBnb2VzIGFsbCB0aGUgd2F5IGJhY2sgdG8gdGhlIGJlZ2lubmluZywgd2UgbmVlZCB0byByZXZlcnQgaXQgdG8gdGhlIE9MRC9PUklHSU5BTCB2YWx1ZSAod2l0aCB0aG9zZSB1bml0cykuIFdlIHJlY29yZCB0aGF0IGFzIGEgXCJiXCIgKGJlZ2lubmluZykgcHJvcGVydHkgYW5kIHBvaW50IHRvIGEgcmVuZGVyIG1ldGhvZCB0aGF0IGhhbmRsZXMgdGhhdC4gKHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbilcbiAgICAgICAgICAgIHRoaXMuX3B0LmIgPSBzdGFydFZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fcHQuciA9IF9yZW5kZXJDU1NQcm9wV2l0aEJlZ2lubmluZztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIShwIGluIHN0eWxlKSkge1xuICAgICAgICAgIGlmIChwIGluIHRhcmdldCkge1xuICAgICAgICAgICAgLy9tYXliZSBpdCdzIG5vdCBhIHN0eWxlIC0gaXQgY291bGQgYmUgYSBwcm9wZXJ0eSBhZGRlZCBkaXJlY3RseSB0byBhbiBlbGVtZW50IGluIHdoaWNoIGNhc2Ugd2UnbGwgdHJ5IHRvIGFuaW1hdGUgdGhhdC5cbiAgICAgICAgICAgIHRoaXMuYWRkKHRhcmdldCwgcCwgc3RhcnRWYWx1ZSB8fCB0YXJnZXRbcF0sIGVuZFZhbHVlLCBpbmRleCwgdGFyZ2V0cyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9taXNzaW5nUGx1Z2luKHAsIGVuZFZhbHVlKTtcblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90d2VlbkNvbXBsZXhDU1NTdHJpbmcuY2FsbCh0aGlzLCB0YXJnZXQsIHAsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3BzLnB1c2gocCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaGFzUHJpb3JpdHkgJiYgX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSh0aGlzKTtcbiAgfSxcbiAgZ2V0OiBfZ2V0LFxuICBhbGlhc2VzOiBfcHJvcGVydHlBbGlhc2VzLFxuICBnZXRTZXR0ZXI6IGZ1bmN0aW9uIGdldFNldHRlcih0YXJnZXQsIHByb3BlcnR5LCBwbHVnaW4pIHtcbiAgICAvL3JldHVybnMgYSBzZXR0ZXIgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHRhcmdldCwgcHJvcGVydHksIHZhbHVlIGFuZCBhcHBsaWVzIGl0IGFjY29yZGluZ2x5LiBSZW1lbWJlciwgcHJvcGVydGllcyBsaWtlIFwieFwiIGFyZW4ndCBhcyBzaW1wbGUgYXMgdGFyZ2V0LnN0eWxlLnByb3BlcnR5ID0gdmFsdWUgYmVjYXVzZSB0aGV5J3ZlIGdvdCB0byBiZSBhcHBsaWVkIHRvIGEgcHJveHkgb2JqZWN0IGFuZCB0aGVuIG1lcmdlZCBpbnRvIGEgdHJhbnNmb3JtIHN0cmluZyBpbiBhIHJlbmRlcmVyLlxuICAgIHZhciBwID0gX3Byb3BlcnR5QWxpYXNlc1twcm9wZXJ0eV07XG4gICAgcCAmJiBwLmluZGV4T2YoXCIsXCIpIDwgMCAmJiAocHJvcGVydHkgPSBwKTtcbiAgICByZXR1cm4gcHJvcGVydHkgaW4gX3RyYW5zZm9ybVByb3BzICYmIHByb3BlcnR5ICE9PSBfdHJhbnNmb3JtT3JpZ2luUHJvcCAmJiAodGFyZ2V0Ll9nc2FwLnggfHwgX2dldCh0YXJnZXQsIFwieFwiKSkgPyBwbHVnaW4gJiYgX3JlY2VudFNldHRlclBsdWdpbiA9PT0gcGx1Z2luID8gcHJvcGVydHkgPT09IFwic2NhbGVcIiA/IF9zZXR0ZXJTY2FsZSA6IF9zZXR0ZXJUcmFuc2Zvcm0gOiAoX3JlY2VudFNldHRlclBsdWdpbiA9IHBsdWdpbiB8fCB7fSkgJiYgKHByb3BlcnR5ID09PSBcInNjYWxlXCIgPyBfc2V0dGVyU2NhbGVXaXRoUmVuZGVyIDogX3NldHRlclRyYW5zZm9ybVdpdGhSZW5kZXIpIDogdGFyZ2V0LnN0eWxlICYmICFfaXNVbmRlZmluZWQodGFyZ2V0LnN0eWxlW3Byb3BlcnR5XSkgPyBfc2V0dGVyQ1NTU3R5bGUgOiB+cHJvcGVydHkuaW5kZXhPZihcIi1cIikgPyBfc2V0dGVyQ1NTUHJvcCA6IF9nZXRTZXR0ZXIodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gIH0sXG4gIGNvcmU6IHtcbiAgICBfcmVtb3ZlUHJvcGVydHk6IF9yZW1vdmVQcm9wZXJ0eSxcbiAgICBfZ2V0TWF0cml4OiBfZ2V0TWF0cml4XG4gIH1cbn07XG5nc2FwLnV0aWxzLmNoZWNrUHJlZml4ID0gX2NoZWNrUHJvcFByZWZpeDtcblxuKGZ1bmN0aW9uIChwb3NpdGlvbkFuZFNjYWxlLCByb3RhdGlvbiwgb3RoZXJzLCBhbGlhc2VzKSB7XG4gIHZhciBhbGwgPSBfZm9yRWFjaE5hbWUocG9zaXRpb25BbmRTY2FsZSArIFwiLFwiICsgcm90YXRpb24gKyBcIixcIiArIG90aGVycywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBfdHJhbnNmb3JtUHJvcHNbbmFtZV0gPSAxO1xuICB9KTtcblxuICBfZm9yRWFjaE5hbWUocm90YXRpb24sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgX2NvbmZpZy51bml0c1tuYW1lXSA9IFwiZGVnXCI7XG4gICAgX3JvdGF0aW9uYWxQcm9wZXJ0aWVzW25hbWVdID0gMTtcbiAgfSk7XG5cbiAgX3Byb3BlcnR5QWxpYXNlc1thbGxbMTNdXSA9IHBvc2l0aW9uQW5kU2NhbGUgKyBcIixcIiArIHJvdGF0aW9uO1xuXG4gIF9mb3JFYWNoTmFtZShhbGlhc2VzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBzcGxpdCA9IG5hbWUuc3BsaXQoXCI6XCIpO1xuICAgIF9wcm9wZXJ0eUFsaWFzZXNbc3BsaXRbMV1dID0gYWxsW3NwbGl0WzBdXTtcbiAgfSk7XG59KShcIngseSx6LHNjYWxlLHNjYWxlWCxzY2FsZVkseFBlcmNlbnQseVBlcmNlbnRcIiwgXCJyb3RhdGlvbixyb3RhdGlvblgscm90YXRpb25ZLHNrZXdYLHNrZXdZXCIsIFwidHJhbnNmb3JtLHRyYW5zZm9ybU9yaWdpbixzdmdPcmlnaW4sZm9yY2UzRCxzbW9vdGhPcmlnaW4sdHJhbnNmb3JtUGVyc3BlY3RpdmVcIiwgXCIwOnRyYW5zbGF0ZVgsMTp0cmFuc2xhdGVZLDI6dHJhbnNsYXRlWiw4OnJvdGF0ZSw4OnJvdGF0aW9uWiw4OnJvdGF0ZVosOTpyb3RhdGVYLDEwOnJvdGF0ZVlcIik7XG5cbl9mb3JFYWNoTmFtZShcIngseSx6LHRvcCxyaWdodCxib3R0b20sbGVmdCx3aWR0aCxoZWlnaHQsZm9udFNpemUscGFkZGluZyxtYXJnaW4scGVyc3BlY3RpdmVcIiwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgX2NvbmZpZy51bml0c1tuYW1lXSA9IFwicHhcIjtcbn0pO1xuXG5nc2FwLnJlZ2lzdGVyUGx1Z2luKENTU1BsdWdpbik7XG5leHBvcnQgeyBDU1NQbHVnaW4gYXMgZGVmYXVsdCwgX2dldEJCb3gsIF9jcmVhdGVFbGVtZW50LCBfY2hlY2tQcm9wUHJlZml4IGFzIGNoZWNrUHJlZml4IH07IiwiLyohXG4gKiBDU1NSdWxlUGx1Z2luIDMuOS4xXG4gKiBodHRwczovL2dyZWVuc29jay5jb21cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAwOC0yMDIxLCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xudmFyIGdzYXAsXG4gICAgX2NvcmVJbml0dGVkLFxuICAgIF93aW4sXG4gICAgX2RvYyxcbiAgICBDU1NQbHVnaW4sXG4gICAgX3dpbmRvd0V4aXN0cyA9IGZ1bmN0aW9uIF93aW5kb3dFeGlzdHMoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xufSxcbiAgICBfZ2V0R1NBUCA9IGZ1bmN0aW9uIF9nZXRHU0FQKCkge1xuICByZXR1cm4gZ3NhcCB8fCBfd2luZG93RXhpc3RzKCkgJiYgKGdzYXAgPSB3aW5kb3cuZ3NhcCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbiAmJiBnc2FwO1xufSxcbiAgICBfY2hlY2tSZWdpc3RlciA9IGZ1bmN0aW9uIF9jaGVja1JlZ2lzdGVyKCkge1xuICBpZiAoIV9jb3JlSW5pdHRlZCkge1xuICAgIF9pbml0Q29yZSgpO1xuXG4gICAgaWYgKCFDU1NQbHVnaW4pIHtcbiAgICAgIGNvbnNvbGUud2FybihcIlBsZWFzZSBnc2FwLnJlZ2lzdGVyUGx1Z2luKENTU1BsdWdpbiwgQ1NTUnVsZVBsdWdpbilcIik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIF9jb3JlSW5pdHRlZDtcbn0sXG4gICAgX2luaXRDb3JlID0gZnVuY3Rpb24gX2luaXRDb3JlKGNvcmUpIHtcbiAgZ3NhcCA9IGNvcmUgfHwgX2dldEdTQVAoKTtcblxuICBpZiAoX3dpbmRvd0V4aXN0cygpKSB7XG4gICAgX3dpbiA9IHdpbmRvdztcbiAgICBfZG9jID0gZG9jdW1lbnQ7XG4gIH1cblxuICBpZiAoZ3NhcCkge1xuICAgIENTU1BsdWdpbiA9IGdzYXAucGx1Z2lucy5jc3M7XG5cbiAgICBpZiAoQ1NTUGx1Z2luKSB7XG4gICAgICBfY29yZUluaXR0ZWQgPSAxO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IHZhciBDU1NSdWxlUGx1Z2luID0ge1xuICB2ZXJzaW9uOiBcIjMuOS4xXCIsXG4gIG5hbWU6IFwiY3NzUnVsZVwiLFxuICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFsdWUsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0cykge1xuICAgIGlmICghX2NoZWNrUmVnaXN0ZXIoKSB8fCB0eXBlb2YgdGFyZ2V0LmNzc1RleHQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgZGl2ID0gdGFyZ2V0Ll9nc1Byb3h5ID0gdGFyZ2V0Ll9nc1Byb3h5IHx8IF9kb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuICAgIHRoaXMuc3MgPSB0YXJnZXQ7XG4gICAgdGhpcy5zdHlsZSA9IGRpdi5zdHlsZTtcbiAgICBkaXYuc3R5bGUuY3NzVGV4dCA9IHRhcmdldC5jc3NUZXh0O1xuICAgIENTU1BsdWdpbi5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGRpdiwgdmFsdWUsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0cyk7IC8vd2UganVzdCBvZmZsb2FkIGFsbCB0aGUgd29yayB0byB0aGUgcmVndWxhciBDU1NQbHVnaW4gYW5kIHRoZW4gY29weSB0aGUgY3NzVGV4dCBiYWNrIG92ZXIgdG8gdGhlIHJ1bGUgaW4gdGhlIHJlbmRlcigpIG1ldGhvZC4gVGhpcyBhbGxvd3MgdXMgdG8gaGF2ZSBhbGwgb2YgdGhlIHVwZGF0ZXMgdG8gQ1NTUGx1Z2luIGF1dG9tYXRpY2FsbHkgZmxvdyB0aHJvdWdoIHRvIENTU1J1bGVQbHVnaW4gaW5zdGVhZCBvZiBoYXZpbmcgdG8gbWFpbnRhaW4gYm90aFxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihyYXRpbywgZGF0YSkge1xuICAgIHZhciBwdCA9IGRhdGEuX3B0LFxuICAgICAgICBzdHlsZSA9IGRhdGEuc3R5bGUsXG4gICAgICAgIHNzID0gZGF0YS5zcyxcbiAgICAgICAgaTtcblxuICAgIHdoaWxlIChwdCkge1xuICAgICAgcHQucihyYXRpbywgcHQuZCk7XG4gICAgICBwdCA9IHB0Ll9uZXh0O1xuICAgIH1cblxuICAgIGkgPSBzdHlsZS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICAgIHNzW3N0eWxlW2ldXSA9IHN0eWxlW3N0eWxlW2ldXTtcbiAgICB9XG4gIH0sXG4gIGdldFJ1bGU6IGZ1bmN0aW9uIGdldFJ1bGUoc2VsZWN0b3IpIHtcbiAgICBfY2hlY2tSZWdpc3RlcigpO1xuXG4gICAgdmFyIHJ1bGVQcm9wID0gX2RvYy5hbGwgPyBcInJ1bGVzXCIgOiBcImNzc1J1bGVzXCIsXG4gICAgICAgIHN0eWxlU2hlZXRzID0gX2RvYy5zdHlsZVNoZWV0cyxcbiAgICAgICAgaSA9IHN0eWxlU2hlZXRzLmxlbmd0aCxcbiAgICAgICAgcHNldWRvID0gc2VsZWN0b3IuY2hhckF0KDApID09PSBcIjpcIixcbiAgICAgICAgaixcbiAgICAgICAgY3VyU1MsXG4gICAgICAgIGNzLFxuICAgICAgICBhO1xuICAgIHNlbGVjdG9yID0gKHBzZXVkbyA/IFwiXCIgOiBcIixcIikgKyBzZWxlY3Rvci5zcGxpdChcIjo6XCIpLmpvaW4oXCI6XCIpLnRvTG93ZXJDYXNlKCkgKyBcIixcIjsgLy9ub3RlOiBvbGQgdmVyc2lvbnMgb2YgSUUgcmVwb3J0IHRhZyBuYW1lIHNlbGVjdG9ycyBhcyB1cHBlciBjYXNlLCBzbyB3ZSBqdXN0IGNoYW5nZSBldmVyeXRoaW5nIHRvIGxvd2VyY2FzZS5cblxuICAgIGlmIChwc2V1ZG8pIHtcbiAgICAgIGEgPSBbXTtcbiAgICB9XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAvL0ZpcmVmb3ggbWF5IHRocm93IGluc2VjdXJlIG9wZXJhdGlvbiBlcnJvcnMgd2hlbiBjc3MgaXMgbG9hZGVkIGZyb20gb3RoZXIgZG9tYWlucywgc28gdHJ5L2NhdGNoLlxuICAgICAgdHJ5IHtcbiAgICAgICAgY3VyU1MgPSBzdHlsZVNoZWV0c1tpXVtydWxlUHJvcF07XG5cbiAgICAgICAgaWYgKCFjdXJTUykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaiA9IGN1clNTLmxlbmd0aDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKC0taiA+IC0xKSB7XG4gICAgICAgIGNzID0gY3VyU1Nbal07XG5cbiAgICAgICAgaWYgKGNzLnNlbGVjdG9yVGV4dCAmJiAoXCIsXCIgKyBjcy5zZWxlY3RvclRleHQuc3BsaXQoXCI6OlwiKS5qb2luKFwiOlwiKS50b0xvd2VyQ2FzZSgpICsgXCIsXCIpLmluZGV4T2Yoc2VsZWN0b3IpICE9PSAtMSkge1xuICAgICAgICAgIC8vbm90ZTogSUUgYWRkcyBhbiBleHRyYSBcIjpcIiB0byBwc2V1ZG8gc2VsZWN0b3JzLCBzbyAubXlDbGFzczphZnRlciBiZWNvbWVzIC5teUNsYXNzOjphZnRlciwgc28gd2UgbmVlZCB0byBzdHJpcCB0aGUgZXh0cmEgb25lIG91dC5cbiAgICAgICAgICBpZiAocHNldWRvKSB7XG4gICAgICAgICAgICBhLnB1c2goY3Muc3R5bGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY3Muc3R5bGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH0sXG4gIHJlZ2lzdGVyOiBfaW5pdENvcmVcbn07XG5fZ2V0R1NBUCgpICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4oQ1NTUnVsZVBsdWdpbik7XG5leHBvcnQgeyBDU1NSdWxlUGx1Z2luIGFzIGRlZmF1bHQgfTsiLCIvKiFcbiAqIEN1c3RvbUVhc2UgMy45LjFcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjEsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgeyBzdHJpbmdUb1Jhd1BhdGgsIHJhd1BhdGhUb1N0cmluZywgdHJhbnNmb3JtUmF3UGF0aCB9IGZyb20gXCIuL3V0aWxzL3BhdGhzLmpzXCI7XG5cbnZhciBnc2FwLFxuICAgIF9jb3JlSW5pdHRlZCxcbiAgICBfZ2V0R1NBUCA9IGZ1bmN0aW9uIF9nZXRHU0FQKCkge1xuICByZXR1cm4gZ3NhcCB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcDtcbn0sXG4gICAgX2luaXRDb3JlID0gZnVuY3Rpb24gX2luaXRDb3JlKCkge1xuICBnc2FwID0gX2dldEdTQVAoKTtcblxuICBpZiAoZ3NhcCkge1xuICAgIGdzYXAucmVnaXN0ZXJFYXNlKFwiX0NFXCIsIEN1c3RvbUVhc2UuY3JlYXRlKTtcbiAgICBfY29yZUluaXR0ZWQgPSAxO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUud2FybihcIlBsZWFzZSBnc2FwLnJlZ2lzdGVyUGx1Z2luKEN1c3RvbUVhc2UpXCIpO1xuICB9XG59LFxuICAgIF9iaWdOdW0gPSAxZTIwLFxuICAgIF9yb3VuZCA9IGZ1bmN0aW9uIF9yb3VuZCh2YWx1ZSkge1xuICByZXR1cm4gfn4odmFsdWUgKiAxMDAwICsgKHZhbHVlIDwgMCA/IC0uNSA6IC41KSkgLyAxMDAwO1xufSxcbiAgICBfYm9udXNWYWxpZGF0ZWQgPSAxLFxuICAgIC8vPG5hbWU+Q3VzdG9tRWFzZTwvbmFtZT5cbl9udW1FeHAgPSAvWy0rPVxcLl0qXFxkK1tcXC5lXFwtXFwrXSpcXGQqW2VcXC1cXCtdKlxcZCovZ2ksXG4gICAgLy9maW5kcyBhbnkgbnVtYmVycywgaW5jbHVkaW5nIG9uZXMgdGhhdCBzdGFydCB3aXRoICs9IG9yIC09LCBuZWdhdGl2ZSBudW1iZXJzLCBhbmQgb25lcyBpbiBzY2llbnRpZmljIG5vdGF0aW9uIGxpa2UgMWUtOC5cbl9uZWVkc1BhcnNpbmdFeHAgPSAvW2NMbHNTYUFoSHZWdFRxUV0vZyxcbiAgICBfZmluZE1pbmltdW0gPSBmdW5jdGlvbiBfZmluZE1pbmltdW0odmFsdWVzKSB7XG4gIHZhciBsID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG1pbiA9IF9iaWdOdW0sXG4gICAgICBpO1xuXG4gIGZvciAoaSA9IDE7IGkgPCBsOyBpICs9IDYpIHtcbiAgICArdmFsdWVzW2ldIDwgbWluICYmIChtaW4gPSArdmFsdWVzW2ldKTtcbiAgfVxuXG4gIHJldHVybiBtaW47XG59LFxuICAgIC8vdGFrZXMgYWxsIHRoZSBwb2ludHMgYW5kIHRyYW5zbGF0ZXMvc2NhbGVzIHRoZW0gc28gdGhhdCB0aGUgeCBzdGFydHMgYXQgMCBhbmQgZW5kcyBhdCAxLlxuX25vcm1hbGl6ZSA9IGZ1bmN0aW9uIF9ub3JtYWxpemUodmFsdWVzLCBoZWlnaHQsIG9yaWdpblkpIHtcbiAgaWYgKCFvcmlnaW5ZICYmIG9yaWdpblkgIT09IDApIHtcbiAgICBvcmlnaW5ZID0gTWF0aC5tYXgoK3ZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV0sICt2YWx1ZXNbMV0pO1xuICB9XG5cbiAgdmFyIHR4ID0gK3ZhbHVlc1swXSAqIC0xLFxuICAgICAgdHkgPSAtb3JpZ2luWSxcbiAgICAgIGwgPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgc3ggPSAxIC8gKCt2YWx1ZXNbbCAtIDJdICsgdHgpLFxuICAgICAgc3kgPSAtaGVpZ2h0IHx8IChNYXRoLmFicygrdmFsdWVzW2wgLSAxXSAtICt2YWx1ZXNbMV0pIDwgMC4wMSAqICgrdmFsdWVzW2wgLSAyXSAtICt2YWx1ZXNbMF0pID8gX2ZpbmRNaW5pbXVtKHZhbHVlcykgKyB0eSA6ICt2YWx1ZXNbbCAtIDFdICsgdHkpLFxuICAgICAgaTtcblxuICBpZiAoc3kpIHtcbiAgICAvL3R5cGljYWxseSB5IGVuZHMgYXQgMSAoc28gdGhhdCB0aGUgZW5kIHZhbHVlcyBhcmUgcmVhY2hlZClcbiAgICBzeSA9IDEgLyBzeTtcbiAgfSBlbHNlIHtcbiAgICAvL2luIGNhc2UgdGhlIGVhc2UgcmV0dXJucyB0byBpdHMgYmVnaW5uaW5nIHZhbHVlLCBzY2FsZSBldmVyeXRoaW5nIHByb3BvcnRpb25hbGx5XG4gICAgc3kgPSAtc3g7XG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgdmFsdWVzW2ldID0gKCt2YWx1ZXNbaV0gKyB0eCkgKiBzeDtcbiAgICB2YWx1ZXNbaSArIDFdID0gKCt2YWx1ZXNbaSArIDFdICsgdHkpICogc3k7XG4gIH1cbn0sXG4gICAgLy9ub3RlIHRoYXQgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHBvaW50IG9iamVjdHMgbGlrZSB7eCwgeX0gcmF0aGVyIHRoYW4gd29ya2luZyB3aXRoIHNlZ21lbnRzIHdoaWNoIGFyZSBhcnJheXMgd2l0aCBhbHRlcm5hdGluZyB4LCB5IHZhbHVlcyBhcyBpbiB0aGUgc2ltaWxhciBmdW5jdGlvbiBpbiBwYXRocy5qc1xuX2JlemllclRvUG9pbnRzID0gZnVuY3Rpb24gX2JlemllclRvUG9pbnRzKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgdGhyZXNob2xkLCBwb2ludHMsIGluZGV4KSB7XG4gIHZhciB4MTIgPSAoeDEgKyB4MikgLyAyLFxuICAgICAgeTEyID0gKHkxICsgeTIpIC8gMixcbiAgICAgIHgyMyA9ICh4MiArIHgzKSAvIDIsXG4gICAgICB5MjMgPSAoeTIgKyB5MykgLyAyLFxuICAgICAgeDM0ID0gKHgzICsgeDQpIC8gMixcbiAgICAgIHkzNCA9ICh5MyArIHk0KSAvIDIsXG4gICAgICB4MTIzID0gKHgxMiArIHgyMykgLyAyLFxuICAgICAgeTEyMyA9ICh5MTIgKyB5MjMpIC8gMixcbiAgICAgIHgyMzQgPSAoeDIzICsgeDM0KSAvIDIsXG4gICAgICB5MjM0ID0gKHkyMyArIHkzNCkgLyAyLFxuICAgICAgeDEyMzQgPSAoeDEyMyArIHgyMzQpIC8gMixcbiAgICAgIHkxMjM0ID0gKHkxMjMgKyB5MjM0KSAvIDIsXG4gICAgICBkeCA9IHg0IC0geDEsXG4gICAgICBkeSA9IHk0IC0geTEsXG4gICAgICBkMiA9IE1hdGguYWJzKCh4MiAtIHg0KSAqIGR5IC0gKHkyIC0geTQpICogZHgpLFxuICAgICAgZDMgPSBNYXRoLmFicygoeDMgLSB4NCkgKiBkeSAtICh5MyAtIHk0KSAqIGR4KSxcbiAgICAgIGxlbmd0aDtcblxuICBpZiAoIXBvaW50cykge1xuICAgIHBvaW50cyA9IFt7XG4gICAgICB4OiB4MSxcbiAgICAgIHk6IHkxXG4gICAgfSwge1xuICAgICAgeDogeDQsXG4gICAgICB5OiB5NFxuICAgIH1dO1xuICAgIGluZGV4ID0gMTtcbiAgfVxuXG4gIHBvaW50cy5zcGxpY2UoaW5kZXggfHwgcG9pbnRzLmxlbmd0aCAtIDEsIDAsIHtcbiAgICB4OiB4MTIzNCxcbiAgICB5OiB5MTIzNFxuICB9KTtcblxuICBpZiAoKGQyICsgZDMpICogKGQyICsgZDMpID4gdGhyZXNob2xkICogKGR4ICogZHggKyBkeSAqIGR5KSkge1xuICAgIGxlbmd0aCA9IHBvaW50cy5sZW5ndGg7XG5cbiAgICBfYmV6aWVyVG9Qb2ludHMoeDEsIHkxLCB4MTIsIHkxMiwgeDEyMywgeTEyMywgeDEyMzQsIHkxMjM0LCB0aHJlc2hvbGQsIHBvaW50cywgaW5kZXgpO1xuXG4gICAgX2JlemllclRvUG9pbnRzKHgxMjM0LCB5MTIzNCwgeDIzNCwgeTIzNCwgeDM0LCB5MzQsIHg0LCB5NCwgdGhyZXNob2xkLCBwb2ludHMsIGluZGV4ICsgMSArIChwb2ludHMubGVuZ3RoIC0gbGVuZ3RoKSk7XG4gIH1cblxuICByZXR1cm4gcG9pbnRzO1xufTtcblxuZXhwb3J0IHZhciBDdXN0b21FYXNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ3VzdG9tRWFzZShpZCwgZGF0YSwgY29uZmlnKSB7XG4gICAgX2NvcmVJbml0dGVkIHx8IF9pbml0Q29yZSgpO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICBfYm9udXNWYWxpZGF0ZWQgJiYgdGhpcy5zZXREYXRhKGRhdGEsIGNvbmZpZyk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQ3VzdG9tRWFzZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnNldERhdGEgPSBmdW5jdGlvbiBzZXREYXRhKGRhdGEsIGNvbmZpZykge1xuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICBkYXRhID0gZGF0YSB8fCBcIjAsMCwxLDFcIjtcbiAgICB2YXIgdmFsdWVzID0gZGF0YS5tYXRjaChfbnVtRXhwKSxcbiAgICAgICAgY2xvc2VzdCA9IDEsXG4gICAgICAgIHBvaW50cyA9IFtdLFxuICAgICAgICBsb29rdXAgPSBbXSxcbiAgICAgICAgcHJlY2lzaW9uID0gY29uZmlnLnByZWNpc2lvbiB8fCAxLFxuICAgICAgICBmYXN0ID0gcHJlY2lzaW9uIDw9IDEsXG4gICAgICAgIGwsXG4gICAgICAgIGExLFxuICAgICAgICBhMixcbiAgICAgICAgaSxcbiAgICAgICAgaW5jLFxuICAgICAgICBqLFxuICAgICAgICBwb2ludCxcbiAgICAgICAgcHJldlBvaW50LFxuICAgICAgICBwO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG5cbiAgICBpZiAoX25lZWRzUGFyc2luZ0V4cC50ZXN0KGRhdGEpIHx8IH5kYXRhLmluZGV4T2YoXCJNXCIpICYmIGRhdGEuaW5kZXhPZihcIkNcIikgPCAwKSB7XG4gICAgICB2YWx1ZXMgPSBzdHJpbmdUb1Jhd1BhdGgoZGF0YSlbMF07XG4gICAgfVxuXG4gICAgbCA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgICBpZiAobCA9PT0gNCkge1xuICAgICAgdmFsdWVzLnVuc2hpZnQoMCwgMCk7XG4gICAgICB2YWx1ZXMucHVzaCgxLCAxKTtcbiAgICAgIGwgPSA4O1xuICAgIH0gZWxzZSBpZiAoKGwgLSAyKSAlIDYpIHtcbiAgICAgIHRocm93IFwiSW52YWxpZCBDdXN0b21FYXNlXCI7XG4gICAgfVxuXG4gICAgaWYgKCt2YWx1ZXNbMF0gIT09IDAgfHwgK3ZhbHVlc1tsIC0gMl0gIT09IDEpIHtcbiAgICAgIF9ub3JtYWxpemUodmFsdWVzLCBjb25maWcuaGVpZ2h0LCBjb25maWcub3JpZ2luWSk7XG4gICAgfVxuXG4gICAgdGhpcy5zZWdtZW50ID0gdmFsdWVzO1xuXG4gICAgZm9yIChpID0gMjsgaSA8IGw7IGkgKz0gNikge1xuICAgICAgYTEgPSB7XG4gICAgICAgIHg6ICt2YWx1ZXNbaSAtIDJdLFxuICAgICAgICB5OiArdmFsdWVzW2kgLSAxXVxuICAgICAgfTtcbiAgICAgIGEyID0ge1xuICAgICAgICB4OiArdmFsdWVzW2kgKyA0XSxcbiAgICAgICAgeTogK3ZhbHVlc1tpICsgNV1cbiAgICAgIH07XG4gICAgICBwb2ludHMucHVzaChhMSwgYTIpO1xuXG4gICAgICBfYmV6aWVyVG9Qb2ludHMoYTEueCwgYTEueSwgK3ZhbHVlc1tpXSwgK3ZhbHVlc1tpICsgMV0sICt2YWx1ZXNbaSArIDJdLCArdmFsdWVzW2kgKyAzXSwgYTIueCwgYTIueSwgMSAvIChwcmVjaXNpb24gKiAyMDAwMDApLCBwb2ludHMsIHBvaW50cy5sZW5ndGggLSAxKTtcbiAgICB9XG5cbiAgICBsID0gcG9pbnRzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgcHJldlBvaW50ID0gcG9pbnRzW2kgLSAxXSB8fCBwb2ludDtcblxuICAgICAgaWYgKChwb2ludC54ID4gcHJldlBvaW50LnggfHwgcHJldlBvaW50LnkgIT09IHBvaW50LnkgJiYgcHJldlBvaW50LnggPT09IHBvaW50LnggfHwgcG9pbnQgPT09IHByZXZQb2ludCkgJiYgcG9pbnQueCA8PSAxKSB7XG4gICAgICAgIC8vaWYgYSBwb2ludCBnb2VzIEJBQ0tXQVJEIGluIHRpbWUgb3IgaXMgYSBkdXBsaWNhdGUsIGp1c3QgZHJvcCBpdC4gQWxzbyBpdCBzaG91bGRuJ3QgZ28gcGFzdCAxIG9uIHRoZSB4IGF4aXMsIGFzIGNvdWxkIGhhcHBlbiBpbiBhIHN0cmluZyBsaWtlIFwiTTAsMCBDMCwwIDAuMTIsMC42OCAwLjE4LDAuNzg4IDAuMTk1LDAuODQ1IDAuMzA4LDEgMC4zMiwxIDAuNDAzLDEuMDA1IDAuMzk4LDEgMC41LDEgMC42MDIsMSAwLjgxNiwxLjAwNSAwLjksMSAwLjkxLDEgMC45NDgsMC42OSAwLjk2MiwwLjYxNSAxLjAwMywwLjM3NiAxLDAgMSwwXCIuXG4gICAgICAgIHByZXZQb2ludC5jeCA9IHBvaW50LnggLSBwcmV2UG9pbnQueDsgLy9jaGFuZ2UgaW4geCBiZXR3ZWVuIHRoaXMgcG9pbnQgYW5kIHRoZSBuZXh0IHBvaW50IChwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24pXG5cbiAgICAgICAgcHJldlBvaW50LmN5ID0gcG9pbnQueSAtIHByZXZQb2ludC55O1xuICAgICAgICBwcmV2UG9pbnQubiA9IHBvaW50O1xuICAgICAgICBwcmV2UG9pbnQubnggPSBwb2ludC54OyAvL25leHQgcG9pbnQncyB4IHZhbHVlIChwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24sIG1ha2luZyBsb29rdXBzIGZhc3RlciBpbiBnZXRSYXRpbygpKS4gUmVtZW1iZXIsIHRoZSBsb29rdXAgd2lsbCBhbHdheXMgbGFuZCBvbiBhIHNwb3Qgd2hlcmUgaXQncyBlaXRoZXIgdGhpcyBwb2ludCBvciB0aGUgdmVyeSBuZXh0IG9uZSAobmV2ZXIgYmV5b25kIHRoYXQpXG5cbiAgICAgICAgaWYgKGZhc3QgJiYgaSA+IDEgJiYgTWF0aC5hYnMocHJldlBvaW50LmN5IC8gcHJldlBvaW50LmN4IC0gcG9pbnRzW2kgLSAyXS5jeSAvIHBvaW50c1tpIC0gMl0uY3gpID4gMikge1xuICAgICAgICAgIC8vaWYgdGhlcmUncyBhIHN1ZGRlbiBjaGFuZ2UgaW4gZGlyZWN0aW9uLCBwcmlvcml0aXplIGFjY3VyYWN5IG92ZXIgc3BlZWQuIExpa2UgYSBib3VuY2UgZWFzZSAtIHlvdSBkb24ndCB3YW50IHRvIHJpc2sgdGhlIHNhbXBsaW5nIGNodW5rcyBsYW5kaW5nIG9uIGVhY2ggc2lkZSBvZiB0aGUgYm91bmNlIGFuY2hvciBhbmQgaGF2aW5nIGl0IGNsaXBwZWQgb2ZmLlxuICAgICAgICAgIGZhc3QgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByZXZQb2ludC5jeCA8IGNsb3Nlc3QpIHtcbiAgICAgICAgICBpZiAoIXByZXZQb2ludC5jeCkge1xuICAgICAgICAgICAgcHJldlBvaW50LmN4ID0gMC4wMDE7IC8vYXZvaWRzIG1hdGggcHJvYmxlbXMgaW4gZ2V0UmF0aW8oKSAoZGl2aWRpbmcgYnkgemVybylcblxuICAgICAgICAgICAgaWYgKGkgPT09IGwgLSAxKSB7XG4gICAgICAgICAgICAgIC8vaW4gY2FzZSB0aGUgZmluYWwgc2VnbWVudCBnb2VzIHZlcnRpY2FsIFJJR0hUIGF0IHRoZSBlbmQsIG1ha2Ugc3VyZSB3ZSBlbmQgYXQgdGhlIGVuZC5cbiAgICAgICAgICAgICAgcHJldlBvaW50LnggLT0gMC4wMDE7XG4gICAgICAgICAgICAgIGNsb3Nlc3QgPSBNYXRoLm1pbihjbG9zZXN0LCAwLjAwMSk7XG4gICAgICAgICAgICAgIGZhc3QgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbG9zZXN0ID0gcHJldlBvaW50LmN4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9pbnRzLnNwbGljZShpLS0sIDEpO1xuICAgICAgICBsLS07XG4gICAgICB9XG4gICAgfVxuXG4gICAgbCA9IDEgLyBjbG9zZXN0ICsgMSB8IDA7XG4gICAgaW5jID0gMSAvIGw7XG4gICAgaiA9IDA7XG4gICAgcG9pbnQgPSBwb2ludHNbMF07XG5cbiAgICBpZiAoZmFzdCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAvL2ZvciBmYXN0ZXN0IGxvb2t1cHMsIHdlIGp1c3Qgc2FtcGxlIGFsb25nIHRoZSBwYXRoIGF0IGVxdWFsIHggKHRpbWUpIGRpc3RhbmNlLiBVc2VzIG1vcmUgbWVtb3J5IGFuZCBpcyBzbGlnaHRseSBsZXNzIGFjY3VyYXRlIGZvciBhbmNob3JzIHRoYXQgZG9uJ3QgbGFuZCBvbiB0aGUgc2FtcGxpbmcgcG9pbnRzLCBidXQgZm9yIHRoZSB2YXN0IG1ham9yaXR5IG9mIGVhc2VzIGl0J3MgZXhjZWxsZW50IChhbmQgZmFzdCkuXG4gICAgICAgIHAgPSBpICogaW5jO1xuXG4gICAgICAgIGlmIChwb2ludC5ueCA8IHApIHtcbiAgICAgICAgICBwb2ludCA9IHBvaW50c1srK2pdO1xuICAgICAgICB9XG5cbiAgICAgICAgYTEgPSBwb2ludC55ICsgKHAgLSBwb2ludC54KSAvIHBvaW50LmN4ICogcG9pbnQuY3k7XG4gICAgICAgIGxvb2t1cFtpXSA9IHtcbiAgICAgICAgICB4OiBwLFxuICAgICAgICAgIGN4OiBpbmMsXG4gICAgICAgICAgeTogYTEsXG4gICAgICAgICAgY3k6IDAsXG4gICAgICAgICAgbng6IDlcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoaSkge1xuICAgICAgICAgIGxvb2t1cFtpIC0gMV0uY3kgPSBhMSAtIGxvb2t1cFtpIC0gMV0ueTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsb29rdXBbbCAtIDFdLmN5ID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXS55IC0gYTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vdGhpcyBvcHRpb24gaXMgbW9yZSBhY2N1cmF0ZSwgZW5zdXJpbmcgdGhhdCBFVkVSWSBhbmNob3IgaXMgaGl0IHBlcmZlY3RseS4gQ2xpcHBpbmcgYWNyb3NzIGEgYm91bmNlLCBmb3IgZXhhbXBsZSwgd291bGQgbmV2ZXIgaGFwcGVuLlxuICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAvL2J1aWxkIGEgbG9va3VwIHRhYmxlIGJhc2VkIG9uIHRoZSBzbWFsbGVzdCBkaXN0YW5jZSBzbyB0aGF0IHdlIGNhbiBpbnN0YW50bHkgZmluZCB0aGUgYXBwcm9wcmlhdGUgcG9pbnQgKHdlbGwsIGl0J2xsIGVpdGhlciBiZSB0aGF0IHBvaW50IG9yIHRoZSB2ZXJ5IG5leHQgb25lKS4gV2UnbGwgbG9vayB1cCBiYXNlZCBvbiB0aGUgbGluZWFyIHByb2dyZXNzLiBTbyBpdCdzIGl0J3MgMC41IGFuZCB0aGUgbG9va3VwIHRhYmxlIGhhcyAxMDAgZWxlbWVudHMsIGl0J2QgYmUgbGlrZSBsb29rdXBbTWF0aC5mbG9vcigwLjUgKiAxMDApXVxuICAgICAgICBpZiAocG9pbnQubnggPCBpICogaW5jKSB7XG4gICAgICAgICAgcG9pbnQgPSBwb2ludHNbKytqXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvb2t1cFtpXSA9IHBvaW50O1xuICAgICAgfVxuXG4gICAgICBpZiAoaiA8IHBvaW50cy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGxvb2t1cFtpIC0gMV0gPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdO1xuICAgICAgfVxuICAgIH0gLy90aGlzLl9jYWxjRW5kID0gKHBvaW50c1twb2ludHMubGVuZ3RoLTFdLnkgIT09IDEgfHwgcG9pbnRzWzBdLnkgIT09IDApOyAvL2Vuc3VyZXMgdGhhdCB3ZSBkb24ndCBydW4gaW50byBmbG9hdGluZyBwb2ludCBlcnJvcnMuIEFzIGxvbmcgYXMgd2UncmUgc3RhcnRpbmcgYXQgMCBhbmQgZW5kaW5nIGF0IDEsIHRlbGwgR1NBUCB0byBza2lwIHRoZSBmaW5hbCBjYWxjdWxhdGlvbiBhbmQgdXNlIDAvMSBhcyB0aGUgZmFjdG9yLlxuXG5cbiAgICB0aGlzLmVhc2UgPSBmdW5jdGlvbiAocCkge1xuICAgICAgdmFyIHBvaW50ID0gbG9va3VwW3AgKiBsIHwgMF0gfHwgbG9va3VwW2wgLSAxXTtcblxuICAgICAgaWYgKHBvaW50Lm54IDwgcCkge1xuICAgICAgICBwb2ludCA9IHBvaW50Lm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwb2ludC55ICsgKHAgLSBwb2ludC54KSAvIHBvaW50LmN4ICogcG9pbnQuY3k7XG4gICAgfTtcblxuICAgIHRoaXMuZWFzZS5jdXN0b20gPSB0aGlzO1xuICAgIHRoaXMuaWQgJiYgZ3NhcCAmJiBnc2FwLnJlZ2lzdGVyRWFzZSh0aGlzLmlkLCB0aGlzLmVhc2UpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5nZXRTVkdEYXRhID0gZnVuY3Rpb24gZ2V0U1ZHRGF0YShjb25maWcpIHtcbiAgICByZXR1cm4gQ3VzdG9tRWFzZS5nZXRTVkdEYXRhKHRoaXMsIGNvbmZpZyk7XG4gIH07XG5cbiAgQ3VzdG9tRWFzZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaWQsIGRhdGEsIGNvbmZpZykge1xuICAgIHJldHVybiBuZXcgQ3VzdG9tRWFzZShpZCwgZGF0YSwgY29uZmlnKS5lYXNlO1xuICB9O1xuXG4gIEN1c3RvbUVhc2UucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3Rlcihjb3JlKSB7XG4gICAgZ3NhcCA9IGNvcmU7XG5cbiAgICBfaW5pdENvcmUoKTtcbiAgfTtcblxuICBDdXN0b21FYXNlLmdldCA9IGZ1bmN0aW9uIGdldChpZCkge1xuICAgIHJldHVybiBnc2FwLnBhcnNlRWFzZShpZCk7XG4gIH07XG5cbiAgQ3VzdG9tRWFzZS5nZXRTVkdEYXRhID0gZnVuY3Rpb24gZ2V0U1ZHRGF0YShlYXNlLCBjb25maWcpIHtcbiAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gICAgdmFyIHdpZHRoID0gY29uZmlnLndpZHRoIHx8IDEwMCxcbiAgICAgICAgaGVpZ2h0ID0gY29uZmlnLmhlaWdodCB8fCAxMDAsXG4gICAgICAgIHggPSBjb25maWcueCB8fCAwLFxuICAgICAgICB5ID0gKGNvbmZpZy55IHx8IDApICsgaGVpZ2h0LFxuICAgICAgICBlID0gZ3NhcC51dGlscy50b0FycmF5KGNvbmZpZy5wYXRoKVswXSxcbiAgICAgICAgYSxcbiAgICAgICAgc2xvcGUsXG4gICAgICAgIGksXG4gICAgICAgIGluYyxcbiAgICAgICAgdHgsXG4gICAgICAgIHR5LFxuICAgICAgICBwcmVjaXNpb24sXG4gICAgICAgIHRocmVzaG9sZCxcbiAgICAgICAgcHJldlgsXG4gICAgICAgIHByZXZZO1xuXG4gICAgaWYgKGNvbmZpZy5pbnZlcnQpIHtcbiAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gICAgICB5ID0gMDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGVhc2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGVhc2UgPSBnc2FwLnBhcnNlRWFzZShlYXNlKTtcbiAgICB9XG5cbiAgICBpZiAoZWFzZS5jdXN0b20pIHtcbiAgICAgIGVhc2UgPSBlYXNlLmN1c3RvbTtcbiAgICB9XG5cbiAgICBpZiAoZWFzZSBpbnN0YW5jZW9mIEN1c3RvbUVhc2UpIHtcbiAgICAgIGEgPSByYXdQYXRoVG9TdHJpbmcodHJhbnNmb3JtUmF3UGF0aChbZWFzZS5zZWdtZW50XSwgd2lkdGgsIDAsIDAsIC1oZWlnaHQsIHgsIHkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IFt4LCB5XTtcbiAgICAgIHByZWNpc2lvbiA9IE1hdGgubWF4KDUsIChjb25maWcucHJlY2lzaW9uIHx8IDEpICogMjAwKTtcbiAgICAgIGluYyA9IDEgLyBwcmVjaXNpb247XG4gICAgICBwcmVjaXNpb24gKz0gMjtcbiAgICAgIHRocmVzaG9sZCA9IDUgLyBwcmVjaXNpb247XG4gICAgICBwcmV2WCA9IF9yb3VuZCh4ICsgaW5jICogd2lkdGgpO1xuICAgICAgcHJldlkgPSBfcm91bmQoeSArIGVhc2UoaW5jKSAqIC1oZWlnaHQpO1xuICAgICAgc2xvcGUgPSAocHJldlkgLSB5KSAvIChwcmV2WCAtIHgpO1xuXG4gICAgICBmb3IgKGkgPSAyOyBpIDwgcHJlY2lzaW9uOyBpKyspIHtcbiAgICAgICAgdHggPSBfcm91bmQoeCArIGkgKiBpbmMgKiB3aWR0aCk7XG4gICAgICAgIHR5ID0gX3JvdW5kKHkgKyBlYXNlKGkgKiBpbmMpICogLWhlaWdodCk7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKCh0eSAtIHByZXZZKSAvICh0eCAtIHByZXZYKSAtIHNsb3BlKSA+IHRocmVzaG9sZCB8fCBpID09PSBwcmVjaXNpb24gLSAxKSB7XG4gICAgICAgICAgLy9vbmx5IGFkZCBwb2ludHMgd2hlbiB0aGUgc2xvcGUgY2hhbmdlcyBiZXlvbmQgdGhlIHRocmVzaG9sZFxuICAgICAgICAgIGEucHVzaChwcmV2WCwgcHJldlkpO1xuICAgICAgICAgIHNsb3BlID0gKHR5IC0gcHJldlkpIC8gKHR4IC0gcHJldlgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldlggPSB0eDtcbiAgICAgICAgcHJldlkgPSB0eTtcbiAgICAgIH1cblxuICAgICAgYSA9IFwiTVwiICsgYS5qb2luKFwiLFwiKTtcbiAgICB9XG5cbiAgICBlICYmIGUuc2V0QXR0cmlidXRlKFwiZFwiLCBhKTtcbiAgICByZXR1cm4gYTtcbiAgfTtcblxuICByZXR1cm4gQ3VzdG9tRWFzZTtcbn0oKTtcbl9nZXRHU0FQKCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbihDdXN0b21FYXNlKTtcbkN1c3RvbUVhc2UudmVyc2lvbiA9IFwiMy45LjFcIjtcbmV4cG9ydCB7IEN1c3RvbUVhc2UgYXMgZGVmYXVsdCB9OyIsImZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyohXG4gKiBEcmFnZ2FibGUgMy45LjFcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjEsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IHsgZ2V0R2xvYmFsTWF0cml4LCBNYXRyaXgyRCB9IGZyb20gXCIuL3V0aWxzL21hdHJpeC5qc1wiO1xuXG52YXIgZ3NhcCxcbiAgICBfd2luLFxuICAgIF9kb2MsXG4gICAgX2RvY0VsZW1lbnQsXG4gICAgX2JvZHksXG4gICAgX3RlbXBEaXYsXG4gICAgX3BsYWNlaG9sZGVyRGl2LFxuICAgIF9jb3JlSW5pdHRlZCxcbiAgICBfY2hlY2tQcmVmaXgsXG4gICAgX3RvQXJyYXksXG4gICAgX3N1cHBvcnRzUGFzc2l2ZSxcbiAgICBfaXNUb3VjaERldmljZSxcbiAgICBfdG91Y2hFdmVudExvb2t1cCxcbiAgICBfZHJhZ0NvdW50LFxuICAgIF9pc011bHRpVG91Y2hpbmcsXG4gICAgX2lzQW5kcm9pZCxcbiAgICBJbmVydGlhUGx1Z2luLFxuICAgIF9kZWZhdWx0Q3Vyc29yLFxuICAgIF9zdXBwb3J0c1BvaW50ZXIsXG4gICAgX3dpbmRvd0V4aXN0cyA9IGZ1bmN0aW9uIF93aW5kb3dFeGlzdHMoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xufSxcbiAgICBfZ2V0R1NBUCA9IGZ1bmN0aW9uIF9nZXRHU0FQKCkge1xuICByZXR1cm4gZ3NhcCB8fCBfd2luZG93RXhpc3RzKCkgJiYgKGdzYXAgPSB3aW5kb3cuZ3NhcCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbiAmJiBnc2FwO1xufSxcbiAgICBfaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIF9pc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcbn0sXG4gICAgX2lzT2JqZWN0ID0gZnVuY3Rpb24gX2lzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCI7XG59LFxuICAgIF9pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uIF9pc1VuZGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiO1xufSxcbiAgICBfZW1wdHlGdW5jID0gZnVuY3Rpb24gX2VtcHR5RnVuYygpIHtcbiAgcmV0dXJuIGZhbHNlO1xufSxcbiAgICBfdHJhbnNmb3JtUHJvcCA9IFwidHJhbnNmb3JtXCIsXG4gICAgX3RyYW5zZm9ybU9yaWdpblByb3AgPSBcInRyYW5zZm9ybU9yaWdpblwiLFxuICAgIF9yb3VuZCA9IGZ1bmN0aW9uIF9yb3VuZCh2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMDAwKSAvIDEwMDAwO1xufSxcbiAgICBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXksXG4gICAgX2NyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiBfY3JlYXRlRWxlbWVudCh0eXBlLCBucykge1xuICB2YXIgZSA9IF9kb2MuY3JlYXRlRWxlbWVudE5TID8gX2RvYy5jcmVhdGVFbGVtZW50TlMoKG5zIHx8IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiKS5yZXBsYWNlKC9eaHR0cHMvLCBcImh0dHBcIiksIHR5cGUpIDogX2RvYy5jcmVhdGVFbGVtZW50KHR5cGUpOyAvL3NvbWUgc2VydmVycyBzd2FwIGluIGh0dHBzIGZvciBodHRwIGluIHRoZSBuYW1lc3BhY2Ugd2hpY2ggY2FuIGJyZWFrIHRoaW5ncywgbWFraW5nIFwic3R5bGVcIiBpbmFjY2Vzc2libGUuXG5cbiAgcmV0dXJuIGUuc3R5bGUgPyBlIDogX2RvYy5jcmVhdGVFbGVtZW50KHR5cGUpOyAvL3NvbWUgZW52aXJvbm1lbnRzIHdvbid0IGFsbG93IGFjY2VzcyB0byB0aGUgZWxlbWVudCdzIHN0eWxlIHdoZW4gY3JlYXRlZCB3aXRoIGEgbmFtZXNwYWNlIGluIHdoaWNoIGNhc2Ugd2UgZGVmYXVsdCB0byB0aGUgc3RhbmRhcmQgY3JlYXRlRWxlbWVudCgpIHRvIHdvcmsgYXJvdW5kIHRoZSBpc3N1ZS4gQWxzbyBub3RlIHRoYXQgd2hlbiBHU0FQIGlzIGVtYmVkZGVkIGRpcmVjdGx5IGluc2lkZSBhbiBTVkcgZmlsZSwgY3JlYXRlRWxlbWVudCgpIHdvbid0IGFsbG93IGFjY2VzcyB0byB0aGUgc3R5bGUgb2JqZWN0IGluIEZpcmVmb3ggKHNlZSBodHRwczovL2dyZWVuc29jay5jb20vZm9ydW1zL3RvcGljLzIwMjE1LXByb2JsZW0tdXNpbmctdHdlZW5tYXgtaW4tc3RhbmRhbG9uZS1zZWxmLWNvbnRhaW5pbmctc3ZnLWZpbGUtZXJyLWNhbm5vdC1zZXQtcHJvcGVydHktY3NzdGV4dC1vZi11bmRlZmluZWQvKS5cbn0sXG4gICAgX1JBRDJERUcgPSAxODAgLyBNYXRoLlBJLFxuICAgIF9iaWdOdW0gPSAxZTIwLFxuICAgIF9pZGVudGl0eU1hdHJpeCA9IG5ldyBNYXRyaXgyRCgpLFxuICAgIF9nZXRUaW1lID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG59LFxuICAgIF9yZW5kZXJRdWV1ZSA9IFtdLFxuICAgIF9sb29rdXAgPSB7fSxcbiAgICAvL3doZW4gYSBEcmFnZ2FibGUgaXMgY3JlYXRlZCwgdGhlIHRhcmdldCBnZXRzIGEgdW5pcXVlIF9nc0RyYWdJRCBwcm9wZXJ0eSB0aGF0IGFsbG93cyBnZXRzIGFzc29jaWF0ZWQgd2l0aCB0aGUgRHJhZ2dhYmxlIGluc3RhbmNlIGZvciBxdWljayBsb29rdXBzIGluIERyYWdnYWJsZS5nZXQoKS4gVGhpcyBhdm9pZHMgY2lyY3VsYXIgcmVmZXJlbmNlcyB0aGF0IGNvdWxkIGNhdXNlIGdjIHByb2JsZW1zLlxuX2xvb2t1cENvdW50ID0gMCxcbiAgICBfY2xpY2thYmxlVGFnRXhwID0gL14oPzphfGlucHV0fHRleHRhcmVhfGJ1dHRvbnxzZWxlY3QpJC9pLFxuICAgIF9sYXN0RHJhZ1RpbWUgPSAwLFxuICAgIF90ZW1wMSA9IHt9LFxuICAgIC8vIGEgc2ltcGxlIG9iamVjdCB3ZSByZXVzZSBhbmQgcG9wdWxhdGUgKHVzdWFsbHkgeC95IHByb3BlcnRpZXMpIHRvIGNvbnNlcnZlIG1lbW9yeSBhbmQgaW1wcm92ZSBwZXJmb3JtYW5jZS5cbl93aW5kb3dQcm94eSA9IHt9LFxuICAgIC8vbWVtb3J5L3BlcmZvcm1hbmNlIG9wdGltaXphdGlvbiAtIHdlIHJldXNlIHRoaXMgb2JqZWN0IGR1cmluZyBhdXRvU2Nyb2xsIHRvIHN0b3JlIHdpbmRvdy1yZWxhdGVkIGJvdW5kcy9vZmZzZXRzLlxuX2NvcHkgPSBmdW5jdGlvbiBfY29weShvYmosIGZhY3Rvcikge1xuICB2YXIgY29weSA9IHt9LFxuICAgICAgcDtcblxuICBmb3IgKHAgaW4gb2JqKSB7XG4gICAgY29weVtwXSA9IGZhY3RvciA/IG9ialtwXSAqIGZhY3RvciA6IG9ialtwXTtcbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufSxcbiAgICBfZXh0ZW5kID0gZnVuY3Rpb24gX2V4dGVuZChvYmosIGRlZmF1bHRzKSB7XG4gIGZvciAodmFyIHAgaW4gZGVmYXVsdHMpIHtcbiAgICBpZiAoIShwIGluIG9iaikpIHtcbiAgICAgIG9ialtwXSA9IGRlZmF1bHRzW3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59LFxuICAgIF9zZXRUb3VjaEFjdGlvbkZvckFsbERlc2NlbmRhbnRzID0gZnVuY3Rpb24gX3NldFRvdWNoQWN0aW9uRm9yQWxsRGVzY2VuZGFudHMoZWxlbWVudHMsIHZhbHVlKSB7XG4gIHZhciBpID0gZWxlbWVudHMubGVuZ3RoLFxuICAgICAgY2hpbGRyZW47XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHZhbHVlID8gZWxlbWVudHNbaV0uc3R5bGUudG91Y2hBY3Rpb24gPSB2YWx1ZSA6IGVsZW1lbnRzW2ldLnN0eWxlLnJlbW92ZVByb3BlcnR5KFwidG91Y2gtYWN0aW9uXCIpO1xuICAgIGNoaWxkcmVuID0gZWxlbWVudHNbaV0uY2hpbGRyZW47XG4gICAgY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoICYmIF9zZXRUb3VjaEFjdGlvbkZvckFsbERlc2NlbmRhbnRzKGNoaWxkcmVuLCB2YWx1ZSk7XG4gIH1cbn0sXG4gICAgX3JlbmRlclF1ZXVlVGljayA9IGZ1bmN0aW9uIF9yZW5kZXJRdWV1ZVRpY2soKSB7XG4gIHJldHVybiBfcmVuZGVyUXVldWUuZm9yRWFjaChmdW5jdGlvbiAoZnVuYykge1xuICAgIHJldHVybiBmdW5jKCk7XG4gIH0pO1xufSxcbiAgICBfYWRkVG9SZW5kZXJRdWV1ZSA9IGZ1bmN0aW9uIF9hZGRUb1JlbmRlclF1ZXVlKGZ1bmMpIHtcbiAgX3JlbmRlclF1ZXVlLnB1c2goZnVuYyk7XG5cbiAgaWYgKF9yZW5kZXJRdWV1ZS5sZW5ndGggPT09IDEpIHtcbiAgICBnc2FwLnRpY2tlci5hZGQoX3JlbmRlclF1ZXVlVGljayk7XG4gIH1cbn0sXG4gICAgX3JlbmRlclF1ZXVlVGltZW91dCA9IGZ1bmN0aW9uIF9yZW5kZXJRdWV1ZVRpbWVvdXQoKSB7XG4gIHJldHVybiAhX3JlbmRlclF1ZXVlLmxlbmd0aCAmJiBnc2FwLnRpY2tlci5yZW1vdmUoX3JlbmRlclF1ZXVlVGljayk7XG59LFxuICAgIF9yZW1vdmVGcm9tUmVuZGVyUXVldWUgPSBmdW5jdGlvbiBfcmVtb3ZlRnJvbVJlbmRlclF1ZXVlKGZ1bmMpIHtcbiAgdmFyIGkgPSBfcmVuZGVyUXVldWUubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoX3JlbmRlclF1ZXVlW2ldID09PSBmdW5jKSB7XG4gICAgICBfcmVuZGVyUXVldWUuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxuXG4gIGdzYXAudG8oX3JlbmRlclF1ZXVlVGltZW91dCwge1xuICAgIG92ZXJ3cml0ZTogdHJ1ZSxcbiAgICBkZWxheTogMTUsXG4gICAgZHVyYXRpb246IDAsXG4gICAgb25Db21wbGV0ZTogX3JlbmRlclF1ZXVlVGltZW91dCxcbiAgICBkYXRhOiBcIl9kcmFnZ2FibGVcIlxuICB9KTsgLy9yZW1vdmUgdGhlIFwidGlja1wiIGxpc3RlbmVyIG9ubHkgYWZ0ZXIgdGhlIHJlbmRlciBxdWV1ZSBpcyBlbXB0eSBmb3IgMTUgc2Vjb25kcyAodG8gaW1wcm92ZSBwZXJmb3JtYW5jZSkuIEFkZGluZy9yZW1vdmluZyBpdCBjb25zdGFudGx5IGZvciBldmVyeSBjbGljay90b3VjaCB3b3VsZG4ndCBkZWxpdmVyIG9wdGltYWwgc3BlZWQsIGFuZCB3ZSBhbHNvIGRvbid0IHdhbnQgdGhlIHRpY2tlciB0byBrZWVwIGNhbGxpbmcgdGhlIHJlbmRlciBtZXRob2Qgd2hlbiB0aGluZ3MgYXJlIGlkbGUgZm9yIGxvbmcgcGVyaW9kcyBvZiB0aW1lICh3ZSB3YW50IHRvIGltcHJvdmUgYmF0dGVyeSBsaWZlIG9uIG1vYmlsZSBkZXZpY2VzKS5cbn0sXG4gICAgX3NldERlZmF1bHRzID0gZnVuY3Rpb24gX3NldERlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHtcbiAgZm9yICh2YXIgcCBpbiBkZWZhdWx0cykge1xuICAgIGlmICghKHAgaW4gb2JqKSkge1xuICAgICAgb2JqW3BdID0gZGVmYXVsdHNbcF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn0sXG4gICAgX2FkZExpc3RlbmVyID0gZnVuY3Rpb24gX2FkZExpc3RlbmVyKGVsZW1lbnQsIHR5cGUsIGZ1bmMsIGNhcHR1cmUpIHtcbiAgaWYgKGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIHZhciB0b3VjaFR5cGUgPSBfdG91Y2hFdmVudExvb2t1cFt0eXBlXTtcbiAgICBjYXB0dXJlID0gY2FwdHVyZSB8fCAoX3N1cHBvcnRzUGFzc2l2ZSA/IHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSA6IG51bGwpO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0b3VjaFR5cGUgfHwgdHlwZSwgZnVuYywgY2FwdHVyZSk7XG4gICAgdG91Y2hUeXBlICYmIHR5cGUgIT09IHRvdWNoVHlwZSAmJiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZnVuYywgY2FwdHVyZSk7IC8vc29tZSBicm93c2VycyBhY3R1YWxseSBzdXBwb3J0IGJvdGgsIHNvIG11c3Qgd2UuIEJ1dCBwb2ludGVyIGV2ZW50cyBjb3ZlciBhbGwuXG4gIH1cbn0sXG4gICAgX3JlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gX3JlbW92ZUxpc3RlbmVyKGVsZW1lbnQsIHR5cGUsIGZ1bmMpIHtcbiAgaWYgKGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgIHZhciB0b3VjaFR5cGUgPSBfdG91Y2hFdmVudExvb2t1cFt0eXBlXTtcbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodG91Y2hUeXBlIHx8IHR5cGUsIGZ1bmMpO1xuICAgIHRvdWNoVHlwZSAmJiB0eXBlICE9PSB0b3VjaFR5cGUgJiYgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZ1bmMpO1xuICB9XG59LFxuICAgIF9wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uIF9wcmV2ZW50RGVmYXVsdChldmVudCkge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCAmJiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBldmVudC5wcmV2ZW50TWFuaXB1bGF0aW9uICYmIGV2ZW50LnByZXZlbnRNYW5pcHVsYXRpb24oKTsgLy9mb3Igc29tZSBNaWNyb3NvZnQgYnJvd3NlcnNcbn0sXG4gICAgX2hhc1RvdWNoSUQgPSBmdW5jdGlvbiBfaGFzVG91Y2hJRChsaXN0LCBJRCkge1xuICB2YXIgaSA9IGxpc3QubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAobGlzdFtpXS5pZGVudGlmaWVyID09PSBJRCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59LFxuICAgIF9vbk11bHRpVG91Y2hEb2N1bWVudEVuZCA9IGZ1bmN0aW9uIF9vbk11bHRpVG91Y2hEb2N1bWVudEVuZChldmVudCkge1xuICBfaXNNdWx0aVRvdWNoaW5nID0gZXZlbnQudG91Y2hlcyAmJiBfZHJhZ0NvdW50IDwgZXZlbnQudG91Y2hlcy5sZW5ndGg7XG5cbiAgX3JlbW92ZUxpc3RlbmVyKGV2ZW50LnRhcmdldCwgXCJ0b3VjaGVuZFwiLCBfb25NdWx0aVRvdWNoRG9jdW1lbnRFbmQpO1xufSxcbiAgICBfb25NdWx0aVRvdWNoRG9jdW1lbnQgPSBmdW5jdGlvbiBfb25NdWx0aVRvdWNoRG9jdW1lbnQoZXZlbnQpIHtcbiAgX2lzTXVsdGlUb3VjaGluZyA9IGV2ZW50LnRvdWNoZXMgJiYgX2RyYWdDb3VudCA8IGV2ZW50LnRvdWNoZXMubGVuZ3RoO1xuXG4gIF9hZGRMaXN0ZW5lcihldmVudC50YXJnZXQsIFwidG91Y2hlbmRcIiwgX29uTXVsdGlUb3VjaERvY3VtZW50RW5kKTtcbn0sXG4gICAgX2dldERvY1Njcm9sbFRvcCA9IGZ1bmN0aW9uIF9nZXREb2NTY3JvbGxUb3AoZG9jKSB7XG4gIHJldHVybiBfd2luLnBhZ2VZT2Zmc2V0IHx8IGRvYy5zY3JvbGxUb3AgfHwgZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jLmJvZHkuc2Nyb2xsVG9wIHx8IDA7XG59LFxuICAgIF9nZXREb2NTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gX2dldERvY1Njcm9sbExlZnQoZG9jKSB7XG4gIHJldHVybiBfd2luLnBhZ2VYT2Zmc2V0IHx8IGRvYy5zY3JvbGxMZWZ0IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2MuYm9keS5zY3JvbGxMZWZ0IHx8IDA7XG59LFxuICAgIF9hZGRTY3JvbGxMaXN0ZW5lciA9IGZ1bmN0aW9uIF9hZGRTY3JvbGxMaXN0ZW5lcihlLCBjYWxsYmFjaykge1xuICBfYWRkTGlzdGVuZXIoZSwgXCJzY3JvbGxcIiwgY2FsbGJhY2spO1xuXG4gIGlmICghX2lzUm9vdChlLnBhcmVudE5vZGUpKSB7XG4gICAgX2FkZFNjcm9sbExpc3RlbmVyKGUucGFyZW50Tm9kZSwgY2FsbGJhY2spO1xuICB9XG59LFxuICAgIF9yZW1vdmVTY3JvbGxMaXN0ZW5lciA9IGZ1bmN0aW9uIF9yZW1vdmVTY3JvbGxMaXN0ZW5lcihlLCBjYWxsYmFjaykge1xuICBfcmVtb3ZlTGlzdGVuZXIoZSwgXCJzY3JvbGxcIiwgY2FsbGJhY2spO1xuXG4gIGlmICghX2lzUm9vdChlLnBhcmVudE5vZGUpKSB7XG4gICAgX3JlbW92ZVNjcm9sbExpc3RlbmVyKGUucGFyZW50Tm9kZSwgY2FsbGJhY2spO1xuICB9XG59LFxuICAgIF9pc1Jvb3QgPSBmdW5jdGlvbiBfaXNSb290KGUpIHtcbiAgcmV0dXJuICEhKCFlIHx8IGUgPT09IF9kb2NFbGVtZW50IHx8IGUubm9kZVR5cGUgPT09IDkgfHwgZSA9PT0gX2RvYy5ib2R5IHx8IGUgPT09IF93aW4gfHwgIWUubm9kZVR5cGUgfHwgIWUucGFyZW50Tm9kZSk7XG59LFxuICAgIF9nZXRNYXhTY3JvbGwgPSBmdW5jdGlvbiBfZ2V0TWF4U2Nyb2xsKGVsZW1lbnQsIGF4aXMpIHtcbiAgdmFyIGRpbSA9IGF4aXMgPT09IFwieFwiID8gXCJXaWR0aFwiIDogXCJIZWlnaHRcIixcbiAgICAgIHNjcm9sbCA9IFwic2Nyb2xsXCIgKyBkaW0sXG4gICAgICBjbGllbnQgPSBcImNsaWVudFwiICsgZGltO1xuICByZXR1cm4gTWF0aC5tYXgoMCwgX2lzUm9vdChlbGVtZW50KSA/IE1hdGgubWF4KF9kb2NFbGVtZW50W3Njcm9sbF0sIF9ib2R5W3Njcm9sbF0pIC0gKF93aW5bXCJpbm5lclwiICsgZGltXSB8fCBfZG9jRWxlbWVudFtjbGllbnRdIHx8IF9ib2R5W2NsaWVudF0pIDogZWxlbWVudFtzY3JvbGxdIC0gZWxlbWVudFtjbGllbnRdKTtcbn0sXG4gICAgX3JlY29yZE1heFNjcm9sbHMgPSBmdW5jdGlvbiBfcmVjb3JkTWF4U2Nyb2xscyhlLCBza2lwQ3VycmVudCkge1xuICAvL3JlY29yZHMgX2dzTWF4U2Nyb2xsWCBhbmQgX2dzTWF4U2Nyb2xsWSBwcm9wZXJ0aWVzIGZvciB0aGUgZWxlbWVudCBhbmQgYWxsIGFuY2VzdG9ycyB1cCB0aGUgY2hhaW4gc28gdGhhdCB3ZSBjYW4gY2FwIGl0LCBvdGhlcndpc2UgZHJhZ2dpbmcgYmV5b25kIHRoZSBlZGdlcyB3aXRoIGF1dG9TY3JvbGwgb24gY2FuIGVuZGxlc3NseSBzY3JvbGwuXG4gIHZhciB4ID0gX2dldE1heFNjcm9sbChlLCBcInhcIiksXG4gICAgICB5ID0gX2dldE1heFNjcm9sbChlLCBcInlcIik7XG5cbiAgaWYgKF9pc1Jvb3QoZSkpIHtcbiAgICBlID0gX3dpbmRvd1Byb3h5O1xuICB9IGVsc2Uge1xuICAgIF9yZWNvcmRNYXhTY3JvbGxzKGUucGFyZW50Tm9kZSwgc2tpcEN1cnJlbnQpO1xuICB9XG5cbiAgZS5fZ3NNYXhTY3JvbGxYID0geDtcbiAgZS5fZ3NNYXhTY3JvbGxZID0geTtcblxuICBpZiAoIXNraXBDdXJyZW50KSB7XG4gICAgZS5fZ3NTY3JvbGxYID0gZS5zY3JvbGxMZWZ0IHx8IDA7XG4gICAgZS5fZ3NTY3JvbGxZID0gZS5zY3JvbGxUb3AgfHwgMDtcbiAgfVxufSxcbiAgICBfc2V0U3R5bGUgPSBmdW5jdGlvbiBfc2V0U3R5bGUoZWxlbWVudCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHZhciBzdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG5cbiAgaWYgKCFzdHlsZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChfaXNVbmRlZmluZWQoc3R5bGVbcHJvcGVydHldKSkge1xuICAgIHByb3BlcnR5ID0gX2NoZWNrUHJlZml4KHByb3BlcnR5LCBlbGVtZW50KSB8fCBwcm9wZXJ0eTtcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgc3R5bGUucmVtb3ZlUHJvcGVydHkgJiYgc3R5bGUucmVtb3ZlUHJvcGVydHkocHJvcGVydHkucmVwbGFjZSgvKFtBLVpdKS9nLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpKTtcbiAgfSBlbHNlIHtcbiAgICBzdHlsZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgfVxufSxcbiAgICBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGZ1bmN0aW9uIF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIF93aW4uZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCA/IGVsZW1lbnQgOiBlbGVtZW50Lmhvc3QgfHwgKGVsZW1lbnQucGFyZW50Tm9kZSB8fCB7fSkuaG9zdCB8fCBlbGVtZW50KTtcbn0sXG4gICAgLy90aGUgXCJob3N0XCIgc3R1ZmYgaGVscHMgdG8gYWNjb21tb2RhdGUgU2hhZG93RG9tIG9iamVjdHMuXG5fdGVtcFJlY3QgPSB7fSxcbiAgICAvL3JldXNlIHRvIHJlZHVjZSBnYXJiYWdlIGNvbGxlY3Rpb24gdGFza3Ncbl9wYXJzZVJlY3QgPSBmdW5jdGlvbiBfcGFyc2VSZWN0KGUpIHtcbiAgLy9hY2NlcHRzIGEgRE9NIGVsZW1lbnQsIGEgbW91c2UgZXZlbnQsIG9yIGEgcmVjdGFuZ2xlIG9iamVjdCBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZWN0YW5nbGUgd2l0aCBsZWZ0LCByaWdodCwgd2lkdGgsIGhlaWdodCwgdG9wLCBhbmQgYm90dG9tIHByb3BlcnRpZXNcbiAgaWYgKGUgPT09IF93aW4pIHtcbiAgICBfdGVtcFJlY3QubGVmdCA9IF90ZW1wUmVjdC50b3AgPSAwO1xuICAgIF90ZW1wUmVjdC53aWR0aCA9IF90ZW1wUmVjdC5yaWdodCA9IF9kb2NFbGVtZW50LmNsaWVudFdpZHRoIHx8IGUuaW5uZXJXaWR0aCB8fCBfYm9keS5jbGllbnRXaWR0aCB8fCAwO1xuICAgIF90ZW1wUmVjdC5oZWlnaHQgPSBfdGVtcFJlY3QuYm90dG9tID0gKGUuaW5uZXJIZWlnaHQgfHwgMCkgLSAyMCA8IF9kb2NFbGVtZW50LmNsaWVudEhlaWdodCA/IF9kb2NFbGVtZW50LmNsaWVudEhlaWdodCA6IGUuaW5uZXJIZWlnaHQgfHwgX2JvZHkuY2xpZW50SGVpZ2h0IHx8IDA7XG4gICAgcmV0dXJuIF90ZW1wUmVjdDtcbiAgfVxuXG4gIHZhciBkb2MgPSBlLm93bmVyRG9jdW1lbnQgfHwgX2RvYyxcbiAgICAgIHIgPSAhX2lzVW5kZWZpbmVkKGUucGFnZVgpID8ge1xuICAgIGxlZnQ6IGUucGFnZVggLSBfZ2V0RG9jU2Nyb2xsTGVmdChkb2MpLFxuICAgIHRvcDogZS5wYWdlWSAtIF9nZXREb2NTY3JvbGxUb3AoZG9jKSxcbiAgICByaWdodDogZS5wYWdlWCAtIF9nZXREb2NTY3JvbGxMZWZ0KGRvYykgKyAxLFxuICAgIGJvdHRvbTogZS5wYWdlWSAtIF9nZXREb2NTY3JvbGxUb3AoZG9jKSArIDFcbiAgfSA6ICFlLm5vZGVUeXBlICYmICFfaXNVbmRlZmluZWQoZS5sZWZ0KSAmJiAhX2lzVW5kZWZpbmVkKGUudG9wKSA/IGUgOiBfdG9BcnJheShlKVswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICBpZiAoX2lzVW5kZWZpbmVkKHIucmlnaHQpICYmICFfaXNVbmRlZmluZWQoci53aWR0aCkpIHtcbiAgICByLnJpZ2h0ID0gci5sZWZ0ICsgci53aWR0aDtcbiAgICByLmJvdHRvbSA9IHIudG9wICsgci5oZWlnaHQ7XG4gIH0gZWxzZSBpZiAoX2lzVW5kZWZpbmVkKHIud2lkdGgpKSB7XG4gICAgLy9zb21lIGJyb3dzZXJzIGRvbid0IGluY2x1ZGUgd2lkdGggYW5kIGhlaWdodCBwcm9wZXJ0aWVzLiBXZSBjYW4ndCBqdXN0IHNldCB0aGVtIGRpcmVjdGx5IG9uIHIgYmVjYXVzZSBzb21lIGJyb3dzZXJzIHRocm93IGVycm9ycywgc28gY3JlYXRlIGEgbmV3IGdlbmVyaWMgb2JqZWN0LlxuICAgIHIgPSB7XG4gICAgICB3aWR0aDogci5yaWdodCAtIHIubGVmdCxcbiAgICAgIGhlaWdodDogci5ib3R0b20gLSByLnRvcCxcbiAgICAgIHJpZ2h0OiByLnJpZ2h0LFxuICAgICAgbGVmdDogci5sZWZ0LFxuICAgICAgYm90dG9tOiByLmJvdHRvbSxcbiAgICAgIHRvcDogci50b3BcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHI7XG59LFxuICAgIF9kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gX2Rpc3BhdGNoRXZlbnQodGFyZ2V0LCB0eXBlLCBjYWxsYmFja05hbWUpIHtcbiAgdmFyIHZhcnMgPSB0YXJnZXQudmFycyxcbiAgICAgIGNhbGxiYWNrID0gdmFyc1tjYWxsYmFja05hbWVdLFxuICAgICAgbGlzdGVuZXJzID0gdGFyZ2V0Ll9saXN0ZW5lcnNbdHlwZV0sXG4gICAgICByZXN1bHQ7XG5cbiAgaWYgKF9pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgIHJlc3VsdCA9IGNhbGxiYWNrLmFwcGx5KHZhcnMuY2FsbGJhY2tTY29wZSB8fCB0YXJnZXQsIHZhcnNbY2FsbGJhY2tOYW1lICsgXCJQYXJhbXNcIl0gfHwgW3RhcmdldC5wb2ludGVyRXZlbnRdKTtcbiAgfVxuXG4gIGlmIChsaXN0ZW5lcnMgJiYgdGFyZ2V0LmRpc3BhdGNoRXZlbnQodHlwZSkgPT09IGZhbHNlKSB7XG4gICAgcmVzdWx0ID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufSxcbiAgICBfZ2V0Qm91bmRzID0gZnVuY3Rpb24gX2dldEJvdW5kcyh0YXJnZXQsIGNvbnRleHQpIHtcbiAgLy9hY2NlcHRzIGFueSBvZiB0aGUgZm9sbG93aW5nOiBhIERPTSBlbGVtZW50LCBqUXVlcnkgb2JqZWN0LCBzZWxlY3RvciB0ZXh0LCBvciBhbiBvYmplY3QgZGVmaW5pbmcgYm91bmRzIGFzIHt0b3AsIGxlZnQsIHdpZHRoLCBoZWlnaHR9IG9yIHttaW5YLCBtYXhYLCBtaW5ZLCBtYXhZfS4gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBsZWZ0LCB0b3AsIHdpZHRoLCBhbmQgaGVpZ2h0IHByb3BlcnRpZXMuXG4gIHZhciBlID0gX3RvQXJyYXkodGFyZ2V0KVswXSxcbiAgICAgIHRvcCxcbiAgICAgIGxlZnQsXG4gICAgICBvZmZzZXQ7XG5cbiAgaWYgKCFlLm5vZGVUeXBlICYmIGUgIT09IF93aW4pIHtcbiAgICBpZiAoIV9pc1VuZGVmaW5lZCh0YXJnZXQubGVmdCkpIHtcbiAgICAgIG9mZnNldCA9IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfTsgLy9fZ2V0T2Zmc2V0VHJhbnNmb3JtT3JpZ2luKGNvbnRleHQpOyAvL3RoZSBib3VuZHMgc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBvcmlnaW5cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogdGFyZ2V0LmxlZnQgLSBvZmZzZXQueCxcbiAgICAgICAgdG9wOiB0YXJnZXQudG9wIC0gb2Zmc2V0LnksXG4gICAgICAgIHdpZHRoOiB0YXJnZXQud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGFyZ2V0LmhlaWdodFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBsZWZ0ID0gdGFyZ2V0Lm1pbiB8fCB0YXJnZXQubWluWCB8fCB0YXJnZXQubWluUm90YXRpb24gfHwgMDtcbiAgICB0b3AgPSB0YXJnZXQubWluIHx8IHRhcmdldC5taW5ZIHx8IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICB0b3A6IHRvcCxcbiAgICAgIHdpZHRoOiAodGFyZ2V0Lm1heCB8fCB0YXJnZXQubWF4WCB8fCB0YXJnZXQubWF4Um90YXRpb24gfHwgMCkgLSBsZWZ0LFxuICAgICAgaGVpZ2h0OiAodGFyZ2V0Lm1heCB8fCB0YXJnZXQubWF4WSB8fCAwKSAtIHRvcFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gX2dldEVsZW1lbnRCb3VuZHMoZSwgY29udGV4dCk7XG59LFxuICAgIF9wb2ludDEgPSB7fSxcbiAgICAvL3dlIHJldXNlIHRvIG1pbmltaXplIGdhcmJhZ2UgY29sbGVjdGlvbiB0YXNrcy5cbl9nZXRFbGVtZW50Qm91bmRzID0gZnVuY3Rpb24gX2dldEVsZW1lbnRCb3VuZHMoZWxlbWVudCwgY29udGV4dCkge1xuICBjb250ZXh0ID0gX3RvQXJyYXkoY29udGV4dClbMF07XG4gIHZhciBpc1NWRyA9IGVsZW1lbnQuZ2V0QkJveCAmJiBlbGVtZW50Lm93bmVyU1ZHRWxlbWVudCxcbiAgICAgIGRvYyA9IGVsZW1lbnQub3duZXJEb2N1bWVudCB8fCBfZG9jLFxuICAgICAgbGVmdCxcbiAgICAgIHJpZ2h0LFxuICAgICAgdG9wLFxuICAgICAgYm90dG9tLFxuICAgICAgbWF0cml4LFxuICAgICAgcDEsXG4gICAgICBwMixcbiAgICAgIHAzLFxuICAgICAgcDQsXG4gICAgICBiYm94LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBjcyxcbiAgICAgIGNvbnRleHRQYXJlbnQ7XG5cbiAgaWYgKGVsZW1lbnQgPT09IF93aW4pIHtcbiAgICB0b3AgPSBfZ2V0RG9jU2Nyb2xsVG9wKGRvYyk7XG4gICAgbGVmdCA9IF9nZXREb2NTY3JvbGxMZWZ0KGRvYyk7XG4gICAgcmlnaHQgPSBsZWZ0ICsgKGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggfHwgZWxlbWVudC5pbm5lcldpZHRoIHx8IGRvYy5ib2R5LmNsaWVudFdpZHRoIHx8IDApO1xuICAgIGJvdHRvbSA9IHRvcCArICgoZWxlbWVudC5pbm5lckhlaWdodCB8fCAwKSAtIDIwIDwgZG9jLmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgPyBkb2MuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCA6IGVsZW1lbnQuaW5uZXJIZWlnaHQgfHwgZG9jLmJvZHkuY2xpZW50SGVpZ2h0IHx8IDApOyAvL3NvbWUgYnJvd3NlcnMgKGxpa2UgRmlyZWZveCkgaWdub3JlIGFic29sdXRlbHkgcG9zaXRpb25lZCBlbGVtZW50cywgYW5kIGNvbGxhcHNlIHRoZSBoZWlnaHQgb2YgdGhlIGRvY3VtZW50RWxlbWVudCwgc28gaXQgY291bGQgYmUgOHB4LCBmb3IgZXhhbXBsZSwgaWYgeW91IGhhdmUganVzdCBhbiBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQgZGl2LiBJbiB0aGF0IGNhc2UsIHdlIHVzZSB0aGUgaW5uZXJIZWlnaHQgdG8gcmVzb2x2ZSB0aGlzLlxuICB9IGVsc2UgaWYgKGNvbnRleHQgPT09IF93aW4gfHwgX2lzVW5kZWZpbmVkKGNvbnRleHQpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH0gZWxzZSB7XG4gICAgbGVmdCA9IHRvcCA9IDA7XG5cbiAgICBpZiAoaXNTVkcpIHtcbiAgICAgIGJib3ggPSBlbGVtZW50LmdldEJCb3goKTtcbiAgICAgIHdpZHRoID0gYmJveC53aWR0aDtcbiAgICAgIGhlaWdodCA9IGJib3guaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZWxlbWVudC52aWV3Qm94ICYmIChiYm94ID0gZWxlbWVudC52aWV3Qm94LmJhc2VWYWwpKSB7XG4gICAgICAgIGxlZnQgPSBiYm94LnggfHwgMDtcbiAgICAgICAgdG9wID0gYmJveC55IHx8IDA7XG4gICAgICAgIHdpZHRoID0gYmJveC53aWR0aDtcbiAgICAgICAgaGVpZ2h0ID0gYmJveC5oZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghd2lkdGgpIHtcbiAgICAgICAgY3MgPSBfZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgICAgICAgYmJveCA9IGNzLmJveFNpemluZyA9PT0gXCJib3JkZXItYm94XCI7XG4gICAgICAgIHdpZHRoID0gKHBhcnNlRmxvYXQoY3Mud2lkdGgpIHx8IGVsZW1lbnQuY2xpZW50V2lkdGggfHwgMCkgKyAoYmJveCA/IDAgOiBwYXJzZUZsb2F0KGNzLmJvcmRlckxlZnRXaWR0aCkgKyBwYXJzZUZsb2F0KGNzLmJvcmRlclJpZ2h0V2lkdGgpKTtcbiAgICAgICAgaGVpZ2h0ID0gKHBhcnNlRmxvYXQoY3MuaGVpZ2h0KSB8fCBlbGVtZW50LmNsaWVudEhlaWdodCB8fCAwKSArIChiYm94ID8gMCA6IHBhcnNlRmxvYXQoY3MuYm9yZGVyVG9wV2lkdGgpICsgcGFyc2VGbG9hdChjcy5ib3JkZXJCb3R0b21XaWR0aCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJpZ2h0ID0gd2lkdGg7XG4gICAgYm90dG9tID0gaGVpZ2h0O1xuICB9XG5cbiAgaWYgKGVsZW1lbnQgPT09IGNvbnRleHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogbGVmdCxcbiAgICAgIHRvcDogdG9wLFxuICAgICAgd2lkdGg6IHJpZ2h0IC0gbGVmdCxcbiAgICAgIGhlaWdodDogYm90dG9tIC0gdG9wXG4gICAgfTtcbiAgfVxuXG4gIG1hdHJpeCA9IGdldEdsb2JhbE1hdHJpeChjb250ZXh0LCB0cnVlKS5tdWx0aXBseShnZXRHbG9iYWxNYXRyaXgoZWxlbWVudCkpO1xuICBwMSA9IG1hdHJpeC5hcHBseSh7XG4gICAgeDogbGVmdCxcbiAgICB5OiB0b3BcbiAgfSk7XG4gIHAyID0gbWF0cml4LmFwcGx5KHtcbiAgICB4OiByaWdodCxcbiAgICB5OiB0b3BcbiAgfSk7XG4gIHAzID0gbWF0cml4LmFwcGx5KHtcbiAgICB4OiByaWdodCxcbiAgICB5OiBib3R0b21cbiAgfSk7XG4gIHA0ID0gbWF0cml4LmFwcGx5KHtcbiAgICB4OiBsZWZ0LFxuICAgIHk6IGJvdHRvbVxuICB9KTtcbiAgbGVmdCA9IE1hdGgubWluKHAxLngsIHAyLngsIHAzLngsIHA0LngpO1xuICB0b3AgPSBNYXRoLm1pbihwMS55LCBwMi55LCBwMy55LCBwNC55KTtcbiAgY29udGV4dFBhcmVudCA9IGNvbnRleHQucGFyZW50Tm9kZSB8fCB7fTtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBsZWZ0ICsgKGNvbnRleHRQYXJlbnQuc2Nyb2xsTGVmdCB8fCAwKSxcbiAgICB0b3A6IHRvcCArIChjb250ZXh0UGFyZW50LnNjcm9sbFRvcCB8fCAwKSxcbiAgICB3aWR0aDogTWF0aC5tYXgocDEueCwgcDIueCwgcDMueCwgcDQueCkgLSBsZWZ0LFxuICAgIGhlaWdodDogTWF0aC5tYXgocDEueSwgcDIueSwgcDMueSwgcDQueSkgLSB0b3BcbiAgfTtcbn0sXG4gICAgX3BhcnNlSW5lcnRpYSA9IGZ1bmN0aW9uIF9wYXJzZUluZXJ0aWEoZHJhZ2dhYmxlLCBzbmFwLCBtYXgsIG1pbiwgZmFjdG9yLCBmb3JjZVplcm9WZWxvY2l0eSkge1xuICB2YXIgdmFycyA9IHt9LFxuICAgICAgYSxcbiAgICAgIGksXG4gICAgICBsO1xuXG4gIGlmIChzbmFwKSB7XG4gICAgaWYgKGZhY3RvciAhPT0gMSAmJiBzbmFwIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIC8vc29tZSBkYXRhIG11c3QgYmUgYWx0ZXJlZCB0byBtYWtlIHNlbnNlLCBsaWtlIGlmIHRoZSB1c2VyIHBhc3NlcyBpbiBhbiBhcnJheSBvZiByb3RhdGlvbmFsIHZhbHVlcyBpbiBkZWdyZWVzLCB3ZSBtdXN0IGNvbnZlcnQgaXQgdG8gcmFkaWFucy4gT3IgZm9yIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCwgd2UgaW52ZXJ0IHRoZSB2YWx1ZXMuXG4gICAgICB2YXJzLmVuZCA9IGEgPSBbXTtcbiAgICAgIGwgPSBzbmFwLmxlbmd0aDtcblxuICAgICAgaWYgKF9pc09iamVjdChzbmFwWzBdKSkge1xuICAgICAgICAvL2lmIHRoZSBhcnJheSBpcyBwb3B1bGF0ZWQgd2l0aCBvYmplY3RzLCBsaWtlIHBvaW50cyAoe3g6MTAwLCB5OjIwMH0pLCBtYWtlIGNvcGllcyBiZWZvcmUgbXVsdGlwbHlpbmcgYnkgdGhlIGZhY3Rvciwgb3RoZXJ3aXNlIHdlJ2xsIG1lc3MgdXAgdGhlIG9yaWdpbmFscyBhbmQgdGhlIHVzZXIgbWF5IHJldXNlIGl0IGVsc2V3aGVyZS5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGFbaV0gPSBfY29weShzbmFwW2ldLCBmYWN0b3IpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgYVtpXSA9IHNuYXBbaV0gKiBmYWN0b3I7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWF4ICs9IDEuMTsgLy9hbGxvdyAxLjEgcGl4ZWxzIG9mIHdpZ2dsZSByb29tIHdoZW4gc25hcHBpbmcgaW4gb3JkZXIgdG8gd29yayBhcm91bmQgc29tZSBicm93c2VyIGluY29uc2lzdGVuY2llcyBpbiB0aGUgd2F5IGJvdW5kcyBhcmUgcmVwb3J0ZWQgd2hpY2ggY2FuIG1ha2UgdGhlbSByb3VnaGx5IGEgcGl4ZWwgb2ZmLiBGb3IgZXhhbXBsZSwgaWYgXCJzbmFwOlstJCgnI21lbnUnKS53aWR0aCgpLCAwXVwiIHdhcyBkZWZpbmVkIGFuZCAjbWVudSBoYWQgYSB3cmFwcGVyIHRoYXQgd2FzIHVzZWQgYXMgdGhlIGJvdW5kcywgc29tZSBicm93c2VycyB3b3VsZCBiZSBvbmUgcGl4ZWwgb2ZmLCBtYWtpbmcgdGhlIG1pbmltdW0gLTc1MiBmb3IgZXhhbXBsZSB3aGVuIHNuYXAgd2FzIFstNzUzLDBdLCB0aHVzIGluc3RlYWQgb2Ygc25hcHBpbmcgdG8gLTc1MywgaXQgd291bGQgc25hcCB0byAwIHNpbmNlIC03NTMgd2FzIGJlbG93IHRoZSBtaW5pbXVtLlxuXG4gICAgICBtaW4gLT0gMS4xO1xuICAgIH0gZWxzZSBpZiAoX2lzRnVuY3Rpb24oc25hcCkpIHtcbiAgICAgIHZhcnMuZW5kID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBzbmFwLmNhbGwoZHJhZ2dhYmxlLCB2YWx1ZSksXG4gICAgICAgICAgICBjb3B5LFxuICAgICAgICAgICAgcDtcblxuICAgICAgICBpZiAoZmFjdG9yICE9PSAxKSB7XG4gICAgICAgICAgaWYgKF9pc09iamVjdChyZXN1bHQpKSB7XG4gICAgICAgICAgICBjb3B5ID0ge307XG5cbiAgICAgICAgICAgIGZvciAocCBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgICAgY29weVtwXSA9IHJlc3VsdFtwXSAqIGZhY3RvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0ID0gY29weTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ICo9IGZhY3RvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0OyAvL3dlIG5lZWQgdG8gZW5zdXJlIHRoYXQgd2UgY2FuIHNjb3BlIHRoZSBmdW5jdGlvbiBjYWxsIHRvIHRoZSBEcmFnZ2FibGUgaW5zdGFuY2UgaXRzZWxmIHNvIHRoYXQgdXNlcnMgY2FuIGFjY2VzcyBpbXBvcnRhbnQgdmFsdWVzIGxpa2UgbWF4WCwgbWluWCwgbWF4WSwgbWluWSwgeCwgYW5kIHkgZnJvbSB3aXRoaW4gdGhhdCBmdW5jdGlvbi5cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhcnMuZW5kID0gc25hcDtcbiAgICB9XG4gIH1cblxuICBpZiAobWF4IHx8IG1heCA9PT0gMCkge1xuICAgIHZhcnMubWF4ID0gbWF4O1xuICB9XG5cbiAgaWYgKG1pbiB8fCBtaW4gPT09IDApIHtcbiAgICB2YXJzLm1pbiA9IG1pbjtcbiAgfVxuXG4gIGlmIChmb3JjZVplcm9WZWxvY2l0eSkge1xuICAgIHZhcnMudmVsb2NpdHkgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHZhcnM7XG59LFxuICAgIF9pc0NsaWNrYWJsZSA9IGZ1bmN0aW9uIF9pc0NsaWNrYWJsZShlbGVtZW50KSB7XG4gIC8vc29tZXRpbWVzIGl0J3MgY29udmVuaWVudCB0byBtYXJrIGFuIGVsZW1lbnQgYXMgY2xpY2thYmxlIGJ5IGFkZGluZyBhIGRhdGEtY2xpY2thYmxlPVwidHJ1ZVwiIGF0dHJpYnV0ZSAoaW4gd2hpY2ggY2FzZSB3ZSB3b24ndCBwcmV2ZW50RGVmYXVsdCgpIHRoZSBtb3VzZS90b3VjaCBldmVudCkuIFRoaXMgbWV0aG9kIGNoZWNrcyBpZiB0aGUgZWxlbWVudCBpcyBhbiA8YT4sIDxpbnB1dD4sIG9yIDxidXR0b24+IG9yIGhhcyBhbiBvbmNsaWNrIG9yIGhhcyB0aGUgZGF0YS1jbGlja2FibGUgb3IgY29udGVudEVkaXRhYmxlIGF0dHJpYnV0ZSBzZXQgdG8gdHJ1ZSAob3IgYW55IG9mIGl0cyBwYXJlbnQgZWxlbWVudHMpLlxuICB2YXIgZGF0YTtcbiAgcmV0dXJuICFlbGVtZW50IHx8ICFlbGVtZW50LmdldEF0dHJpYnV0ZSB8fCBlbGVtZW50ID09PSBfYm9keSA/IGZhbHNlIDogKGRhdGEgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtY2xpY2thYmxlXCIpKSA9PT0gXCJ0cnVlXCIgfHwgZGF0YSAhPT0gXCJmYWxzZVwiICYmIChlbGVtZW50Lm9uY2xpY2sgfHwgX2NsaWNrYWJsZVRhZ0V4cC50ZXN0KGVsZW1lbnQubm9kZU5hbWUgKyBcIlwiKSB8fCBlbGVtZW50LmdldEF0dHJpYnV0ZShcImNvbnRlbnRFZGl0YWJsZVwiKSA9PT0gXCJ0cnVlXCIpID8gdHJ1ZSA6IF9pc0NsaWNrYWJsZShlbGVtZW50LnBhcmVudE5vZGUpO1xufSxcbiAgICBfc2V0U2VsZWN0YWJsZSA9IGZ1bmN0aW9uIF9zZXRTZWxlY3RhYmxlKGVsZW1lbnRzLCBzZWxlY3RhYmxlKSB7XG4gIHZhciBpID0gZWxlbWVudHMubGVuZ3RoLFxuICAgICAgZTtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgZSA9IGVsZW1lbnRzW2ldO1xuICAgIGUub25kcmFnc3RhcnQgPSBlLm9uc2VsZWN0c3RhcnQgPSBzZWxlY3RhYmxlID8gbnVsbCA6IF9lbXB0eUZ1bmM7XG4gICAgZ3NhcC5zZXQoZSwge1xuICAgICAgbGF6eTogdHJ1ZSxcbiAgICAgIHVzZXJTZWxlY3Q6IHNlbGVjdGFibGUgPyBcInRleHRcIiA6IFwibm9uZVwiXG4gICAgfSk7XG4gIH1cbn0sXG4gICAgX2lzRml4ZWQgPSBmdW5jdGlvbiBfaXNGaXhlZChlbGVtZW50KSB7XG4gIGlmIChfZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBlbGVtZW50ID0gZWxlbWVudC5wYXJlbnROb2RlO1xuXG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAvLyBhdm9pZCBkb2N1bWVudCBmcmFnbWVudHMgd2hpY2ggd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICByZXR1cm4gX2lzRml4ZWQoZWxlbWVudCk7XG4gIH1cbn0sXG4gICAgX3N1cHBvcnRzM0QsXG4gICAgX2FkZFBhZGRpbmdCUixcbiAgICAvL1RoZSBTY3JvbGxQcm94eSBjbGFzcyB3cmFwcyBhbiBlbGVtZW50J3MgY29udGVudHMgaW50byBhbm90aGVyIGRpdiAod2UgY2FsbCBpdCBcImNvbnRlbnRcIikgdGhhdCB3ZSBlaXRoZXIgYWRkIHBhZGRpbmcgd2hlbiBuZWNlc3Nhcnkgb3IgYXBwbHkgYSB0cmFuc2xhdGUzZCgpIHRyYW5zZm9ybSBpbiBvcmRlciB0byBvdmVyc2Nyb2xsIChzY3JvbGwgcGFzdCB0aGUgYm91bmRhcmllcykuIFRoaXMgYWxsb3dzIHVzIHRvIHNpbXBseSBzZXQgdGhlIHNjcm9sbFRvcC9zY3JvbGxMZWZ0IChvciB0b3AvbGVmdCBmb3IgZWFzaWVyIHJldmVyc2UtYXhpcyBvcmllbnRhdGlvbiwgd2hpY2ggaXMgd2hhdCB3ZSBkbyBpbiBEcmFnZ2FibGUpIGFuZCBpdCdsbCBkbyBhbGwgdGhlIHdvcmsgZm9yIHVzLiBGb3IgZXhhbXBsZSwgaWYgd2UgdHJpZWQgc2V0dGluZyBzY3JvbGxUb3AgdG8gLTEwMCBvbiBhIG5vcm1hbCBET00gZWxlbWVudCwgaXQgd291bGRuJ3Qgd29yayAtIGl0J2QgbG9vayB0aGUgc2FtZSBhcyBzZXR0aW5nIGl0IHRvIDAsIGJ1dCBpZiB3ZSBzZXQgc2Nyb2xsVG9wIG9mIGEgU2Nyb2xsUHJveHkgdG8gLTEwMCwgaXQnbGwgZ2l2ZSB0aGUgY29ycmVjdCBhcHBlYXJhbmNlIGJ5IGVpdGhlciBzZXR0aW5nIHBhZGRpbmdUb3Agb2YgdGhlIHdyYXBwZXIgdG8gMTAwIG9yIGFwcGx5aW5nIGEgMTAwLXBpeGVsIHRyYW5zbGF0ZVkuXG5TY3JvbGxQcm94eSA9IGZ1bmN0aW9uIFNjcm9sbFByb3h5KGVsZW1lbnQsIHZhcnMpIHtcbiAgZWxlbWVudCA9IGdzYXAudXRpbHMudG9BcnJheShlbGVtZW50KVswXTtcbiAgdmFycyA9IHZhcnMgfHwge307XG4gIHZhciBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgIHN0eWxlID0gY29udGVudC5zdHlsZSxcbiAgICAgIG5vZGUgPSBlbGVtZW50LmZpcnN0Q2hpbGQsXG4gICAgICBvZmZzZXRUb3AgPSAwLFxuICAgICAgb2Zmc2V0TGVmdCA9IDAsXG4gICAgICBwcmV2VG9wID0gZWxlbWVudC5zY3JvbGxUb3AsXG4gICAgICBwcmV2TGVmdCA9IGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgIHNjcm9sbFdpZHRoID0gZWxlbWVudC5zY3JvbGxXaWR0aCxcbiAgICAgIHNjcm9sbEhlaWdodCA9IGVsZW1lbnQuc2Nyb2xsSGVpZ2h0LFxuICAgICAgZXh0cmFQYWRSaWdodCA9IDAsXG4gICAgICBtYXhMZWZ0ID0gMCxcbiAgICAgIG1heFRvcCA9IDAsXG4gICAgICBlbGVtZW50V2lkdGgsXG4gICAgICBlbGVtZW50SGVpZ2h0LFxuICAgICAgY29udGVudEhlaWdodCxcbiAgICAgIG5leHROb2RlLFxuICAgICAgdHJhbnNmb3JtU3RhcnQsXG4gICAgICB0cmFuc2Zvcm1FbmQ7XG5cbiAgaWYgKF9zdXBwb3J0czNEICYmIHZhcnMuZm9yY2UzRCAhPT0gZmFsc2UpIHtcbiAgICB0cmFuc2Zvcm1TdGFydCA9IFwidHJhbnNsYXRlM2QoXCI7XG4gICAgdHJhbnNmb3JtRW5kID0gXCJweCwwcHgpXCI7XG4gIH0gZWxzZSBpZiAoX3RyYW5zZm9ybVByb3ApIHtcbiAgICB0cmFuc2Zvcm1TdGFydCA9IFwidHJhbnNsYXRlKFwiO1xuICAgIHRyYW5zZm9ybUVuZCA9IFwicHgpXCI7XG4gIH1cblxuICB0aGlzLnNjcm9sbFRvcCA9IGZ1bmN0aW9uICh2YWx1ZSwgZm9yY2UpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiAtdGhpcy50b3AoKTtcbiAgICB9XG5cbiAgICB0aGlzLnRvcCgtdmFsdWUsIGZvcmNlKTtcbiAgfTtcblxuICB0aGlzLnNjcm9sbExlZnQgPSBmdW5jdGlvbiAodmFsdWUsIGZvcmNlKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gLXRoaXMubGVmdCgpO1xuICAgIH1cblxuICAgIHRoaXMubGVmdCgtdmFsdWUsIGZvcmNlKTtcbiAgfTtcblxuICB0aGlzLmxlZnQgPSBmdW5jdGlvbiAodmFsdWUsIGZvcmNlKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gLShlbGVtZW50LnNjcm9sbExlZnQgKyBvZmZzZXRMZWZ0KTtcbiAgICB9XG5cbiAgICB2YXIgZGlmID0gZWxlbWVudC5zY3JvbGxMZWZ0IC0gcHJldkxlZnQsXG4gICAgICAgIG9sZE9mZnNldCA9IG9mZnNldExlZnQ7XG5cbiAgICBpZiAoKGRpZiA+IDIgfHwgZGlmIDwgLTIpICYmICFmb3JjZSkge1xuICAgICAgLy9pZiB0aGUgdXNlciBpbnRlcmFjdHMgd2l0aCB0aGUgc2Nyb2xsYmFyIChvciBzb21ldGhpbmcgZWxzZSBzY3JvbGxzIGl0LCBsaWtlIHRoZSBtb3VzZSB3aGVlbCksIHdlIHNob3VsZCBraWxsIGFueSB0d2VlbnMgb2YgdGhlIFNjcm9sbFByb3h5LlxuICAgICAgcHJldkxlZnQgPSBlbGVtZW50LnNjcm9sbExlZnQ7XG4gICAgICBnc2FwLmtpbGxUd2VlbnNPZih0aGlzLCB7XG4gICAgICAgIGxlZnQ6IDEsXG4gICAgICAgIHNjcm9sbExlZnQ6IDFcbiAgICAgIH0pO1xuICAgICAgdGhpcy5sZWZ0KC1wcmV2TGVmdCk7XG5cbiAgICAgIGlmICh2YXJzLm9uS2lsbCkge1xuICAgICAgICB2YXJzLm9uS2lsbCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFsdWUgPSAtdmFsdWU7IC8vaW52ZXJ0IGJlY2F1c2Ugc2Nyb2xsaW5nIHdvcmtzIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb25cblxuICAgIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgIG9mZnNldExlZnQgPSB2YWx1ZSAtIDAuNSB8IDA7XG4gICAgICB2YWx1ZSA9IDA7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA+IG1heExlZnQpIHtcbiAgICAgIG9mZnNldExlZnQgPSB2YWx1ZSAtIG1heExlZnQgfCAwO1xuICAgICAgdmFsdWUgPSBtYXhMZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXRMZWZ0ID0gMDtcbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0TGVmdCB8fCBvbGRPZmZzZXQpIHtcbiAgICAgIGlmICghdGhpcy5fc2tpcCkge1xuICAgICAgICBzdHlsZVtfdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm1TdGFydCArIC1vZmZzZXRMZWZ0ICsgXCJweCxcIiArIC1vZmZzZXRUb3AgKyB0cmFuc2Zvcm1FbmQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChvZmZzZXRMZWZ0ICsgZXh0cmFQYWRSaWdodCA+PSAwKSB7XG4gICAgICAgIHN0eWxlLnBhZGRpbmdSaWdodCA9IG9mZnNldExlZnQgKyBleHRyYVBhZFJpZ2h0ICsgXCJweFwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIGVsZW1lbnQuc2Nyb2xsTGVmdCA9IHZhbHVlIHwgMDtcbiAgICBwcmV2TGVmdCA9IGVsZW1lbnQuc2Nyb2xsTGVmdDsgLy9kb24ndCBtZXJnZSB0aGlzIHdpdGggdGhlIGxpbmUgYWJvdmUgYmVjYXVzZSBzb21lIGJyb3dzZXJzIGFkanVzdCB0aGUgc2Nyb2xsTGVmdCBhZnRlciBpdCdzIHNldCwgc28gaW4gb3JkZXIgdG8gYmUgMTAwJSBhY2N1cmF0ZSBpbiB0cmFja2luZyBpdCwgd2UgbmVlZCB0byBhc2sgdGhlIGJyb3dzZXIgdG8gcmVwb3J0IGl0LlxuICB9O1xuXG4gIHRoaXMudG9wID0gZnVuY3Rpb24gKHZhbHVlLCBmb3JjZSkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIC0oZWxlbWVudC5zY3JvbGxUb3AgKyBvZmZzZXRUb3ApO1xuICAgIH1cblxuICAgIHZhciBkaWYgPSBlbGVtZW50LnNjcm9sbFRvcCAtIHByZXZUb3AsXG4gICAgICAgIG9sZE9mZnNldCA9IG9mZnNldFRvcDtcblxuICAgIGlmICgoZGlmID4gMiB8fCBkaWYgPCAtMikgJiYgIWZvcmNlKSB7XG4gICAgICAvL2lmIHRoZSB1c2VyIGludGVyYWN0cyB3aXRoIHRoZSBzY3JvbGxiYXIgKG9yIHNvbWV0aGluZyBlbHNlIHNjcm9sbHMgaXQsIGxpa2UgdGhlIG1vdXNlIHdoZWVsKSwgd2Ugc2hvdWxkIGtpbGwgYW55IHR3ZWVucyBvZiB0aGUgU2Nyb2xsUHJveHkuXG4gICAgICBwcmV2VG9wID0gZWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICBnc2FwLmtpbGxUd2VlbnNPZih0aGlzLCB7XG4gICAgICAgIHRvcDogMSxcbiAgICAgICAgc2Nyb2xsVG9wOiAxXG4gICAgICB9KTtcbiAgICAgIHRoaXMudG9wKC1wcmV2VG9wKTtcblxuICAgICAgaWYgKHZhcnMub25LaWxsKSB7XG4gICAgICAgIHZhcnMub25LaWxsKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YWx1ZSA9IC12YWx1ZTsgLy9pbnZlcnQgYmVjYXVzZSBzY3JvbGxpbmcgd29ya3MgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxuXG4gICAgaWYgKHZhbHVlIDwgMCkge1xuICAgICAgb2Zmc2V0VG9wID0gdmFsdWUgLSAwLjUgfCAwO1xuICAgICAgdmFsdWUgPSAwO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPiBtYXhUb3ApIHtcbiAgICAgIG9mZnNldFRvcCA9IHZhbHVlIC0gbWF4VG9wIHwgMDtcbiAgICAgIHZhbHVlID0gbWF4VG9wO1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXRUb3AgPSAwO1xuICAgIH1cblxuICAgIGlmIChvZmZzZXRUb3AgfHwgb2xkT2Zmc2V0KSB7XG4gICAgICBpZiAoIXRoaXMuX3NraXApIHtcbiAgICAgICAgc3R5bGVbX3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtU3RhcnQgKyAtb2Zmc2V0TGVmdCArIFwicHgsXCIgKyAtb2Zmc2V0VG9wICsgdHJhbnNmb3JtRW5kO1xuICAgICAgfVxuICAgIH1cblxuICAgIGVsZW1lbnQuc2Nyb2xsVG9wID0gdmFsdWUgfCAwO1xuICAgIHByZXZUb3AgPSBlbGVtZW50LnNjcm9sbFRvcDtcbiAgfTtcblxuICB0aGlzLm1heFNjcm9sbFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbWF4VG9wO1xuICB9O1xuXG4gIHRoaXMubWF4U2Nyb2xsTGVmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbWF4TGVmdDtcbiAgfTtcblxuICB0aGlzLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgbm9kZSA9IGNvbnRlbnQuZmlyc3RDaGlsZDtcblxuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICBuZXh0Tm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICBlbGVtZW50LmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgbm9kZSA9IG5leHROb2RlO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50ID09PSBjb250ZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIC8vaW4gY2FzZSBkaXNhYmxlKCkgaXMgY2FsbGVkIHdoZW4gaXQncyBhbHJlYWR5IGRpc2FibGVkLlxuICAgICAgZWxlbWVudC5yZW1vdmVDaGlsZChjb250ZW50KTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgbm9kZSA9IGVsZW1lbnQuZmlyc3RDaGlsZDtcblxuICAgIGlmIChub2RlID09PSBjb250ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgIG5leHROb2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICBub2RlID0gbmV4dE5vZGU7XG4gICAgfVxuXG4gICAgZWxlbWVudC5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICB0aGlzLmNhbGlicmF0ZSgpO1xuICB9O1xuXG4gIHRoaXMuY2FsaWJyYXRlID0gZnVuY3Rpb24gKGZvcmNlKSB7XG4gICAgdmFyIHdpZHRoTWF0Y2hlcyA9IGVsZW1lbnQuY2xpZW50V2lkdGggPT09IGVsZW1lbnRXaWR0aCxcbiAgICAgICAgY3MsXG4gICAgICAgIHgsXG4gICAgICAgIHk7XG4gICAgcHJldlRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgIHByZXZMZWZ0ID0gZWxlbWVudC5zY3JvbGxMZWZ0O1xuXG4gICAgaWYgKHdpZHRoTWF0Y2hlcyAmJiBlbGVtZW50LmNsaWVudEhlaWdodCA9PT0gZWxlbWVudEhlaWdodCAmJiBjb250ZW50Lm9mZnNldEhlaWdodCA9PT0gY29udGVudEhlaWdodCAmJiBzY3JvbGxXaWR0aCA9PT0gZWxlbWVudC5zY3JvbGxXaWR0aCAmJiBzY3JvbGxIZWlnaHQgPT09IGVsZW1lbnQuc2Nyb2xsSGVpZ2h0ICYmICFmb3JjZSkge1xuICAgICAgcmV0dXJuOyAvL25vIG5lZWQgdG8gcmVjYWxjdWxhdGUgdGhpbmdzIGlmIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IGhhdmVuJ3QgY2hhbmdlZC5cbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0VG9wIHx8IG9mZnNldExlZnQpIHtcbiAgICAgIHggPSB0aGlzLmxlZnQoKTtcbiAgICAgIHkgPSB0aGlzLnRvcCgpO1xuICAgICAgdGhpcy5sZWZ0KC1lbGVtZW50LnNjcm9sbExlZnQpO1xuICAgICAgdGhpcy50b3AoLWVsZW1lbnQuc2Nyb2xsVG9wKTtcbiAgICB9XG5cbiAgICBjcyA9IF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpOyAvL2ZpcnN0LCB3ZSBuZWVkIHRvIHJlbW92ZSBhbnkgd2lkdGggY29uc3RyYWludHMgdG8gc2VlIGhvdyB0aGUgY29udGVudCBuYXR1cmFsbHkgZmxvd3Mgc28gdGhhdCB3ZSBjYW4gc2VlIGlmIGl0J3Mgd2lkZXIgdGhhbiB0aGUgY29udGFpbmluZyBlbGVtZW50LiBJZiBzbywgd2UndmUgZ290IHRvIHJlY29yZCB0aGUgYW1vdW50IG9mIG92ZXJhZ2Ugc28gdGhhdCB3ZSBjYW4gYXBwbHkgdGhhdCBhcyBwYWRkaW5nIGluIG9yZGVyIGZvciBicm93c2VycyB0byBjb3JyZWN0bHkgaGFuZGxlIHRoaW5ncy4gVGhlbiB3ZSBzd2l0Y2ggYmFjayB0byBhIHdpZHRoIG9mIDEwMCUgKHdpdGhvdXQgdGhhdCwgc29tZSBicm93c2VycyBkb24ndCBmbG93IHRoZSBjb250ZW50IGNvcnJlY3RseSlcblxuICAgIGlmICghd2lkdGhNYXRjaGVzIHx8IGZvcmNlKSB7XG4gICAgICBzdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgc3R5bGUud2lkdGggPSBcImF1dG9cIjtcbiAgICAgIHN0eWxlLnBhZGRpbmdSaWdodCA9IFwiMHB4XCI7XG4gICAgICBleHRyYVBhZFJpZ2h0ID0gTWF0aC5tYXgoMCwgZWxlbWVudC5zY3JvbGxXaWR0aCAtIGVsZW1lbnQuY2xpZW50V2lkdGgpOyAvL2lmIHRoZSBjb250ZW50IGlzIHdpZGVyIHRoYW4gdGhlIGNvbnRhaW5lciwgd2UgbmVlZCB0byBhZGQgdGhlIHBhZGRpbmdMZWZ0IGFuZCBwYWRkaW5nUmlnaHQgaW4gb3JkZXIgZm9yIHRoaW5ncyB0byBiZWhhdmUgY29ycmVjdGx5LlxuXG4gICAgICBpZiAoZXh0cmFQYWRSaWdodCkge1xuICAgICAgICBleHRyYVBhZFJpZ2h0ICs9IHBhcnNlRmxvYXQoY3MucGFkZGluZ0xlZnQpICsgKF9hZGRQYWRkaW5nQlIgPyBwYXJzZUZsb2F0KGNzLnBhZGRpbmdSaWdodCkgOiAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcbiAgICBzdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcbiAgICBzdHlsZS5vdmVyZmxvdyA9IFwidmlzaWJsZVwiO1xuICAgIHN0eWxlLnZlcnRpY2FsQWxpZ24gPSBcInRvcFwiO1xuICAgIHN0eWxlLmJveFNpemluZyA9IFwiY29udGVudC1ib3hcIjtcbiAgICBzdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgIHN0eWxlLnBhZGRpbmdSaWdodCA9IGV4dHJhUGFkUmlnaHQgKyBcInB4XCI7IC8vc29tZSBicm93c2VycyBuZWdsZWN0IHRvIGZhY3RvciBpbiB0aGUgYm90dG9tIHBhZGRpbmcgd2hlbiBjYWxjdWxhdGluZyB0aGUgc2Nyb2xsSGVpZ2h0LCBzbyB3ZSBuZWVkIHRvIGFkZCB0aGF0IHBhZGRpbmcgdG8gdGhlIGNvbnRlbnQgd2hlbiB0aGF0IGhhcHBlbnMuIEFsbG93IGEgMnB4IG1hcmdpbiBmb3IgZXJyb3JcblxuICAgIGlmIChfYWRkUGFkZGluZ0JSKSB7XG4gICAgICBzdHlsZS5wYWRkaW5nQm90dG9tID0gY3MucGFkZGluZ0JvdHRvbTtcbiAgICB9XG5cbiAgICBlbGVtZW50V2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoO1xuICAgIGVsZW1lbnRIZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICBzY3JvbGxXaWR0aCA9IGVsZW1lbnQuc2Nyb2xsV2lkdGg7XG4gICAgc2Nyb2xsSGVpZ2h0ID0gZWxlbWVudC5zY3JvbGxIZWlnaHQ7XG4gICAgbWF4TGVmdCA9IGVsZW1lbnQuc2Nyb2xsV2lkdGggLSBlbGVtZW50V2lkdGg7XG4gICAgbWF4VG9wID0gZWxlbWVudC5zY3JvbGxIZWlnaHQgLSBlbGVtZW50SGVpZ2h0O1xuICAgIGNvbnRlbnRIZWlnaHQgPSBjb250ZW50Lm9mZnNldEhlaWdodDtcbiAgICBzdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXG4gICAgaWYgKHggfHwgeSkge1xuICAgICAgdGhpcy5sZWZ0KHgpO1xuICAgICAgdGhpcy50b3AoeSk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gIHRoaXMuX3NraXAgPSBmYWxzZTtcbiAgdGhpcy5lbmFibGUoKTtcbn0sXG4gICAgX2luaXRDb3JlID0gZnVuY3Rpb24gX2luaXRDb3JlKHJlcXVpcmVkKSB7XG4gIGlmIChfd2luZG93RXhpc3RzKCkgJiYgZG9jdW1lbnQuYm9keSkge1xuICAgIHZhciBuYXYgPSB3aW5kb3cgJiYgd2luZG93Lm5hdmlnYXRvcjtcbiAgICBfd2luID0gd2luZG93O1xuICAgIF9kb2MgPSBkb2N1bWVudDtcbiAgICBfZG9jRWxlbWVudCA9IF9kb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIF9ib2R5ID0gX2RvYy5ib2R5O1xuICAgIF90ZW1wRGl2ID0gX2NyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgX3N1cHBvcnRzUG9pbnRlciA9ICEhd2luZG93LlBvaW50ZXJFdmVudDtcbiAgICBfcGxhY2Vob2xkZXJEaXYgPSBfY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBfcGxhY2Vob2xkZXJEaXYuc3R5bGUuY3NzVGV4dCA9IFwidmlzaWJpbGl0eTpoaWRkZW47aGVpZ2h0OjFweDt0b3A6LTFweDtwb2ludGVyLWV2ZW50czpub25lO3Bvc2l0aW9uOnJlbGF0aXZlO2NsZWFyOmJvdGg7Y3Vyc29yOmdyYWJcIjtcbiAgICBfZGVmYXVsdEN1cnNvciA9IF9wbGFjZWhvbGRlckRpdi5zdHlsZS5jdXJzb3IgPT09IFwiZ3JhYlwiID8gXCJncmFiXCIgOiBcIm1vdmVcIjtcbiAgICBfaXNBbmRyb2lkID0gbmF2ICYmIG5hdi51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKFwiYW5kcm9pZFwiKSAhPT0gLTE7IC8vQW5kcm9pZCBoYW5kbGVzIHRvdWNoIGV2ZW50cyBpbiBhbiBvZGQgd2F5IGFuZCBpdCdzIHZpcnR1YWxseSBpbXBvc3NpYmxlIHRvIFwiZmVhdHVyZSB0ZXN0XCIgc28gd2UgcmVzb3J0IHRvIFVBIHNuaWZmaW5nXG5cbiAgICBfaXNUb3VjaERldmljZSA9IFwib250b3VjaHN0YXJ0XCIgaW4gX2RvY0VsZW1lbnQgJiYgXCJvcmllbnRhdGlvblwiIGluIF93aW4gfHwgbmF2ICYmIChuYXYuTWF4VG91Y2hQb2ludHMgPiAwIHx8IG5hdi5tc01heFRvdWNoUG9pbnRzID4gMCk7XG5cbiAgICBfYWRkUGFkZGluZ0JSID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy90aGlzIGZ1bmN0aW9uIGlzIGluIGNoYXJnZSBvZiBhbmFseXppbmcgYnJvd3NlciBiZWhhdmlvciByZWxhdGVkIHRvIHBhZGRpbmcuIEl0IHNldHMgdGhlIF9hZGRQYWRkaW5nQlIgdG8gdHJ1ZSBpZiB0aGUgYnJvd3NlciBkb2Vzbid0IG5vcm1hbGx5IGZhY3RvciBpbiB0aGUgYm90dG9tIG9yIHJpZ2h0IHBhZGRpbmcgb24gdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBzY3JvbGxpbmcgYXJlYSwgYW5kIGl0IHNldHMgX2FkZFBhZGRpbmdMZWZ0IHRvIHRydWUgaWYgaXQncyBhIGJyb3dzZXIgdGhhdCByZXF1aXJlcyB0aGUgZXh0cmEgb2Zmc2V0IChvZmZzZXRMZWZ0KSB0byBiZSBhZGRlZCB0byB0aGUgcGFkZGluZ1JpZ2h0IChsaWtlIE9wZXJhKS5cbiAgICAgIHZhciBkaXYgPSBfY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgICAgICBjaGlsZCA9IF9jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICAgIGNoaWxkU3R5bGUgPSBjaGlsZC5zdHlsZSxcbiAgICAgICAgICBwYXJlbnQgPSBfYm9keSxcbiAgICAgICAgICB2YWw7XG5cbiAgICAgIGNoaWxkU3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XG4gICAgICBjaGlsZFN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgZGl2LnN0eWxlLmNzc1RleHQgPSBjaGlsZC5pbm5lckhUTUwgPSBcIndpZHRoOjkwcHg7aGVpZ2h0OjQwcHg7cGFkZGluZzoxMHB4O292ZXJmbG93OmF1dG87dmlzaWJpbGl0eTpoaWRkZW5cIjtcbiAgICAgIGRpdi5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgIHZhbCA9IGNoaWxkLm9mZnNldEhlaWdodCArIDE4ID4gZGl2LnNjcm9sbEhlaWdodDsgLy9kaXYuc2Nyb2xsSGVpZ2h0IHNob3VsZCBiZSBjaGlsZC5vZmZzZXRIZWlnaHQgKyAyMCBiZWNhdXNlIG9mIHRoZSAxMHB4IG9mIHBhZGRpbmcgb24gZWFjaCBzaWRlLCBidXQgc29tZSBicm93c2VycyBpZ25vcmUgb25lIHNpZGUuIFdlIGFsbG93IGEgMnB4IG1hcmdpbiBvZiBlcnJvci5cblxuICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGRpdik7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH0oKTtcblxuICAgIF90b3VjaEV2ZW50TG9va3VwID0gZnVuY3Rpb24gKHR5cGVzKSB7XG4gICAgICAvL3dlIGNyZWF0ZSBhbiBvYmplY3QgdGhhdCBtYWtlcyBpdCBlYXN5IHRvIHRyYW5zbGF0ZSB0b3VjaCBldmVudCB0eXBlcyBpbnRvIHRoZWlyIFwicG9pbnRlclwiIGNvdW50ZXJwYXJ0cyBpZiB3ZSdyZSBpbiBhIGJyb3dzZXIgdGhhdCB1c2VzIHRob3NlIGluc3RlYWQuIExpa2UgSUUxMCB1c2VzIFwiTVNQb2ludGVyRG93blwiIGluc3RlYWQgb2YgXCJ0b3VjaHN0YXJ0XCIsIGZvciBleGFtcGxlLlxuICAgICAgdmFyIHN0YW5kYXJkID0gdHlwZXMuc3BsaXQoXCIsXCIpLFxuICAgICAgICAgIGNvbnZlcnRlZCA9IChcIm9ucG9pbnRlcmRvd25cIiBpbiBfdGVtcERpdiA/IFwicG9pbnRlcmRvd24scG9pbnRlcm1vdmUscG9pbnRlcnVwLHBvaW50ZXJjYW5jZWxcIiA6IFwib25tc3BvaW50ZXJkb3duXCIgaW4gX3RlbXBEaXYgPyBcIk1TUG9pbnRlckRvd24sTVNQb2ludGVyTW92ZSxNU1BvaW50ZXJVcCxNU1BvaW50ZXJDYW5jZWxcIiA6IHR5cGVzKS5zcGxpdChcIixcIiksXG4gICAgICAgICAgb2JqID0ge30sXG4gICAgICAgICAgaSA9IDQ7XG5cbiAgICAgIHdoaWxlICgtLWkgPiAtMSkge1xuICAgICAgICBvYmpbc3RhbmRhcmRbaV1dID0gY29udmVydGVkW2ldO1xuICAgICAgICBvYmpbY29udmVydGVkW2ldXSA9IHN0YW5kYXJkW2ldO1xuICAgICAgfSAvL3RvIGF2b2lkIHByb2JsZW1zIGluIGlPUyA5LCB0ZXN0IHRvIHNlZSBpZiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgXCJwYXNzaXZlXCIgb3B0aW9uIG9uIGFkZEV2ZW50TGlzdGVuZXIoKS5cblxuXG4gICAgICB0cnkge1xuICAgICAgICBfZG9jRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidGVzdFwiLCBudWxsLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIFwicGFzc2l2ZVwiLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICBfc3VwcG9ydHNQYXNzaXZlID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfShcInRvdWNoc3RhcnQsdG91Y2htb3ZlLHRvdWNoZW5kLHRvdWNoY2FuY2VsXCIpO1xuXG4gICAgX2FkZExpc3RlbmVyKF9kb2MsIFwidG91Y2hjYW5jZWxcIiwgX2VtcHR5RnVuYyk7IC8vc29tZSBvbGRlciBBbmRyb2lkIGRldmljZXMgaW50ZXJtaXR0ZW50bHkgc3RvcCBkaXNwYXRjaGluZyBcInRvdWNobW92ZVwiIGV2ZW50cyBpZiB3ZSBkb24ndCBsaXN0ZW4gZm9yIFwidG91Y2hjYW5jZWxcIiBvbiB0aGUgZG9jdW1lbnQuIFZlcnkgc3RyYW5nZSBpbmRlZWQuXG5cblxuICAgIF9hZGRMaXN0ZW5lcihfd2luLCBcInRvdWNobW92ZVwiLCBfZW1wdHlGdW5jKTsgLy93b3JrcyBhcm91bmQgU2FmYXJpIGJ1Z3MgdGhhdCBzdGlsbCBhbGxvdyB0aGUgcGFnZSB0byBzY3JvbGwgZXZlbiB3aGVuIHdlIHByZXZlbnREZWZhdWx0KCkgb24gdGhlIHRvdWNobW92ZSBldmVudC5cblxuXG4gICAgX2JvZHkgJiYgX2JvZHkuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgX2VtcHR5RnVuYyk7IC8vd29ya3MgYXJvdW5kIFNhZmFyaSBidWc6IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9mb3J1bXMvdG9waWMvMjE0NTAtZHJhZ2dhYmxlLWluLWlmcmFtZS1vbi1tb2JpbGUtaXMtYnVnZ3kvXG5cbiAgICBfYWRkTGlzdGVuZXIoX2RvYywgXCJjb250ZXh0bWVudVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBwIGluIF9sb29rdXApIHtcbiAgICAgICAgaWYgKF9sb29rdXBbcF0uaXNQcmVzc2VkKSB7XG4gICAgICAgICAgX2xvb2t1cFtwXS5lbmREcmFnKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGdzYXAgPSBfY29yZUluaXR0ZWQgPSBfZ2V0R1NBUCgpO1xuICB9XG5cbiAgaWYgKGdzYXApIHtcbiAgICBJbmVydGlhUGx1Z2luID0gZ3NhcC5wbHVnaW5zLmluZXJ0aWE7XG4gICAgX2NoZWNrUHJlZml4ID0gZ3NhcC51dGlscy5jaGVja1ByZWZpeDtcbiAgICBfdHJhbnNmb3JtUHJvcCA9IF9jaGVja1ByZWZpeChfdHJhbnNmb3JtUHJvcCk7XG4gICAgX3RyYW5zZm9ybU9yaWdpblByb3AgPSBfY2hlY2tQcmVmaXgoX3RyYW5zZm9ybU9yaWdpblByb3ApO1xuICAgIF90b0FycmF5ID0gZ3NhcC51dGlscy50b0FycmF5O1xuICAgIF9zdXBwb3J0czNEID0gISFfY2hlY2tQcmVmaXgoXCJwZXJzcGVjdGl2ZVwiKTtcbiAgfSBlbHNlIGlmIChyZXF1aXJlZCkge1xuICAgIGNvbnNvbGUud2FybihcIlBsZWFzZSBnc2FwLnJlZ2lzdGVyUGx1Z2luKERyYWdnYWJsZSlcIik7XG4gIH1cbn07XG5cbnZhciBFdmVudERpc3BhdGNoZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFdmVudERpc3BhdGNoZXIodGFyZ2V0KSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaykge1xuICAgIHZhciBsaXN0ID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdIHx8ICh0aGlzLl9saXN0ZW5lcnNbdHlwZV0gPSBbXSk7XG5cbiAgICBpZiAoIX5saXN0LmluZGV4T2YoY2FsbGJhY2spKSB7XG4gICAgICBsaXN0LnB1c2goY2FsbGJhY2spO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgbGlzdCA9IHRoaXMuX2xpc3RlbmVyc1t0eXBlXSxcbiAgICAgICAgaSA9IGxpc3QgJiYgbGlzdC5pbmRleE9mKGNhbGxiYWNrKSB8fCAtMTtcbiAgICBpID4gLTEgJiYgbGlzdC5zcGxpY2UoaSwgMSk7XG4gIH07XG5cbiAgX3Byb3RvLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiBkaXNwYXRjaEV2ZW50KHR5cGUpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIHJlc3VsdDtcbiAgICAodGhpcy5fbGlzdGVuZXJzW3R5cGVdIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoX3RoaXMsIHtcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgdGFyZ2V0OiBfdGhpcy50YXJnZXRcbiAgICAgIH0pID09PSBmYWxzZSAmJiAocmVzdWx0ID0gZmFsc2UpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7IC8vaWYgYW55IG9mIHRoZSBjYWxsYmFja3MgcmV0dXJuIGZhbHNlLCBwYXNzIHRoYXQgYWxvbmcuXG4gIH07XG5cbiAgcmV0dXJuIEV2ZW50RGlzcGF0Y2hlcjtcbn0oKTtcblxuZXhwb3J0IHZhciBEcmFnZ2FibGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FdmVudERpc3BhdGNoZXIpIHtcbiAgX2luaGVyaXRzTG9vc2UoRHJhZ2dhYmxlLCBfRXZlbnREaXNwYXRjaGVyKTtcblxuICBmdW5jdGlvbiBEcmFnZ2FibGUodGFyZ2V0LCB2YXJzKSB7XG4gICAgdmFyIF90aGlzMjtcblxuICAgIF90aGlzMiA9IF9FdmVudERpc3BhdGNoZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgIF9jb3JlSW5pdHRlZCB8fCBfaW5pdENvcmUoMSk7XG4gICAgdGFyZ2V0ID0gX3RvQXJyYXkodGFyZ2V0KVswXTsgLy9pbiBjYXNlIHRoZSB0YXJnZXQgaXMgYSBzZWxlY3RvciBvYmplY3Qgb3Igc2VsZWN0b3IgdGV4dFxuXG4gICAgaWYgKCFJbmVydGlhUGx1Z2luKSB7XG4gICAgICBJbmVydGlhUGx1Z2luID0gZ3NhcC5wbHVnaW5zLmluZXJ0aWE7XG4gICAgfVxuXG4gICAgX3RoaXMyLnZhcnMgPSB2YXJzID0gX2NvcHkodmFycyB8fCB7fSk7XG4gICAgX3RoaXMyLnRhcmdldCA9IHRhcmdldDtcbiAgICBfdGhpczIueCA9IF90aGlzMi55ID0gX3RoaXMyLnJvdGF0aW9uID0gMDtcbiAgICBfdGhpczIuZHJhZ1Jlc2lzdGFuY2UgPSBwYXJzZUZsb2F0KHZhcnMuZHJhZ1Jlc2lzdGFuY2UpIHx8IDA7XG4gICAgX3RoaXMyLmVkZ2VSZXNpc3RhbmNlID0gaXNOYU4odmFycy5lZGdlUmVzaXN0YW5jZSkgPyAxIDogcGFyc2VGbG9hdCh2YXJzLmVkZ2VSZXNpc3RhbmNlKSB8fCAwO1xuICAgIF90aGlzMi5sb2NrQXhpcyA9IHZhcnMubG9ja0F4aXM7XG4gICAgX3RoaXMyLmF1dG9TY3JvbGwgPSB2YXJzLmF1dG9TY3JvbGwgfHwgMDtcbiAgICBfdGhpczIubG9ja2VkQXhpcyA9IG51bGw7XG4gICAgX3RoaXMyLmFsbG93RXZlbnREZWZhdWx0ID0gISF2YXJzLmFsbG93RXZlbnREZWZhdWx0O1xuICAgIGdzYXAuZ2V0UHJvcGVydHkodGFyZ2V0LCBcInhcIik7IC8vIHRvIGVuc3VyZSB0aGF0IHRyYW5zZm9ybXMgYXJlIGluc3RhbnRpYXRlZC5cblxuICAgIHZhciB0eXBlID0gKHZhcnMudHlwZSB8fCBcIngseVwiKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICB4eU1vZGUgPSB+dHlwZS5pbmRleE9mKFwieFwiKSB8fCB+dHlwZS5pbmRleE9mKFwieVwiKSxcbiAgICAgICAgcm90YXRpb25Nb2RlID0gdHlwZS5pbmRleE9mKFwicm90YXRpb25cIikgIT09IC0xLFxuICAgICAgICB4UHJvcCA9IHJvdGF0aW9uTW9kZSA/IFwicm90YXRpb25cIiA6IHh5TW9kZSA/IFwieFwiIDogXCJsZWZ0XCIsXG4gICAgICAgIHlQcm9wID0geHlNb2RlID8gXCJ5XCIgOiBcInRvcFwiLFxuICAgICAgICBhbGxvd1ggPSAhISh+dHlwZS5pbmRleE9mKFwieFwiKSB8fCB+dHlwZS5pbmRleE9mKFwibGVmdFwiKSB8fCB0eXBlID09PSBcInNjcm9sbFwiKSxcbiAgICAgICAgYWxsb3dZID0gISEofnR5cGUuaW5kZXhPZihcInlcIikgfHwgfnR5cGUuaW5kZXhPZihcInRvcFwiKSB8fCB0eXBlID09PSBcInNjcm9sbFwiKSxcbiAgICAgICAgbWluaW11bU1vdmVtZW50ID0gdmFycy5taW5pbXVtTW92ZW1lbnQgfHwgMixcbiAgICAgICAgc2VsZiA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMyKSxcbiAgICAgICAgdHJpZ2dlcnMgPSBfdG9BcnJheSh2YXJzLnRyaWdnZXIgfHwgdmFycy5oYW5kbGUgfHwgdGFyZ2V0KSxcbiAgICAgICAga2lsbFByb3BzID0ge30sXG4gICAgICAgIGRyYWdFbmRUaW1lID0gMCxcbiAgICAgICAgY2hlY2tBdXRvU2Nyb2xsQm91bmRzID0gZmFsc2UsXG4gICAgICAgIGF1dG9TY3JvbGxNYXJnaW5Ub3AgPSB2YXJzLmF1dG9TY3JvbGxNYXJnaW5Ub3AgfHwgNDAsXG4gICAgICAgIGF1dG9TY3JvbGxNYXJnaW5SaWdodCA9IHZhcnMuYXV0b1Njcm9sbE1hcmdpblJpZ2h0IHx8IDQwLFxuICAgICAgICBhdXRvU2Nyb2xsTWFyZ2luQm90dG9tID0gdmFycy5hdXRvU2Nyb2xsTWFyZ2luQm90dG9tIHx8IDQwLFxuICAgICAgICBhdXRvU2Nyb2xsTWFyZ2luTGVmdCA9IHZhcnMuYXV0b1Njcm9sbE1hcmdpbkxlZnQgfHwgNDAsXG4gICAgICAgIGlzQ2xpY2thYmxlID0gdmFycy5jbGlja2FibGVUZXN0IHx8IF9pc0NsaWNrYWJsZSxcbiAgICAgICAgY2xpY2tUaW1lID0gMCxcbiAgICAgICAgZ3NDYWNoZSA9IHRhcmdldC5fZ3NhcCB8fCBnc2FwLmNvcmUuZ2V0Q2FjaGUodGFyZ2V0KSxcbiAgICAgICAgaXNGaXhlZCA9IF9pc0ZpeGVkKHRhcmdldCksXG4gICAgICAgIGdldFByb3BBc051bSA9IGZ1bmN0aW9uIGdldFByb3BBc051bShwcm9wZXJ0eSwgdW5pdCkge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoZ3NDYWNoZS5nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgdW5pdCkpO1xuICAgIH0sXG4gICAgICAgIG93bmVyRG9jID0gdGFyZ2V0Lm93bmVyRG9jdW1lbnQgfHwgX2RvYyxcbiAgICAgICAgZW5hYmxlZCxcbiAgICAgICAgc2Nyb2xsUHJveHksXG4gICAgICAgIHN0YXJ0UG9pbnRlclgsXG4gICAgICAgIHN0YXJ0UG9pbnRlclksXG4gICAgICAgIHN0YXJ0RWxlbWVudFgsXG4gICAgICAgIHN0YXJ0RWxlbWVudFksXG4gICAgICAgIGhhc0JvdW5kcyxcbiAgICAgICAgaGFzRHJhZ0NhbGxiYWNrLFxuICAgICAgICBoYXNNb3ZlQ2FsbGJhY2ssXG4gICAgICAgIG1heFgsXG4gICAgICAgIG1pblgsXG4gICAgICAgIG1heFksXG4gICAgICAgIG1pblksXG4gICAgICAgIHRvdWNoLFxuICAgICAgICB0b3VjaElELFxuICAgICAgICByb3RhdGlvbk9yaWdpbixcbiAgICAgICAgZGlydHksXG4gICAgICAgIG9sZCxcbiAgICAgICAgc25hcFgsXG4gICAgICAgIHNuYXBZLFxuICAgICAgICBzbmFwWFksXG4gICAgICAgIGlzQ2xpY2tpbmcsXG4gICAgICAgIHRvdWNoRXZlbnRUYXJnZXQsXG4gICAgICAgIG1hdHJpeCxcbiAgICAgICAgaW50ZXJydXB0ZWQsXG4gICAgICAgIGFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcsXG4gICAgICAgIHRvdWNoRHJhZ0F4aXMsXG4gICAgICAgIGlzRGlzcGF0Y2hpbmcsXG4gICAgICAgIGNsaWNrRGlzcGF0Y2gsXG4gICAgICAgIHRydXN0ZWRDbGlja0Rpc3BhdGNoLFxuICAgICAgICBpc1ByZXZlbnRpbmdEZWZhdWx0LFxuICAgICAgICBpbm5lck1hdHJpeCxcbiAgICAgICAgb25Db250ZXh0TWVudSA9IGZ1bmN0aW9uIG9uQ29udGV4dE1lbnUoZSkge1xuICAgICAgLy91c2VkIHRvIHByZXZlbnQgbG9uZy10b3VjaCBmcm9tIHRyaWdnZXJpbmcgYSBjb250ZXh0IG1lbnUuXG4gICAgICAvLyAoc2VsZi5pc1ByZXNzZWQgJiYgZS53aGljaCA8IDIpICYmIHNlbGYuZW5kRHJhZygpIC8vIHByZXZpb3VzbHkgZW5kZWQgZHJhZyB3aGVuIGNvbnRleHQgbWVudSB3YXMgdHJpZ2dlcmVkLCBidXQgaW5zdGVhZCB3ZSBzaG91bGQganVzdCBzdG9wIHByb3BhZ2F0aW9uIGFuZCBwcmV2ZW50IHRoZSBkZWZhdWx0IGV2ZW50IGJlaGF2aW9yLlxuICAgICAgX3ByZXZlbnREZWZhdWx0KGUpO1xuXG4gICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiAmJiBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgICAgIC8vdGhpcyBtZXRob2QgZ2V0cyBjYWxsZWQgb24gZXZlcnkgdGljayBvZiBUd2VlbkxpdGUudGlja2VyIHdoaWNoIGFsbG93cyB1cyB0byBzeW5jaHJvbml6ZSB0aGUgcmVuZGVycyB0byB0aGUgY29yZSBlbmdpbmUgKHdoaWNoIGlzIHR5cGljYWxseSBzeW5jaHJvbml6ZWQgd2l0aCB0aGUgZGlzcGxheSByZWZyZXNoIHZpYSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUpLiBUaGlzIGlzIGFuIG9wdGltaXphdGlvbiAtIGl0J3MgYmV0dGVyIHRoYW4gYXBwbHlpbmcgdGhlIHZhbHVlcyBpbnNpZGUgdGhlIFwibW91c2Vtb3ZlXCIgb3IgXCJ0b3VjaG1vdmVcIiBldmVudCBoYW5kbGVyIHdoaWNoIG1heSBnZXQgY2FsbGVkIG1hbnkgdGltZXMgaW5iZXR3ZWVuIHJlZnJlc2hlcy5cbiAgICByZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgIGlmIChzZWxmLmF1dG9TY3JvbGwgJiYgc2VsZi5pc0RyYWdnaW5nICYmIChjaGVja0F1dG9TY3JvbGxCb3VuZHMgfHwgZGlydHkpKSB7XG4gICAgICAgIHZhciBlID0gdGFyZ2V0LFxuICAgICAgICAgICAgYXV0b1Njcm9sbEZhY3RvciA9IHNlbGYuYXV0b1Njcm9sbCAqIDE1LFxuICAgICAgICAgICAgLy9tdWx0aXBseWluZyBieSAxNSBqdXN0IGdpdmVzIHVzIGEgYmV0dGVyIFwiZmVlbFwiIHNwZWVkLXdpc2UuXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgICAgIGlzUm9vdCxcbiAgICAgICAgICAgIHJlY3QsXG4gICAgICAgICAgICBwb2ludGVyWCxcbiAgICAgICAgICAgIHBvaW50ZXJZLFxuICAgICAgICAgICAgY2hhbmdlWCxcbiAgICAgICAgICAgIGNoYW5nZVksXG4gICAgICAgICAgICBnYXA7XG4gICAgICAgIGNoZWNrQXV0b1Njcm9sbEJvdW5kcyA9IGZhbHNlO1xuICAgICAgICBfd2luZG93UHJveHkuc2Nyb2xsVG9wID0gX3dpbi5wYWdlWU9mZnNldCAhPSBudWxsID8gX3dpbi5wYWdlWU9mZnNldCA6IG93bmVyRG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgIT0gbnVsbCA/IG93bmVyRG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgOiBvd25lckRvYy5ib2R5LnNjcm9sbFRvcDtcbiAgICAgICAgX3dpbmRvd1Byb3h5LnNjcm9sbExlZnQgPSBfd2luLnBhZ2VYT2Zmc2V0ICE9IG51bGwgPyBfd2luLnBhZ2VYT2Zmc2V0IDogb3duZXJEb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgIT0gbnVsbCA/IG93bmVyRG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IDogb3duZXJEb2MuYm9keS5zY3JvbGxMZWZ0O1xuICAgICAgICBwb2ludGVyWCA9IHNlbGYucG9pbnRlclggLSBfd2luZG93UHJveHkuc2Nyb2xsTGVmdDtcbiAgICAgICAgcG9pbnRlclkgPSBzZWxmLnBvaW50ZXJZIC0gX3dpbmRvd1Byb3h5LnNjcm9sbFRvcDtcblxuICAgICAgICB3aGlsZSAoZSAmJiAhaXNSb290KSB7XG4gICAgICAgICAgLy93YWxrIHVwIHRoZSBjaGFpbiBhbmQgc2Vuc2Ugd2hlcmV2ZXIgdGhlIHBvaW50ZXIgaXMgd2l0aGluIDQwcHggb2YgYW4gZWRnZSB0aGF0J3Mgc2Nyb2xsYWJsZS5cbiAgICAgICAgICBpc1Jvb3QgPSBfaXNSb290KGUucGFyZW50Tm9kZSk7XG4gICAgICAgICAgcGFyZW50ID0gaXNSb290ID8gX3dpbmRvd1Byb3h5IDogZS5wYXJlbnROb2RlO1xuICAgICAgICAgIHJlY3QgPSBpc1Jvb3QgPyB7XG4gICAgICAgICAgICBib3R0b206IE1hdGgubWF4KF9kb2NFbGVtZW50LmNsaWVudEhlaWdodCwgX3dpbi5pbm5lckhlaWdodCB8fCAwKSxcbiAgICAgICAgICAgIHJpZ2h0OiBNYXRoLm1heChfZG9jRWxlbWVudC5jbGllbnRXaWR0aCwgX3dpbi5pbm5lcldpZHRoIHx8IDApLFxuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIHRvcDogMFxuICAgICAgICAgIH0gOiBwYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgY2hhbmdlWCA9IGNoYW5nZVkgPSAwO1xuXG4gICAgICAgICAgaWYgKGFsbG93WSkge1xuICAgICAgICAgICAgZ2FwID0gcGFyZW50Ll9nc01heFNjcm9sbFkgLSBwYXJlbnQuc2Nyb2xsVG9wO1xuXG4gICAgICAgICAgICBpZiAoZ2FwIDwgMCkge1xuICAgICAgICAgICAgICBjaGFuZ2VZID0gZ2FwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwb2ludGVyWSA+IHJlY3QuYm90dG9tIC0gYXV0b1Njcm9sbE1hcmdpbkJvdHRvbSAmJiBnYXApIHtcbiAgICAgICAgICAgICAgY2hlY2tBdXRvU2Nyb2xsQm91bmRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY2hhbmdlWSA9IE1hdGgubWluKGdhcCwgYXV0b1Njcm9sbEZhY3RvciAqICgxIC0gTWF0aC5tYXgoMCwgcmVjdC5ib3R0b20gLSBwb2ludGVyWSkgLyBhdXRvU2Nyb2xsTWFyZ2luQm90dG9tKSB8IDApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwb2ludGVyWSA8IHJlY3QudG9wICsgYXV0b1Njcm9sbE1hcmdpblRvcCAmJiBwYXJlbnQuc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICAgIGNoZWNrQXV0b1Njcm9sbEJvdW5kcyA9IHRydWU7XG4gICAgICAgICAgICAgIGNoYW5nZVkgPSAtTWF0aC5taW4ocGFyZW50LnNjcm9sbFRvcCwgYXV0b1Njcm9sbEZhY3RvciAqICgxIC0gTWF0aC5tYXgoMCwgcG9pbnRlclkgLSByZWN0LnRvcCkgLyBhdXRvU2Nyb2xsTWFyZ2luVG9wKSB8IDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2hhbmdlWSkge1xuICAgICAgICAgICAgICBwYXJlbnQuc2Nyb2xsVG9wICs9IGNoYW5nZVk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFsbG93WCkge1xuICAgICAgICAgICAgZ2FwID0gcGFyZW50Ll9nc01heFNjcm9sbFggLSBwYXJlbnQuc2Nyb2xsTGVmdDtcblxuICAgICAgICAgICAgaWYgKGdhcCA8IDApIHtcbiAgICAgICAgICAgICAgY2hhbmdlWCA9IGdhcDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocG9pbnRlclggPiByZWN0LnJpZ2h0IC0gYXV0b1Njcm9sbE1hcmdpblJpZ2h0ICYmIGdhcCkge1xuICAgICAgICAgICAgICBjaGVja0F1dG9TY3JvbGxCb3VuZHMgPSB0cnVlO1xuICAgICAgICAgICAgICBjaGFuZ2VYID0gTWF0aC5taW4oZ2FwLCBhdXRvU2Nyb2xsRmFjdG9yICogKDEgLSBNYXRoLm1heCgwLCByZWN0LnJpZ2h0IC0gcG9pbnRlclgpIC8gYXV0b1Njcm9sbE1hcmdpblJpZ2h0KSB8IDApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwb2ludGVyWCA8IHJlY3QubGVmdCArIGF1dG9TY3JvbGxNYXJnaW5MZWZ0ICYmIHBhcmVudC5zY3JvbGxMZWZ0KSB7XG4gICAgICAgICAgICAgIGNoZWNrQXV0b1Njcm9sbEJvdW5kcyA9IHRydWU7XG4gICAgICAgICAgICAgIGNoYW5nZVggPSAtTWF0aC5taW4ocGFyZW50LnNjcm9sbExlZnQsIGF1dG9TY3JvbGxGYWN0b3IgKiAoMSAtIE1hdGgubWF4KDAsIHBvaW50ZXJYIC0gcmVjdC5sZWZ0KSAvIGF1dG9TY3JvbGxNYXJnaW5MZWZ0KSB8IDApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2hhbmdlWCkge1xuICAgICAgICAgICAgICBwYXJlbnQuc2Nyb2xsTGVmdCArPSBjaGFuZ2VYO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc1Jvb3QgJiYgKGNoYW5nZVggfHwgY2hhbmdlWSkpIHtcbiAgICAgICAgICAgIF93aW4uc2Nyb2xsVG8ocGFyZW50LnNjcm9sbExlZnQsIHBhcmVudC5zY3JvbGxUb3ApO1xuXG4gICAgICAgICAgICBzZXRQb2ludGVyUG9zaXRpb24oc2VsZi5wb2ludGVyWCArIGNoYW5nZVgsIHNlbGYucG9pbnRlclkgKyBjaGFuZ2VZKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXJ0eSkge1xuICAgICAgICB2YXIgeCA9IHNlbGYueCxcbiAgICAgICAgICAgIHkgPSBzZWxmLnk7XG5cbiAgICAgICAgaWYgKHJvdGF0aW9uTW9kZSkge1xuICAgICAgICAgIHNlbGYuZGVsdGFYID0geCAtIHBhcnNlRmxvYXQoZ3NDYWNoZS5yb3RhdGlvbik7XG4gICAgICAgICAgc2VsZi5yb3RhdGlvbiA9IHg7XG4gICAgICAgICAgZ3NDYWNoZS5yb3RhdGlvbiA9IHggKyBcImRlZ1wiO1xuICAgICAgICAgIGdzQ2FjaGUucmVuZGVyVHJhbnNmb3JtKDEsIGdzQ2FjaGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzY3JvbGxQcm94eSkge1xuICAgICAgICAgICAgaWYgKGFsbG93WSkge1xuICAgICAgICAgICAgICBzZWxmLmRlbHRhWSA9IHkgLSBzY3JvbGxQcm94eS50b3AoKTtcbiAgICAgICAgICAgICAgc2Nyb2xsUHJveHkudG9wKHkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWxsb3dYKSB7XG4gICAgICAgICAgICAgIHNlbGYuZGVsdGFYID0geCAtIHNjcm9sbFByb3h5LmxlZnQoKTtcbiAgICAgICAgICAgICAgc2Nyb2xsUHJveHkubGVmdCh4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHh5TW9kZSkge1xuICAgICAgICAgICAgaWYgKGFsbG93WSkge1xuICAgICAgICAgICAgICBzZWxmLmRlbHRhWSA9IHkgLSBwYXJzZUZsb2F0KGdzQ2FjaGUueSk7XG4gICAgICAgICAgICAgIGdzQ2FjaGUueSA9IHkgKyBcInB4XCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhbGxvd1gpIHtcbiAgICAgICAgICAgICAgc2VsZi5kZWx0YVggPSB4IC0gcGFyc2VGbG9hdChnc0NhY2hlLngpO1xuICAgICAgICAgICAgICBnc0NhY2hlLnggPSB4ICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnc0NhY2hlLnJlbmRlclRyYW5zZm9ybSgxLCBnc0NhY2hlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGFsbG93WSkge1xuICAgICAgICAgICAgICBzZWxmLmRlbHRhWSA9IHkgLSBwYXJzZUZsb2F0KHRhcmdldC5zdHlsZS50b3AgfHwgMCk7XG4gICAgICAgICAgICAgIHRhcmdldC5zdHlsZS50b3AgPSB5ICsgXCJweFwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWxsb3dYKSB7XG4gICAgICAgICAgICAgIHNlbGYuZGVsdGFYID0geCAtIHBhcnNlRmxvYXQodGFyZ2V0LnN0eWxlLmxlZnQgfHwgMCk7XG4gICAgICAgICAgICAgIHRhcmdldC5zdHlsZS5sZWZ0ID0geCArIFwicHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzRHJhZ0NhbGxiYWNrICYmICFzdXBwcmVzc0V2ZW50cyAmJiAhaXNEaXNwYXRjaGluZykge1xuICAgICAgICAgIGlzRGlzcGF0Y2hpbmcgPSB0cnVlOyAvL2luIGNhc2Ugb25EcmFnIGhhcyBhbiB1cGRhdGUoKSBjYWxsIChhdm9pZCBlbmRsZXNzIGxvb3ApXG5cbiAgICAgICAgICBpZiAoX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJkcmFnXCIsIFwib25EcmFnXCIpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaWYgKGFsbG93WCkge1xuICAgICAgICAgICAgICBzZWxmLnggLT0gc2VsZi5kZWx0YVg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhbGxvd1kpIHtcbiAgICAgICAgICAgICAgc2VsZi55IC09IHNlbGYuZGVsdGFZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZW5kZXIodHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaXNEaXNwYXRjaGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRpcnR5ID0gZmFsc2U7XG4gICAgfSxcbiAgICAgICAgLy9jb3BpZXMgdGhlIHgveSBmcm9tIHRoZSBlbGVtZW50ICh3aGV0aGVyIHRoYXQgYmUgdHJhbnNmb3JtcywgdG9wL2xlZnQsIG9yIFNjcm9sbFByb3h5J3MgdG9wL2xlZnQpIHRvIHRoZSBEcmFnZ2FibGUncyB4IGFuZCB5IChhbmQgcm90YXRpb24gaWYgbmVjZXNzYXJ5KSBwcm9wZXJ0aWVzIHNvIHRoYXQgdGhleSByZWZsZWN0IHJlYWxpdHkgYW5kIGl0IGFsc28gKG9wdGlvbmFsbHkpIGFwcGxpZXMgYW55IHNuYXBwaW5nIG5lY2Vzc2FyeS4gVGhpcyBpcyB1c2VkIGJ5IHRoZSBJbmVydGlhUGx1Z2luIHR3ZWVuIGluIGFuIG9uVXBkYXRlIHRvIGVuc3VyZSB0aGluZ3MgYXJlIHN5bmNlZCBhbmQgc25hcHBlZC5cbiAgICBzeW5jWFkgPSBmdW5jdGlvbiBzeW5jWFkoc2tpcE9uVXBkYXRlLCBza2lwU25hcCkge1xuICAgICAgdmFyIHggPSBzZWxmLngsXG4gICAgICAgICAgeSA9IHNlbGYueSxcbiAgICAgICAgICBzbmFwcGVkVmFsdWUsXG4gICAgICAgICAgY3M7XG5cbiAgICAgIGlmICghdGFyZ2V0Ll9nc2FwKSB7XG4gICAgICAgIC8vanVzdCBpbiBjYXNlIHRoZSBfZ3NhcCBjYWNoZSBnb3Qgd2lwZWQsIGxpa2UgaWYgdGhlIHVzZXIgY2FsbGVkIGNsZWFyUHJvcHMgb24gdGhlIHRyYW5zZm9ybSBvciBzb21ldGhpbmcgKHZlcnkgcmFyZSkuXG4gICAgICAgIGdzQ2FjaGUgPSBnc2FwLmNvcmUuZ2V0Q2FjaGUodGFyZ2V0KTtcbiAgICAgIH1cblxuICAgICAgZ3NDYWNoZS51bmNhY2hlICYmIGdzYXAuZ2V0UHJvcGVydHkodGFyZ2V0LCBcInhcIik7IC8vIHRyaWdnZXIgYSByZS1jYWNoZVxuXG4gICAgICBpZiAoeHlNb2RlKSB7XG4gICAgICAgIHNlbGYueCA9IHBhcnNlRmxvYXQoZ3NDYWNoZS54KTtcbiAgICAgICAgc2VsZi55ID0gcGFyc2VGbG9hdChnc0NhY2hlLnkpO1xuICAgICAgfSBlbHNlIGlmIChyb3RhdGlvbk1vZGUpIHtcbiAgICAgICAgc2VsZi54ID0gc2VsZi5yb3RhdGlvbiA9IHBhcnNlRmxvYXQoZ3NDYWNoZS5yb3RhdGlvbik7XG4gICAgICB9IGVsc2UgaWYgKHNjcm9sbFByb3h5KSB7XG4gICAgICAgIHNlbGYueSA9IHNjcm9sbFByb3h5LnRvcCgpO1xuICAgICAgICBzZWxmLnggPSBzY3JvbGxQcm94eS5sZWZ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLnkgPSBwYXJzZUZsb2F0KHRhcmdldC5zdHlsZS50b3AgfHwgKGNzID0gX2dldENvbXB1dGVkU3R5bGUodGFyZ2V0KSkgJiYgY3MudG9wKSB8fCAwO1xuICAgICAgICBzZWxmLnggPSBwYXJzZUZsb2F0KHRhcmdldC5zdHlsZS5sZWZ0IHx8IChjcyB8fCB7fSkubGVmdCkgfHwgMDtcbiAgICAgIH1cblxuICAgICAgaWYgKChzbmFwWCB8fCBzbmFwWSB8fCBzbmFwWFkpICYmICFza2lwU25hcCAmJiAoc2VsZi5pc0RyYWdnaW5nIHx8IHNlbGYuaXNUaHJvd2luZykpIHtcbiAgICAgICAgaWYgKHNuYXBYWSkge1xuICAgICAgICAgIF90ZW1wMS54ID0gc2VsZi54O1xuICAgICAgICAgIF90ZW1wMS55ID0gc2VsZi55O1xuICAgICAgICAgIHNuYXBwZWRWYWx1ZSA9IHNuYXBYWShfdGVtcDEpO1xuXG4gICAgICAgICAgaWYgKHNuYXBwZWRWYWx1ZS54ICE9PSBzZWxmLngpIHtcbiAgICAgICAgICAgIHNlbGYueCA9IHNuYXBwZWRWYWx1ZS54O1xuICAgICAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzbmFwcGVkVmFsdWUueSAhPT0gc2VsZi55KSB7XG4gICAgICAgICAgICBzZWxmLnkgPSBzbmFwcGVkVmFsdWUueTtcbiAgICAgICAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc25hcFgpIHtcbiAgICAgICAgICBzbmFwcGVkVmFsdWUgPSBzbmFwWChzZWxmLngpO1xuXG4gICAgICAgICAgaWYgKHNuYXBwZWRWYWx1ZSAhPT0gc2VsZi54KSB7XG4gICAgICAgICAgICBzZWxmLnggPSBzbmFwcGVkVmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChyb3RhdGlvbk1vZGUpIHtcbiAgICAgICAgICAgICAgc2VsZi5yb3RhdGlvbiA9IHNuYXBwZWRWYWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzbmFwWSkge1xuICAgICAgICAgIHNuYXBwZWRWYWx1ZSA9IHNuYXBZKHNlbGYueSk7XG5cbiAgICAgICAgICBpZiAoc25hcHBlZFZhbHVlICE9PSBzZWxmLnkpIHtcbiAgICAgICAgICAgIHNlbGYueSA9IHNuYXBwZWRWYWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZGlydHkgJiYgcmVuZGVyKHRydWUpO1xuXG4gICAgICBpZiAoIXNraXBPblVwZGF0ZSkge1xuICAgICAgICBzZWxmLmRlbHRhWCA9IHNlbGYueCAtIHg7XG4gICAgICAgIHNlbGYuZGVsdGFZID0gc2VsZi55IC0geTtcblxuICAgICAgICBfZGlzcGF0Y2hFdmVudChzZWxmLCBcInRocm93dXBkYXRlXCIsIFwib25UaHJvd1VwZGF0ZVwiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICAgICBidWlsZFNuYXBGdW5jID0gZnVuY3Rpb24gYnVpbGRTbmFwRnVuYyhzbmFwLCBtaW4sIG1heCwgZmFjdG9yKSB7XG4gICAgICBpZiAobWluID09IG51bGwpIHtcbiAgICAgICAgbWluID0gLV9iaWdOdW07XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXggPT0gbnVsbCkge1xuICAgICAgICBtYXggPSBfYmlnTnVtO1xuICAgICAgfVxuXG4gICAgICBpZiAoX2lzRnVuY3Rpb24oc25hcCkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgdmFyIGVkZ2VUb2xlcmFuY2UgPSAhc2VsZi5pc1ByZXNzZWQgPyAxIDogMSAtIHNlbGYuZWRnZVJlc2lzdGFuY2U7IC8vaWYgd2UncmUgdHdlZW5pbmcsIGRpc2FibGUgdGhlIGVkZ2VUb2xlcmFuY2UgYmVjYXVzZSBpdCdzIGFscmVhZHkgZmFjdG9yZWQgaW50byB0aGUgdHdlZW5pbmcgdmFsdWVzICh3ZSBkb24ndCB3YW50IHRvIGFwcGx5IGl0IG11bHRpcGxlIHRpbWVzKVxuXG4gICAgICAgICAgcmV0dXJuIHNuYXAuY2FsbChzZWxmLCBuID4gbWF4ID8gbWF4ICsgKG4gLSBtYXgpICogZWRnZVRvbGVyYW5jZSA6IG4gPCBtaW4gPyBtaW4gKyAobiAtIG1pbikgKiBlZGdlVG9sZXJhbmNlIDogbikgKiBmYWN0b3I7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChfaXNBcnJheShzbmFwKSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICB2YXIgaSA9IHNuYXAubGVuZ3RoLFxuICAgICAgICAgICAgICBjbG9zZXN0ID0gMCxcbiAgICAgICAgICAgICAgYWJzRGlmID0gX2JpZ051bSxcbiAgICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgICBkaWY7XG5cbiAgICAgICAgICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICAgICAgICAgIHZhbCA9IHNuYXBbaV07XG4gICAgICAgICAgICBkaWYgPSB2YWwgLSBuO1xuXG4gICAgICAgICAgICBpZiAoZGlmIDwgMCkge1xuICAgICAgICAgICAgICBkaWYgPSAtZGlmO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGlmIDwgYWJzRGlmICYmIHZhbCA+PSBtaW4gJiYgdmFsIDw9IG1heCkge1xuICAgICAgICAgICAgICBjbG9zZXN0ID0gaTtcbiAgICAgICAgICAgICAgYWJzRGlmID0gZGlmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzbmFwW2Nsb3Nlc3RdO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaXNOYU4oc25hcCkgPyBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gbjtcbiAgICAgIH0gOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzbmFwICogZmFjdG9yO1xuICAgICAgfTtcbiAgICB9LFxuICAgICAgICBidWlsZFBvaW50U25hcEZ1bmMgPSBmdW5jdGlvbiBidWlsZFBvaW50U25hcEZ1bmMoc25hcCwgbWluWCwgbWF4WCwgbWluWSwgbWF4WSwgcmFkaXVzLCBmYWN0b3IpIHtcbiAgICAgIHJhZGl1cyA9IHJhZGl1cyAmJiByYWRpdXMgPCBfYmlnTnVtID8gcmFkaXVzICogcmFkaXVzIDogX2JpZ051bTsgLy9zbyB3ZSBkb24ndCBoYXZlIHRvIE1hdGguc3FydCgpIGluIHRoZSBmdW5jdGlvbnMuIFBlcmZvcm1hbmNlIG9wdGltaXphdGlvbi5cblxuICAgICAgaWYgKF9pc0Z1bmN0aW9uKHNuYXApKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICB2YXIgZWRnZVRvbGVyYW5jZSA9ICFzZWxmLmlzUHJlc3NlZCA/IDEgOiAxIC0gc2VsZi5lZGdlUmVzaXN0YW5jZSxcbiAgICAgICAgICAgICAgeCA9IHBvaW50LngsXG4gICAgICAgICAgICAgIHkgPSBwb2ludC55LFxuICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgIGR4LFxuICAgICAgICAgICAgICBkeTsgLy9pZiB3ZSdyZSB0d2VlbmluZywgZGlzYWJsZSB0aGUgZWRnZVRvbGVyYW5jZSBiZWNhdXNlIGl0J3MgYWxyZWFkeSBmYWN0b3JlZCBpbnRvIHRoZSB0d2VlbmluZyB2YWx1ZXMgKHdlIGRvbid0IHdhbnQgdG8gYXBwbHkgaXQgbXVsdGlwbGUgdGltZXMpXG5cbiAgICAgICAgICBwb2ludC54ID0geCA9IHggPiBtYXhYID8gbWF4WCArICh4IC0gbWF4WCkgKiBlZGdlVG9sZXJhbmNlIDogeCA8IG1pblggPyBtaW5YICsgKHggLSBtaW5YKSAqIGVkZ2VUb2xlcmFuY2UgOiB4O1xuICAgICAgICAgIHBvaW50LnkgPSB5ID0geSA+IG1heFkgPyBtYXhZICsgKHkgLSBtYXhZKSAqIGVkZ2VUb2xlcmFuY2UgOiB5IDwgbWluWSA/IG1pblkgKyAoeSAtIG1pblkpICogZWRnZVRvbGVyYW5jZSA6IHk7XG4gICAgICAgICAgcmVzdWx0ID0gc25hcC5jYWxsKHNlbGYsIHBvaW50KTtcblxuICAgICAgICAgIGlmIChyZXN1bHQgIT09IHBvaW50KSB7XG4gICAgICAgICAgICBwb2ludC54ID0gcmVzdWx0Lng7XG4gICAgICAgICAgICBwb2ludC55ID0gcmVzdWx0Lnk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZhY3RvciAhPT0gMSkge1xuICAgICAgICAgICAgcG9pbnQueCAqPSBmYWN0b3I7XG4gICAgICAgICAgICBwb2ludC55ICo9IGZhY3RvcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmFkaXVzIDwgX2JpZ051bSkge1xuICAgICAgICAgICAgZHggPSBwb2ludC54IC0geDtcbiAgICAgICAgICAgIGR5ID0gcG9pbnQueSAtIHk7XG5cbiAgICAgICAgICAgIGlmIChkeCAqIGR4ICsgZHkgKiBkeSA+IHJhZGl1cykge1xuICAgICAgICAgICAgICBwb2ludC54ID0geDtcbiAgICAgICAgICAgICAgcG9pbnQueSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoX2lzQXJyYXkoc25hcCkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgdmFyIGkgPSBzbmFwLmxlbmd0aCxcbiAgICAgICAgICAgICAgY2xvc2VzdCA9IDAsXG4gICAgICAgICAgICAgIG1pbkRpc3QgPSBfYmlnTnVtLFxuICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICBwb2ludCxcbiAgICAgICAgICAgICAgZGlzdDtcblxuICAgICAgICAgIHdoaWxlICgtLWkgPiAtMSkge1xuICAgICAgICAgICAgcG9pbnQgPSBzbmFwW2ldO1xuICAgICAgICAgICAgeCA9IHBvaW50LnggLSBwLng7XG4gICAgICAgICAgICB5ID0gcG9pbnQueSAtIHAueTtcbiAgICAgICAgICAgIGRpc3QgPSB4ICogeCArIHkgKiB5O1xuXG4gICAgICAgICAgICBpZiAoZGlzdCA8IG1pbkRpc3QpIHtcbiAgICAgICAgICAgICAgY2xvc2VzdCA9IGk7XG4gICAgICAgICAgICAgIG1pbkRpc3QgPSBkaXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBtaW5EaXN0IDw9IHJhZGl1cyA/IHNuYXBbY2xvc2VzdF0gOiBwO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9O1xuICAgIH0sXG4gICAgICAgIGNhbGN1bGF0ZUJvdW5kcyA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUJvdW5kcygpIHtcbiAgICAgIHZhciBib3VuZHMsIHRhcmdldEJvdW5kcywgc25hcCwgc25hcElzUmF3O1xuICAgICAgaGFzQm91bmRzID0gZmFsc2U7XG5cbiAgICAgIGlmIChzY3JvbGxQcm94eSkge1xuICAgICAgICBzY3JvbGxQcm94eS5jYWxpYnJhdGUoKTtcbiAgICAgICAgc2VsZi5taW5YID0gbWluWCA9IC1zY3JvbGxQcm94eS5tYXhTY3JvbGxMZWZ0KCk7XG4gICAgICAgIHNlbGYubWluWSA9IG1pblkgPSAtc2Nyb2xsUHJveHkubWF4U2Nyb2xsVG9wKCk7XG4gICAgICAgIHNlbGYubWF4WCA9IG1heFggPSBzZWxmLm1heFkgPSBtYXhZID0gMDtcbiAgICAgICAgaGFzQm91bmRzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoISF2YXJzLmJvdW5kcykge1xuICAgICAgICBib3VuZHMgPSBfZ2V0Qm91bmRzKHZhcnMuYm91bmRzLCB0YXJnZXQucGFyZW50Tm9kZSk7IC8vY291bGQgYmUgYSBzZWxlY3Rvci9qUXVlcnkgb2JqZWN0IG9yIGEgRE9NIGVsZW1lbnQgb3IgYSBnZW5lcmljIG9iamVjdCBsaWtlIHt0b3A6MCwgbGVmdDoxMDAsIHdpZHRoOjEwMDAsIGhlaWdodDo4MDB9IG9yIHttaW5YOjEwMCwgbWF4WDoxMTAwLCBtaW5ZOjAsIG1heFk6ODAwfVxuXG4gICAgICAgIGlmIChyb3RhdGlvbk1vZGUpIHtcbiAgICAgICAgICBzZWxmLm1pblggPSBtaW5YID0gYm91bmRzLmxlZnQ7XG4gICAgICAgICAgc2VsZi5tYXhYID0gbWF4WCA9IGJvdW5kcy5sZWZ0ICsgYm91bmRzLndpZHRoO1xuICAgICAgICAgIHNlbGYubWluWSA9IG1pblkgPSBzZWxmLm1heFkgPSBtYXhZID0gMDtcbiAgICAgICAgfSBlbHNlIGlmICghX2lzVW5kZWZpbmVkKHZhcnMuYm91bmRzLm1heFgpIHx8ICFfaXNVbmRlZmluZWQodmFycy5ib3VuZHMubWF4WSkpIHtcbiAgICAgICAgICBib3VuZHMgPSB2YXJzLmJvdW5kcztcbiAgICAgICAgICBzZWxmLm1pblggPSBtaW5YID0gYm91bmRzLm1pblg7XG4gICAgICAgICAgc2VsZi5taW5ZID0gbWluWSA9IGJvdW5kcy5taW5ZO1xuICAgICAgICAgIHNlbGYubWF4WCA9IG1heFggPSBib3VuZHMubWF4WDtcbiAgICAgICAgICBzZWxmLm1heFkgPSBtYXhZID0gYm91bmRzLm1heFk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0Qm91bmRzID0gX2dldEJvdW5kcyh0YXJnZXQsIHRhcmdldC5wYXJlbnROb2RlKTtcbiAgICAgICAgICBzZWxmLm1pblggPSBtaW5YID0gTWF0aC5yb3VuZChnZXRQcm9wQXNOdW0oeFByb3AsIFwicHhcIikgKyBib3VuZHMubGVmdCAtIHRhcmdldEJvdW5kcy5sZWZ0KTtcbiAgICAgICAgICBzZWxmLm1pblkgPSBtaW5ZID0gTWF0aC5yb3VuZChnZXRQcm9wQXNOdW0oeVByb3AsIFwicHhcIikgKyBib3VuZHMudG9wIC0gdGFyZ2V0Qm91bmRzLnRvcCk7XG4gICAgICAgICAgc2VsZi5tYXhYID0gbWF4WCA9IE1hdGgucm91bmQobWluWCArIChib3VuZHMud2lkdGggLSB0YXJnZXRCb3VuZHMud2lkdGgpKTtcbiAgICAgICAgICBzZWxmLm1heFkgPSBtYXhZID0gTWF0aC5yb3VuZChtaW5ZICsgKGJvdW5kcy5oZWlnaHQgLSB0YXJnZXRCb3VuZHMuaGVpZ2h0KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWluWCA+IG1heFgpIHtcbiAgICAgICAgICBzZWxmLm1pblggPSBtYXhYO1xuICAgICAgICAgIHNlbGYubWF4WCA9IG1heFggPSBtaW5YO1xuICAgICAgICAgIG1pblggPSBzZWxmLm1pblg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWluWSA+IG1heFkpIHtcbiAgICAgICAgICBzZWxmLm1pblkgPSBtYXhZO1xuICAgICAgICAgIHNlbGYubWF4WSA9IG1heFkgPSBtaW5ZO1xuICAgICAgICAgIG1pblkgPSBzZWxmLm1pblk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICAgICAgc2VsZi5taW5Sb3RhdGlvbiA9IG1pblg7XG4gICAgICAgICAgc2VsZi5tYXhSb3RhdGlvbiA9IG1heFg7XG4gICAgICAgIH1cblxuICAgICAgICBoYXNCb3VuZHMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodmFycy5saXZlU25hcCkge1xuICAgICAgICBzbmFwID0gdmFycy5saXZlU25hcCA9PT0gdHJ1ZSA/IHZhcnMuc25hcCB8fCB7fSA6IHZhcnMubGl2ZVNuYXA7XG4gICAgICAgIHNuYXBJc1JhdyA9IF9pc0FycmF5KHNuYXApIHx8IF9pc0Z1bmN0aW9uKHNuYXApO1xuXG4gICAgICAgIGlmIChyb3RhdGlvbk1vZGUpIHtcbiAgICAgICAgICBzbmFwWCA9IGJ1aWxkU25hcEZ1bmMoc25hcElzUmF3ID8gc25hcCA6IHNuYXAucm90YXRpb24sIG1pblgsIG1heFgsIDEpO1xuICAgICAgICAgIHNuYXBZID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc25hcC5wb2ludHMpIHtcbiAgICAgICAgICAgIHNuYXBYWSA9IGJ1aWxkUG9pbnRTbmFwRnVuYyhzbmFwSXNSYXcgPyBzbmFwIDogc25hcC5wb2ludHMsIG1pblgsIG1heFgsIG1pblksIG1heFksIHNuYXAucmFkaXVzLCBzY3JvbGxQcm94eSA/IC0xIDogMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhbGxvd1gpIHtcbiAgICAgICAgICAgICAgc25hcFggPSBidWlsZFNuYXBGdW5jKHNuYXBJc1JhdyA/IHNuYXAgOiBzbmFwLnggfHwgc25hcC5sZWZ0IHx8IHNuYXAuc2Nyb2xsTGVmdCwgbWluWCwgbWF4WCwgc2Nyb2xsUHJveHkgPyAtMSA6IDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYWxsb3dZKSB7XG4gICAgICAgICAgICAgIHNuYXBZID0gYnVpbGRTbmFwRnVuYyhzbmFwSXNSYXcgPyBzbmFwIDogc25hcC55IHx8IHNuYXAudG9wIHx8IHNuYXAuc2Nyb2xsVG9wLCBtaW5ZLCBtYXhZLCBzY3JvbGxQcm94eSA/IC0xIDogMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgb25UaHJvd0NvbXBsZXRlID0gZnVuY3Rpb24gb25UaHJvd0NvbXBsZXRlKCkge1xuICAgICAgc2VsZi5pc1Rocm93aW5nID0gZmFsc2U7XG5cbiAgICAgIF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwidGhyb3djb21wbGV0ZVwiLCBcIm9uVGhyb3dDb21wbGV0ZVwiKTtcbiAgICB9LFxuICAgICAgICBvblRocm93SW50ZXJydXB0ID0gZnVuY3Rpb24gb25UaHJvd0ludGVycnVwdCgpIHtcbiAgICAgIHNlbGYuaXNUaHJvd2luZyA9IGZhbHNlO1xuICAgIH0sXG4gICAgICAgIGFuaW1hdGUgPSBmdW5jdGlvbiBhbmltYXRlKGluZXJ0aWEsIGZvcmNlWmVyb1ZlbG9jaXR5KSB7XG4gICAgICB2YXIgc25hcCwgc25hcElzUmF3LCB0d2Vlbiwgb3ZlcnNob290VG9sZXJhbmNlO1xuXG4gICAgICBpZiAoaW5lcnRpYSAmJiBJbmVydGlhUGx1Z2luKSB7XG4gICAgICAgIGlmIChpbmVydGlhID09PSB0cnVlKSB7XG4gICAgICAgICAgc25hcCA9IHZhcnMuc25hcCB8fCB2YXJzLmxpdmVTbmFwIHx8IHt9O1xuICAgICAgICAgIHNuYXBJc1JhdyA9IF9pc0FycmF5KHNuYXApIHx8IF9pc0Z1bmN0aW9uKHNuYXApO1xuICAgICAgICAgIGluZXJ0aWEgPSB7XG4gICAgICAgICAgICByZXNpc3RhbmNlOiAodmFycy50aHJvd1Jlc2lzdGFuY2UgfHwgdmFycy5yZXNpc3RhbmNlIHx8IDEwMDApIC8gKHJvdGF0aW9uTW9kZSA/IDEwIDogMSlcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHJvdGF0aW9uTW9kZSkge1xuICAgICAgICAgICAgaW5lcnRpYS5yb3RhdGlvbiA9IF9wYXJzZUluZXJ0aWEoc2VsZiwgc25hcElzUmF3ID8gc25hcCA6IHNuYXAucm90YXRpb24sIG1heFgsIG1pblgsIDEsIGZvcmNlWmVyb1ZlbG9jaXR5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGFsbG93WCkge1xuICAgICAgICAgICAgICBpbmVydGlhW3hQcm9wXSA9IF9wYXJzZUluZXJ0aWEoc2VsZiwgc25hcElzUmF3ID8gc25hcCA6IHNuYXAucG9pbnRzIHx8IHNuYXAueCB8fCBzbmFwLmxlZnQsIG1heFgsIG1pblgsIHNjcm9sbFByb3h5ID8gLTEgOiAxLCBmb3JjZVplcm9WZWxvY2l0eSB8fCBzZWxmLmxvY2tlZEF4aXMgPT09IFwieFwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFsbG93WSkge1xuICAgICAgICAgICAgICBpbmVydGlhW3lQcm9wXSA9IF9wYXJzZUluZXJ0aWEoc2VsZiwgc25hcElzUmF3ID8gc25hcCA6IHNuYXAucG9pbnRzIHx8IHNuYXAueSB8fCBzbmFwLnRvcCwgbWF4WSwgbWluWSwgc2Nyb2xsUHJveHkgPyAtMSA6IDEsIGZvcmNlWmVyb1ZlbG9jaXR5IHx8IHNlbGYubG9ja2VkQXhpcyA9PT0gXCJ5XCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc25hcC5wb2ludHMgfHwgX2lzQXJyYXkoc25hcCkgJiYgX2lzT2JqZWN0KHNuYXBbMF0pKSB7XG4gICAgICAgICAgICAgIGluZXJ0aWEubGlua2VkUHJvcHMgPSB4UHJvcCArIFwiLFwiICsgeVByb3A7XG4gICAgICAgICAgICAgIGluZXJ0aWEucmFkaXVzID0gc25hcC5yYWRpdXM7IC8vbm90ZTogd2UgYWxzbyBkaXNhYmxlIGxpdmVTbmFwcGluZyB3aGlsZSB0aHJvd2luZyBpZiB0aGVyZSdzIGEgXCJyYWRpdXNcIiBkZWZpbmVkLCBvdGhlcndpc2UgaXQgbG9va3Mgd2VpcmQgdG8gaGF2ZSB0aGUgaXRlbSB0aHJvd24gcGFzdCBhIHNuYXBwaW5nIHBvaW50IGJ1dCBsaXZlLXNuYXBwaW5nIG1pZC10d2Vlbi4gV2UgZG8gdGhpcyBieSBhbHRlcmluZyB0aGUgb25VcGRhdGVQYXJhbXMgc28gdGhhdCBcInNraXBTbmFwXCIgcGFyYW1ldGVyIGlzIHRydWUgZm9yIHN5bmNYWS5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLmlzVGhyb3dpbmcgPSB0cnVlO1xuICAgICAgICBvdmVyc2hvb3RUb2xlcmFuY2UgPSAhaXNOYU4odmFycy5vdmVyc2hvb3RUb2xlcmFuY2UpID8gdmFycy5vdmVyc2hvb3RUb2xlcmFuY2UgOiB2YXJzLmVkZ2VSZXNpc3RhbmNlID09PSAxID8gMCA6IDEgLSBzZWxmLmVkZ2VSZXNpc3RhbmNlICsgMC4yO1xuXG4gICAgICAgIGlmICghaW5lcnRpYS5kdXJhdGlvbikge1xuICAgICAgICAgIGluZXJ0aWEuZHVyYXRpb24gPSB7XG4gICAgICAgICAgICBtYXg6IE1hdGgubWF4KHZhcnMubWluRHVyYXRpb24gfHwgMCwgXCJtYXhEdXJhdGlvblwiIGluIHZhcnMgPyB2YXJzLm1heER1cmF0aW9uIDogMiksXG4gICAgICAgICAgICBtaW46ICFpc05hTih2YXJzLm1pbkR1cmF0aW9uKSA/IHZhcnMubWluRHVyYXRpb24gOiBvdmVyc2hvb3RUb2xlcmFuY2UgPT09IDAgfHwgX2lzT2JqZWN0KGluZXJ0aWEpICYmIGluZXJ0aWEucmVzaXN0YW5jZSA+IDEwMDAgPyAwIDogMC41LFxuICAgICAgICAgICAgb3ZlcnNob290OiBvdmVyc2hvb3RUb2xlcmFuY2VcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZi50d2VlbiA9IHR3ZWVuID0gZ3NhcC50byhzY3JvbGxQcm94eSB8fCB0YXJnZXQsIHtcbiAgICAgICAgICBpbmVydGlhOiBpbmVydGlhLFxuICAgICAgICAgIGRhdGE6IFwiX2RyYWdnYWJsZVwiLFxuICAgICAgICAgIG9uQ29tcGxldGU6IG9uVGhyb3dDb21wbGV0ZSxcbiAgICAgICAgICBvbkludGVycnVwdDogb25UaHJvd0ludGVycnVwdCxcbiAgICAgICAgICBvblVwZGF0ZTogdmFycy5mYXN0TW9kZSA/IF9kaXNwYXRjaEV2ZW50IDogc3luY1hZLFxuICAgICAgICAgIG9uVXBkYXRlUGFyYW1zOiB2YXJzLmZhc3RNb2RlID8gW3NlbGYsIFwib250aHJvd3VwZGF0ZVwiLCBcIm9uVGhyb3dVcGRhdGVcIl0gOiBzbmFwICYmIHNuYXAucmFkaXVzID8gW2ZhbHNlLCB0cnVlXSA6IFtdXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghdmFycy5mYXN0TW9kZSkge1xuICAgICAgICAgIGlmIChzY3JvbGxQcm94eSkge1xuICAgICAgICAgICAgc2Nyb2xsUHJveHkuX3NraXAgPSB0cnVlOyAvLyBNaWNyb3NvZnQgYnJvd3NlcnMgaGF2ZSBhIGJ1ZyB0aGF0IGNhdXNlcyB0aGVtIHRvIGJyaWVmbHkgcmVuZGVyIHRoZSBwb3NpdGlvbiBpbmNvcnJlY3RseSAoaXQgZmxhc2hlcyB0byB0aGUgZW5kIHN0YXRlIHdoZW4gd2Ugc2VlaygpIHRoZSB0d2VlbiBldmVuIHRob3VnaCB3ZSBqdW1wIHJpZ2h0IGJhY2sgdG8gdGhlIGN1cnJlbnQgcG9zaXRpb24sIGFuZCB0aGlzIG9ubHkgc2VlbXMgdG8gaGFwcGVuIHdoZW4gd2UncmUgYWZmZWN0aW5nIGJvdGggdG9wIGFuZCBsZWZ0KSwgc28gd2Ugc2V0IGEgX3N1c3BlbmRUcmFuc2Zvcm1zIGZsYWcgdG8gcHJldmVudCBpdCBmcm9tIGFjdHVhbGx5IGFwcGx5aW5nIHRoZSB2YWx1ZXMgaW4gdGhlIFNjcm9sbFByb3h5LlxuICAgICAgICAgIH1cblxuICAgICAgICAgIHR3ZWVuLnJlbmRlcigxZTksIHRydWUsIHRydWUpOyAvLyBmb3JjZSB0byB0aGUgZW5kLiBSZW1lbWJlciwgdGhlIGR1cmF0aW9uIHdpbGwgbGlrZWx5IGNoYW5nZSB1cG9uIGluaXR0aW5nIGJlY2F1c2UgdGhhdCdzIHdoZW4gSW5lcnRpYVBsdWdpbiBjYWxjdWxhdGVzIGl0LlxuXG4gICAgICAgICAgc3luY1hZKHRydWUsIHRydWUpO1xuICAgICAgICAgIHNlbGYuZW5kWCA9IHNlbGYueDtcbiAgICAgICAgICBzZWxmLmVuZFkgPSBzZWxmLnk7XG5cbiAgICAgICAgICBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICAgICAgICBzZWxmLmVuZFJvdGF0aW9uID0gc2VsZi54O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHR3ZWVuLnBsYXkoMCk7XG4gICAgICAgICAgc3luY1hZKHRydWUsIHRydWUpO1xuXG4gICAgICAgICAgaWYgKHNjcm9sbFByb3h5KSB7XG4gICAgICAgICAgICBzY3JvbGxQcm94eS5fc2tpcCA9IGZhbHNlOyAvL01pY3Jvc29mdCBicm93c2VycyBoYXZlIGEgYnVnIHRoYXQgY2F1c2VzIHRoZW0gdG8gYnJpZWZseSByZW5kZXIgdGhlIHBvc2l0aW9uIGluY29ycmVjdGx5IChpdCBmbGFzaGVzIHRvIHRoZSBlbmQgc3RhdGUgd2hlbiB3ZSBzZWVrKCkgdGhlIHR3ZWVuIGV2ZW4gdGhvdWdoIHdlIGp1bXAgcmlnaHQgYmFjayB0byB0aGUgY3VycmVudCBwb3NpdGlvbiwgYW5kIHRoaXMgb25seSBzZWVtcyB0byBoYXBwZW4gd2hlbiB3ZSdyZSBhZmZlY3RpbmcgYm90aCB0b3AgYW5kIGxlZnQpLCBzbyB3ZSBzZXQgYSBfc3VzcGVuZFRyYW5zZm9ybXMgZmxhZyB0byBwcmV2ZW50IGl0IGZyb20gYWN0dWFsbHkgYXBwbHlpbmcgdGhlIHZhbHVlcyBpbiB0aGUgU2Nyb2xsUHJveHkuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGhhc0JvdW5kcykge1xuICAgICAgICBzZWxmLmFwcGx5Qm91bmRzKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgdXBkYXRlTWF0cml4ID0gZnVuY3Rpb24gdXBkYXRlTWF0cml4KHNoaWZ0U3RhcnQpIHtcbiAgICAgIHZhciBzdGFydCA9IG1hdHJpeCxcbiAgICAgICAgICBwO1xuICAgICAgbWF0cml4ID0gZ2V0R2xvYmFsTWF0cml4KHRhcmdldC5wYXJlbnROb2RlLCB0cnVlKTtcblxuICAgICAgaWYgKHNoaWZ0U3RhcnQgJiYgc2VsZi5pc1ByZXNzZWQgJiYgIW1hdHJpeC5lcXVhbHMoc3RhcnQgfHwgbmV3IE1hdHJpeDJEKCkpKSB7XG4gICAgICAgIC8vaWYgdGhlIG1hdHJpeCBjaGFuZ2VzIFdISUxFIHRoZSBlbGVtZW50IGlzIHByZXNzZWQsIHdlIG11c3QgYWRqdXN0IHRoZSBzdGFydFBvaW50ZXJYIGFuZCBzdGFydFBvaW50ZXJZIGFjY29yZGluZ2x5LCBzbyB3ZSBpbnZlcnQgdGhlIG9yaWdpbmFsIG1hdHJpeCBhbmQgZmlndXJlIG91dCB3aGVyZSB0aGUgcG9pbnRlclggYW5kIHBvaW50ZXJZIHdlcmUgaW4gdGhlIGdsb2JhbCBzcGFjZSwgdGhlbiBhcHBseSB0aGUgbmV3IG1hdHJpeCB0byBnZXQgdGhlIHVwZGF0ZWQgY29vcmRpbmF0ZXMuXG4gICAgICAgIHAgPSBzdGFydC5pbnZlcnNlKCkuYXBwbHkoe1xuICAgICAgICAgIHg6IHN0YXJ0UG9pbnRlclgsXG4gICAgICAgICAgeTogc3RhcnRQb2ludGVyWVxuICAgICAgICB9KTtcbiAgICAgICAgbWF0cml4LmFwcGx5KHAsIHApO1xuICAgICAgICBzdGFydFBvaW50ZXJYID0gcC54O1xuICAgICAgICBzdGFydFBvaW50ZXJZID0gcC55O1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0cml4LmVxdWFscyhfaWRlbnRpdHlNYXRyaXgpKSB7XG4gICAgICAgIC8vaWYgdGhlcmUgYXJlIG5vIHRyYW5zZm9ybXMsIHdlIGNhbiBvcHRpbWl6ZSBwZXJmb3JtYW5jZSBieSBub3QgZmFjdG9yaW5nIGluIHRoZSBtYXRyaXhcbiAgICAgICAgbWF0cml4ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgICAgICByZWNvcmRTdGFydFBvc2l0aW9ucyA9IGZ1bmN0aW9uIHJlY29yZFN0YXJ0UG9zaXRpb25zKCkge1xuICAgICAgdmFyIGVkZ2VUb2xlcmFuY2UgPSAxIC0gc2VsZi5lZGdlUmVzaXN0YW5jZSxcbiAgICAgICAgICBvZmZzZXRYID0gaXNGaXhlZCA/IF9nZXREb2NTY3JvbGxMZWZ0KG93bmVyRG9jKSA6IDAsXG4gICAgICAgICAgb2Zmc2V0WSA9IGlzRml4ZWQgPyBfZ2V0RG9jU2Nyb2xsVG9wKG93bmVyRG9jKSA6IDAsXG4gICAgICAgICAgcGFyc2VkT3JpZ2luLFxuICAgICAgICAgIHgsXG4gICAgICAgICAgeTtcbiAgICAgIHVwZGF0ZU1hdHJpeChmYWxzZSk7XG4gICAgICBfcG9pbnQxLnggPSBzZWxmLnBvaW50ZXJYIC0gb2Zmc2V0WDtcbiAgICAgIF9wb2ludDEueSA9IHNlbGYucG9pbnRlclkgLSBvZmZzZXRZO1xuICAgICAgbWF0cml4ICYmIG1hdHJpeC5hcHBseShfcG9pbnQxLCBfcG9pbnQxKTtcbiAgICAgIHN0YXJ0UG9pbnRlclggPSBfcG9pbnQxLng7IC8vdHJhbnNsYXRlIHRvIGxvY2FsIGNvb3JkaW5hdGUgc3lzdGVtXG5cbiAgICAgIHN0YXJ0UG9pbnRlclkgPSBfcG9pbnQxLnk7XG5cbiAgICAgIGlmIChkaXJ0eSkge1xuICAgICAgICBzZXRQb2ludGVyUG9zaXRpb24oc2VsZi5wb2ludGVyWCwgc2VsZi5wb2ludGVyWSk7XG4gICAgICAgIHJlbmRlcih0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaW5uZXJNYXRyaXggPSBnZXRHbG9iYWxNYXRyaXgodGFyZ2V0KTtcblxuICAgICAgaWYgKHNjcm9sbFByb3h5KSB7XG4gICAgICAgIGNhbGN1bGF0ZUJvdW5kcygpO1xuICAgICAgICBzdGFydEVsZW1lbnRZID0gc2Nyb2xsUHJveHkudG9wKCk7XG4gICAgICAgIHN0YXJ0RWxlbWVudFggPSBzY3JvbGxQcm94eS5sZWZ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL2lmIHRoZSBlbGVtZW50IGlzIGluIHRoZSBwcm9jZXNzIG9mIHR3ZWVuaW5nLCBkb24ndCBmb3JjZSBzbmFwcGluZyB0byBvY2N1ciBiZWNhdXNlIGl0IGNvdWxkIG1ha2UgaXQganVtcC4gSW1hZ2luZSB0aGUgdXNlciB0aHJvd2luZywgdGhlbiBiZWZvcmUgaXQncyBkb25lLCBjbGlja2luZyBvbiB0aGUgZWxlbWVudCBpbiBpdHMgaW5iZXR3ZWVuIHN0YXRlLlxuICAgICAgICBpZiAoaXNUd2VlbmluZygpKSB7XG4gICAgICAgICAgc3luY1hZKHRydWUsIHRydWUpO1xuICAgICAgICAgIGNhbGN1bGF0ZUJvdW5kcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuYXBwbHlCb3VuZHMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyb3RhdGlvbk1vZGUpIHtcbiAgICAgICAgICBwYXJzZWRPcmlnaW4gPSB0YXJnZXQub3duZXJTVkdFbGVtZW50ID8gW2dzQ2FjaGUueE9yaWdpbiAtIHRhcmdldC5nZXRCQm94KCkueCwgZ3NDYWNoZS55T3JpZ2luIC0gdGFyZ2V0LmdldEJCb3goKS55XSA6IChfZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpW190cmFuc2Zvcm1PcmlnaW5Qcm9wXSB8fCBcIjAgMFwiKS5zcGxpdChcIiBcIik7XG4gICAgICAgICAgcm90YXRpb25PcmlnaW4gPSBzZWxmLnJvdGF0aW9uT3JpZ2luID0gZ2V0R2xvYmFsTWF0cml4KHRhcmdldCkuYXBwbHkoe1xuICAgICAgICAgICAgeDogcGFyc2VGbG9hdChwYXJzZWRPcmlnaW5bMF0pIHx8IDAsXG4gICAgICAgICAgICB5OiBwYXJzZUZsb2F0KHBhcnNlZE9yaWdpblsxXSkgfHwgMFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN5bmNYWSh0cnVlLCB0cnVlKTtcbiAgICAgICAgICB4ID0gc2VsZi5wb2ludGVyWCAtIHJvdGF0aW9uT3JpZ2luLnggLSBvZmZzZXRYO1xuICAgICAgICAgIHkgPSByb3RhdGlvbk9yaWdpbi55IC0gc2VsZi5wb2ludGVyWSArIG9mZnNldFk7XG4gICAgICAgICAgc3RhcnRFbGVtZW50WCA9IHNlbGYueDsgLy9zdGFydGluZyByb3RhdGlvbiAoeCBhbHdheXMgcmVmZXJzIHRvIHJvdGF0aW9uIGluIHR5cGU6XCJyb3RhdGlvblwiLCBtZWFzdXJlZCBpbiBkZWdyZWVzKVxuXG4gICAgICAgICAgc3RhcnRFbGVtZW50WSA9IHNlbGYueSA9IE1hdGguYXRhbjIoeSwgeCkgKiBfUkFEMkRFRztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL3BhcmVudCA9ICFpc0ZpeGVkICYmIHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICAgIC8vc3RhcnRTY3JvbGxUb3AgPSBwYXJlbnQgPyBwYXJlbnQuc2Nyb2xsVG9wIHx8IDAgOiAwO1xuICAgICAgICAgIC8vc3RhcnRTY3JvbGxMZWZ0ID0gcGFyZW50ID8gcGFyZW50LnNjcm9sbExlZnQgfHwgMCA6IDA7XG4gICAgICAgICAgc3RhcnRFbGVtZW50WSA9IGdldFByb3BBc051bSh5UHJvcCwgXCJweFwiKTsgLy9yZWNvcmQgdGhlIHN0YXJ0aW5nIHRvcCBhbmQgbGVmdCB2YWx1ZXMgc28gdGhhdCB3ZSBjYW4ganVzdCBhZGQgdGhlIG1vdXNlJ3MgbW92ZW1lbnQgdG8gdGhlbSBsYXRlci5cblxuICAgICAgICAgIHN0YXJ0RWxlbWVudFggPSBnZXRQcm9wQXNOdW0oeFByb3AsIFwicHhcIik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGhhc0JvdW5kcyAmJiBlZGdlVG9sZXJhbmNlKSB7XG4gICAgICAgIGlmIChzdGFydEVsZW1lbnRYID4gbWF4WCkge1xuICAgICAgICAgIHN0YXJ0RWxlbWVudFggPSBtYXhYICsgKHN0YXJ0RWxlbWVudFggLSBtYXhYKSAvIGVkZ2VUb2xlcmFuY2U7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhcnRFbGVtZW50WCA8IG1pblgpIHtcbiAgICAgICAgICBzdGFydEVsZW1lbnRYID0gbWluWCAtIChtaW5YIC0gc3RhcnRFbGVtZW50WCkgLyBlZGdlVG9sZXJhbmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyb3RhdGlvbk1vZGUpIHtcbiAgICAgICAgICBpZiAoc3RhcnRFbGVtZW50WSA+IG1heFkpIHtcbiAgICAgICAgICAgIHN0YXJ0RWxlbWVudFkgPSBtYXhZICsgKHN0YXJ0RWxlbWVudFkgLSBtYXhZKSAvIGVkZ2VUb2xlcmFuY2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGFydEVsZW1lbnRZIDwgbWluWSkge1xuICAgICAgICAgICAgc3RhcnRFbGVtZW50WSA9IG1pblkgLSAobWluWSAtIHN0YXJ0RWxlbWVudFkpIC8gZWRnZVRvbGVyYW5jZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZi5zdGFydFggPSBzdGFydEVsZW1lbnRYID0gX3JvdW5kKHN0YXJ0RWxlbWVudFgpO1xuICAgICAgc2VsZi5zdGFydFkgPSBzdGFydEVsZW1lbnRZID0gX3JvdW5kKHN0YXJ0RWxlbWVudFkpO1xuICAgIH0sXG4gICAgICAgIGlzVHdlZW5pbmcgPSBmdW5jdGlvbiBpc1R3ZWVuaW5nKCkge1xuICAgICAgcmV0dXJuIHNlbGYudHdlZW4gJiYgc2VsZi50d2Vlbi5pc0FjdGl2ZSgpO1xuICAgIH0sXG4gICAgICAgIHJlbW92ZVBsYWNlaG9sZGVyID0gZnVuY3Rpb24gcmVtb3ZlUGxhY2Vob2xkZXIoKSB7XG4gICAgICBpZiAoX3BsYWNlaG9sZGVyRGl2LnBhcmVudE5vZGUgJiYgIWlzVHdlZW5pbmcoKSAmJiAhc2VsZi5pc0RyYWdnaW5nKSB7XG4gICAgICAgIC8vX3BsYWNlaG9sZGVyRGl2IGp1c3QgcHJvcHMgb3BlbiBhdXRvLXNjcm9sbGluZyBjb250YWluZXJzIHNvIHRoZXkgZG9uJ3QgY29sbGFwc2UgYXMgdGhlIHVzZXIgZHJhZ3MgbGVmdC91cC4gV2UgcmVtb3ZlIGl0IGFmdGVyIGRyYWdnaW5nIChhbmQgdGhyb3dpbmcsIGlmIG5lY2Vzc2FyeSkgZmluaXNoZXMuXG4gICAgICAgIF9wbGFjZWhvbGRlckRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKF9wbGFjZWhvbGRlckRpdik7XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgLy9jYWxsZWQgd2hlbiB0aGUgbW91c2UgaXMgcHJlc3NlZCAob3IgdG91Y2ggc3RhcnRzKVxuICAgIG9uUHJlc3MgPSBmdW5jdGlvbiBvblByZXNzKGUsIGZvcmNlKSB7XG4gICAgICB2YXIgaTtcblxuICAgICAgaWYgKCFlbmFibGVkIHx8IHNlbGYuaXNQcmVzc2VkIHx8ICFlIHx8IChlLnR5cGUgPT09IFwibW91c2Vkb3duXCIgfHwgZS50eXBlID09PSBcInBvaW50ZXJkb3duXCIpICYmICFmb3JjZSAmJiBfZ2V0VGltZSgpIC0gY2xpY2tUaW1lIDwgMzAgJiYgX3RvdWNoRXZlbnRMb29rdXBbc2VsZi5wb2ludGVyRXZlbnQudHlwZV0pIHtcbiAgICAgICAgLy93aGVuIHdlIERPTidUIHByZXZlbnREZWZhdWx0KCkgaW4gb3JkZXIgdG8gYWNjb21tb2RhdGUgdG91Y2gtc2Nyb2xsaW5nIGFuZCB0aGUgdXNlciBqdXN0IHRhcHMsIG1hbnkgYnJvd3NlcnMgYWxzbyBmaXJlIGEgbW91c2Vkb3duL21vdXNldXAgc2VxdWVuY2UgQUZURVIgdGhlIHRvdWNoc3RhcnQvdG91Y2hlbmQgc2VxdWVuY2UsIHRodXMgaXQnZCByZXN1bHQgaW4gdHdvIHF1aWNrIFwiY2xpY2tcIiBldmVudHMgYmVpbmcgZGlzcGF0Y2hlZC4gVGhpcyBsaW5lIHNlbnNlcyB0aGF0IGNvbmRpdGlvbiBhbmQgaGFsdHMgaXQgb24gdGhlIHN1YnNlcXVlbnQgbW91c2Vkb3duLlxuICAgICAgICBpc1ByZXZlbnRpbmdEZWZhdWx0ICYmIGUgJiYgZW5hYmxlZCAmJiBfcHJldmVudERlZmF1bHQoZSk7IC8vIGluIHNvbWUgYnJvd3NlcnMsIHdlIG11c3QgbGlzdGVuIGZvciBtdWx0aXBsZSBldmVudCB0eXBlcyBsaWtlIHRvdWNoc3RhcnQsIHBvaW50ZXJkb3duLCBtb3VzZWRvd24uIFRoZSBmaXJzdCB0aW1lIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkLCB3ZSByZWNvcmQgd2hldGhlciBvciBub3Qgd2UgX3ByZXZlbnREZWZhdWx0KCkgc28gdGhhdCBvbiBkdXBsaWNhdGUgY2FsbHMsIHdlIGNhbiBkbyB0aGUgc2FtZSBpZiBuZWNlc3NhcnkuXG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpbnRlcnJ1cHRlZCA9IGlzVHdlZW5pbmcoKTtcbiAgICAgIHNlbGYucG9pbnRlckV2ZW50ID0gZTtcblxuICAgICAgaWYgKF90b3VjaEV2ZW50TG9va3VwW2UudHlwZV0pIHtcbiAgICAgICAgLy9ub3RlOiBvbiBpT1MsIEJPVEggdG91Y2htb3ZlIGFuZCBtb3VzZW1vdmUgYXJlIGRpc3BhdGNoZWQsIGJ1dCB0aGUgbW91c2Vtb3ZlIGhhcyBwYWdlWSBhbmQgcGFnZVggb2YgMCB3aGljaCB3b3VsZCBtZXNzIHVwIHRoZSBjYWxjdWxhdGlvbnMgYW5kIG5lZWRsZXNzbHkgaHVydCBwZXJmb3JtYW5jZS5cbiAgICAgICAgdG91Y2hFdmVudFRhcmdldCA9IH5lLnR5cGUuaW5kZXhPZihcInRvdWNoXCIpID8gZS5jdXJyZW50VGFyZ2V0IHx8IGUudGFyZ2V0IDogb3duZXJEb2M7IC8vcG9pbnRlci1iYXNlZCB0b3VjaGVzIChmb3IgTWljcm9zb2Z0IGJyb3dzZXJzKSBkb24ndCByZW1haW4gbG9ja2VkIHRvIHRoZSBvcmlnaW5hbCB0YXJnZXQgbGlrZSBvdGhlciBicm93c2Vycywgc28gd2UgbXVzdCB1c2UgdGhlIGRvY3VtZW50IGluc3RlYWQuIFRoZSBldmVudCB0eXBlIHdvdWxkIGJlIFwiTVNQb2ludGVyRG93blwiIG9yIFwicG9pbnRlcmRvd25cIi5cblxuICAgICAgICBfYWRkTGlzdGVuZXIodG91Y2hFdmVudFRhcmdldCwgXCJ0b3VjaGVuZFwiLCBvblJlbGVhc2UpO1xuXG4gICAgICAgIF9hZGRMaXN0ZW5lcih0b3VjaEV2ZW50VGFyZ2V0LCBcInRvdWNobW92ZVwiLCBvbk1vdmUpO1xuXG4gICAgICAgIF9hZGRMaXN0ZW5lcih0b3VjaEV2ZW50VGFyZ2V0LCBcInRvdWNoY2FuY2VsXCIsIG9uUmVsZWFzZSk7XG5cbiAgICAgICAgX2FkZExpc3RlbmVyKG93bmVyRG9jLCBcInRvdWNoc3RhcnRcIiwgX29uTXVsdGlUb3VjaERvY3VtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvdWNoRXZlbnRUYXJnZXQgPSBudWxsO1xuXG4gICAgICAgIF9hZGRMaXN0ZW5lcihvd25lckRvYywgXCJtb3VzZW1vdmVcIiwgb25Nb3ZlKTsgLy9hdHRhY2ggdGhlc2UgdG8gdGhlIGRvY3VtZW50IGluc3RlYWQgb2YgdGhlIGJveCBpdHNlbGYgc28gdGhhdCBpZiB0aGUgdXNlcidzIG1vdXNlIG1vdmVzIHRvbyBxdWlja2x5IChhbmQgb2ZmIG9mIHRoZSBib3gpLCB0aGluZ3Mgc3RpbGwgd29yay5cblxuICAgICAgfVxuXG4gICAgICB0b3VjaERyYWdBeGlzID0gbnVsbDtcblxuICAgICAgaWYgKCFfc3VwcG9ydHNQb2ludGVyIHx8ICF0b3VjaEV2ZW50VGFyZ2V0KSB7XG4gICAgICAgIF9hZGRMaXN0ZW5lcihvd25lckRvYywgXCJtb3VzZXVwXCIsIG9uUmVsZWFzZSk7XG5cbiAgICAgICAgZSAmJiBlLnRhcmdldCAmJiBfYWRkTGlzdGVuZXIoZS50YXJnZXQsIFwibW91c2V1cFwiLCBvblJlbGVhc2UpOyAvL3dlIGFsc28gaGF2ZSB0byBsaXN0ZW4gZGlyZWN0bHkgb24gdGhlIGVsZW1lbnQgYmVjYXVzZSBzb21lIGJyb3dzZXJzIGRvbid0IGJ1YmJsZSB1cCB0aGUgZXZlbnQgdG8gdGhlIF9kb2Mgb24gZWxlbWVudHMgd2l0aCBjb250ZW50RWRpdGFibGU9XCJ0cnVlXCJcbiAgICAgIH1cblxuICAgICAgaXNDbGlja2luZyA9IGlzQ2xpY2thYmxlLmNhbGwoc2VsZiwgZS50YXJnZXQpICYmIHZhcnMuZHJhZ0NsaWNrYWJsZXMgPT09IGZhbHNlICYmICFmb3JjZTtcblxuICAgICAgaWYgKGlzQ2xpY2tpbmcpIHtcbiAgICAgICAgX2FkZExpc3RlbmVyKGUudGFyZ2V0LCBcImNoYW5nZVwiLCBvblJlbGVhc2UpOyAvL2luIHNvbWUgYnJvd3NlcnMsIHdoZW4geW91IG1vdXNlZG93biBvbiBhIDxzZWxlY3Q+IGVsZW1lbnQsIG5vIG1vdXNldXAgZ2V0cyBkaXNwYXRjaGVkISBTbyB3ZSBsaXN0ZW4gZm9yIGEgXCJjaGFuZ2VcIiBldmVudCBpbnN0ZWFkLlxuXG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJwcmVzc0luaXRcIiwgXCJvblByZXNzSW5pdFwiKTtcblxuICAgICAgICBfZGlzcGF0Y2hFdmVudChzZWxmLCBcInByZXNzXCIsIFwib25QcmVzc1wiKTtcblxuICAgICAgICBfc2V0U2VsZWN0YWJsZSh0cmlnZ2VycywgdHJ1ZSk7IC8vYWNjb21tb2RhdGVzIHRoaW5ncyBsaWtlIGlucHV0cyBhbmQgZWxlbWVudHMgd2l0aCBjb250ZW50RWRpdGFibGU9XCJ0cnVlXCIgKG90aGVyd2lzZSB1c2VyIGNvdWxkbid0IGRyYWcgdG8gc2VsZWN0IHRleHQpXG5cblxuICAgICAgICBpc1ByZXZlbnRpbmdEZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYWxsb3dOYXRpdmVUb3VjaFNjcm9sbGluZyA9ICF0b3VjaEV2ZW50VGFyZ2V0IHx8IGFsbG93WCA9PT0gYWxsb3dZIHx8IHNlbGYudmFycy5hbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nID09PSBmYWxzZSB8fCBzZWxmLnZhcnMuYWxsb3dDb250ZXh0TWVudSAmJiBlICYmIChlLmN0cmxLZXkgfHwgZS53aGljaCA+IDIpID8gZmFsc2UgOiBhbGxvd1ggPyBcInlcIiA6IFwieFwiOyAvL25vdGU6IGluIENocm9tZSwgcmlnaHQtY2xpY2tpbmcgKGZvciBhIGNvbnRleHQgbWVudSkgZmlyZXMgb25QcmVzcyBhbmQgaXQgZG9lc24ndCBoYXZlIHRoZSBldmVudC53aGljaCBzZXQgcHJvcGVybHksIHNvIHdlIG11c3QgbG9vayBmb3IgZXZlbnQuY3RybEtleS4gSWYgdGhlIHVzZXIgd2FudHMgdG8gYWxsb3cgY29udGV4dCBtZW51cyB3ZSBzaG91bGQgb2YgY291cnNlIHNlbnNlIGl0IGhlcmUgYW5kIG5vdCBhbGxvdyBuYXRpdmUgdG91Y2ggc2Nyb2xsaW5nLlxuXG4gICAgICBpc1ByZXZlbnRpbmdEZWZhdWx0ID0gIWFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgJiYgIXNlbGYuYWxsb3dFdmVudERlZmF1bHQ7XG5cbiAgICAgIGlmIChpc1ByZXZlbnRpbmdEZWZhdWx0KSB7XG4gICAgICAgIF9wcmV2ZW50RGVmYXVsdChlKTtcblxuICAgICAgICBfYWRkTGlzdGVuZXIoX3dpbiwgXCJ0b3VjaGZvcmNlY2hhbmdlXCIsIF9wcmV2ZW50RGVmYXVsdCk7IC8vd29ya3MgYXJvdW5kIHNhZmFyaSBidWc6IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9mb3J1bXMvdG9waWMvMjE0NTAtZHJhZ2dhYmxlLWluLWlmcmFtZS1vbi1tb2JpbGUtaXMtYnVnZ3kvXG5cbiAgICAgIH1cblxuICAgICAgaWYgKGUuY2hhbmdlZFRvdWNoZXMpIHtcbiAgICAgICAgLy90b3VjaCBldmVudHMgc3RvcmUgdGhlIGRhdGEgc2xpZ2h0bHkgZGlmZmVyZW50bHlcbiAgICAgICAgZSA9IHRvdWNoID0gZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgICAgdG91Y2hJRCA9IGUuaWRlbnRpZmllcjtcbiAgICAgIH0gZWxzZSBpZiAoZS5wb2ludGVySWQpIHtcbiAgICAgICAgdG91Y2hJRCA9IGUucG9pbnRlcklkOyAvL2ZvciBzb21lIE1pY3Jvc29mdCBicm93c2Vyc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG91Y2ggPSB0b3VjaElEID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgX2RyYWdDb3VudCsrO1xuXG4gICAgICBfYWRkVG9SZW5kZXJRdWV1ZShyZW5kZXIpOyAvL2NhdXNlcyB0aGUgRHJhZ2dhYmxlIHRvIHJlbmRlciBvbiBlYWNoIFwidGlja1wiIG9mIFR3ZWVuTGl0ZS50aWNrZXIgKHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiAtIHVwZGF0aW5nIHZhbHVlcyBpbiBhIG1vdXNlbW92ZSBjYW4gY2F1c2UgdGhlbSB0byBoYXBwZW4gdG9vIGZyZXF1ZW50bHksIGxpa2UgbXVsdGlwbGUgdGltZXMgYmV0d2VlbiBmcmFtZSByZWRyYXdzIHdoaWNoIGlzIHdhc3RlZnVsLCBhbmQgaXQgYWxzbyBwcmV2ZW50cyB2YWx1ZXMgZnJvbSB1cGRhdGluZyBwcm9wZXJseSBpbiBJRTgpXG5cblxuICAgICAgc3RhcnRQb2ludGVyWSA9IHNlbGYucG9pbnRlclkgPSBlLnBhZ2VZOyAvL3JlY29yZCB0aGUgc3RhcnRpbmcgeCBhbmQgeSBzbyB0aGF0IHdlIGNhbiBjYWxjdWxhdGUgdGhlIG1vdmVtZW50IGZyb20gdGhlIG9yaWdpbmFsIGluIF9vbk1vdXNlTW92ZVxuXG4gICAgICBzdGFydFBvaW50ZXJYID0gc2VsZi5wb2ludGVyWCA9IGUucGFnZVg7XG5cbiAgICAgIF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwicHJlc3NJbml0XCIsIFwib25QcmVzc0luaXRcIik7XG5cbiAgICAgIGlmIChhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nIHx8IHNlbGYuYXV0b1Njcm9sbCkge1xuICAgICAgICBfcmVjb3JkTWF4U2Nyb2xscyh0YXJnZXQucGFyZW50Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0YXJnZXQucGFyZW50Tm9kZSAmJiBzZWxmLmF1dG9TY3JvbGwgJiYgIXNjcm9sbFByb3h5ICYmICFyb3RhdGlvbk1vZGUgJiYgdGFyZ2V0LnBhcmVudE5vZGUuX2dzTWF4U2Nyb2xsWCAmJiAhX3BsYWNlaG9sZGVyRGl2LnBhcmVudE5vZGUgJiYgIXRhcmdldC5nZXRCQm94KSB7XG4gICAgICAgIC8vYWRkIGEgcGxhY2Vob2xkZXIgZGl2IHRvIHByZXZlbnQgdGhlIHBhcmVudCBjb250YWluZXIgZnJvbSBjb2xsYXBzaW5nIHdoZW4gdGhlIHVzZXIgZHJhZ3MgdGhlIGVsZW1lbnQgbGVmdC5cbiAgICAgICAgX3BsYWNlaG9sZGVyRGl2LnN0eWxlLndpZHRoID0gdGFyZ2V0LnBhcmVudE5vZGUuc2Nyb2xsV2lkdGggKyBcInB4XCI7XG4gICAgICAgIHRhcmdldC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKF9wbGFjZWhvbGRlckRpdik7XG4gICAgICB9XG5cbiAgICAgIHJlY29yZFN0YXJ0UG9zaXRpb25zKCk7XG4gICAgICBzZWxmLnR3ZWVuICYmIHNlbGYudHdlZW4ua2lsbCgpO1xuICAgICAgc2VsZi5pc1Rocm93aW5nID0gZmFsc2U7XG4gICAgICBnc2FwLmtpbGxUd2VlbnNPZihzY3JvbGxQcm94eSB8fCB0YXJnZXQsIGtpbGxQcm9wcywgdHJ1ZSk7IC8vaW4gY2FzZSB0aGUgdXNlciB0cmllcyB0byBkcmFnIGl0IGJlZm9yZSB0aGUgbGFzdCB0d2VlbiBpcyBkb25lLlxuXG4gICAgICBzY3JvbGxQcm94eSAmJiBnc2FwLmtpbGxUd2VlbnNPZih0YXJnZXQsIHtcbiAgICAgICAgc2Nyb2xsVG86IDFcbiAgICAgIH0sIHRydWUpOyAvL2p1c3QgaW4gY2FzZSB0aGUgb3JpZ2luYWwgdGFyZ2V0J3Mgc2Nyb2xsIHBvc2l0aW9uIGlzIGJlaW5nIHR3ZWVuZWQgc29tZXdoZXJlIGVsc2UuXG5cbiAgICAgIHNlbGYudHdlZW4gPSBzZWxmLmxvY2tlZEF4aXMgPSBudWxsO1xuXG4gICAgICBpZiAodmFycy56SW5kZXhCb29zdCB8fCAhcm90YXRpb25Nb2RlICYmICFzY3JvbGxQcm94eSAmJiB2YXJzLnpJbmRleEJvb3N0ICE9PSBmYWxzZSkge1xuICAgICAgICB0YXJnZXQuc3R5bGUuekluZGV4ID0gRHJhZ2dhYmxlLnpJbmRleCsrO1xuICAgICAgfVxuXG4gICAgICBzZWxmLmlzUHJlc3NlZCA9IHRydWU7XG4gICAgICBoYXNEcmFnQ2FsbGJhY2sgPSAhISh2YXJzLm9uRHJhZyB8fCBzZWxmLl9saXN0ZW5lcnMuZHJhZyk7XG4gICAgICBoYXNNb3ZlQ2FsbGJhY2sgPSAhISh2YXJzLm9uTW92ZSB8fCBzZWxmLl9saXN0ZW5lcnMubW92ZSk7XG5cbiAgICAgIGlmICh2YXJzLmN1cnNvciAhPT0gZmFsc2UgfHwgdmFycy5hY3RpdmVDdXJzb3IpIHtcbiAgICAgICAgaSA9IHRyaWdnZXJzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICAgICAgICBnc2FwLnNldCh0cmlnZ2Vyc1tpXSwge1xuICAgICAgICAgICAgY3Vyc29yOiB2YXJzLmFjdGl2ZUN1cnNvciB8fCB2YXJzLmN1cnNvciB8fCAoX2RlZmF1bHRDdXJzb3IgPT09IFwiZ3JhYlwiID8gXCJncmFiYmluZ1wiIDogX2RlZmF1bHRDdXJzb3IpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJwcmVzc1wiLCBcIm9uUHJlc3NcIik7XG4gICAgfSxcbiAgICAgICAgLy9jYWxsZWQgZXZlcnkgdGltZSB0aGUgbW91c2UvdG91Y2ggbW92ZXNcbiAgICBvbk1vdmUgPSBmdW5jdGlvbiBvbk1vdmUoZSkge1xuICAgICAgdmFyIG9yaWdpbmFsRXZlbnQgPSBlLFxuICAgICAgICAgIHRvdWNoZXMsXG4gICAgICAgICAgcG9pbnRlclgsXG4gICAgICAgICAgcG9pbnRlclksXG4gICAgICAgICAgaSxcbiAgICAgICAgICBkeCxcbiAgICAgICAgICBkeTtcblxuICAgICAgaWYgKCFlbmFibGVkIHx8IF9pc011bHRpVG91Y2hpbmcgfHwgIXNlbGYuaXNQcmVzc2VkIHx8ICFlKSB7XG4gICAgICAgIGlzUHJldmVudGluZ0RlZmF1bHQgJiYgZSAmJiBlbmFibGVkICYmIF9wcmV2ZW50RGVmYXVsdChlKTsgLy8gaW4gc29tZSBicm93c2Vycywgd2UgbXVzdCBsaXN0ZW4gZm9yIG11bHRpcGxlIGV2ZW50IHR5cGVzIGxpa2UgdG91Y2htb3ZlLCBwb2ludGVybW92ZSwgbW91c2Vtb3ZlLiBUaGUgZmlyc3QgdGltZSB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCwgd2UgcmVjb3JkIHdoZXRoZXIgb3Igbm90IHdlIF9wcmV2ZW50RGVmYXVsdCgpIHNvIHRoYXQgb24gZHVwbGljYXRlIGNhbGxzLCB3ZSBjYW4gZG8gdGhlIHNhbWUgaWYgbmVjZXNzYXJ5LlxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2VsZi5wb2ludGVyRXZlbnQgPSBlO1xuICAgICAgdG91Y2hlcyA9IGUuY2hhbmdlZFRvdWNoZXM7XG5cbiAgICAgIGlmICh0b3VjaGVzKSB7XG4gICAgICAgIC8vdG91Y2ggZXZlbnRzIHN0b3JlIHRoZSBkYXRhIHNsaWdodGx5IGRpZmZlcmVudGx5XG4gICAgICAgIGUgPSB0b3VjaGVzWzBdO1xuXG4gICAgICAgIGlmIChlICE9PSB0b3VjaCAmJiBlLmlkZW50aWZpZXIgIT09IHRvdWNoSUQpIHtcbiAgICAgICAgICAvL1VzdWFsbHkgY2hhbmdlZFRvdWNoZXNbMF0gd2lsbCBiZSB3aGF0IHdlJ3JlIGxvb2tpbmcgZm9yLCBidXQgaW4gY2FzZSBpdCdzIG5vdCwgbG9vayB0aHJvdWdoIHRoZSByZXN0IG9mIHRoZSBhcnJheS4uLihhbmQgQW5kcm9pZCBicm93c2VycyBkb24ndCByZXVzZSB0aGUgZXZlbnQgbGlrZSBpT1MpXG4gICAgICAgICAgaSA9IHRvdWNoZXMubGVuZ3RoO1xuXG4gICAgICAgICAgd2hpbGUgKC0taSA+IC0xICYmIChlID0gdG91Y2hlc1tpXSkuaWRlbnRpZmllciAhPT0gdG91Y2hJRCAmJiBlLnRhcmdldCAhPT0gdGFyZ2V0KSB7fSAvLyBTb21lIEFuZHJvaWQgZGV2aWNlcyBkaXNwYXRjaCBhIHRvdWNoc3RhcnQgQU5EIHBvaW50ZXJkb3duIGluaXRpYWxseSwgYW5kIHRoZW4gb25seSBwb2ludGVybW92ZSB0aHVzIHRoZSB0b3VjaElEIG1heSBub3QgbWF0Y2ggYmVjYXVzZSBpdCB3YXMgZ3JhYmJlZCBmcm9tIHRoZSB0b3VjaHN0YXJ0IGV2ZW50IHdoZXJlYXMgdGhlIHBvaW50ZXIgZXZlbnQgaXMgdGhlIG9uZSB0aGF0IHRoZSBicm93c2VyIGRpc3BhdGNoZXMgZm9yIG1vdmUsIHNvIGlmIHRoZSBldmVudCB0YXJnZXQgbWF0Y2hlcyB0aGlzIERyYWdnYWJsZSdzIHRhcmdldCwgbGV0IGl0IHRocm91Z2guXG5cblxuICAgICAgICAgIGlmIChpIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlLnBvaW50ZXJJZCAmJiB0b3VjaElEICYmIGUucG9pbnRlcklkICE9PSB0b3VjaElEKSB7XG4gICAgICAgIC8vZm9yIHNvbWUgTWljcm9zb2Z0IGJyb3dzZXJzLCB3ZSBtdXN0IGF0dGFjaCB0aGUgbGlzdGVuZXIgdG8gdGhlIGRvYyByYXRoZXIgdGhhbiB0aGUgdHJpZ2dlciBzbyB0aGF0IHdoZW4gdGhlIGZpbmdlciBtb3ZlcyBvdXRzaWRlIHRoZSBib3VuZHMgb2YgdGhlIHRyaWdnZXIsIHRoaW5ncyBzdGlsbCB3b3JrLiBTbyBpZiB0aGUgZXZlbnQgd2UncmUgcmVjZWl2aW5nIGhhcyBhIHBvaW50ZXJJZCB0aGF0IGRvZXNuJ3QgbWF0Y2ggdGhlIHRvdWNoSUQsIGlnbm9yZSBpdCAoZm9yIG11bHRpLXRvdWNoKVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0b3VjaEV2ZW50VGFyZ2V0ICYmIGFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgJiYgIXRvdWNoRHJhZ0F4aXMpIHtcbiAgICAgICAgLy9BbmRyb2lkIGJyb3dzZXJzIGZvcmNlIHVzIHRvIGRlY2lkZSBvbiB0aGUgZmlyc3QgXCJ0b3VjaG1vdmVcIiBldmVudCBpZiB3ZSBzaG91bGQgYWxsb3cgdGhlIGRlZmF1bHQgKHNjcm9sbGluZykgYmVoYXZpb3Igb3IgcHJldmVudERlZmF1bHQoKS4gT3RoZXJ3aXNlLCBhIFwidG91Y2hjYW5jZWxcIiB3aWxsIGJlIGZpcmVkIGFuZCB0aGVuIG5vIFwidG91Y2htb3ZlXCIgb3IgXCJ0b3VjaGVuZFwiIHdpbGwgZmlyZSBkdXJpbmcgdGhlIHNjcm9sbGluZyAobm8gZ29vZCkuXG4gICAgICAgIF9wb2ludDEueCA9IGUucGFnZVggLSAoaXNGaXhlZCA/IF9nZXREb2NTY3JvbGxMZWZ0KG93bmVyRG9jKSA6IDApO1xuICAgICAgICBfcG9pbnQxLnkgPSBlLnBhZ2VZIC0gKGlzRml4ZWQgPyBfZ2V0RG9jU2Nyb2xsVG9wKG93bmVyRG9jKSA6IDApO1xuICAgICAgICBtYXRyaXggJiYgbWF0cml4LmFwcGx5KF9wb2ludDEsIF9wb2ludDEpO1xuICAgICAgICBwb2ludGVyWCA9IF9wb2ludDEueDtcbiAgICAgICAgcG9pbnRlclkgPSBfcG9pbnQxLnk7XG4gICAgICAgIGR4ID0gTWF0aC5hYnMocG9pbnRlclggLSBzdGFydFBvaW50ZXJYKTtcbiAgICAgICAgZHkgPSBNYXRoLmFicyhwb2ludGVyWSAtIHN0YXJ0UG9pbnRlclkpO1xuXG4gICAgICAgIGlmIChkeCAhPT0gZHkgJiYgKGR4ID4gbWluaW11bU1vdmVtZW50IHx8IGR5ID4gbWluaW11bU1vdmVtZW50KSB8fCBfaXNBbmRyb2lkICYmIGFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgPT09IHRvdWNoRHJhZ0F4aXMpIHtcbiAgICAgICAgICB0b3VjaERyYWdBeGlzID0gZHggPiBkeSAmJiBhbGxvd1ggPyBcInhcIiA6IFwieVwiO1xuXG4gICAgICAgICAgaWYgKGFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgJiYgdG91Y2hEcmFnQXhpcyAhPT0gYWxsb3dOYXRpdmVUb3VjaFNjcm9sbGluZykge1xuICAgICAgICAgICAgX2FkZExpc3RlbmVyKF93aW4sIFwidG91Y2hmb3JjZWNoYW5nZVwiLCBfcHJldmVudERlZmF1bHQpOyAvLyBwcmV2ZW50cyBuYXRpdmUgdG91Y2ggc2Nyb2xsaW5nIGZyb20gdGFraW5nIG92ZXIgaWYgdGhlIHVzZXIgc3RhcnRlZCBkcmFnZ2luZyBpbiB0aGUgb3RoZXIgZGlyZWN0aW9uIGluIGlPUyBTYWZhcmlcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWxmLnZhcnMubG9ja0F4aXNPblRvdWNoU2Nyb2xsICE9PSBmYWxzZSAmJiBhbGxvd1ggJiYgYWxsb3dZKSB7XG4gICAgICAgICAgICBzZWxmLmxvY2tlZEF4aXMgPSB0b3VjaERyYWdBeGlzID09PSBcInhcIiA/IFwieVwiIDogXCJ4XCI7XG4gICAgICAgICAgICBfaXNGdW5jdGlvbihzZWxmLnZhcnMub25Mb2NrQXhpcykgJiYgc2VsZi52YXJzLm9uTG9ja0F4aXMuY2FsbChzZWxmLCBvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX2lzQW5kcm9pZCAmJiBhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nID09PSB0b3VjaERyYWdBeGlzKSB7XG4gICAgICAgICAgICBvblJlbGVhc2Uob3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghc2VsZi5hbGxvd0V2ZW50RGVmYXVsdCAmJiAoIWFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgfHwgdG91Y2hEcmFnQXhpcyAmJiBhbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nICE9PSB0b3VjaERyYWdBeGlzKSAmJiBvcmlnaW5hbEV2ZW50LmNhbmNlbGFibGUgIT09IGZhbHNlKSB7XG4gICAgICAgIF9wcmV2ZW50RGVmYXVsdChvcmlnaW5hbEV2ZW50KTtcblxuICAgICAgICBpc1ByZXZlbnRpbmdEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNQcmV2ZW50aW5nRGVmYXVsdCkge1xuICAgICAgICBpc1ByZXZlbnRpbmdEZWZhdWx0ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLmF1dG9TY3JvbGwpIHtcbiAgICAgICAgY2hlY2tBdXRvU2Nyb2xsQm91bmRzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgc2V0UG9pbnRlclBvc2l0aW9uKGUucGFnZVgsIGUucGFnZVksIGhhc01vdmVDYWxsYmFjayk7XG4gICAgfSxcbiAgICAgICAgc2V0UG9pbnRlclBvc2l0aW9uID0gZnVuY3Rpb24gc2V0UG9pbnRlclBvc2l0aW9uKHBvaW50ZXJYLCBwb2ludGVyWSwgaW52b2tlT25Nb3ZlKSB7XG4gICAgICB2YXIgZHJhZ1RvbGVyYW5jZSA9IDEgLSBzZWxmLmRyYWdSZXNpc3RhbmNlLFxuICAgICAgICAgIGVkZ2VUb2xlcmFuY2UgPSAxIC0gc2VsZi5lZGdlUmVzaXN0YW5jZSxcbiAgICAgICAgICBwcmV2UG9pbnRlclggPSBzZWxmLnBvaW50ZXJYLFxuICAgICAgICAgIHByZXZQb2ludGVyWSA9IHNlbGYucG9pbnRlclksXG4gICAgICAgICAgcHJldlN0YXJ0RWxlbWVudFkgPSBzdGFydEVsZW1lbnRZLFxuICAgICAgICAgIHByZXZYID0gc2VsZi54LFxuICAgICAgICAgIHByZXZZID0gc2VsZi55LFxuICAgICAgICAgIHByZXZFbmRYID0gc2VsZi5lbmRYLFxuICAgICAgICAgIHByZXZFbmRZID0gc2VsZi5lbmRZLFxuICAgICAgICAgIHByZXZFbmRSb3RhdGlvbiA9IHNlbGYuZW5kUm90YXRpb24sXG4gICAgICAgICAgcHJldkRpcnR5ID0gZGlydHksXG4gICAgICAgICAgeENoYW5nZSxcbiAgICAgICAgICB5Q2hhbmdlLFxuICAgICAgICAgIHgsXG4gICAgICAgICAgeSxcbiAgICAgICAgICBkaWYsXG4gICAgICAgICAgdGVtcDtcbiAgICAgIHNlbGYucG9pbnRlclggPSBwb2ludGVyWDtcbiAgICAgIHNlbGYucG9pbnRlclkgPSBwb2ludGVyWTtcblxuICAgICAgaWYgKGlzRml4ZWQpIHtcbiAgICAgICAgcG9pbnRlclggLT0gX2dldERvY1Njcm9sbExlZnQob3duZXJEb2MpO1xuICAgICAgICBwb2ludGVyWSAtPSBfZ2V0RG9jU2Nyb2xsVG9wKG93bmVyRG9jKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJvdGF0aW9uTW9kZSkge1xuICAgICAgICB5ID0gTWF0aC5hdGFuMihyb3RhdGlvbk9yaWdpbi55IC0gcG9pbnRlclksIHBvaW50ZXJYIC0gcm90YXRpb25PcmlnaW4ueCkgKiBfUkFEMkRFRztcbiAgICAgICAgZGlmID0gc2VsZi55IC0geTtcblxuICAgICAgICBpZiAoZGlmID4gMTgwKSB7XG4gICAgICAgICAgc3RhcnRFbGVtZW50WSAtPSAzNjA7XG4gICAgICAgICAgc2VsZi55ID0geTtcbiAgICAgICAgfSBlbHNlIGlmIChkaWYgPCAtMTgwKSB7XG4gICAgICAgICAgc3RhcnRFbGVtZW50WSArPSAzNjA7XG4gICAgICAgICAgc2VsZi55ID0geTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZWxmLnggIT09IHN0YXJ0RWxlbWVudFggfHwgTWF0aC5hYnMoc3RhcnRFbGVtZW50WSAtIHkpID4gbWluaW11bU1vdmVtZW50KSB7XG4gICAgICAgICAgc2VsZi55ID0geTtcbiAgICAgICAgICB4ID0gc3RhcnRFbGVtZW50WCArIChzdGFydEVsZW1lbnRZIC0geSkgKiBkcmFnVG9sZXJhbmNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHggPSBzdGFydEVsZW1lbnRYO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobWF0cml4KSB7XG4gICAgICAgICAgdGVtcCA9IHBvaW50ZXJYICogbWF0cml4LmEgKyBwb2ludGVyWSAqIG1hdHJpeC5jICsgbWF0cml4LmU7XG4gICAgICAgICAgcG9pbnRlclkgPSBwb2ludGVyWCAqIG1hdHJpeC5iICsgcG9pbnRlclkgKiBtYXRyaXguZCArIG1hdHJpeC5mO1xuICAgICAgICAgIHBvaW50ZXJYID0gdGVtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHlDaGFuZ2UgPSBwb2ludGVyWSAtIHN0YXJ0UG9pbnRlclk7XG4gICAgICAgIHhDaGFuZ2UgPSBwb2ludGVyWCAtIHN0YXJ0UG9pbnRlclg7XG5cbiAgICAgICAgaWYgKHlDaGFuZ2UgPCBtaW5pbXVtTW92ZW1lbnQgJiYgeUNoYW5nZSA+IC1taW5pbXVtTW92ZW1lbnQpIHtcbiAgICAgICAgICB5Q2hhbmdlID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh4Q2hhbmdlIDwgbWluaW11bU1vdmVtZW50ICYmIHhDaGFuZ2UgPiAtbWluaW11bU1vdmVtZW50KSB7XG4gICAgICAgICAgeENoYW5nZSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKHNlbGYubG9ja0F4aXMgfHwgc2VsZi5sb2NrZWRBeGlzKSAmJiAoeENoYW5nZSB8fCB5Q2hhbmdlKSkge1xuICAgICAgICAgIHRlbXAgPSBzZWxmLmxvY2tlZEF4aXM7XG5cbiAgICAgICAgICBpZiAoIXRlbXApIHtcbiAgICAgICAgICAgIHNlbGYubG9ja2VkQXhpcyA9IHRlbXAgPSBhbGxvd1ggJiYgTWF0aC5hYnMoeENoYW5nZSkgPiBNYXRoLmFicyh5Q2hhbmdlKSA/IFwieVwiIDogYWxsb3dZID8gXCJ4XCIgOiBudWxsO1xuXG4gICAgICAgICAgICBpZiAodGVtcCAmJiBfaXNGdW5jdGlvbihzZWxmLnZhcnMub25Mb2NrQXhpcykpIHtcbiAgICAgICAgICAgICAgc2VsZi52YXJzLm9uTG9ja0F4aXMuY2FsbChzZWxmLCBzZWxmLnBvaW50ZXJFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRlbXAgPT09IFwieVwiKSB7XG4gICAgICAgICAgICB5Q2hhbmdlID0gMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRlbXAgPT09IFwieFwiKSB7XG4gICAgICAgICAgICB4Q2hhbmdlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB4ID0gX3JvdW5kKHN0YXJ0RWxlbWVudFggKyB4Q2hhbmdlICogZHJhZ1RvbGVyYW5jZSk7XG4gICAgICAgIHkgPSBfcm91bmQoc3RhcnRFbGVtZW50WSArIHlDaGFuZ2UgKiBkcmFnVG9sZXJhbmNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKChzbmFwWCB8fCBzbmFwWSB8fCBzbmFwWFkpICYmIChzZWxmLnggIT09IHggfHwgc2VsZi55ICE9PSB5ICYmICFyb3RhdGlvbk1vZGUpKSB7XG4gICAgICAgIGlmIChzbmFwWFkpIHtcbiAgICAgICAgICBfdGVtcDEueCA9IHg7XG4gICAgICAgICAgX3RlbXAxLnkgPSB5O1xuICAgICAgICAgIHRlbXAgPSBzbmFwWFkoX3RlbXAxKTtcbiAgICAgICAgICB4ID0gX3JvdW5kKHRlbXAueCk7XG4gICAgICAgICAgeSA9IF9yb3VuZCh0ZW1wLnkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNuYXBYKSB7XG4gICAgICAgICAgeCA9IF9yb3VuZChzbmFwWCh4KSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc25hcFkpIHtcbiAgICAgICAgICB5ID0gX3JvdW5kKHNuYXBZKHkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaGFzQm91bmRzKSB7XG4gICAgICAgIGlmICh4ID4gbWF4WCkge1xuICAgICAgICAgIHggPSBtYXhYICsgTWF0aC5yb3VuZCgoeCAtIG1heFgpICogZWRnZVRvbGVyYW5jZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoeCA8IG1pblgpIHtcbiAgICAgICAgICB4ID0gbWluWCArIE1hdGgucm91bmQoKHggLSBtaW5YKSAqIGVkZ2VUb2xlcmFuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFyb3RhdGlvbk1vZGUpIHtcbiAgICAgICAgICBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgICAgIHkgPSBNYXRoLnJvdW5kKG1heFkgKyAoeSAtIG1heFkpICogZWRnZVRvbGVyYW5jZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh5IDwgbWluWSkge1xuICAgICAgICAgICAgeSA9IE1hdGgucm91bmQobWluWSArICh5IC0gbWluWSkgKiBlZGdlVG9sZXJhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYueCAhPT0geCB8fCBzZWxmLnkgIT09IHkgJiYgIXJvdGF0aW9uTW9kZSkge1xuICAgICAgICBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICAgICAgc2VsZi5lbmRSb3RhdGlvbiA9IHNlbGYueCA9IHNlbGYuZW5kWCA9IHg7XG4gICAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChhbGxvd1kpIHtcbiAgICAgICAgICAgIHNlbGYueSA9IHNlbGYuZW5kWSA9IHk7XG4gICAgICAgICAgICBkaXJ0eSA9IHRydWU7IC8vYSBmbGFnIHRoYXQgaW5kaWNhdGVzIHdlIG5lZWQgdG8gcmVuZGVyIHRoZSB0YXJnZXQgbmV4dCB0aW1lIHRoZSBUd2VlbkxpdGUudGlja2VyIGRpc3BhdGNoZXMgYSBcInRpY2tcIiBldmVudCAodHlwaWNhbGx5IG9uIGEgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKSAtIHRoaXMgaXMgYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gKHdlIHNob3VsZG4ndCByZW5kZXIgb24gZXZlcnkgbW92ZSBiZWNhdXNlIHNvbWV0aW1lcyBtYW55IG1vdmUgZXZlbnRzIGNhbiBnZXQgZGlzcGF0Y2hlZCBiZXR3ZWVuIHNjcmVlbiByZWZyZXNoZXMsIGFuZCB0aGF0J2QgYmUgd2FzdGVmdWwgdG8gcmVuZGVyIGV2ZXJ5IHRpbWUpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFsbG93WCkge1xuICAgICAgICAgICAgc2VsZi54ID0gc2VsZi5lbmRYID0geDtcbiAgICAgICAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWludm9rZU9uTW92ZSB8fCBfZGlzcGF0Y2hFdmVudChzZWxmLCBcIm1vdmVcIiwgXCJvbk1vdmVcIikgIT09IGZhbHNlKSB7XG4gICAgICAgICAgaWYgKCFzZWxmLmlzRHJhZ2dpbmcgJiYgc2VsZi5pc1ByZXNzZWQpIHtcbiAgICAgICAgICAgIHNlbGYuaXNEcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwiZHJhZ3N0YXJ0XCIsIFwib25EcmFnU3RhcnRcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vcmV2ZXJ0IGJlY2F1c2UgdGhlIG9uTW92ZSByZXR1cm5lZCBmYWxzZSFcbiAgICAgICAgICBzZWxmLnBvaW50ZXJYID0gcHJldlBvaW50ZXJYO1xuICAgICAgICAgIHNlbGYucG9pbnRlclkgPSBwcmV2UG9pbnRlclk7XG4gICAgICAgICAgc3RhcnRFbGVtZW50WSA9IHByZXZTdGFydEVsZW1lbnRZO1xuICAgICAgICAgIHNlbGYueCA9IHByZXZYO1xuICAgICAgICAgIHNlbGYueSA9IHByZXZZO1xuICAgICAgICAgIHNlbGYuZW5kWCA9IHByZXZFbmRYO1xuICAgICAgICAgIHNlbGYuZW5kWSA9IHByZXZFbmRZO1xuICAgICAgICAgIHNlbGYuZW5kUm90YXRpb24gPSBwcmV2RW5kUm90YXRpb247XG4gICAgICAgICAgZGlydHkgPSBwcmV2RGlydHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICAgICAvL2NhbGxlZCB3aGVuIHRoZSBtb3VzZS90b3VjaCBpcyByZWxlYXNlZFxuICAgIG9uUmVsZWFzZSA9IGZ1bmN0aW9uIG9uUmVsZWFzZShlLCBmb3JjZSkge1xuICAgICAgaWYgKCFlbmFibGVkIHx8ICFzZWxmLmlzUHJlc3NlZCB8fCBlICYmIHRvdWNoSUQgIT0gbnVsbCAmJiAhZm9yY2UgJiYgKGUucG9pbnRlcklkICYmIGUucG9pbnRlcklkICE9PSB0b3VjaElEICYmIGUudGFyZ2V0ICE9PSB0YXJnZXQgfHwgZS5jaGFuZ2VkVG91Y2hlcyAmJiAhX2hhc1RvdWNoSUQoZS5jaGFuZ2VkVG91Y2hlcywgdG91Y2hJRCkpKSB7XG4gICAgICAgIC8vZm9yIHNvbWUgTWljcm9zb2Z0IGJyb3dzZXJzLCB3ZSBtdXN0IGF0dGFjaCB0aGUgbGlzdGVuZXIgdG8gdGhlIGRvYyByYXRoZXIgdGhhbiB0aGUgdHJpZ2dlciBzbyB0aGF0IHdoZW4gdGhlIGZpbmdlciBtb3ZlcyBvdXRzaWRlIHRoZSBib3VuZHMgb2YgdGhlIHRyaWdnZXIsIHRoaW5ncyBzdGlsbCB3b3JrLiBTbyBpZiB0aGUgZXZlbnQgd2UncmUgcmVjZWl2aW5nIGhhcyBhIHBvaW50ZXJJZCB0aGF0IGRvZXNuJ3QgbWF0Y2ggdGhlIHRvdWNoSUQsIGlnbm9yZSBpdCAoZm9yIG11bHRpLXRvdWNoKVxuICAgICAgICBpc1ByZXZlbnRpbmdEZWZhdWx0ICYmIGUgJiYgZW5hYmxlZCAmJiBfcHJldmVudERlZmF1bHQoZSk7IC8vIGluIHNvbWUgYnJvd3NlcnMsIHdlIG11c3QgbGlzdGVuIGZvciBtdWx0aXBsZSBldmVudCB0eXBlcyBsaWtlIHRvdWNoZW5kLCBwb2ludGVydXAsIG1vdXNldXAuIFRoZSBmaXJzdCB0aW1lIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkLCB3ZSByZWNvcmQgd2hldGhlciBvciBub3Qgd2UgX3ByZXZlbnREZWZhdWx0KCkgc28gdGhhdCBvbiBkdXBsaWNhdGUgY2FsbHMsIHdlIGNhbiBkbyB0aGUgc2FtZSBpZiBuZWNlc3NhcnkuXG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZWxmLmlzUHJlc3NlZCA9IGZhbHNlO1xuICAgICAgdmFyIG9yaWdpbmFsRXZlbnQgPSBlLFxuICAgICAgICAgIHdhc0RyYWdnaW5nID0gc2VsZi5pc0RyYWdnaW5nLFxuICAgICAgICAgIGlzQ29udGV4dE1lbnVSZWxlYXNlID0gc2VsZi52YXJzLmFsbG93Q29udGV4dE1lbnUgJiYgZSAmJiAoZS5jdHJsS2V5IHx8IGUud2hpY2ggPiAyKSxcbiAgICAgICAgICBwbGFjZWhvbGRlckRlbGF5ZWRDYWxsID0gZ3NhcC5kZWxheWVkQ2FsbCgwLjAwMSwgcmVtb3ZlUGxhY2Vob2xkZXIpLFxuICAgICAgICAgIHRvdWNoZXMsXG4gICAgICAgICAgaSxcbiAgICAgICAgICBzeW50aGV0aWNFdmVudCxcbiAgICAgICAgICBldmVudFRhcmdldCxcbiAgICAgICAgICBzeW50aGV0aWNDbGljaztcblxuICAgICAgaWYgKHRvdWNoRXZlbnRUYXJnZXQpIHtcbiAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRvdWNoRXZlbnRUYXJnZXQsIFwidG91Y2hlbmRcIiwgb25SZWxlYXNlKTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodG91Y2hFdmVudFRhcmdldCwgXCJ0b3VjaG1vdmVcIiwgb25Nb3ZlKTtcblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodG91Y2hFdmVudFRhcmdldCwgXCJ0b3VjaGNhbmNlbFwiLCBvblJlbGVhc2UpO1xuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcihvd25lckRvYywgXCJ0b3VjaHN0YXJ0XCIsIF9vbk11bHRpVG91Y2hEb2N1bWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIob3duZXJEb2MsIFwibW91c2Vtb3ZlXCIsIG9uTW92ZSk7XG4gICAgICB9XG5cbiAgICAgIF9yZW1vdmVMaXN0ZW5lcihfd2luLCBcInRvdWNoZm9yY2VjaGFuZ2VcIiwgX3ByZXZlbnREZWZhdWx0KTtcblxuICAgICAgaWYgKCFfc3VwcG9ydHNQb2ludGVyIHx8ICF0b3VjaEV2ZW50VGFyZ2V0KSB7XG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcihvd25lckRvYywgXCJtb3VzZXVwXCIsIG9uUmVsZWFzZSk7XG5cbiAgICAgICAgZSAmJiBlLnRhcmdldCAmJiBfcmVtb3ZlTGlzdGVuZXIoZS50YXJnZXQsIFwibW91c2V1cFwiLCBvblJlbGVhc2UpO1xuICAgICAgfVxuXG4gICAgICBkaXJ0eSA9IGZhbHNlO1xuXG4gICAgICBpZiAod2FzRHJhZ2dpbmcpIHtcbiAgICAgICAgZHJhZ0VuZFRpbWUgPSBfbGFzdERyYWdUaW1lID0gX2dldFRpbWUoKTtcbiAgICAgICAgc2VsZi5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0NsaWNraW5nICYmICFpc0NvbnRleHRNZW51UmVsZWFzZSkge1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcihlLnRhcmdldCwgXCJjaGFuZ2VcIiwgb25SZWxlYXNlKTtcblxuICAgICAgICAgIHNlbGYucG9pbnRlckV2ZW50ID0gb3JpZ2luYWxFdmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIF9zZXRTZWxlY3RhYmxlKHRyaWdnZXJzLCBmYWxzZSk7XG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJyZWxlYXNlXCIsIFwib25SZWxlYXNlXCIpO1xuXG4gICAgICAgIF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwiY2xpY2tcIiwgXCJvbkNsaWNrXCIpO1xuXG4gICAgICAgIGlzQ2xpY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfcmVtb3ZlRnJvbVJlbmRlclF1ZXVlKHJlbmRlcik7XG5cbiAgICAgIGkgPSB0cmlnZ2Vycy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgtLWkgPiAtMSkge1xuICAgICAgICBfc2V0U3R5bGUodHJpZ2dlcnNbaV0sIFwiY3Vyc29yXCIsIHZhcnMuY3Vyc29yIHx8ICh2YXJzLmN1cnNvciAhPT0gZmFsc2UgPyBfZGVmYXVsdEN1cnNvciA6IG51bGwpKTtcbiAgICAgIH1cblxuICAgICAgX2RyYWdDb3VudC0tO1xuXG4gICAgICBpZiAoZSkge1xuICAgICAgICB0b3VjaGVzID0gZS5jaGFuZ2VkVG91Y2hlcztcblxuICAgICAgICBpZiAodG91Y2hlcykge1xuICAgICAgICAgIC8vdG91Y2ggZXZlbnRzIHN0b3JlIHRoZSBkYXRhIHNsaWdodGx5IGRpZmZlcmVudGx5XG4gICAgICAgICAgZSA9IHRvdWNoZXNbMF07XG5cbiAgICAgICAgICBpZiAoZSAhPT0gdG91Y2ggJiYgZS5pZGVudGlmaWVyICE9PSB0b3VjaElEKSB7XG4gICAgICAgICAgICAvL1VzdWFsbHkgY2hhbmdlZFRvdWNoZXNbMF0gd2lsbCBiZSB3aGF0IHdlJ3JlIGxvb2tpbmcgZm9yLCBidXQgaW4gY2FzZSBpdCdzIG5vdCwgbG9vayB0aHJvdWdoIHRoZSByZXN0IG9mIHRoZSBhcnJheS4uLihhbmQgQW5kcm9pZCBicm93c2VycyBkb24ndCByZXVzZSB0aGUgZXZlbnQgbGlrZSBpT1MpXG4gICAgICAgICAgICBpID0gdG91Y2hlcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIHdoaWxlICgtLWkgPiAtMSAmJiAoZSA9IHRvdWNoZXNbaV0pLmlkZW50aWZpZXIgIT09IHRvdWNoSUQgJiYgZS50YXJnZXQgIT09IHRhcmdldCkge31cblxuICAgICAgICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLnBvaW50ZXJFdmVudCA9IG9yaWdpbmFsRXZlbnQ7XG4gICAgICAgIHNlbGYucG9pbnRlclggPSBlLnBhZ2VYO1xuICAgICAgICBzZWxmLnBvaW50ZXJZID0gZS5wYWdlWTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzQ29udGV4dE1lbnVSZWxlYXNlICYmIG9yaWdpbmFsRXZlbnQpIHtcbiAgICAgICAgX3ByZXZlbnREZWZhdWx0KG9yaWdpbmFsRXZlbnQpO1xuXG4gICAgICAgIGlzUHJldmVudGluZ0RlZmF1bHQgPSB0cnVlO1xuXG4gICAgICAgIF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwicmVsZWFzZVwiLCBcIm9uUmVsZWFzZVwiKTtcbiAgICAgIH0gZWxzZSBpZiAob3JpZ2luYWxFdmVudCAmJiAhd2FzRHJhZ2dpbmcpIHtcbiAgICAgICAgaXNQcmV2ZW50aW5nRGVmYXVsdCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChpbnRlcnJ1cHRlZCAmJiAodmFycy5zbmFwIHx8IHZhcnMuYm91bmRzKSkge1xuICAgICAgICAgIC8vb3RoZXJ3aXNlLCBpZiB0aGUgdXNlciBjbGlja3Mgb24gdGhlIG9iamVjdCB3aGlsZSBpdCdzIGFuaW1hdGluZyB0byBhIHNuYXBwZWQgcG9zaXRpb24sIGFuZCB0aGVuIHJlbGVhc2VzIHdpdGhvdXQgbW92aW5nIDMgcGl4ZWxzLCBpdCB3aWxsIGp1c3Qgc3RheSB0aGVyZSAoaXQgc2hvdWxkIGFuaW1hdGUvc25hcClcbiAgICAgICAgICBhbmltYXRlKHZhcnMuaW5lcnRpYSB8fCB2YXJzLnRocm93UHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJyZWxlYXNlXCIsIFwib25SZWxlYXNlXCIpO1xuXG4gICAgICAgIGlmICgoIV9pc0FuZHJvaWQgfHwgb3JpZ2luYWxFdmVudC50eXBlICE9PSBcInRvdWNobW92ZVwiKSAmJiBvcmlnaW5hbEV2ZW50LnR5cGUuaW5kZXhPZihcImNhbmNlbFwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAvL3RvIGFjY29tbW9kYXRlIG5hdGl2ZSBzY3JvbGxpbmcgb24gQW5kcm9pZCBkZXZpY2VzLCB3ZSBoYXZlIHRvIGltbWVkaWF0ZWx5IGNhbGwgb25SZWxlYXNlKCkgb24gdGhlIGZpcnN0IHRvdWNobW92ZSBldmVudCwgYnV0IHRoYXQgc2hvdWxkbid0IHRyaWdnZXIgYSBcImNsaWNrXCIuXG4gICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJjbGlja1wiLCBcIm9uQ2xpY2tcIik7XG5cbiAgICAgICAgICBpZiAoX2dldFRpbWUoKSAtIGNsaWNrVGltZSA8IDMwMCkge1xuICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJkb3VibGVjbGlja1wiLCBcIm9uRG91YmxlQ2xpY2tcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXZlbnRUYXJnZXQgPSBvcmlnaW5hbEV2ZW50LnRhcmdldCB8fCB0YXJnZXQ7IC8vb2xkIElFIHVzZXMgc3JjRWxlbWVudFxuXG4gICAgICAgICAgY2xpY2tUaW1lID0gX2dldFRpbWUoKTtcblxuICAgICAgICAgIHN5bnRoZXRpY0NsaWNrID0gZnVuY3Rpb24gc3ludGhldGljQ2xpY2soKSB7XG4gICAgICAgICAgICAvLyBzb21lIGJyb3dzZXJzIChsaWtlIEZpcmVmb3gpIHdvbid0IHRydXN0IHNjcmlwdC1nZW5lcmF0ZWQgY2xpY2tzLCBzbyBpZiB0aGUgdXNlciB0cmllcyB0byBjbGljayBvbiBhIHZpZGVvIHRvIHBsYXkgaXQsIGZvciBleGFtcGxlLCBpdCBzaW1wbHkgd29uJ3Qgd29yay4gU2luY2UgYSByZWd1bGFyIFwiY2xpY2tcIiBldmVudCB3aWxsIG1vc3QgbGlrZWx5IGJlIGdlbmVyYXRlZCBhbnl3YXkgKG9uZSB0aGF0IGhhcyBpdHMgaXNUcnVzdGVkIGZsYWcgc2V0IHRvIHRydWUpLCB3ZSBtdXN0IHNsaWdodGx5IGRlbGF5IG91ciBzY3JpcHQtZ2VuZXJhdGVkIGNsaWNrIHNvIHRoYXQgdGhlIFwicmVhbFwiL3RydXN0ZWQgb25lIGlzIHByaW9yaXRpemVkLiBSZW1lbWJlciwgd2hlbiB0aGVyZSBhcmUgZHVwbGljYXRlIGV2ZW50cyBpbiBxdWljayBzdWNjZXNzaW9uLCB3ZSBzdXBwcmVzcyBhbGwgYnV0IHRoZSBmaXJzdCBvbmUuIFNvbWUgYnJvd3NlcnMgZG9uJ3QgZXZlbiB0cmlnZ2VyIHRoZSBcInJlYWxcIiBvbmUgYXQgYWxsLCBzbyBvdXIgc3ludGhldGljIG9uZSBpcyBhIHNhZmV0eSB2YWx2ZSB0aGF0IGVuc3VyZXMgdGhhdCBubyBtYXR0ZXIgd2hhdCwgYSBjbGljayBldmVudCBkb2VzIGdldCBkaXNwYXRjaGVkLlxuICAgICAgICAgICAgaWYgKGNsaWNrVGltZSAhPT0gY2xpY2tEaXNwYXRjaCAmJiBzZWxmLmVuYWJsZWQoKSAmJiAhc2VsZi5pc1ByZXNzZWQgJiYgIW9yaWdpbmFsRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICBpZiAoZXZlbnRUYXJnZXQuY2xpY2spIHtcbiAgICAgICAgICAgICAgICAvL3NvbWUgYnJvd3NlcnMgKGxpa2UgbW9iaWxlIFNhZmFyaSkgZG9uJ3QgcHJvcGVybHkgdHJpZ2dlciB0aGUgY2xpY2sgZXZlbnRcbiAgICAgICAgICAgICAgICBldmVudFRhcmdldC5jbGljaygpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG93bmVyRG9jLmNyZWF0ZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgc3ludGhldGljRXZlbnQgPSBvd25lckRvYy5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRzXCIpO1xuICAgICAgICAgICAgICAgIHN5bnRoZXRpY0V2ZW50LmluaXRNb3VzZUV2ZW50KFwiY2xpY2tcIiwgdHJ1ZSwgdHJ1ZSwgX3dpbiwgMSwgc2VsZi5wb2ludGVyRXZlbnQuc2NyZWVuWCwgc2VsZi5wb2ludGVyRXZlbnQuc2NyZWVuWSwgc2VsZi5wb2ludGVyWCwgc2VsZi5wb2ludGVyWSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIG51bGwpO1xuICAgICAgICAgICAgICAgIGV2ZW50VGFyZ2V0LmRpc3BhdGNoRXZlbnQoc3ludGhldGljRXZlbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmICghX2lzQW5kcm9pZCAmJiAhb3JpZ2luYWxFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAvL2lPUyBTYWZhcmkgcmVxdWlyZXMgdGhlIHN5bnRoZXRpYyBjbGljayB0byBoYXBwZW4gaW1tZWRpYXRlbHkgb3IgZWxzZSBpdCBzaW1wbHkgd29uJ3Qgd29yaywgYnV0IEFuZHJvaWQgZG9lc24ndCBwbGF5IG5pY2UuXG4gICAgICAgICAgICBnc2FwLmRlbGF5ZWRDYWxsKDAuMDUsIHN5bnRoZXRpY0NsaWNrKTsgLy9pbiBhZGRpdGlvbiB0byB0aGUgaU9TIGJ1ZyB3b3JrYXJvdW5kLCB0aGVyZSdzIGEgRmlyZWZveCBpc3N1ZSB3aXRoIGNsaWNraW5nIG9uIHRoaW5ncyBsaWtlIGEgdmlkZW8gdG8gcGxheSwgc28gd2UgbXVzdCBmYWtlIGEgY2xpY2sgZXZlbnQgaW4gYSBzbGlnaHRseSBkZWxheWVkIGZhc2hpb24uIFByZXZpb3VzbHksIHdlIGxpc3RlbmVkIGZvciB0aGUgXCJjbGlja1wiIGV2ZW50IHdpdGggXCJjYXB0dXJlXCIgZmFsc2Ugd2hpY2ggc29sdmVkIHRoZSB2aWRlby1jbGljay10by1wbGF5IGlzc3VlLCBidXQgaXQgd291bGQgYWxsb3cgdGhlIFwiY2xpY2tcIiBldmVudCB0byBiZSBkaXNwYXRjaGVkIHR3aWNlIGxpa2UgaWYgeW91IHdlcmUgdXNpbmcgYSBqUXVlcnkuY2xpY2soKSBiZWNhdXNlIHRoYXQgd2FzIGhhbmRsZWQgaW4gdGhlIGNhcHR1cmUgcGhhc2UsIHRodXMgd2UgaGFkIHRvIHN3aXRjaCB0byB0aGUgY2FwdHVyZSBwaGFzZSB0byBhdm9pZCB0aGUgZG91YmxlLWRpc3BhdGNoaW5nLCBidXQgZG8gdGhlIGRlbGF5ZWQgc3ludGhldGljIGNsaWNrLiBEb24ndCBmaXJlIGl0IHRvbyBmYXN0IChsaWtlIDAuMDAwMDEpIGJlY2F1c2Ugd2Ugd2FudCB0byBnaXZlIHRoZSBuYXRpdmUgZXZlbnQgYSBjaGFuY2UgdG8gZmlyZSBmaXJzdCBhcyBpdCdzIFwidHJ1c3RlZFwiLlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW5pbWF0ZSh2YXJzLmluZXJ0aWEgfHwgdmFycy50aHJvd1Byb3BzKTsgLy93aWxsIHNraXAgaWYgaW5lcnRpYS90aHJvd1Byb3BzIGlzbid0IGRlZmluZWQgb3IgSW50ZXJ0aWFQbHVnaW4gaXNuJ3QgbG9hZGVkLlxuXG4gICAgICAgIGlmICghc2VsZi5hbGxvd0V2ZW50RGVmYXVsdCAmJiBvcmlnaW5hbEV2ZW50ICYmICh2YXJzLmRyYWdDbGlja2FibGVzICE9PSBmYWxzZSB8fCAhaXNDbGlja2FibGUuY2FsbChzZWxmLCBvcmlnaW5hbEV2ZW50LnRhcmdldCkpICYmIHdhc0RyYWdnaW5nICYmICghYWxsb3dOYXRpdmVUb3VjaFNjcm9sbGluZyB8fCB0b3VjaERyYWdBeGlzICYmIGFsbG93TmF0aXZlVG91Y2hTY3JvbGxpbmcgPT09IHRvdWNoRHJhZ0F4aXMpICYmIG9yaWdpbmFsRXZlbnQuY2FuY2VsYWJsZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBpc1ByZXZlbnRpbmdEZWZhdWx0ID0gdHJ1ZTtcblxuICAgICAgICAgIF9wcmV2ZW50RGVmYXVsdChvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc1ByZXZlbnRpbmdEZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBfZGlzcGF0Y2hFdmVudChzZWxmLCBcInJlbGVhc2VcIiwgXCJvblJlbGVhc2VcIik7XG4gICAgICB9XG5cbiAgICAgIGlzVHdlZW5pbmcoKSAmJiBwbGFjZWhvbGRlckRlbGF5ZWRDYWxsLmR1cmF0aW9uKHNlbGYudHdlZW4uZHVyYXRpb24oKSk7IC8vc3luYyB0aGUgdGltaW5nIHNvIHRoYXQgdGhlIHBsYWNlaG9sZGVyIERJViBnZXRzXG5cbiAgICAgIHdhc0RyYWdnaW5nICYmIF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwiZHJhZ2VuZFwiLCBcIm9uRHJhZ0VuZFwiKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgICAgIHVwZGF0ZVNjcm9sbCA9IGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbChlKSB7XG4gICAgICBpZiAoZSAmJiBzZWxmLmlzRHJhZ2dpbmcgJiYgIXNjcm9sbFByb3h5KSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBlLnRhcmdldCB8fCB0YXJnZXQucGFyZW50Tm9kZSxcbiAgICAgICAgICAgIGRlbHRhWCA9IHBhcmVudC5zY3JvbGxMZWZ0IC0gcGFyZW50Ll9nc1Njcm9sbFgsXG4gICAgICAgICAgICBkZWx0YVkgPSBwYXJlbnQuc2Nyb2xsVG9wIC0gcGFyZW50Ll9nc1Njcm9sbFk7XG5cbiAgICAgICAgaWYgKGRlbHRhWCB8fCBkZWx0YVkpIHtcbiAgICAgICAgICBpZiAobWF0cml4KSB7XG4gICAgICAgICAgICBzdGFydFBvaW50ZXJYIC09IGRlbHRhWCAqIG1hdHJpeC5hICsgZGVsdGFZICogbWF0cml4LmM7XG4gICAgICAgICAgICBzdGFydFBvaW50ZXJZIC09IGRlbHRhWSAqIG1hdHJpeC5kICsgZGVsdGFYICogbWF0cml4LmI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0UG9pbnRlclggLT0gZGVsdGFYO1xuICAgICAgICAgICAgc3RhcnRQb2ludGVyWSAtPSBkZWx0YVk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFyZW50Ll9nc1Njcm9sbFggKz0gZGVsdGFYO1xuICAgICAgICAgIHBhcmVudC5fZ3NTY3JvbGxZICs9IGRlbHRhWTtcbiAgICAgICAgICBzZXRQb2ludGVyUG9zaXRpb24oc2VsZi5wb2ludGVyWCwgc2VsZi5wb2ludGVyWSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICAgICBvbkNsaWNrID0gZnVuY3Rpb24gb25DbGljayhlKSB7XG4gICAgICAvL3RoaXMgd2FzIGEgaHVnZSBwYWluIGluIHRoZSBuZWNrIHRvIGFsaWduIGFsbCB0aGUgdmFyaW91cyBicm93c2VycyBhbmQgdGhlaXIgYmVoYXZpb3JzLiBDaHJvbWUsIEZpcmVmb3gsIFNhZmFyaSwgT3BlcmEsIEFuZHJvaWQsIGFuZCBNaWNyb3NvZnQgRWRnZSBhbGwgaGFuZGxlIGV2ZW50cyBkaWZmZXJlbnRseSEgU29tZSB3aWxsIG9ubHkgdHJpZ2dlciBuYXRpdmUgYmVoYXZpb3IgKGxpa2UgY2hlY2tib3ggdG9nZ2xpbmcpIGZyb20gdHJ1c3RlZCBldmVudHMuIE90aGVycyBkb24ndCBldmVuIHN1cHBvcnQgaXNUcnVzdGVkLCBidXQgcmVxdWlyZSAyIGV2ZW50cyB0byBmbG93IHRocm91Z2ggYmVmb3JlIHRyaWdnZXJpbmcgbmF0aXZlIGJlaGF2aW9yLiBFZGdlIHRyZWF0cyBldmVyeXRoaW5nIGFzIHRydXN0ZWQgYnV0IGFsc28gbWFuZGF0ZXMgdGhhdCAyIGZsb3cgdGhyb3VnaCB0byB0cmlnZ2VyIHRoZSBjb3JyZWN0IG5hdGl2ZSBiZWhhdmlvci5cbiAgICAgIHZhciB0aW1lID0gX2dldFRpbWUoKSxcbiAgICAgICAgICByZWNlbnRseUNsaWNrZWQgPSB0aW1lIC0gY2xpY2tUaW1lIDwgMTAwLFxuICAgICAgICAgIHJlY2VudGx5RHJhZ2dlZCA9IHRpbWUgLSBkcmFnRW5kVGltZSA8IDUwLFxuICAgICAgICAgIGFscmVhZHlEaXNwYXRjaGVkID0gcmVjZW50bHlDbGlja2VkICYmIGNsaWNrRGlzcGF0Y2ggPT09IGNsaWNrVGltZSxcbiAgICAgICAgICBkZWZhdWx0UHJldmVudGVkID0gc2VsZi5wb2ludGVyRXZlbnQgJiYgc2VsZi5wb2ludGVyRXZlbnQuZGVmYXVsdFByZXZlbnRlZCxcbiAgICAgICAgICBhbHJlYWR5RGlzcGF0Y2hlZFRydXN0ZWQgPSByZWNlbnRseUNsaWNrZWQgJiYgdHJ1c3RlZENsaWNrRGlzcGF0Y2ggPT09IGNsaWNrVGltZSxcbiAgICAgICAgICB0cnVzdGVkID0gZS5pc1RydXN0ZWQgfHwgZS5pc1RydXN0ZWQgPT0gbnVsbCAmJiByZWNlbnRseUNsaWNrZWQgJiYgYWxyZWFkeURpc3BhdGNoZWQ7IC8vbm90ZTogU2FmYXJpIGRvZXNuJ3Qgc3VwcG9ydCBpc1RydXN0ZWQsIGFuZCBpdCB3b24ndCBwcm9wZXJseSBleGVjdXRlIG5hdGl2ZSBiZWhhdmlvciAobGlrZSB0b2dnbGluZyBjaGVja2JveGVzKSBvbiB0aGUgZmlyc3Qgc3ludGhldGljIFwiY2xpY2tcIiBldmVudCAtIHdlIG11c3Qgd2FpdCBmb3IgdGhlIDJuZCBhbmQgdHJlYXQgaXQgYXMgdHJ1c3RlZCAoYnV0IHN0b3AgcHJvcGFnYXRpb24gYXQgdGhhdCBwb2ludCkuIENvbmZ1c2luZywgSSBrbm93LiBEb24ndCB5b3UgbG92ZSBjcm9zcy1icm93c2VyIGNvbXBhdGliaWxpdHkgY2hhbGxlbmdlcz9cblxuXG4gICAgICBpZiAoKGFscmVhZHlEaXNwYXRjaGVkIHx8IHJlY2VudGx5RHJhZ2dlZCAmJiBzZWxmLnZhcnMuc3VwcHJlc3NDbGlja09uRHJhZyAhPT0gZmFsc2UpICYmIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKSB7XG4gICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNlbnRseUNsaWNrZWQgJiYgIShzZWxmLnBvaW50ZXJFdmVudCAmJiBzZWxmLnBvaW50ZXJFdmVudC5kZWZhdWx0UHJldmVudGVkKSAmJiAoIWFscmVhZHlEaXNwYXRjaGVkIHx8IHRydXN0ZWQgJiYgIWFscmVhZHlEaXNwYXRjaGVkVHJ1c3RlZCkpIHtcbiAgICAgICAgLy9sZXQgdGhlIGZpcnN0IGNsaWNrIHBhc3MgdGhyb3VnaCB1bmhpbmRlcmVkLiBMZXQgdGhlIG5leHQgb25lIG9ubHkgaWYgaXQncyB0cnVzdGVkLCB0aGVuIG5vIG1vcmUgKHN0b3AgcXVpY2stc3VjY2Vzc2lvbiBvbmVzKVxuICAgICAgICBpZiAodHJ1c3RlZCAmJiBhbHJlYWR5RGlzcGF0Y2hlZCkge1xuICAgICAgICAgIHRydXN0ZWRDbGlja0Rpc3BhdGNoID0gY2xpY2tUaW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xpY2tEaXNwYXRjaCA9IGNsaWNrVGltZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5pc1ByZXNzZWQgfHwgcmVjZW50bHlEcmFnZ2VkIHx8IHJlY2VudGx5Q2xpY2tlZCkge1xuICAgICAgICBpZiAoIXRydXN0ZWQgfHwgIWUuZGV0YWlsIHx8ICFyZWNlbnRseUNsaWNrZWQgfHwgZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIF9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXJlY2VudGx5Q2xpY2tlZCAmJiAhcmVjZW50bHlEcmFnZ2VkKSB7XG4gICAgICAgIC8vIGZvciBzY3JpcHQtdHJpZ2dlcmVkIGV2ZW50IGRpc3BhdGNoZXMsIGxpa2UgZWxlbWVudC5jbGljaygpXG4gICAgICAgIGUgJiYgZS50YXJnZXQgJiYgKHNlbGYucG9pbnRlckV2ZW50ID0gZSk7XG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJjbGlja1wiLCBcIm9uQ2xpY2tcIik7XG4gICAgICB9XG4gICAgfSxcbiAgICAgICAgbG9jYWxpemVQb2ludCA9IGZ1bmN0aW9uIGxvY2FsaXplUG9pbnQocCkge1xuICAgICAgcmV0dXJuIG1hdHJpeCA/IHtcbiAgICAgICAgeDogcC54ICogbWF0cml4LmEgKyBwLnkgKiBtYXRyaXguYyArIG1hdHJpeC5lLFxuICAgICAgICB5OiBwLnggKiBtYXRyaXguYiArIHAueSAqIG1hdHJpeC5kICsgbWF0cml4LmZcbiAgICAgIH0gOiB7XG4gICAgICAgIHg6IHAueCxcbiAgICAgICAgeTogcC55XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBvbGQgPSBEcmFnZ2FibGUuZ2V0KHRhcmdldCk7XG4gICAgb2xkICYmIG9sZC5raWxsKCk7IC8vIGF2b2lkcyBkdXBsaWNhdGVzIChhbiBlbGVtZW50IGNhbiBvbmx5IGJlIGNvbnRyb2xsZWQgYnkgb25lIERyYWdnYWJsZSlcbiAgICAvL2dpdmUgdGhlIHVzZXIgYWNjZXNzIHRvIHN0YXJ0L3N0b3AgZHJhZ2dpbmcuLi5cblxuICAgIF90aGlzMi5zdGFydERyYWcgPSBmdW5jdGlvbiAoZXZlbnQsIGFsaWduKSB7XG4gICAgICB2YXIgcjEsIHIyLCBwMSwgcDI7XG4gICAgICBvblByZXNzKGV2ZW50IHx8IHNlbGYucG9pbnRlckV2ZW50LCB0cnVlKTsgLy9pZiB0aGUgcG9pbnRlciBpc24ndCBvbiB0b3Agb2YgdGhlIGVsZW1lbnQsIGFkanVzdCB0aGluZ3MgYWNjb3JkaW5nbHlcblxuICAgICAgaWYgKGFsaWduICYmICFzZWxmLmhpdFRlc3QoZXZlbnQgfHwgc2VsZi5wb2ludGVyRXZlbnQpKSB7XG4gICAgICAgIHIxID0gX3BhcnNlUmVjdChldmVudCB8fCBzZWxmLnBvaW50ZXJFdmVudCk7XG4gICAgICAgIHIyID0gX3BhcnNlUmVjdCh0YXJnZXQpO1xuICAgICAgICBwMSA9IGxvY2FsaXplUG9pbnQoe1xuICAgICAgICAgIHg6IHIxLmxlZnQgKyByMS53aWR0aCAvIDIsXG4gICAgICAgICAgeTogcjEudG9wICsgcjEuaGVpZ2h0IC8gMlxuICAgICAgICB9KTtcbiAgICAgICAgcDIgPSBsb2NhbGl6ZVBvaW50KHtcbiAgICAgICAgICB4OiByMi5sZWZ0ICsgcjIud2lkdGggLyAyLFxuICAgICAgICAgIHk6IHIyLnRvcCArIHIyLmhlaWdodCAvIDJcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXJ0UG9pbnRlclggLT0gcDEueCAtIHAyLng7XG4gICAgICAgIHN0YXJ0UG9pbnRlclkgLT0gcDEueSAtIHAyLnk7XG4gICAgICB9XG5cbiAgICAgIGlmICghc2VsZi5pc0RyYWdnaW5nKSB7XG4gICAgICAgIHNlbGYuaXNEcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgX2Rpc3BhdGNoRXZlbnQoc2VsZiwgXCJkcmFnc3RhcnRcIiwgXCJvbkRyYWdTdGFydFwiKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMyLmRyYWcgPSBvbk1vdmU7XG5cbiAgICBfdGhpczIuZW5kRHJhZyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICByZXR1cm4gb25SZWxlYXNlKGUgfHwgc2VsZi5wb2ludGVyRXZlbnQsIHRydWUpO1xuICAgIH07XG5cbiAgICBfdGhpczIudGltZVNpbmNlRHJhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBzZWxmLmlzRHJhZ2dpbmcgPyAwIDogKF9nZXRUaW1lKCkgLSBkcmFnRW5kVGltZSkgLyAxMDAwO1xuICAgIH07XG5cbiAgICBfdGhpczIudGltZVNpbmNlQ2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKF9nZXRUaW1lKCkgLSBjbGlja1RpbWUpIC8gMTAwMDtcbiAgICB9O1xuXG4gICAgX3RoaXMyLmhpdFRlc3QgPSBmdW5jdGlvbiAodGFyZ2V0LCB0aHJlc2hvbGQpIHtcbiAgICAgIHJldHVybiBEcmFnZ2FibGUuaGl0VGVzdChzZWxmLnRhcmdldCwgdGFyZ2V0LCB0aHJlc2hvbGQpO1xuICAgIH07XG5cbiAgICBfdGhpczIuZ2V0RGlyZWN0aW9uID0gZnVuY3Rpb24gKGZyb20sIGRpYWdvbmFsVGhyZXNob2xkKSB7XG4gICAgICAvL2Zyb20gY2FuIGJlIFwic3RhcnRcIiAoZGVmYXVsdCksIFwidmVsb2NpdHlcIiwgb3IgYW4gZWxlbWVudFxuICAgICAgdmFyIG1vZGUgPSBmcm9tID09PSBcInZlbG9jaXR5XCIgJiYgSW5lcnRpYVBsdWdpbiA/IGZyb20gOiBfaXNPYmplY3QoZnJvbSkgJiYgIXJvdGF0aW9uTW9kZSA/IFwiZWxlbWVudFwiIDogXCJzdGFydFwiLFxuICAgICAgICAgIHhDaGFuZ2UsXG4gICAgICAgICAgeUNoYW5nZSxcbiAgICAgICAgICByYXRpbyxcbiAgICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgICAgcjEsXG4gICAgICAgICAgcjI7XG5cbiAgICAgIGlmIChtb2RlID09PSBcImVsZW1lbnRcIikge1xuICAgICAgICByMSA9IF9wYXJzZVJlY3Qoc2VsZi50YXJnZXQpO1xuICAgICAgICByMiA9IF9wYXJzZVJlY3QoZnJvbSk7XG4gICAgICB9XG5cbiAgICAgIHhDaGFuZ2UgPSBtb2RlID09PSBcInN0YXJ0XCIgPyBzZWxmLnggLSBzdGFydEVsZW1lbnRYIDogbW9kZSA9PT0gXCJ2ZWxvY2l0eVwiID8gSW5lcnRpYVBsdWdpbi5nZXRWZWxvY2l0eSh0YXJnZXQsIHhQcm9wKSA6IHIxLmxlZnQgKyByMS53aWR0aCAvIDIgLSAocjIubGVmdCArIHIyLndpZHRoIC8gMik7XG5cbiAgICAgIGlmIChyb3RhdGlvbk1vZGUpIHtcbiAgICAgICAgcmV0dXJuIHhDaGFuZ2UgPCAwID8gXCJjb3VudGVyLWNsb2Nrd2lzZVwiIDogXCJjbG9ja3dpc2VcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpYWdvbmFsVGhyZXNob2xkID0gZGlhZ29uYWxUaHJlc2hvbGQgfHwgMjtcbiAgICAgICAgeUNoYW5nZSA9IG1vZGUgPT09IFwic3RhcnRcIiA/IHNlbGYueSAtIHN0YXJ0RWxlbWVudFkgOiBtb2RlID09PSBcInZlbG9jaXR5XCIgPyBJbmVydGlhUGx1Z2luLmdldFZlbG9jaXR5KHRhcmdldCwgeVByb3ApIDogcjEudG9wICsgcjEuaGVpZ2h0IC8gMiAtIChyMi50b3AgKyByMi5oZWlnaHQgLyAyKTtcbiAgICAgICAgcmF0aW8gPSBNYXRoLmFicyh4Q2hhbmdlIC8geUNoYW5nZSk7XG4gICAgICAgIGRpcmVjdGlvbiA9IHJhdGlvIDwgMSAvIGRpYWdvbmFsVGhyZXNob2xkID8gXCJcIiA6IHhDaGFuZ2UgPCAwID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCI7XG5cbiAgICAgICAgaWYgKHJhdGlvIDwgZGlhZ29uYWxUaHJlc2hvbGQpIHtcbiAgICAgICAgICBpZiAoZGlyZWN0aW9uICE9PSBcIlwiKSB7XG4gICAgICAgICAgICBkaXJlY3Rpb24gKz0gXCItXCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlyZWN0aW9uICs9IHlDaGFuZ2UgPCAwID8gXCJ1cFwiIDogXCJkb3duXCI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRpcmVjdGlvbjtcbiAgICB9O1xuXG4gICAgX3RoaXMyLmFwcGx5Qm91bmRzID0gZnVuY3Rpb24gKG5ld0JvdW5kcywgc3RpY2t5KSB7XG4gICAgICB2YXIgeCwgeSwgZm9yY2VaZXJvVmVsb2NpdHksIGUsIHBhcmVudCwgaXNSb290O1xuXG4gICAgICBpZiAobmV3Qm91bmRzICYmIHZhcnMuYm91bmRzICE9PSBuZXdCb3VuZHMpIHtcbiAgICAgICAgdmFycy5ib3VuZHMgPSBuZXdCb3VuZHM7XG4gICAgICAgIHJldHVybiBzZWxmLnVwZGF0ZSh0cnVlLCBzdGlja3kpO1xuICAgICAgfVxuXG4gICAgICBzeW5jWFkodHJ1ZSk7XG4gICAgICBjYWxjdWxhdGVCb3VuZHMoKTtcblxuICAgICAgaWYgKGhhc0JvdW5kcyAmJiAhaXNUd2VlbmluZygpKSB7XG4gICAgICAgIHggPSBzZWxmLng7XG4gICAgICAgIHkgPSBzZWxmLnk7XG5cbiAgICAgICAgaWYgKHggPiBtYXhYKSB7XG4gICAgICAgICAgeCA9IG1heFg7XG4gICAgICAgIH0gZWxzZSBpZiAoeCA8IG1pblgpIHtcbiAgICAgICAgICB4ID0gbWluWDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh5ID4gbWF4WSkge1xuICAgICAgICAgIHkgPSBtYXhZO1xuICAgICAgICB9IGVsc2UgaWYgKHkgPCBtaW5ZKSB7XG4gICAgICAgICAgeSA9IG1pblk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VsZi54ICE9PSB4IHx8IHNlbGYueSAhPT0geSkge1xuICAgICAgICAgIGZvcmNlWmVyb1ZlbG9jaXR5ID0gdHJ1ZTtcbiAgICAgICAgICBzZWxmLnggPSBzZWxmLmVuZFggPSB4O1xuXG4gICAgICAgICAgaWYgKHJvdGF0aW9uTW9kZSkge1xuICAgICAgICAgICAgc2VsZi5lbmRSb3RhdGlvbiA9IHg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYueSA9IHNlbGYuZW5kWSA9IHk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICAgIHJlbmRlcih0cnVlKTtcblxuICAgICAgICAgIGlmIChzZWxmLmF1dG9TY3JvbGwgJiYgIXNlbGYuaXNEcmFnZ2luZykge1xuICAgICAgICAgICAgX3JlY29yZE1heFNjcm9sbHModGFyZ2V0LnBhcmVudE5vZGUpO1xuXG4gICAgICAgICAgICBlID0gdGFyZ2V0O1xuICAgICAgICAgICAgX3dpbmRvd1Byb3h5LnNjcm9sbFRvcCA9IF93aW4ucGFnZVlPZmZzZXQgIT0gbnVsbCA/IF93aW4ucGFnZVlPZmZzZXQgOiBvd25lckRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wICE9IG51bGwgPyBvd25lckRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIDogb3duZXJEb2MuYm9keS5zY3JvbGxUb3A7XG4gICAgICAgICAgICBfd2luZG93UHJveHkuc2Nyb2xsTGVmdCA9IF93aW4ucGFnZVhPZmZzZXQgIT0gbnVsbCA/IF93aW4ucGFnZVhPZmZzZXQgOiBvd25lckRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCAhPSBudWxsID8gb3duZXJEb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgOiBvd25lckRvYy5ib2R5LnNjcm9sbExlZnQ7XG5cbiAgICAgICAgICAgIHdoaWxlIChlICYmICFpc1Jvb3QpIHtcbiAgICAgICAgICAgICAgLy93YWxrIHVwIHRoZSBjaGFpbiBhbmQgc2Vuc2Ugd2hlcmV2ZXIgdGhlIHNjcm9sbFRvcC9zY3JvbGxMZWZ0IGV4Y2VlZHMgdGhlIG1heGltdW0uXG4gICAgICAgICAgICAgIGlzUm9vdCA9IF9pc1Jvb3QoZS5wYXJlbnROb2RlKTtcbiAgICAgICAgICAgICAgcGFyZW50ID0gaXNSb290ID8gX3dpbmRvd1Byb3h5IDogZS5wYXJlbnROb2RlO1xuXG4gICAgICAgICAgICAgIGlmIChhbGxvd1kgJiYgcGFyZW50LnNjcm9sbFRvcCA+IHBhcmVudC5fZ3NNYXhTY3JvbGxZKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LnNjcm9sbFRvcCA9IHBhcmVudC5fZ3NNYXhTY3JvbGxZO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGFsbG93WCAmJiBwYXJlbnQuc2Nyb2xsTGVmdCA+IHBhcmVudC5fZ3NNYXhTY3JvbGxYKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LnNjcm9sbExlZnQgPSBwYXJlbnQuX2dzTWF4U2Nyb2xsWDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGUgPSBwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlbGYuaXNUaHJvd2luZyAmJiAoZm9yY2VaZXJvVmVsb2NpdHkgfHwgc2VsZi5lbmRYID4gbWF4WCB8fCBzZWxmLmVuZFggPCBtaW5YIHx8IHNlbGYuZW5kWSA+IG1heFkgfHwgc2VsZi5lbmRZIDwgbWluWSkpIHtcbiAgICAgICAgICBhbmltYXRlKHZhcnMuaW5lcnRpYSB8fCB2YXJzLnRocm93UHJvcHMsIGZvcmNlWmVyb1ZlbG9jaXR5KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgX3RoaXMyLnVwZGF0ZSA9IGZ1bmN0aW9uIChhcHBseUJvdW5kcywgc3RpY2t5LCBpZ25vcmVFeHRlcm5hbENoYW5nZXMpIHtcbiAgICAgIGlmIChzdGlja3kgJiYgc2VsZi5pc1ByZXNzZWQpIHtcbiAgICAgICAgLy8gaW4gY2FzZSB0aGUgZWxlbWVudCB3YXMgcmVwb3NpdGlvbmVkIGluIHRoZSBkb2N1bWVudCBmbG93LCB0aHVzIGl0cyB4L3kgbWF5IGJlIGlkZW50aWNhbCBidXQgaXRzIHBvc2l0aW9uIGlzIGFjdHVhbGx5IHF1aXRlIGRpZmZlcmVudC5cbiAgICAgICAgdmFyIG0gPSBnZXRHbG9iYWxNYXRyaXgodGFyZ2V0KSxcbiAgICAgICAgICAgIHAgPSBpbm5lck1hdHJpeC5hcHBseSh7XG4gICAgICAgICAgeDogc2VsZi54IC0gc3RhcnRFbGVtZW50WCxcbiAgICAgICAgICB5OiBzZWxmLnkgLSBzdGFydEVsZW1lbnRZXG4gICAgICAgIH0pLFxuICAgICAgICAgICAgbTIgPSBnZXRHbG9iYWxNYXRyaXgodGFyZ2V0LnBhcmVudE5vZGUsIHRydWUpO1xuICAgICAgICBtMi5hcHBseSh7XG4gICAgICAgICAgeDogbS5lIC0gcC54LFxuICAgICAgICAgIHk6IG0uZiAtIHAueVxuICAgICAgICB9LCBwKTtcbiAgICAgICAgc2VsZi54IC09IHAueCAtIG0yLmU7XG4gICAgICAgIHNlbGYueSAtPSBwLnkgLSBtMi5mO1xuICAgICAgICByZW5kZXIodHJ1ZSk7XG4gICAgICAgIHJlY29yZFN0YXJ0UG9zaXRpb25zKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB4ID0gc2VsZi54LFxuICAgICAgICAgIHkgPSBzZWxmLnk7XG4gICAgICB1cGRhdGVNYXRyaXgoIXN0aWNreSk7XG5cbiAgICAgIGlmIChhcHBseUJvdW5kcykge1xuICAgICAgICBzZWxmLmFwcGx5Qm91bmRzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXJ0eSAmJiBpZ25vcmVFeHRlcm5hbENoYW5nZXMgJiYgcmVuZGVyKHRydWUpO1xuICAgICAgICBzeW5jWFkodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGlja3kpIHtcbiAgICAgICAgc2V0UG9pbnRlclBvc2l0aW9uKHNlbGYucG9pbnRlclgsIHNlbGYucG9pbnRlclkpO1xuICAgICAgICBkaXJ0eSAmJiByZW5kZXIodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLmlzUHJlc3NlZCAmJiAhc3RpY2t5ICYmIChhbGxvd1ggJiYgTWF0aC5hYnMoeCAtIHNlbGYueCkgPiAwLjAxIHx8IGFsbG93WSAmJiBNYXRoLmFicyh5IC0gc2VsZi55KSA+IDAuMDEgJiYgIXJvdGF0aW9uTW9kZSkpIHtcbiAgICAgICAgcmVjb3JkU3RhcnRQb3NpdGlvbnMoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGYuYXV0b1Njcm9sbCkge1xuICAgICAgICBfcmVjb3JkTWF4U2Nyb2xscyh0YXJnZXQucGFyZW50Tm9kZSwgc2VsZi5pc0RyYWdnaW5nKTtcblxuICAgICAgICBjaGVja0F1dG9TY3JvbGxCb3VuZHMgPSBzZWxmLmlzRHJhZ2dpbmc7XG4gICAgICAgIHJlbmRlcih0cnVlKTsgLy9pbiBjYXNlIHJlcGFyZW50aW5nIG9jY3VycmVkLlxuXG4gICAgICAgIF9yZW1vdmVTY3JvbGxMaXN0ZW5lcih0YXJnZXQsIHVwZGF0ZVNjcm9sbCk7XG5cbiAgICAgICAgX2FkZFNjcm9sbExpc3RlbmVyKHRhcmdldCwgdXBkYXRlU2Nyb2xsKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIF90aGlzMi5lbmFibGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgdmFyIHNldFZhcnMgPSB7XG4gICAgICAgIGxhenk6IHRydWVcbiAgICAgIH0sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgaSxcbiAgICAgICAgICB0cmlnZ2VyO1xuXG4gICAgICBpZiAodmFycy5jdXJzb3IgIT09IGZhbHNlKSB7XG4gICAgICAgIHNldFZhcnMuY3Vyc29yID0gdmFycy5jdXJzb3IgfHwgX2RlZmF1bHRDdXJzb3I7XG4gICAgICB9XG5cbiAgICAgIGlmIChnc2FwLnV0aWxzLmNoZWNrUHJlZml4KFwidG91Y2hDYWxsb3V0XCIpKSB7XG4gICAgICAgIHNldFZhcnMudG91Y2hDYWxsb3V0ID0gXCJub25lXCI7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlICE9PSBcInNvZnRcIikge1xuICAgICAgICBfc2V0VG91Y2hBY3Rpb25Gb3JBbGxEZXNjZW5kYW50cyh0cmlnZ2VycywgYWxsb3dYID09PSBhbGxvd1kgPyBcIm5vbmVcIiA6IHZhcnMuYWxsb3dOYXRpdmVUb3VjaFNjcm9sbGluZyAmJiB0YXJnZXQuc2Nyb2xsSGVpZ2h0ID09PSB0YXJnZXQuY2xpZW50SGVpZ2h0ID09PSAodGFyZ2V0LnNjcm9sbFdpZHRoID09PSB0YXJnZXQuY2xpZW50SGVpZ2h0KSB8fCB2YXJzLmFsbG93RXZlbnREZWZhdWx0ID8gXCJtYW5pcHVsYXRpb25cIiA6IGFsbG93WCA/IFwicGFuLXlcIiA6IFwicGFuLXhcIik7IC8vIFNvbWUgYnJvd3NlcnMgbGlrZSBJbnRlcm5ldCBFeHBsb3JlciB3aWxsIGZpcmUgYSBwb2ludGVyY2FuY2VsIGV2ZW50IHdoZW4gdGhlIHVzZXIgYXR0ZW1wdHMgdG8gZHJhZyB3aGVuIHRvdWNoQWN0aW9uIGlzIFwibWFuaXB1bGF0ZVwiIGJlY2F1c2UgaXQncyBwZXJjZWl2ZWQgYXMgYSBwYW4uIElmIHRoZSBlbGVtZW50IGhhcyBzY3JvbGxhYmxlIGNvbnRlbnQgaW4gb25seSBvbmUgZGlyZWN0aW9uLCB3ZSBzaG91bGQgdXNlIHBhbi14IG9yIHBhbi15IGFjY29yZGluZ2x5IHNvIHRoYXQgdGhlIHBvaW50ZXJjYW5jZWwgZG9lc24ndCBwcmV2ZW50IGRyYWdnaW5nLlxuXG5cbiAgICAgICAgaSA9IHRyaWdnZXJzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICAgICAgICB0cmlnZ2VyID0gdHJpZ2dlcnNbaV07XG4gICAgICAgICAgX3N1cHBvcnRzUG9pbnRlciB8fCBfYWRkTGlzdGVuZXIodHJpZ2dlciwgXCJtb3VzZWRvd25cIiwgb25QcmVzcyk7XG5cbiAgICAgICAgICBfYWRkTGlzdGVuZXIodHJpZ2dlciwgXCJ0b3VjaHN0YXJ0XCIsIG9uUHJlc3MpO1xuXG4gICAgICAgICAgX2FkZExpc3RlbmVyKHRyaWdnZXIsIFwiY2xpY2tcIiwgb25DbGljaywgdHJ1ZSk7IC8vbm90ZTogdXNlZCB0byBwYXNzIHRydWUgZm9yIGNhcHR1cmUgYnV0IGl0IHByZXZlbnRlZCBjbGljay10by1wbGF5LXZpZGVvIGZ1bmN0aW9uYWxpdHkgaW4gRmlyZWZveC5cblxuXG4gICAgICAgICAgZ3NhcC5zZXQodHJpZ2dlciwgc2V0VmFycyk7XG5cbiAgICAgICAgICBpZiAodHJpZ2dlci5nZXRCQm94ICYmIHRyaWdnZXIub3duZXJTVkdFbGVtZW50KSB7XG4gICAgICAgICAgICAvLyBhIGJ1ZyBpbiBjaHJvbWUgZG9lc24ndCByZXNwZWN0IHRvdWNoLWFjdGlvbiBvbiBTVkcgZWxlbWVudHMgLSBpdCBvbmx5IHdvcmtzIGlmIHdlIHNldCBpdCBvbiB0aGUgcGFyZW50IFNWRy5cbiAgICAgICAgICAgIGdzYXAuc2V0KHRyaWdnZXIub3duZXJTVkdFbGVtZW50LCB7XG4gICAgICAgICAgICAgIHRvdWNoQWN0aW9uOiBhbGxvd1ggPT09IGFsbG93WSA/IFwibm9uZVwiIDogdmFycy5hbGxvd05hdGl2ZVRvdWNoU2Nyb2xsaW5nIHx8IHZhcnMuYWxsb3dFdmVudERlZmF1bHQgPyBcIm1hbmlwdWxhdGlvblwiIDogYWxsb3dYID8gXCJwYW4teVwiIDogXCJwYW4teFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXJzLmFsbG93Q29udGV4dE1lbnUgfHwgX2FkZExpc3RlbmVyKHRyaWdnZXIsIFwiY29udGV4dG1lbnVcIiwgb25Db250ZXh0TWVudSk7XG4gICAgICAgIH1cblxuICAgICAgICBfc2V0U2VsZWN0YWJsZSh0cmlnZ2VycywgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICBfYWRkU2Nyb2xsTGlzdGVuZXIodGFyZ2V0LCB1cGRhdGVTY3JvbGwpO1xuXG4gICAgICBlbmFibGVkID0gdHJ1ZTtcblxuICAgICAgaWYgKEluZXJ0aWFQbHVnaW4gJiYgdHlwZSAhPT0gXCJzb2Z0XCIpIHtcbiAgICAgICAgSW5lcnRpYVBsdWdpbi50cmFjayhzY3JvbGxQcm94eSB8fCB0YXJnZXQsIHh5TW9kZSA/IFwieCx5XCIgOiByb3RhdGlvbk1vZGUgPyBcInJvdGF0aW9uXCIgOiBcInRvcCxsZWZ0XCIpO1xuICAgICAgfVxuXG4gICAgICB0YXJnZXQuX2dzRHJhZ0lEID0gaWQgPSBcImRcIiArIF9sb29rdXBDb3VudCsrO1xuICAgICAgX2xvb2t1cFtpZF0gPSBzZWxmO1xuXG4gICAgICBpZiAoc2Nyb2xsUHJveHkpIHtcbiAgICAgICAgc2Nyb2xsUHJveHkuZW5hYmxlKCk7XG4gICAgICAgIHNjcm9sbFByb3h5LmVsZW1lbnQuX2dzRHJhZ0lEID0gaWQ7XG4gICAgICB9XG5cbiAgICAgICh2YXJzLmJvdW5kcyB8fCByb3RhdGlvbk1vZGUpICYmIHJlY29yZFN0YXJ0UG9zaXRpb25zKCk7XG4gICAgICB2YXJzLmJvdW5kcyAmJiBzZWxmLmFwcGx5Qm91bmRzKCk7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuXG4gICAgX3RoaXMyLmRpc2FibGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgdmFyIGRyYWdnaW5nID0gc2VsZi5pc0RyYWdnaW5nLFxuICAgICAgICAgIGkgPSB0cmlnZ2Vycy5sZW5ndGgsXG4gICAgICAgICAgdHJpZ2dlcjtcblxuICAgICAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgICAgIF9zZXRTdHlsZSh0cmlnZ2Vyc1tpXSwgXCJjdXJzb3JcIiwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlICE9PSBcInNvZnRcIikge1xuICAgICAgICBfc2V0VG91Y2hBY3Rpb25Gb3JBbGxEZXNjZW5kYW50cyh0cmlnZ2VycywgbnVsbCk7XG5cbiAgICAgICAgaSA9IHRyaWdnZXJzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICAgICAgICB0cmlnZ2VyID0gdHJpZ2dlcnNbaV07XG5cbiAgICAgICAgICBfc2V0U3R5bGUodHJpZ2dlciwgXCJ0b3VjaENhbGxvdXRcIiwgbnVsbCk7XG5cbiAgICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodHJpZ2dlciwgXCJtb3VzZWRvd25cIiwgb25QcmVzcyk7XG5cbiAgICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodHJpZ2dlciwgXCJ0b3VjaHN0YXJ0XCIsIG9uUHJlc3MpO1xuXG4gICAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRyaWdnZXIsIFwiY2xpY2tcIiwgb25DbGljayk7XG5cbiAgICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodHJpZ2dlciwgXCJjb250ZXh0bWVudVwiLCBvbkNvbnRleHRNZW51KTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9zZXRTZWxlY3RhYmxlKHRyaWdnZXJzLCB0cnVlKTtcblxuICAgICAgICBpZiAodG91Y2hFdmVudFRhcmdldCkge1xuICAgICAgICAgIF9yZW1vdmVMaXN0ZW5lcih0b3VjaEV2ZW50VGFyZ2V0LCBcInRvdWNoY2FuY2VsXCIsIG9uUmVsZWFzZSk7XG5cbiAgICAgICAgICBfcmVtb3ZlTGlzdGVuZXIodG91Y2hFdmVudFRhcmdldCwgXCJ0b3VjaGVuZFwiLCBvblJlbGVhc2UpO1xuXG4gICAgICAgICAgX3JlbW92ZUxpc3RlbmVyKHRvdWNoRXZlbnRUYXJnZXQsIFwidG91Y2htb3ZlXCIsIG9uTW92ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBfcmVtb3ZlTGlzdGVuZXIob3duZXJEb2MsIFwibW91c2V1cFwiLCBvblJlbGVhc2UpO1xuXG4gICAgICAgIF9yZW1vdmVMaXN0ZW5lcihvd25lckRvYywgXCJtb3VzZW1vdmVcIiwgb25Nb3ZlKTtcbiAgICAgIH1cblxuICAgICAgX3JlbW92ZVNjcm9sbExpc3RlbmVyKHRhcmdldCwgdXBkYXRlU2Nyb2xsKTtcblxuICAgICAgZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgSW5lcnRpYVBsdWdpbiAmJiB0eXBlICE9PSBcInNvZnRcIiAmJiBJbmVydGlhUGx1Z2luLnVudHJhY2soc2Nyb2xsUHJveHkgfHwgdGFyZ2V0LCB4eU1vZGUgPyBcIngseVwiIDogcm90YXRpb25Nb2RlID8gXCJyb3RhdGlvblwiIDogXCJ0b3AsbGVmdFwiKTtcbiAgICAgIHNjcm9sbFByb3h5ICYmIHNjcm9sbFByb3h5LmRpc2FibGUoKTtcblxuICAgICAgX3JlbW92ZUZyb21SZW5kZXJRdWV1ZShyZW5kZXIpO1xuXG4gICAgICBzZWxmLmlzRHJhZ2dpbmcgPSBzZWxmLmlzUHJlc3NlZCA9IGlzQ2xpY2tpbmcgPSBmYWxzZTtcbiAgICAgIGRyYWdnaW5nICYmIF9kaXNwYXRjaEV2ZW50KHNlbGYsIFwiZHJhZ2VuZFwiLCBcIm9uRHJhZ0VuZFwiKTtcbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG5cbiAgICBfdGhpczIuZW5hYmxlZCA9IGZ1bmN0aW9uICh2YWx1ZSwgdHlwZSkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB2YWx1ZSA/IHNlbGYuZW5hYmxlKHR5cGUpIDogc2VsZi5kaXNhYmxlKHR5cGUpIDogZW5hYmxlZDtcbiAgICB9O1xuXG4gICAgX3RoaXMyLmtpbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzZWxmLmlzVGhyb3dpbmcgPSBmYWxzZTtcbiAgICAgIHNlbGYudHdlZW4gJiYgc2VsZi50d2Vlbi5raWxsKCk7XG4gICAgICBzZWxmLmRpc2FibGUoKTtcbiAgICAgIGdzYXAuc2V0KHRyaWdnZXJzLCB7XG4gICAgICAgIGNsZWFyUHJvcHM6IFwidXNlclNlbGVjdFwiXG4gICAgICB9KTtcbiAgICAgIGRlbGV0ZSBfbG9va3VwW3RhcmdldC5fZ3NEcmFnSURdO1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcblxuICAgIGlmICh+dHlwZS5pbmRleE9mKFwic2Nyb2xsXCIpKSB7XG4gICAgICBzY3JvbGxQcm94eSA9IF90aGlzMi5zY3JvbGxQcm94eSA9IG5ldyBTY3JvbGxQcm94eSh0YXJnZXQsIF9leHRlbmQoe1xuICAgICAgICBvbktpbGw6IGZ1bmN0aW9uIG9uS2lsbCgpIHtcbiAgICAgICAgICAvL1Njcm9sbFByb3h5J3Mgb25LaWxsKCkgZ2V0cyBjYWxsZWQgaWYvd2hlbiB0aGUgU2Nyb2xsUHJveHkgc2Vuc2VzIHRoYXQgdGhlIHVzZXIgaW50ZXJhY3RlZCB3aXRoIHRoZSBzY3JvbGwgcG9zaXRpb24gbWFudWFsbHkgKGxpa2UgdXNpbmcgdGhlIHNjcm9sbGJhcikuIElFOSBkb2Vzbid0IGZpcmUgdGhlIFwibW91c2V1cFwiIHByb3Blcmx5IHdoZW4gdXNlcnMgZHJhZyB0aGUgc2Nyb2xsYmFyIG9mIGFuIGVsZW1lbnQsIHNvIHRoaXMgd29ya3MgYXJvdW5kIHRoYXQgaXNzdWUuXG4gICAgICAgICAgc2VsZi5pc1ByZXNzZWQgJiYgb25SZWxlYXNlKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9LCB2YXJzKSk7IC8vYSBidWcgaW4gbWFueSBBbmRyb2lkIGRldmljZXMnIHN0b2NrIGJyb3dzZXIgY2F1c2VzIHNjcm9sbFRvcCB0byBnZXQgZm9yY2VkIGJhY2sgdG8gMCBhZnRlciBpdCBpcyBhbHRlcmVkIHZpYSBKUywgc28gd2Ugc2V0IG92ZXJmbG93IHRvIFwiaGlkZGVuXCIgb24gbW9iaWxlL3RvdWNoIGRldmljZXMgKHRoZXkgaGlkZSB0aGUgc2Nyb2xsIGJhciBhbnl3YXkpLiBUaGF0IHdvcmtzIGFyb3VuZCB0aGUgYnVnLiAoVGhpcyBidWcgaXMgZGlzY3Vzc2VkIGF0IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvYW5kcm9pZC9pc3N1ZXMvZGV0YWlsP2lkPTE5NjI1KVxuXG4gICAgICB0YXJnZXQuc3R5bGUub3ZlcmZsb3dZID0gYWxsb3dZICYmICFfaXNUb3VjaERldmljZSA/IFwiYXV0b1wiIDogXCJoaWRkZW5cIjtcbiAgICAgIHRhcmdldC5zdHlsZS5vdmVyZmxvd1ggPSBhbGxvd1ggJiYgIV9pc1RvdWNoRGV2aWNlID8gXCJhdXRvXCIgOiBcImhpZGRlblwiO1xuICAgICAgdGFyZ2V0ID0gc2Nyb2xsUHJveHkuY29udGVudDtcbiAgICB9XG5cbiAgICBpZiAocm90YXRpb25Nb2RlKSB7XG4gICAgICBraWxsUHJvcHMucm90YXRpb24gPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYWxsb3dYKSB7XG4gICAgICAgIGtpbGxQcm9wc1t4UHJvcF0gPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWxsb3dZKSB7XG4gICAgICAgIGtpbGxQcm9wc1t5UHJvcF0gPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGdzQ2FjaGUuZm9yY2UzRCA9IFwiZm9yY2UzRFwiIGluIHZhcnMgPyB2YXJzLmZvcmNlM0QgOiB0cnVlOyAvL290aGVyd2lzZSwgbm9ybWFsIGRyYWdnaW5nIHdvdWxkIGJlIGluIDJEIGFuZCB0aGVuIGFzIHNvb24gYXMgaXQncyByZWxlYXNlZCBhbmQgdGhlcmUncyBhbiBpbmVydGlhIHR3ZWVuLCBpdCdkIGp1bXAgdG8gM0Qgd2hpY2ggY2FuIGNyZWF0ZSBhbiBpbml0aWFsIGp1bXAgZHVlIHRvIHRoZSB3b3JrIHRoZSBicm93c2VyIG11c3QgdG8gZG8gbGF5ZXJpemUgaXQuXG5cbiAgICBfdGhpczIuZW5hYmxlKCk7XG5cbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG5cbiAgRHJhZ2dhYmxlLnJlZ2lzdGVyID0gZnVuY3Rpb24gcmVnaXN0ZXIoY29yZSkge1xuICAgIGdzYXAgPSBjb3JlO1xuXG4gICAgX2luaXRDb3JlKCk7XG4gIH07XG5cbiAgRHJhZ2dhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSh0YXJnZXRzLCB2YXJzKSB7XG4gICAgX2NvcmVJbml0dGVkIHx8IF9pbml0Q29yZSh0cnVlKTtcbiAgICByZXR1cm4gX3RvQXJyYXkodGFyZ2V0cykubWFwKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIHJldHVybiBuZXcgRHJhZ2dhYmxlKHRhcmdldCwgdmFycyk7XG4gICAgfSk7XG4gIH07XG5cbiAgRHJhZ2dhYmxlLmdldCA9IGZ1bmN0aW9uIGdldCh0YXJnZXQpIHtcbiAgICByZXR1cm4gX2xvb2t1cFsoX3RvQXJyYXkodGFyZ2V0KVswXSB8fCB7fSkuX2dzRHJhZ0lEXTtcbiAgfTtcblxuICBEcmFnZ2FibGUudGltZVNpbmNlRHJhZyA9IGZ1bmN0aW9uIHRpbWVTaW5jZURyYWcoKSB7XG4gICAgcmV0dXJuIChfZ2V0VGltZSgpIC0gX2xhc3REcmFnVGltZSkgLyAxMDAwO1xuICB9O1xuXG4gIERyYWdnYWJsZS5oaXRUZXN0ID0gZnVuY3Rpb24gaGl0VGVzdChvYmoxLCBvYmoyLCB0aHJlc2hvbGQpIHtcbiAgICBpZiAob2JqMSA9PT0gb2JqMikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciByMSA9IF9wYXJzZVJlY3Qob2JqMSksXG4gICAgICAgIHIyID0gX3BhcnNlUmVjdChvYmoyKSxcbiAgICAgICAgdG9wID0gcjEudG9wLFxuICAgICAgICBsZWZ0ID0gcjEubGVmdCxcbiAgICAgICAgcmlnaHQgPSByMS5yaWdodCxcbiAgICAgICAgYm90dG9tID0gcjEuYm90dG9tLFxuICAgICAgICB3aWR0aCA9IHIxLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSByMS5oZWlnaHQsXG4gICAgICAgIGlzT3V0c2lkZSA9IHIyLmxlZnQgPiByaWdodCB8fCByMi5yaWdodCA8IGxlZnQgfHwgcjIudG9wID4gYm90dG9tIHx8IHIyLmJvdHRvbSA8IHRvcCxcbiAgICAgICAgb3ZlcmxhcCxcbiAgICAgICAgYXJlYSxcbiAgICAgICAgaXNSYXRpbztcblxuICAgIGlmIChpc091dHNpZGUgfHwgIXRocmVzaG9sZCkge1xuICAgICAgcmV0dXJuICFpc091dHNpZGU7XG4gICAgfVxuXG4gICAgaXNSYXRpbyA9ICh0aHJlc2hvbGQgKyBcIlwiKS5pbmRleE9mKFwiJVwiKSAhPT0gLTE7XG4gICAgdGhyZXNob2xkID0gcGFyc2VGbG9hdCh0aHJlc2hvbGQpIHx8IDA7XG4gICAgb3ZlcmxhcCA9IHtcbiAgICAgIGxlZnQ6IE1hdGgubWF4KGxlZnQsIHIyLmxlZnQpLFxuICAgICAgdG9wOiBNYXRoLm1heCh0b3AsIHIyLnRvcClcbiAgICB9O1xuICAgIG92ZXJsYXAud2lkdGggPSBNYXRoLm1pbihyaWdodCwgcjIucmlnaHQpIC0gb3ZlcmxhcC5sZWZ0O1xuICAgIG92ZXJsYXAuaGVpZ2h0ID0gTWF0aC5taW4oYm90dG9tLCByMi5ib3R0b20pIC0gb3ZlcmxhcC50b3A7XG5cbiAgICBpZiAob3ZlcmxhcC53aWR0aCA8IDAgfHwgb3ZlcmxhcC5oZWlnaHQgPCAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGlzUmF0aW8pIHtcbiAgICAgIHRocmVzaG9sZCAqPSAwLjAxO1xuICAgICAgYXJlYSA9IG92ZXJsYXAud2lkdGggKiBvdmVybGFwLmhlaWdodDtcbiAgICAgIHJldHVybiBhcmVhID49IHdpZHRoICogaGVpZ2h0ICogdGhyZXNob2xkIHx8IGFyZWEgPj0gcjIud2lkdGggKiByMi5oZWlnaHQgKiB0aHJlc2hvbGQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG92ZXJsYXAud2lkdGggPiB0aHJlc2hvbGQgJiYgb3ZlcmxhcC5oZWlnaHQgPiB0aHJlc2hvbGQ7XG4gIH07XG5cbiAgcmV0dXJuIERyYWdnYWJsZTtcbn0oRXZlbnREaXNwYXRjaGVyKTtcblxuX3NldERlZmF1bHRzKERyYWdnYWJsZS5wcm90b3R5cGUsIHtcbiAgcG9pbnRlclg6IDAsXG4gIHBvaW50ZXJZOiAwLFxuICBzdGFydFg6IDAsXG4gIHN0YXJ0WTogMCxcbiAgZGVsdGFYOiAwLFxuICBkZWx0YVk6IDAsXG4gIGlzRHJhZ2dpbmc6IGZhbHNlLFxuICBpc1ByZXNzZWQ6IGZhbHNlXG59KTtcblxuRHJhZ2dhYmxlLnpJbmRleCA9IDEwMDA7XG5EcmFnZ2FibGUudmVyc2lvbiA9IFwiMy45LjFcIjtcbl9nZXRHU0FQKCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbihEcmFnZ2FibGUpO1xuZXhwb3J0IHsgRHJhZ2dhYmxlIGFzIGRlZmF1bHQgfTsiLCIvKiFcbiAqIEVhc2VQYWNrIDMuOS4xXG4gKiBodHRwczovL2dyZWVuc29jay5jb21cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAwOC0yMDIxLCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xudmFyIGdzYXAsXG4gICAgX2NvcmVJbml0dGVkLFxuICAgIF9yZWdpc3RlckVhc2UsXG4gICAgX2dldEdTQVAgPSBmdW5jdGlvbiBfZ2V0R1NBUCgpIHtcbiAgcmV0dXJuIGdzYXAgfHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoZ3NhcCA9IHdpbmRvdy5nc2FwKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luICYmIGdzYXA7XG59LFxuICAgIF9ib29sZWFuID0gZnVuY3Rpb24gX2Jvb2xlYW4odmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4gISEodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiID8gZGVmYXVsdFZhbHVlIDogdmFsdWUgJiYgIX4odmFsdWUgKyBcIlwiKS5pbmRleE9mKFwiZmFsc2VcIikpO1xufSxcbiAgICBfaW5pdENvcmUgPSBmdW5jdGlvbiBfaW5pdENvcmUoY29yZSkge1xuICBnc2FwID0gY29yZSB8fCBfZ2V0R1NBUCgpO1xuXG4gIGlmIChnc2FwKSB7XG4gICAgX3JlZ2lzdGVyRWFzZSA9IGdzYXAucmVnaXN0ZXJFYXNlOyAvL2FkZCB3ZWlnaHRlZCBlYXNlIGNhcGFiaWxpdGllcyB0byBzdGFuZGFyZCBlYXNlcyBzbyB1c2VycyBjYW4gZG8gXCJwb3dlcjIuaW5PdXQoMC44KVwiIGZvciBleGFtcGxlIHRvIHB1c2ggZXZlcnl0aGluZyB0b3dhcmQgdGhlIFwib3V0XCIsIG9yICgtMC44KSB0byBwdXNoIGl0IHRvd2FyZCB0aGUgXCJpblwiICgwIGlzIG5ldXRyYWwpXG5cbiAgICB2YXIgZWFzZXMgPSBnc2FwLnBhcnNlRWFzZSgpLFxuICAgICAgICBjcmVhdGVDb25maWcgPSBmdW5jdGlvbiBjcmVhdGVDb25maWcoZWFzZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyYXRpbykge1xuICAgICAgICB2YXIgeSA9IDAuNSArIHJhdGlvIC8gMjtcblxuICAgICAgICBlYXNlLmNvbmZpZyA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgcmV0dXJuIGVhc2UoMiAqICgxIC0gcCkgKiBwICogeSArIHAgKiBwKTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfSxcbiAgICAgICAgcDtcblxuICAgIGZvciAocCBpbiBlYXNlcykge1xuICAgICAgaWYgKCFlYXNlc1twXS5jb25maWcpIHtcbiAgICAgICAgY3JlYXRlQ29uZmlnKGVhc2VzW3BdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfcmVnaXN0ZXJFYXNlKFwic2xvd1wiLCBTbG93TW8pO1xuXG4gICAgX3JlZ2lzdGVyRWFzZShcImV4cG9TY2FsZVwiLCBFeHBvU2NhbGVFYXNlKTtcblxuICAgIF9yZWdpc3RlckVhc2UoXCJyb3VnaFwiLCBSb3VnaEVhc2UpO1xuXG4gICAgZm9yIChwIGluIEVhc2VQYWNrKSB7XG4gICAgICBwICE9PSBcInZlcnNpb25cIiAmJiBnc2FwLmNvcmUuZ2xvYmFscyhwLCBFYXNlUGFja1twXSk7XG4gICAgfVxuXG4gICAgX2NvcmVJbml0dGVkID0gMTtcbiAgfVxufSxcbiAgICBfY3JlYXRlU2xvd01vID0gZnVuY3Rpb24gX2NyZWF0ZVNsb3dNbyhsaW5lYXJSYXRpbywgcG93ZXIsIHlveW9Nb2RlKSB7XG4gIGxpbmVhclJhdGlvID0gTWF0aC5taW4oMSwgbGluZWFyUmF0aW8gfHwgMC43KTtcblxuICB2YXIgcG93ID0gbGluZWFyUmF0aW8gPCAxID8gcG93ZXIgfHwgcG93ZXIgPT09IDAgPyBwb3dlciA6IDAuNyA6IDAsXG4gICAgICBwMSA9ICgxIC0gbGluZWFyUmF0aW8pIC8gMixcbiAgICAgIHAzID0gcDEgKyBsaW5lYXJSYXRpbyxcbiAgICAgIGNhbGNFbmQgPSBfYm9vbGVhbih5b3lvTW9kZSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgdmFyIHIgPSBwICsgKDAuNSAtIHApICogcG93O1xuICAgIHJldHVybiBwIDwgcDEgPyBjYWxjRW5kID8gMSAtIChwID0gMSAtIHAgLyBwMSkgKiBwIDogciAtIChwID0gMSAtIHAgLyBwMSkgKiBwICogcCAqIHAgKiByIDogcCA+IHAzID8gY2FsY0VuZCA/IHAgPT09IDEgPyAwIDogMSAtIChwID0gKHAgLSBwMykgLyBwMSkgKiBwIDogciArIChwIC0gcikgKiAocCA9IChwIC0gcDMpIC8gcDEpICogcCAqIHAgKiBwIDogY2FsY0VuZCA/IDEgOiByO1xuICB9O1xufSxcbiAgICBfY3JlYXRlRXhwb1NjYWxlID0gZnVuY3Rpb24gX2NyZWF0ZUV4cG9TY2FsZShzdGFydCwgZW5kLCBlYXNlKSB7XG4gIHZhciBwMSA9IE1hdGgubG9nKGVuZCAvIHN0YXJ0KSxcbiAgICAgIHAyID0gZW5kIC0gc3RhcnQ7XG4gIGVhc2UgJiYgKGVhc2UgPSBnc2FwLnBhcnNlRWFzZShlYXNlKSk7XG4gIHJldHVybiBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiAoc3RhcnQgKiBNYXRoLmV4cChwMSAqIChlYXNlID8gZWFzZShwKSA6IHApKSAtIHN0YXJ0KSAvIHAyO1xuICB9O1xufSxcbiAgICBFYXNlUG9pbnQgPSBmdW5jdGlvbiBFYXNlUG9pbnQodGltZSwgdmFsdWUsIG5leHQpIHtcbiAgdGhpcy50ID0gdGltZTtcbiAgdGhpcy52ID0gdmFsdWU7XG5cbiAgaWYgKG5leHQpIHtcbiAgICB0aGlzLm5leHQgPSBuZXh0O1xuICAgIG5leHQucHJldiA9IHRoaXM7XG4gICAgdGhpcy5jID0gbmV4dC52IC0gdmFsdWU7XG4gICAgdGhpcy5nYXAgPSBuZXh0LnQgLSB0aW1lO1xuICB9XG59LFxuICAgIF9jcmVhdGVSb3VnaEVhc2UgPSBmdW5jdGlvbiBfY3JlYXRlUm91Z2hFYXNlKHZhcnMpIHtcbiAgaWYgKHR5cGVvZiB2YXJzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgLy91c2VycyBtYXkgcGFzcyBpbiB2aWEgYSBzdHJpbmcsIGxpa2UgXCJyb3VnaCgzMClcIlxuICAgIHZhcnMgPSB7XG4gICAgICBwb2ludHM6ICt2YXJzIHx8IDIwXG4gICAgfTtcbiAgfVxuXG4gIHZhciB0YXBlciA9IHZhcnMudGFwZXIgfHwgXCJub25lXCIsXG4gICAgICBhID0gW10sXG4gICAgICBjbnQgPSAwLFxuICAgICAgcG9pbnRzID0gKCt2YXJzLnBvaW50cyB8fCAyMCkgfCAwLFxuICAgICAgaSA9IHBvaW50cyxcbiAgICAgIHJhbmRvbWl6ZSA9IF9ib29sZWFuKHZhcnMucmFuZG9taXplLCB0cnVlKSxcbiAgICAgIGNsYW1wID0gX2Jvb2xlYW4odmFycy5jbGFtcCksXG4gICAgICB0ZW1wbGF0ZSA9IGdzYXAgPyBnc2FwLnBhcnNlRWFzZSh2YXJzLnRlbXBsYXRlKSA6IDAsXG4gICAgICBzdHJlbmd0aCA9ICgrdmFycy5zdHJlbmd0aCB8fCAxKSAqIDAuNCxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgYnVtcCxcbiAgICAgIGludlgsXG4gICAgICBvYmosXG4gICAgICBwbnQsXG4gICAgICByZWNlbnQ7XG5cbiAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgeCA9IHJhbmRvbWl6ZSA/IE1hdGgucmFuZG9tKCkgOiAxIC8gcG9pbnRzICogaTtcbiAgICB5ID0gdGVtcGxhdGUgPyB0ZW1wbGF0ZSh4KSA6IHg7XG5cbiAgICBpZiAodGFwZXIgPT09IFwibm9uZVwiKSB7XG4gICAgICBidW1wID0gc3RyZW5ndGg7XG4gICAgfSBlbHNlIGlmICh0YXBlciA9PT0gXCJvdXRcIikge1xuICAgICAgaW52WCA9IDEgLSB4O1xuICAgICAgYnVtcCA9IGludlggKiBpbnZYICogc3RyZW5ndGg7XG4gICAgfSBlbHNlIGlmICh0YXBlciA9PT0gXCJpblwiKSB7XG4gICAgICBidW1wID0geCAqIHggKiBzdHJlbmd0aDtcbiAgICB9IGVsc2UgaWYgKHggPCAwLjUpIHtcbiAgICAgIC8vXCJib3RoXCIgKHN0YXJ0KVxuICAgICAgaW52WCA9IHggKiAyO1xuICAgICAgYnVtcCA9IGludlggKiBpbnZYICogMC41ICogc3RyZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vXCJib3RoXCIgKGVuZClcbiAgICAgIGludlggPSAoMSAtIHgpICogMjtcbiAgICAgIGJ1bXAgPSBpbnZYICogaW52WCAqIDAuNSAqIHN0cmVuZ3RoO1xuICAgIH1cblxuICAgIGlmIChyYW5kb21pemUpIHtcbiAgICAgIHkgKz0gTWF0aC5yYW5kb20oKSAqIGJ1bXAgLSBidW1wICogMC41O1xuICAgIH0gZWxzZSBpZiAoaSAlIDIpIHtcbiAgICAgIHkgKz0gYnVtcCAqIDAuNTtcbiAgICB9IGVsc2Uge1xuICAgICAgeSAtPSBidW1wICogMC41O1xuICAgIH1cblxuICAgIGlmIChjbGFtcCkge1xuICAgICAgaWYgKHkgPiAxKSB7XG4gICAgICAgIHkgPSAxO1xuICAgICAgfSBlbHNlIGlmICh5IDwgMCkge1xuICAgICAgICB5ID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhW2NudCsrXSA9IHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfTtcbiAgfVxuXG4gIGEuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhLnggLSBiLng7XG4gIH0pO1xuICBwbnQgPSBuZXcgRWFzZVBvaW50KDEsIDEsIG51bGwpO1xuICBpID0gcG9pbnRzO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBvYmogPSBhW2ldO1xuICAgIHBudCA9IG5ldyBFYXNlUG9pbnQob2JqLngsIG9iai55LCBwbnQpO1xuICB9XG5cbiAgcmVjZW50ID0gbmV3IEVhc2VQb2ludCgwLCAwLCBwbnQudCA/IHBudCA6IHBudC5uZXh0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgdmFyIHBudCA9IHJlY2VudDtcblxuICAgIGlmIChwID4gcG50LnQpIHtcbiAgICAgIHdoaWxlIChwbnQubmV4dCAmJiBwID49IHBudC50KSB7XG4gICAgICAgIHBudCA9IHBudC5uZXh0O1xuICAgICAgfVxuXG4gICAgICBwbnQgPSBwbnQucHJldjtcbiAgICB9IGVsc2Uge1xuICAgICAgd2hpbGUgKHBudC5wcmV2ICYmIHAgPD0gcG50LnQpIHtcbiAgICAgICAgcG50ID0gcG50LnByZXY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVjZW50ID0gcG50O1xuICAgIHJldHVybiBwbnQudiArIChwIC0gcG50LnQpIC8gcG50LmdhcCAqIHBudC5jO1xuICB9O1xufTtcblxuZXhwb3J0IHZhciBTbG93TW8gPSBfY3JlYXRlU2xvd01vKDAuNyk7XG5TbG93TW8uZWFzZSA9IFNsb3dNbzsgLy9mb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuXG5TbG93TW8uY29uZmlnID0gX2NyZWF0ZVNsb3dNbztcbmV4cG9ydCB2YXIgRXhwb1NjYWxlRWFzZSA9IF9jcmVhdGVFeHBvU2NhbGUoMSwgMik7XG5FeHBvU2NhbGVFYXNlLmNvbmZpZyA9IF9jcmVhdGVFeHBvU2NhbGU7XG5leHBvcnQgdmFyIFJvdWdoRWFzZSA9IF9jcmVhdGVSb3VnaEVhc2UoKTtcblJvdWdoRWFzZS5lYXNlID0gUm91Z2hFYXNlOyAvL2ZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5cblJvdWdoRWFzZS5jb25maWcgPSBfY3JlYXRlUm91Z2hFYXNlO1xuZXhwb3J0IHZhciBFYXNlUGFjayA9IHtcbiAgU2xvd01vOiBTbG93TW8sXG4gIFJvdWdoRWFzZTogUm91Z2hFYXNlLFxuICBFeHBvU2NhbGVFYXNlOiBFeHBvU2NhbGVFYXNlXG59O1xuXG5mb3IgKHZhciBwIGluIEVhc2VQYWNrKSB7XG4gIEVhc2VQYWNrW3BdLnJlZ2lzdGVyID0gX2luaXRDb3JlO1xuICBFYXNlUGFja1twXS52ZXJzaW9uID0gXCIzLjkuMVwiO1xufVxuXG5fZ2V0R1NBUCgpICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4oU2xvd01vKTtcbmV4cG9ydCB7IEVhc2VQYWNrIGFzIGRlZmF1bHQgfTsiLCIvKiFcbiAqIEVhc2VsUGx1Z2luIDMuOS4xXG4gKiBodHRwczovL2dyZWVuc29jay5jb21cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAwOC0yMDIxLCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xudmFyIGdzYXAsXG4gICAgX2NvcmVJbml0dGVkLFxuICAgIF93aW4sXG4gICAgX2NyZWF0ZUpTLFxuICAgIF9Db2xvckZpbHRlcixcbiAgICBfQ29sb3JNYXRyaXhGaWx0ZXIsXG4gICAgX2NvbG9yUHJvcHMgPSBcInJlZE11bHRpcGxpZXIsZ3JlZW5NdWx0aXBsaWVyLGJsdWVNdWx0aXBsaWVyLGFscGhhTXVsdGlwbGllcixyZWRPZmZzZXQsZ3JlZW5PZmZzZXQsYmx1ZU9mZnNldCxhbHBoYU9mZnNldFwiLnNwbGl0KFwiLFwiKSxcbiAgICBfd2luZG93RXhpc3RzID0gZnVuY3Rpb24gX3dpbmRvd0V4aXN0cygpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG59LFxuICAgIF9nZXRHU0FQID0gZnVuY3Rpb24gX2dldEdTQVAoKSB7XG4gIHJldHVybiBnc2FwIHx8IF93aW5kb3dFeGlzdHMoKSAmJiAoZ3NhcCA9IHdpbmRvdy5nc2FwKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luICYmIGdzYXA7XG59LFxuICAgIF9nZXRDcmVhdGVKUyA9IGZ1bmN0aW9uIF9nZXRDcmVhdGVKUygpIHtcbiAgcmV0dXJuIF9jcmVhdGVKUyB8fCBfd2luICYmIF93aW4uY3JlYXRlanMgfHwgX3dpbiB8fCB7fTtcbn0sXG4gICAgX3dhcm4gPSBmdW5jdGlvbiBfd2FybihtZXNzYWdlKSB7XG4gIHJldHVybiBjb25zb2xlLndhcm4obWVzc2FnZSk7XG59LFxuICAgIF9jYWNoZSA9IGZ1bmN0aW9uIF9jYWNoZSh0YXJnZXQpIHtcbiAgdmFyIGIgPSB0YXJnZXQuZ2V0Qm91bmRzICYmIHRhcmdldC5nZXRCb3VuZHMoKTtcblxuICBpZiAoIWIpIHtcbiAgICBiID0gdGFyZ2V0Lm5vbWluYWxCb3VuZHMgfHwge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICB3aWR0aDogMTAwLFxuICAgICAgaGVpZ2h0OiAxMDBcbiAgICB9O1xuICAgIHRhcmdldC5zZXRCb3VuZHMgJiYgdGFyZ2V0LnNldEJvdW5kcyhiLngsIGIueSwgYi53aWR0aCwgYi5oZWlnaHQpO1xuICB9XG5cbiAgdGFyZ2V0LmNhY2hlICYmIHRhcmdldC5jYWNoZShiLngsIGIueSwgYi53aWR0aCwgYi5oZWlnaHQpO1xuXG4gIF93YXJuKFwiRWFzZWxQbHVnaW46IGZvciBmaWx0ZXJzIHRvIGRpc3BsYXkgaW4gRWFzZWxKUywgeW91IG11c3QgY2FsbCB0aGUgb2JqZWN0J3MgY2FjaGUoKSBtZXRob2QgZmlyc3QuIEdTQVAgYXR0ZW1wdGVkIHRvIHVzZSB0aGUgdGFyZ2V0J3MgZ2V0Qm91bmRzKCkgZm9yIHRoZSBjYWNoZSBidXQgdGhhdCBtYXkgbm90IGJlIGNvbXBsZXRlbHkgYWNjdXJhdGUuIFwiICsgdGFyZ2V0KTtcbn0sXG4gICAgX3BhcnNlQ29sb3JGaWx0ZXIgPSBmdW5jdGlvbiBfcGFyc2VDb2xvckZpbHRlcih0YXJnZXQsIHYsIHBsdWdpbikge1xuICBpZiAoIV9Db2xvckZpbHRlcikge1xuICAgIF9Db2xvckZpbHRlciA9IF9nZXRDcmVhdGVKUygpLkNvbG9yRmlsdGVyO1xuXG4gICAgaWYgKCFfQ29sb3JGaWx0ZXIpIHtcbiAgICAgIF93YXJuKFwiRWFzZWxQbHVnaW4gZXJyb3I6IFRoZSBFYXNlbEpTIENvbG9yRmlsdGVyIEphdmFTY3JpcHQgZmlsZSB3YXNuJ3QgbG9hZGVkLlwiKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZmlsdGVycyA9IHRhcmdldC5maWx0ZXJzIHx8IFtdLFxuICAgICAgaSA9IGZpbHRlcnMubGVuZ3RoLFxuICAgICAgYyxcbiAgICAgIHMsXG4gICAgICBlLFxuICAgICAgYSxcbiAgICAgIHAsXG4gICAgICBwdDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKGZpbHRlcnNbaV0gaW5zdGFuY2VvZiBfQ29sb3JGaWx0ZXIpIHtcbiAgICAgIHMgPSBmaWx0ZXJzW2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzKSB7XG4gICAgcyA9IG5ldyBfQ29sb3JGaWx0ZXIoKTtcbiAgICBmaWx0ZXJzLnB1c2gocyk7XG4gICAgdGFyZ2V0LmZpbHRlcnMgPSBmaWx0ZXJzO1xuICB9XG5cbiAgZSA9IHMuY2xvbmUoKTtcblxuICBpZiAodi50aW50ICE9IG51bGwpIHtcbiAgICBjID0gZ3NhcC51dGlscy5zcGxpdENvbG9yKHYudGludCk7XG4gICAgYSA9IHYudGludEFtb3VudCAhPSBudWxsID8gK3YudGludEFtb3VudCA6IDE7XG4gICAgZS5yZWRPZmZzZXQgPSArY1swXSAqIGE7XG4gICAgZS5ncmVlbk9mZnNldCA9ICtjWzFdICogYTtcbiAgICBlLmJsdWVPZmZzZXQgPSArY1syXSAqIGE7XG4gICAgZS5yZWRNdWx0aXBsaWVyID0gZS5ncmVlbk11bHRpcGxpZXIgPSBlLmJsdWVNdWx0aXBsaWVyID0gMSAtIGE7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChwIGluIHYpIHtcbiAgICAgIGlmIChwICE9PSBcImV4cG9zdXJlXCIpIGlmIChwICE9PSBcImJyaWdodG5lc3NcIikge1xuICAgICAgICBlW3BdID0gK3ZbcF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHYuZXhwb3N1cmUgIT0gbnVsbCkge1xuICAgIGUucmVkT2Zmc2V0ID0gZS5ncmVlbk9mZnNldCA9IGUuYmx1ZU9mZnNldCA9IDI1NSAqICgrdi5leHBvc3VyZSAtIDEpO1xuICAgIGUucmVkTXVsdGlwbGllciA9IGUuZ3JlZW5NdWx0aXBsaWVyID0gZS5ibHVlTXVsdGlwbGllciA9IDE7XG4gIH0gZWxzZSBpZiAodi5icmlnaHRuZXNzICE9IG51bGwpIHtcbiAgICBhID0gK3YuYnJpZ2h0bmVzcyAtIDE7XG4gICAgZS5yZWRPZmZzZXQgPSBlLmdyZWVuT2Zmc2V0ID0gZS5ibHVlT2Zmc2V0ID0gYSA+IDAgPyBhICogMjU1IDogMDtcbiAgICBlLnJlZE11bHRpcGxpZXIgPSBlLmdyZWVuTXVsdGlwbGllciA9IGUuYmx1ZU11bHRpcGxpZXIgPSAxIC0gTWF0aC5hYnMoYSk7XG4gIH1cblxuICBpID0gODtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgcCA9IF9jb2xvclByb3BzW2ldO1xuXG4gICAgaWYgKHNbcF0gIT09IGVbcF0pIHtcbiAgICAgIHB0ID0gcGx1Z2luLmFkZChzLCBwLCBzW3BdLCBlW3BdKTtcblxuICAgICAgaWYgKHB0KSB7XG4gICAgICAgIHB0Lm9wID0gXCJlYXNlbF9jb2xvckZpbHRlclwiO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHBsdWdpbi5fcHJvcHMucHVzaChcImVhc2VsX2NvbG9yRmlsdGVyXCIpO1xuXG4gIGlmICghdGFyZ2V0LmNhY2hlSUQpIHtcbiAgICBfY2FjaGUodGFyZ2V0KTtcbiAgfVxufSxcbiAgICBfaWRNYXRyaXggPSBbMSwgMCwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMCwgMSwgMF0sXG4gICAgX2x1bVIgPSAwLjIxMjY3MSxcbiAgICBfbHVtRyA9IDAuNzE1MTYwLFxuICAgIF9sdW1CID0gMC4wNzIxNjksXG4gICAgX2FwcGx5TWF0cml4ID0gZnVuY3Rpb24gX2FwcGx5TWF0cml4KG0sIG0yKSB7XG4gIGlmICghKG0gaW5zdGFuY2VvZiBBcnJheSkgfHwgIShtMiBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgIHJldHVybiBtMjtcbiAgfVxuXG4gIHZhciB0ZW1wID0gW10sXG4gICAgICBpID0gMCxcbiAgICAgIHogPSAwLFxuICAgICAgeSxcbiAgICAgIHg7XG5cbiAgZm9yICh5ID0gMDsgeSA8IDQ7IHkrKykge1xuICAgIGZvciAoeCA9IDA7IHggPCA1OyB4KyspIHtcbiAgICAgIHogPSB4ID09PSA0ID8gbVtpICsgNF0gOiAwO1xuICAgICAgdGVtcFtpICsgeF0gPSBtW2ldICogbTJbeF0gKyBtW2kgKyAxXSAqIG0yW3ggKyA1XSArIG1baSArIDJdICogbTJbeCArIDEwXSArIG1baSArIDNdICogbTJbeCArIDE1XSArIHo7XG4gICAgfVxuXG4gICAgaSArPSA1O1xuICB9XG5cbiAgcmV0dXJuIHRlbXA7XG59LFxuICAgIF9zZXRTYXR1cmF0aW9uID0gZnVuY3Rpb24gX3NldFNhdHVyYXRpb24obSwgbikge1xuICBpZiAoaXNOYU4obikpIHtcbiAgICByZXR1cm4gbTtcbiAgfVxuXG4gIHZhciBpbnYgPSAxIC0gbixcbiAgICAgIHIgPSBpbnYgKiBfbHVtUixcbiAgICAgIGcgPSBpbnYgKiBfbHVtRyxcbiAgICAgIGIgPSBpbnYgKiBfbHVtQjtcbiAgcmV0dXJuIF9hcHBseU1hdHJpeChbciArIG4sIGcsIGIsIDAsIDAsIHIsIGcgKyBuLCBiLCAwLCAwLCByLCBnLCBiICsgbiwgMCwgMCwgMCwgMCwgMCwgMSwgMF0sIG0pO1xufSxcbiAgICBfY29sb3JpemUgPSBmdW5jdGlvbiBfY29sb3JpemUobSwgY29sb3IsIGFtb3VudCkge1xuICBpZiAoaXNOYU4oYW1vdW50KSkge1xuICAgIGFtb3VudCA9IDE7XG4gIH1cblxuICB2YXIgYyA9IGdzYXAudXRpbHMuc3BsaXRDb2xvcihjb2xvciksXG4gICAgICByID0gY1swXSAvIDI1NSxcbiAgICAgIGcgPSBjWzFdIC8gMjU1LFxuICAgICAgYiA9IGNbMl0gLyAyNTUsXG4gICAgICBpbnYgPSAxIC0gYW1vdW50O1xuICByZXR1cm4gX2FwcGx5TWF0cml4KFtpbnYgKyBhbW91bnQgKiByICogX2x1bVIsIGFtb3VudCAqIHIgKiBfbHVtRywgYW1vdW50ICogciAqIF9sdW1CLCAwLCAwLCBhbW91bnQgKiBnICogX2x1bVIsIGludiArIGFtb3VudCAqIGcgKiBfbHVtRywgYW1vdW50ICogZyAqIF9sdW1CLCAwLCAwLCBhbW91bnQgKiBiICogX2x1bVIsIGFtb3VudCAqIGIgKiBfbHVtRywgaW52ICsgYW1vdW50ICogYiAqIF9sdW1CLCAwLCAwLCAwLCAwLCAwLCAxLCAwXSwgbSk7XG59LFxuICAgIF9zZXRIdWUgPSBmdW5jdGlvbiBfc2V0SHVlKG0sIG4pIHtcbiAgaWYgKGlzTmFOKG4pKSB7XG4gICAgcmV0dXJuIG07XG4gIH1cblxuICBuICo9IE1hdGguUEkgLyAxODA7XG4gIHZhciBjID0gTWF0aC5jb3MobiksXG4gICAgICBzID0gTWF0aC5zaW4obik7XG4gIHJldHVybiBfYXBwbHlNYXRyaXgoW19sdW1SICsgYyAqICgxIC0gX2x1bVIpICsgcyAqIC1fbHVtUiwgX2x1bUcgKyBjICogLV9sdW1HICsgcyAqIC1fbHVtRywgX2x1bUIgKyBjICogLV9sdW1CICsgcyAqICgxIC0gX2x1bUIpLCAwLCAwLCBfbHVtUiArIGMgKiAtX2x1bVIgKyBzICogMC4xNDMsIF9sdW1HICsgYyAqICgxIC0gX2x1bUcpICsgcyAqIDAuMTQsIF9sdW1CICsgYyAqIC1fbHVtQiArIHMgKiAtMC4yODMsIDAsIDAsIF9sdW1SICsgYyAqIC1fbHVtUiArIHMgKiAtKDEgLSBfbHVtUiksIF9sdW1HICsgYyAqIC1fbHVtRyArIHMgKiBfbHVtRywgX2x1bUIgKyBjICogKDEgLSBfbHVtQikgKyBzICogX2x1bUIsIDAsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDAsIDFdLCBtKTtcbn0sXG4gICAgX3NldENvbnRyYXN0ID0gZnVuY3Rpb24gX3NldENvbnRyYXN0KG0sIG4pIHtcbiAgaWYgKGlzTmFOKG4pKSB7XG4gICAgcmV0dXJuIG07XG4gIH1cblxuICBuICs9IDAuMDE7XG4gIHJldHVybiBfYXBwbHlNYXRyaXgoW24sIDAsIDAsIDAsIDEyOCAqICgxIC0gbiksIDAsIG4sIDAsIDAsIDEyOCAqICgxIC0gbiksIDAsIDAsIG4sIDAsIDEyOCAqICgxIC0gbiksIDAsIDAsIDAsIDEsIDBdLCBtKTtcbn0sXG4gICAgX3BhcnNlQ29sb3JNYXRyaXhGaWx0ZXIgPSBmdW5jdGlvbiBfcGFyc2VDb2xvck1hdHJpeEZpbHRlcih0YXJnZXQsIHYsIHBsdWdpbikge1xuICBpZiAoIV9Db2xvck1hdHJpeEZpbHRlcikge1xuICAgIF9Db2xvck1hdHJpeEZpbHRlciA9IF9nZXRDcmVhdGVKUygpLkNvbG9yTWF0cml4RmlsdGVyO1xuXG4gICAgaWYgKCFfQ29sb3JNYXRyaXhGaWx0ZXIpIHtcbiAgICAgIF93YXJuKFwiRWFzZWxQbHVnaW46IFRoZSBFYXNlbEpTIENvbG9yTWF0cml4RmlsdGVyIEphdmFTY3JpcHQgZmlsZSB3YXNuJ3QgbG9hZGVkLlwiKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZmlsdGVycyA9IHRhcmdldC5maWx0ZXJzIHx8IFtdLFxuICAgICAgaSA9IGZpbHRlcnMubGVuZ3RoLFxuICAgICAgbWF0cml4LFxuICAgICAgc3RhcnRNYXRyaXgsXG4gICAgICBzLFxuICAgICAgcGc7XG5cbiAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgaWYgKGZpbHRlcnNbaV0gaW5zdGFuY2VvZiBfQ29sb3JNYXRyaXhGaWx0ZXIpIHtcbiAgICAgIHMgPSBmaWx0ZXJzW2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFzKSB7XG4gICAgcyA9IG5ldyBfQ29sb3JNYXRyaXhGaWx0ZXIoX2lkTWF0cml4LnNsaWNlKCkpO1xuICAgIGZpbHRlcnMucHVzaChzKTtcbiAgICB0YXJnZXQuZmlsdGVycyA9IGZpbHRlcnM7XG4gIH1cblxuICBzdGFydE1hdHJpeCA9IHMubWF0cml4O1xuICBtYXRyaXggPSBfaWRNYXRyaXguc2xpY2UoKTtcblxuICBpZiAodi5jb2xvcml6ZSAhPSBudWxsKSB7XG4gICAgbWF0cml4ID0gX2NvbG9yaXplKG1hdHJpeCwgdi5jb2xvcml6ZSwgTnVtYmVyKHYuY29sb3JpemVBbW91bnQpKTtcbiAgfVxuXG4gIGlmICh2LmNvbnRyYXN0ICE9IG51bGwpIHtcbiAgICBtYXRyaXggPSBfc2V0Q29udHJhc3QobWF0cml4LCBOdW1iZXIodi5jb250cmFzdCkpO1xuICB9XG5cbiAgaWYgKHYuaHVlICE9IG51bGwpIHtcbiAgICBtYXRyaXggPSBfc2V0SHVlKG1hdHJpeCwgTnVtYmVyKHYuaHVlKSk7XG4gIH1cblxuICBpZiAodi5zYXR1cmF0aW9uICE9IG51bGwpIHtcbiAgICBtYXRyaXggPSBfc2V0U2F0dXJhdGlvbihtYXRyaXgsIE51bWJlcih2LnNhdHVyYXRpb24pKTtcbiAgfVxuXG4gIGkgPSBtYXRyaXgubGVuZ3RoO1xuXG4gIHdoaWxlICgtLWkgPiAtMSkge1xuICAgIGlmIChtYXRyaXhbaV0gIT09IHN0YXJ0TWF0cml4W2ldKSB7XG4gICAgICBwZyA9IHBsdWdpbi5hZGQoc3RhcnRNYXRyaXgsIGksIHN0YXJ0TWF0cml4W2ldLCBtYXRyaXhbaV0pO1xuXG4gICAgICBpZiAocGcpIHtcbiAgICAgICAgcGcub3AgPSBcImVhc2VsX2NvbG9yTWF0cml4RmlsdGVyXCI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcGx1Z2luLl9wcm9wcy5wdXNoKFwiZWFzZWxfY29sb3JNYXRyaXhGaWx0ZXJcIik7XG5cbiAgaWYgKCF0YXJnZXQuY2FjaGVJRCkge1xuICAgIF9jYWNoZSgpO1xuICB9XG5cbiAgcGx1Z2luLl9tYXRyaXggPSBzdGFydE1hdHJpeDtcbn0sXG4gICAgX2luaXRDb3JlID0gZnVuY3Rpb24gX2luaXRDb3JlKGNvcmUpIHtcbiAgZ3NhcCA9IGNvcmUgfHwgX2dldEdTQVAoKTtcblxuICBpZiAoX3dpbmRvd0V4aXN0cygpKSB7XG4gICAgX3dpbiA9IHdpbmRvdztcbiAgfVxuXG4gIGlmIChnc2FwKSB7XG4gICAgX2NvcmVJbml0dGVkID0gMTtcbiAgfVxufTtcblxuZXhwb3J0IHZhciBFYXNlbFBsdWdpbiA9IHtcbiAgdmVyc2lvbjogXCIzLjkuMVwiLFxuICBuYW1lOiBcImVhc2VsXCIsXG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQodGFyZ2V0LCB2YWx1ZSwgdHdlZW4sIGluZGV4LCB0YXJnZXRzKSB7XG4gICAgaWYgKCFfY29yZUluaXR0ZWQpIHtcbiAgICAgIF9pbml0Q29yZSgpO1xuXG4gICAgICBpZiAoIWdzYXApIHtcbiAgICAgICAgX3dhcm4oXCJQbGVhc2UgZ3NhcC5yZWdpc3RlclBsdWdpbihFYXNlbFBsdWdpbilcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdmFyIHAsIHB0LCB0aW50LCBjb2xvck1hdHJpeCwgZW5kLCBsYWJlbHMsIGk7XG5cbiAgICBmb3IgKHAgaW4gdmFsdWUpIHtcbiAgICAgIGVuZCA9IHZhbHVlW3BdO1xuXG4gICAgICBpZiAocCA9PT0gXCJjb2xvckZpbHRlclwiIHx8IHAgPT09IFwidGludFwiIHx8IHAgPT09IFwidGludEFtb3VudFwiIHx8IHAgPT09IFwiZXhwb3N1cmVcIiB8fCBwID09PSBcImJyaWdodG5lc3NcIikge1xuICAgICAgICBpZiAoIXRpbnQpIHtcbiAgICAgICAgICBfcGFyc2VDb2xvckZpbHRlcih0YXJnZXQsIHZhbHVlLmNvbG9yRmlsdGVyIHx8IHZhbHVlLCB0aGlzKTtcblxuICAgICAgICAgIHRpbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHAgPT09IFwic2F0dXJhdGlvblwiIHx8IHAgPT09IFwiY29udHJhc3RcIiB8fCBwID09PSBcImh1ZVwiIHx8IHAgPT09IFwiY29sb3JpemVcIiB8fCBwID09PSBcImNvbG9yaXplQW1vdW50XCIpIHtcbiAgICAgICAgaWYgKCFjb2xvck1hdHJpeCkge1xuICAgICAgICAgIF9wYXJzZUNvbG9yTWF0cml4RmlsdGVyKHRhcmdldCwgdmFsdWUuY29sb3JNYXRyaXhGaWx0ZXIgfHwgdmFsdWUsIHRoaXMpO1xuXG4gICAgICAgICAgY29sb3JNYXRyaXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHAgPT09IFwiZnJhbWVcIikge1xuICAgICAgICBpZiAodHlwZW9mIGVuZCA9PT0gXCJzdHJpbmdcIiAmJiBlbmQuY2hhckF0KDEpICE9PSBcIj1cIiAmJiAobGFiZWxzID0gdGFyZ2V0LmxhYmVscykpIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobGFiZWxzW2ldLmxhYmVsID09PSBlbmQpIHtcbiAgICAgICAgICAgICAgZW5kID0gbGFiZWxzW2ldLnBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHB0ID0gdGhpcy5hZGQodGFyZ2V0LCBcImdvdG9BbmRTdG9wXCIsIHRhcmdldC5jdXJyZW50RnJhbWUsIGVuZCwgaW5kZXgsIHRhcmdldHMsIE1hdGgucm91bmQpO1xuXG4gICAgICAgIGlmIChwdCkge1xuICAgICAgICAgIHB0Lm9wID0gcDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0YXJnZXRbcF0gIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmFkZCh0YXJnZXQsIHAsIFwiZ2V0XCIsIGVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihyYXRpbywgZGF0YSkge1xuICAgIHZhciBwdCA9IGRhdGEuX3B0O1xuXG4gICAgd2hpbGUgKHB0KSB7XG4gICAgICBwdC5yKHJhdGlvLCBwdC5kKTtcbiAgICAgIHB0ID0gcHQuX25leHQ7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEudGFyZ2V0LmNhY2hlSUQpIHtcbiAgICAgIGRhdGEudGFyZ2V0LnVwZGF0ZUNhY2hlKCk7XG4gICAgfVxuICB9LFxuICByZWdpc3RlcjogX2luaXRDb3JlXG59O1xuXG5FYXNlbFBsdWdpbi5yZWdpc3RlckNyZWF0ZUpTID0gZnVuY3Rpb24gKGNyZWF0ZWpzKSB7XG4gIF9jcmVhdGVKUyA9IGNyZWF0ZWpzO1xufTtcblxuX2dldEdTQVAoKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luKEVhc2VsUGx1Z2luKTtcbmV4cG9ydCB7IEVhc2VsUGx1Z2luIGFzIGRlZmF1bHQgfTsiLCIvKiFcbiAqIEZsaXAgMy45LjFcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjEsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgeyBnZXRHbG9iYWxNYXRyaXgsIF9nZXREb2NTY3JvbGxUb3AsIF9nZXREb2NTY3JvbGxMZWZ0LCBNYXRyaXgyRCwgX3NldERvYywgX2dldENUTSB9IGZyb20gXCIuL3V0aWxzL21hdHJpeC5qc1wiO1xuXG52YXIgX2lkID0gMSxcbiAgICBfdG9BcnJheSxcbiAgICBnc2FwLFxuICAgIF9iYXRjaCxcbiAgICBfYmF0Y2hBY3Rpb24sXG4gICAgX2JvZHksXG4gICAgX2Nsb3Nlc3RUZW50aCxcbiAgICBfZm9yRWFjaEJhdGNoID0gZnVuY3Rpb24gX2ZvckVhY2hCYXRjaChiYXRjaCwgbmFtZSkge1xuICByZXR1cm4gYmF0Y2guYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIGEudmFyc1tuYW1lXSAmJiBhLnZhcnNbbmFtZV0oYSk7XG4gIH0pO1xufSxcbiAgICBfYmF0Y2hMb29rdXAgPSB7fSxcbiAgICBfUkFEMkRFRyA9IDE4MCAvIE1hdGguUEksXG4gICAgX0RFRzJSQUQgPSBNYXRoLlBJIC8gMTgwLFxuICAgIF9lbXB0eU9iaiA9IHt9LFxuICAgIF9kYXNoZWROYW1lTG9va3VwID0ge30sXG4gICAgX21lbW9pemVkUmVtb3ZlUHJvcHMgPSB7fSxcbiAgICBfbGlzdFRvQXJyYXkgPSBmdW5jdGlvbiBfbGlzdFRvQXJyYXkobGlzdCkge1xuICByZXR1cm4gdHlwZW9mIGxpc3QgPT09IFwic3RyaW5nXCIgPyBsaXN0LnNwbGl0KFwiIFwiKS5qb2luKFwiXCIpLnNwbGl0KFwiLFwiKSA6IGxpc3Q7XG59LFxuICAgIC8vIHJlbW92ZXMgZXh0cmEgc3BhY2VzIGNvbnRhbWluYXRpbmcgdGhlIG5hbWVzLCByZXR1cm5zIGFuIEFycmF5LlxuX2NhbGxiYWNrcyA9IF9saXN0VG9BcnJheShcIm9uU3RhcnQsb25VcGRhdGUsb25Db21wbGV0ZSxvblJldmVyc2VDb21wbGV0ZSxvbkludGVycnVwdFwiKSxcbiAgICBfcmVtb3ZlUHJvcHMgPSBfbGlzdFRvQXJyYXkoXCJ0cmFuc2Zvcm0sdHJhbnNmb3JtT3JpZ2luLHdpZHRoLGhlaWdodCxwb3NpdGlvbix0b3AsbGVmdCxvcGFjaXR5LHpJbmRleCxtYXhXaWR0aCxtYXhIZWlnaHQsbWluV2lkdGgsbWluSGVpZ2h0XCIpLFxuICAgIF9nZXRFbCA9IGZ1bmN0aW9uIF9nZXRFbCh0YXJnZXQpIHtcbiAgcmV0dXJuIF90b0FycmF5KHRhcmdldClbMF0gfHwgY29uc29sZS53YXJuKFwiRWxlbWVudCBub3QgZm91bmQ6XCIsIHRhcmdldCk7XG59LFxuICAgIF9yb3VuZCA9IGZ1bmN0aW9uIF9yb3VuZCh2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMDAwKSAvIDEwMDAwIHx8IDA7XG59LFxuICAgIF90b2dnbGVDbGFzcyA9IGZ1bmN0aW9uIF90b2dnbGVDbGFzcyh0YXJnZXRzLCBjbGFzc05hbWUsIGFjdGlvbikge1xuICByZXR1cm4gdGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgIHJldHVybiBlbC5jbGFzc0xpc3RbYWN0aW9uXShjbGFzc05hbWUpO1xuICB9KTtcbn0sXG4gICAgX3Jlc2VydmVkID0ge1xuICB6SW5kZXg6IDEsXG4gIGtpbGw6IDEsXG4gIHNpbXBsZTogMSxcbiAgc3BpbjogMSxcbiAgY2xlYXJQcm9wczogMSxcbiAgdGFyZ2V0czogMSxcbiAgdG9nZ2xlQ2xhc3M6IDEsXG4gIG9uQ29tcGxldGU6IDEsXG4gIG9uVXBkYXRlOiAxLFxuICBvbkludGVycnVwdDogMSxcbiAgb25TdGFydDogMSxcbiAgZGVsYXk6IDEsXG4gIHJlcGVhdDogMSxcbiAgcmVwZWF0RGVsYXk6IDEsXG4gIHlveW86IDEsXG4gIHNjYWxlOiAxLFxuICBmYWRlOiAxLFxuICBhYnNvbHV0ZTogMSxcbiAgcHJvcHM6IDEsXG4gIG9uRW50ZXI6IDEsXG4gIG9uTGVhdmU6IDEsXG4gIGN1c3RvbTogMSxcbiAgcGF1c2VkOiAxLFxuICBuZXN0ZWQ6IDEsXG4gIHBydW5lOiAxLFxuICBhYnNvbHV0ZU9uTGVhdmU6IDFcbn0sXG4gICAgX2ZpdFJlc2VydmVkID0ge1xuICB6SW5kZXg6IDEsXG4gIHNpbXBsZTogMSxcbiAgY2xlYXJQcm9wczogMSxcbiAgc2NhbGU6IDEsXG4gIGFic29sdXRlOiAxLFxuICBmaXRDaGlsZDogMSxcbiAgZ2V0VmFyczogMSxcbiAgcHJvcHM6IDFcbn0sXG4gICAgX2NhbWVsVG9EYXNoZWQgPSBmdW5jdGlvbiBfY2FtZWxUb0Rhc2hlZChwKSB7XG4gIHJldHVybiBwLnJlcGxhY2UoLyhbQS1aXSkvZywgXCItJDFcIikudG9Mb3dlckNhc2UoKTtcbn0sXG4gICAgX2NvcHkgPSBmdW5jdGlvbiBfY29weShvYmosIGV4Y2x1ZGUpIHtcbiAgdmFyIHJlc3VsdCA9IHt9LFxuICAgICAgcDtcblxuICBmb3IgKHAgaW4gb2JqKSB7XG4gICAgZXhjbHVkZVtwXSB8fCAocmVzdWx0W3BdID0gb2JqW3BdKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59LFxuICAgIF9tZW1vaXplZFByb3BzID0ge30sXG4gICAgX21lbW9pemVQcm9wcyA9IGZ1bmN0aW9uIF9tZW1vaXplUHJvcHMocHJvcHMpIHtcbiAgdmFyIHAgPSBfbWVtb2l6ZWRQcm9wc1twcm9wc10gPSBfbGlzdFRvQXJyYXkocHJvcHMpO1xuXG4gIF9tZW1vaXplZFJlbW92ZVByb3BzW3Byb3BzXSA9IHAuY29uY2F0KF9yZW1vdmVQcm9wcyk7XG4gIHJldHVybiBwO1xufSxcbiAgICBfZ2V0SW52ZXJzZUdsb2JhbE1hdHJpeCA9IGZ1bmN0aW9uIF9nZXRJbnZlcnNlR2xvYmFsTWF0cml4KGVsKSB7XG4gIC8vIGludGVncmF0ZXMgY2FjaGluZyBmb3IgaW1wcm92ZWQgcGVyZm9ybWFuY2VcbiAgdmFyIGNhY2hlID0gZWwuX2dzYXAgfHwgZ3NhcC5jb3JlLmdldENhY2hlKGVsKTtcblxuICBpZiAoY2FjaGUuZ21DYWNoZSA9PT0gZ3NhcC50aWNrZXIuZnJhbWUpIHtcbiAgICByZXR1cm4gY2FjaGUuZ01hdHJpeDtcbiAgfVxuXG4gIGNhY2hlLmdtQ2FjaGUgPSBnc2FwLnRpY2tlci5mcmFtZTtcbiAgcmV0dXJuIGNhY2hlLmdNYXRyaXggPSBnZXRHbG9iYWxNYXRyaXgoZWwsIHRydWUsIGZhbHNlLCB0cnVlKTtcbn0sXG4gICAgX2dldERPTURlcHRoID0gZnVuY3Rpb24gX2dldERPTURlcHRoKGVsLCBpbnZlcnQsIGxldmVsKSB7XG4gIGlmIChsZXZlbCA9PT0gdm9pZCAwKSB7XG4gICAgbGV2ZWwgPSAwO1xuICB9XG5cbiAgLy8gSW4gaW52ZXJ0IGlzIHRydWUsIHRoZSBzaWJsaW5nIGRlcHRoIGlzIGluY3JlbWVudHMgb2YgMSwgYW5kIHBhcmVudC9uZXN0aW5nIGRlcHRoIGlzIGluY3JlbWVudHMgb2YgMTAwMC4gVGhpcyBsZXRzIHVzIG9yZGVyIGVsZW1lbnRzIGluIGFuIEFycmF5IHRvIHJlZmxlY3QgZG9jdW1lbnQgZmxvdy5cbiAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGUsXG4gICAgICBpbmMgPSAxMDAwICogTWF0aC5wb3coMTAsIGxldmVsKSAqIChpbnZlcnQgPyAtMSA6IDEpLFxuICAgICAgbCA9IGludmVydCA/IC1pbmMgKiA5MDAgOiAwO1xuXG4gIHdoaWxlIChlbCkge1xuICAgIGwgKz0gaW5jO1xuICAgIGVsID0gZWwucHJldmlvdXNTaWJsaW5nO1xuICB9XG5cbiAgcmV0dXJuIHBhcmVudCA/IGwgKyBfZ2V0RE9NRGVwdGgocGFyZW50LCBpbnZlcnQsIGxldmVsICsgMSkgOiBsO1xufSxcbiAgICBfb3JkZXJCeURPTURlcHRoID0gZnVuY3Rpb24gX29yZGVyQnlET01EZXB0aChjb21wcywgaW52ZXJ0LCBpc0VsU3RhdGVzKSB7XG4gIGNvbXBzLmZvckVhY2goZnVuY3Rpb24gKGNvbXApIHtcbiAgICByZXR1cm4gY29tcC5kID0gX2dldERPTURlcHRoKGlzRWxTdGF0ZXMgPyBjb21wLmVsZW1lbnQgOiBjb21wLnQsIGludmVydCk7XG4gIH0pO1xuICBjb21wcy5zb3J0KGZ1bmN0aW9uIChjMSwgYzIpIHtcbiAgICByZXR1cm4gYzEuZCAtIGMyLmQ7XG4gIH0pO1xuICByZXR1cm4gY29tcHM7XG59LFxuICAgIF9yZWNvcmRJbmxpbmVTdHlsZXMgPSBmdW5jdGlvbiBfcmVjb3JkSW5saW5lU3R5bGVzKGVsU3RhdGUsIHByb3BzKSB7XG4gIC8vIHJlY29yZHMgdGhlIGN1cnJlbnQgaW5saW5lIENTUyBwcm9wZXJ0aWVzIGludG8gYW4gQXJyYXkgaW4gYWx0ZXJuYXRpbmcgbmFtZS92YWx1ZSBwYWlycyB0aGF0J3Mgc3RvcmVkIGluIGEgXCJjc3NcIiBwcm9wZXJ0eSBvbiB0aGUgc3RhdGUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIHJldmVydCBsYXRlci5cbiAgdmFyIHN0eWxlID0gZWxTdGF0ZS5lbGVtZW50LnN0eWxlLFxuICAgICAgYSA9IGVsU3RhdGUuY3NzID0gZWxTdGF0ZS5jc3MgfHwgW10sXG4gICAgICBpID0gcHJvcHMubGVuZ3RoLFxuICAgICAgcCxcbiAgICAgIHY7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHAgPSBwcm9wc1tpXTtcbiAgICB2ID0gc3R5bGVbcF0gfHwgc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShwKTtcbiAgICBhLnB1c2godiA/IHAgOiBfZGFzaGVkTmFtZUxvb2t1cFtwXSB8fCAoX2Rhc2hlZE5hbWVMb29rdXBbcF0gPSBfY2FtZWxUb0Rhc2hlZChwKSksIHYpO1xuICB9XG5cbiAgcmV0dXJuIHN0eWxlO1xufSxcbiAgICBfYXBwbHlJbmxpbmVTdHlsZXMgPSBmdW5jdGlvbiBfYXBwbHlJbmxpbmVTdHlsZXMoc3RhdGUpIHtcbiAgdmFyIGNzcyA9IHN0YXRlLmNzcyxcbiAgICAgIHN0eWxlID0gc3RhdGUuZWxlbWVudC5zdHlsZSxcbiAgICAgIGkgPSAwO1xuICBzdGF0ZS5jYWNoZS51bmNhY2hlID0gMTtcblxuICBmb3IgKDsgaSA8IGNzcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIGNzc1tpICsgMV0gPyBzdHlsZVtjc3NbaV1dID0gY3NzW2kgKyAxXSA6IHN0eWxlLnJlbW92ZVByb3BlcnR5KGNzc1tpXSk7XG4gIH1cbn0sXG4gICAgX3NldEZpbmFsU3RhdGVzID0gZnVuY3Rpb24gX3NldEZpbmFsU3RhdGVzKGNvbXBzLCBvbmx5VHJhbnNmb3Jtcykge1xuICBjb21wcy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuIGMuYS5jYWNoZS51bmNhY2hlID0gMTtcbiAgfSk7XG4gIG9ubHlUcmFuc2Zvcm1zIHx8IGNvbXBzLmZpbmFsU3RhdGVzLmZvckVhY2goX2FwcGx5SW5saW5lU3R5bGVzKTtcbn0sXG4gICAgX2Fic29sdXRlUHJvcHMgPSBcInBhZGRpbmdUb3AscGFkZGluZ1JpZ2h0LHBhZGRpbmdCb3R0b20scGFkZGluZ0xlZnQsZ3JpZEFyZWEsdHJhbnNpdGlvblwiLnNwbGl0KFwiLFwiKSxcbiAgICAvLyBwcm9wZXJ0aWVzIHRoYXQgd2UgbXVzdCByZWNvcmQganVzdFxuX21ha2VBYnNvbHV0ZSA9IGZ1bmN0aW9uIF9tYWtlQWJzb2x1dGUoZWxTdGF0ZSwgZmFsbGJhY2tOb2RlLCBpZ25vcmVCYXRjaCkge1xuICB2YXIgZWxlbWVudCA9IGVsU3RhdGUuZWxlbWVudCxcbiAgICAgIHdpZHRoID0gZWxTdGF0ZS53aWR0aCxcbiAgICAgIGhlaWdodCA9IGVsU3RhdGUuaGVpZ2h0LFxuICAgICAgdW5jYWNoZSA9IGVsU3RhdGUudW5jYWNoZSxcbiAgICAgIGdldFByb3AgPSBlbFN0YXRlLmdldFByb3AsXG4gICAgICBzdHlsZSA9IGVsZW1lbnQuc3R5bGUsXG4gICAgICBpID0gNCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIGRpc3BsYXlJc05vbmUsXG4gICAgICBjcztcbiAgdHlwZW9mIGZhbGxiYWNrTm9kZSAhPT0gXCJvYmplY3RcIiAmJiAoZmFsbGJhY2tOb2RlID0gZWxTdGF0ZSk7XG5cbiAgaWYgKF9iYXRjaCAmJiBpZ25vcmVCYXRjaCAhPT0gMSkge1xuICAgIF9iYXRjaC5fYWJzLnB1c2goe1xuICAgICAgdDogZWxlbWVudCxcbiAgICAgIGI6IGVsU3RhdGUsXG4gICAgICBhOiBlbFN0YXRlLFxuICAgICAgc2Q6IDBcbiAgICB9KTtcblxuICAgIF9iYXRjaC5fZmluYWwucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKGVsU3RhdGUuY2FjaGUudW5jYWNoZSA9IDEpICYmIF9hcHBseUlubGluZVN0eWxlcyhlbFN0YXRlKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgZGlzcGxheUlzTm9uZSA9IGdldFByb3AoXCJkaXNwbGF5XCIpID09PSBcIm5vbmVcIjtcblxuICBpZiAoIWVsU3RhdGUuaXNWaXNpYmxlIHx8IGRpc3BsYXlJc05vbmUpIHtcbiAgICBkaXNwbGF5SXNOb25lICYmIChfcmVjb3JkSW5saW5lU3R5bGVzKGVsU3RhdGUsIFtcImRpc3BsYXlcIl0pLmRpc3BsYXkgPSBmYWxsYmFja05vZGUuZGlzcGxheSk7XG4gICAgZWxTdGF0ZS5tYXRyaXggPSBmYWxsYmFja05vZGUubWF0cml4O1xuICAgIGVsU3RhdGUud2lkdGggPSB3aWR0aCA9IGVsU3RhdGUud2lkdGggfHwgZmFsbGJhY2tOb2RlLndpZHRoO1xuICAgIGVsU3RhdGUuaGVpZ2h0ID0gaGVpZ2h0ID0gZWxTdGF0ZS5oZWlnaHQgfHwgZmFsbGJhY2tOb2RlLmhlaWdodDtcbiAgfVxuXG4gIF9yZWNvcmRJbmxpbmVTdHlsZXMoZWxTdGF0ZSwgX2Fic29sdXRlUHJvcHMpO1xuXG4gIGNzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHN0eWxlW19hYnNvbHV0ZVByb3BzW2ldXSA9IGNzW19hYnNvbHV0ZVByb3BzW2ldXTsgLy8gcmVjb3JkIHBhZGRpbmdzIGFzIHB4LWJhc2VkIGJlY2F1c2UgaWYgcmVtb3ZlZCBmcm9tIGdyaWQsIHBlcmNlbnRhZ2UtYmFzZWQgb25lcyBjb3VsZCBiZSBhbHRlcmVkLlxuICB9XG5cbiAgc3R5bGUuZ3JpZEFyZWEgPSBcIjEgLyAxIC8gMSAvIDFcIjtcbiAgc3R5bGUudHJhbnNpdGlvbiA9IFwibm9uZVwiO1xuICBzdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgc3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIjtcbiAgc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xuICBzdHlsZS50b3AgfHwgKHN0eWxlLnRvcCA9IFwiMHB4XCIpO1xuICBzdHlsZS5sZWZ0IHx8IChzdHlsZS5sZWZ0ID0gXCIwcHhcIik7XG5cbiAgaWYgKHVuY2FjaGUpIHtcbiAgICByZXN1bHQgPSBuZXcgRWxlbWVudFN0YXRlKGVsZW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIC8vIGJldHRlciBwZXJmb3JtYW5jZVxuICAgIHJlc3VsdCA9IF9jb3B5KGVsU3RhdGUsIF9lbXB0eU9iaik7XG4gICAgcmVzdWx0LnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuXG4gICAgaWYgKGVsU3RhdGUuc2ltcGxlKSB7XG4gICAgICB2YXIgYm91bmRzID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHJlc3VsdC5tYXRyaXggPSBuZXcgTWF0cml4MkQoMSwgMCwgMCwgMSwgYm91bmRzLmxlZnQgKyBfZ2V0RG9jU2Nyb2xsTGVmdCgpLCBib3VuZHMudG9wICsgX2dldERvY1Njcm9sbFRvcCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0Lm1hdHJpeCA9IGdldEdsb2JhbE1hdHJpeChlbGVtZW50LCBmYWxzZSwgZmFsc2UsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIHJlc3VsdCA9IF9maXQocmVzdWx0LCBlbFN0YXRlLCB0cnVlKTtcbiAgZWxTdGF0ZS54ID0gX2Nsb3Nlc3RUZW50aChyZXN1bHQueCwgMC4wMSk7XG4gIGVsU3RhdGUueSA9IF9jbG9zZXN0VGVudGgocmVzdWx0LnksIDAuMDEpO1xuICByZXR1cm4gZWxlbWVudDtcbn0sXG4gICAgX2ZpbHRlckNvbXBzID0gZnVuY3Rpb24gX2ZpbHRlckNvbXBzKGNvbXBzLCB0YXJnZXRzKSB7XG4gIGlmICh0YXJnZXRzICE9PSB0cnVlKSB7XG4gICAgdGFyZ2V0cyA9IF90b0FycmF5KHRhcmdldHMpO1xuICAgIGNvbXBzID0gY29tcHMuZmlsdGVyKGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAodGFyZ2V0cy5pbmRleE9mKChjLnNkIDwgMCA/IGMuYiA6IGMuYSkuZWxlbWVudCkgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYy50Ll9nc2FwLnJlbmRlclRyYW5zZm9ybSgxKTsgLy8gd2UgbXVzdCBmb3JjZSB0cmFuc2Zvcm1zIHRvIHJlbmRlciBvbiBhbnl0aGluZyB0aGF0IGlzbid0IGJlaW5nIG1hZGUgcG9zaXRpb246IGFic29sdXRlLCBvdGhlcndpc2UgdGhlIGFic29sdXRlIHBvc2l0aW9uIGhhcHBlbnMgYW5kIHRoZW4gd2hlbiBhbmltYXRpb24gYmVnaW5zIGl0IGFwcGxpZXMgdHJhbnNmb3JtcyB3aGljaCBjYW4gY3JlYXRlIGEgbmV3IHN0YWNraW5nIGNvbnRleHQsIHRocm93aW5nIG9mZiBwb3NpdGlvbmluZyFcblxuXG4gICAgICAgIGMudC5zdHlsZS53aWR0aCA9IGMuYi53aWR0aCArIFwicHhcIjsgLy8gb3RoZXJ3aXNlIHRoaW5ncyBjYW4gY29sbGFwc2Ugd2hlbiBjb250ZW50cyBhcmUgbWFkZSBwb3NpdGlvbjogYWJzb2x1dGUuXG5cbiAgICAgICAgYy50LnN0eWxlLmhlaWdodCA9IGMuYi5oZWlnaHQgKyBcInB4XCI7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gY29tcHM7XG59LFxuICAgIF9tYWtlQ29tcHNBYnNvbHV0ZSA9IGZ1bmN0aW9uIF9tYWtlQ29tcHNBYnNvbHV0ZShjb21wcykge1xuICByZXR1cm4gX29yZGVyQnlET01EZXB0aChjb21wcywgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiAoYy5hLmlzVmlzaWJsZSB8fCBjLmIuaXNWaXNpYmxlKSAmJiBfbWFrZUFic29sdXRlKGMuc2QgPCAwID8gYy5iIDogYy5hLCBjLmIsIDEpO1xuICB9KTtcbn0sXG4gICAgX2ZpbmRFbFN0YXRlSW5TdGF0ZSA9IGZ1bmN0aW9uIF9maW5kRWxTdGF0ZUluU3RhdGUoc3RhdGUsIG90aGVyKSB7XG4gIHJldHVybiBvdGhlciAmJiBzdGF0ZS5pZExvb2t1cFtfcGFyc2VFbGVtZW50U3RhdGUob3RoZXIpLmlkXSB8fCBzdGF0ZS5lbGVtZW50U3RhdGVzWzBdO1xufSxcbiAgICBfcGFyc2VFbGVtZW50U3RhdGUgPSBmdW5jdGlvbiBfcGFyc2VFbGVtZW50U3RhdGUoZWxPck5vZGUsIHByb3BzLCBzaW1wbGUsIG90aGVyKSB7XG4gIHJldHVybiBlbE9yTm9kZSBpbnN0YW5jZW9mIEVsZW1lbnRTdGF0ZSA/IGVsT3JOb2RlIDogZWxPck5vZGUgaW5zdGFuY2VvZiBGbGlwU3RhdGUgPyBfZmluZEVsU3RhdGVJblN0YXRlKGVsT3JOb2RlLCBvdGhlcikgOiBuZXcgRWxlbWVudFN0YXRlKHR5cGVvZiBlbE9yTm9kZSA9PT0gXCJzdHJpbmdcIiA/IF9nZXRFbChlbE9yTm9kZSkgfHwgY29uc29sZS53YXJuKGVsT3JOb2RlICsgXCIgbm90IGZvdW5kXCIpIDogZWxPck5vZGUsIHByb3BzLCBzaW1wbGUpO1xufSxcbiAgICBfcmVjb3JkUHJvcHMgPSBmdW5jdGlvbiBfcmVjb3JkUHJvcHMoZWxTdGF0ZSwgcHJvcHMpIHtcbiAgdmFyIGdldFByb3AgPSBnc2FwLmdldFByb3BlcnR5KGVsU3RhdGUuZWxlbWVudCwgbnVsbCwgXCJuYXRpdmVcIiksXG4gICAgICBvYmogPSBlbFN0YXRlLnByb3BzID0ge30sXG4gICAgICBpID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBvYmpbcHJvcHNbaV1dID0gKGdldFByb3AocHJvcHNbaV0pICsgXCJcIikudHJpbSgpO1xuICB9XG5cbiAgb2JqLnpJbmRleCAmJiAob2JqLnpJbmRleCA9IHBhcnNlRmxvYXQob2JqLnpJbmRleCkgfHwgMCk7XG4gIHJldHVybiBlbFN0YXRlO1xufSxcbiAgICBfYXBwbHlQcm9wcyA9IGZ1bmN0aW9uIF9hcHBseVByb3BzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBzdHlsZSA9IGVsZW1lbnQuc3R5bGUgfHwgZWxlbWVudCxcbiAgICAgIC8vIGNvdWxkIHBhc3MgaW4gYSB2YXJzIG9iamVjdC5cbiAgcDtcblxuICBmb3IgKHAgaW4gcHJvcHMpIHtcbiAgICBzdHlsZVtwXSA9IHByb3BzW3BdO1xuICB9XG59LFxuICAgIF9nZXRJRCA9IGZ1bmN0aW9uIF9nZXRJRChlbCkge1xuICB2YXIgaWQgPSBlbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWZsaXAtaWRcIik7XG4gIGlkIHx8IGVsLnNldEF0dHJpYnV0ZShcImRhdGEtZmxpcC1pZFwiLCBpZCA9IFwiYXV0by1cIiArIF9pZCsrKTtcbiAgcmV0dXJuIGlkO1xufSxcbiAgICBfZWxlbWVudHNGcm9tRWxlbWVudFN0YXRlcyA9IGZ1bmN0aW9uIF9lbGVtZW50c0Zyb21FbGVtZW50U3RhdGVzKGVsU3RhdGVzKSB7XG4gIHJldHVybiBlbFN0YXRlcy5tYXAoZnVuY3Rpb24gKGVsU3RhdGUpIHtcbiAgICByZXR1cm4gZWxTdGF0ZS5lbGVtZW50O1xuICB9KTtcbn0sXG4gICAgX2hhbmRsZUNhbGxiYWNrID0gZnVuY3Rpb24gX2hhbmRsZUNhbGxiYWNrKGNhbGxiYWNrLCBlbFN0YXRlcywgdGwpIHtcbiAgcmV0dXJuIGNhbGxiYWNrICYmIGVsU3RhdGVzLmxlbmd0aCAmJiB0bC5hZGQoY2FsbGJhY2soX2VsZW1lbnRzRnJvbUVsZW1lbnRTdGF0ZXMoZWxTdGF0ZXMpLCB0bCwgbmV3IEZsaXBTdGF0ZShlbFN0YXRlcywgMCwgdHJ1ZSkpLCAwKTtcbn0sXG4gICAgX2ZpdCA9IGZ1bmN0aW9uIF9maXQoZnJvbVN0YXRlLCB0b1N0YXRlLCBzY2FsZSwgYXBwbHlQcm9wcywgZml0Q2hpbGQsIHZhcnMpIHtcbiAgdmFyIGVsZW1lbnQgPSBmcm9tU3RhdGUuZWxlbWVudCxcbiAgICAgIGNhY2hlID0gZnJvbVN0YXRlLmNhY2hlLFxuICAgICAgcGFyZW50ID0gZnJvbVN0YXRlLnBhcmVudCxcbiAgICAgIHggPSBmcm9tU3RhdGUueCxcbiAgICAgIHkgPSBmcm9tU3RhdGUueSxcbiAgICAgIHdpZHRoID0gdG9TdGF0ZS53aWR0aCxcbiAgICAgIGhlaWdodCA9IHRvU3RhdGUuaGVpZ2h0LFxuICAgICAgc2NhbGVYID0gdG9TdGF0ZS5zY2FsZVgsXG4gICAgICBzY2FsZVkgPSB0b1N0YXRlLnNjYWxlWSxcbiAgICAgIHJvdGF0aW9uID0gdG9TdGF0ZS5yb3RhdGlvbixcbiAgICAgIGJvdW5kcyA9IHRvU3RhdGUuYm91bmRzLFxuICAgICAgY3NzVGV4dCA9IHZhcnMgJiYgZWxlbWVudC5zdHlsZS5jc3NUZXh0LFxuICAgICAgdHJhbnNmb3JtID0gdmFycyAmJiBlbGVtZW50LmdldEJCb3ggJiYgZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiksXG4gICAgICBkaW1lbnNpb25TdGF0ZSA9IGZyb21TdGF0ZSxcbiAgICAgIF90b1N0YXRlJG1hdHJpeCA9IHRvU3RhdGUubWF0cml4LFxuICAgICAgZSA9IF90b1N0YXRlJG1hdHJpeC5lLFxuICAgICAgZiA9IF90b1N0YXRlJG1hdHJpeC5mLFxuICAgICAgZGVlcCA9IGZyb21TdGF0ZS5ib3VuZHMud2lkdGggIT09IGJvdW5kcy53aWR0aCB8fCBmcm9tU3RhdGUuYm91bmRzLmhlaWdodCAhPT0gYm91bmRzLmhlaWdodCB8fCBmcm9tU3RhdGUuc2NhbGVYICE9PSBzY2FsZVggfHwgZnJvbVN0YXRlLnNjYWxlWSAhPT0gc2NhbGVZIHx8IGZyb21TdGF0ZS5yb3RhdGlvbiAhPT0gcm90YXRpb24sXG4gICAgICBzaW1wbGUgPSAhZGVlcCAmJiBmcm9tU3RhdGUuc2ltcGxlICYmIHRvU3RhdGUuc2ltcGxlICYmICFmaXRDaGlsZCxcbiAgICAgIHNrZXdYLFxuICAgICAgZnJvbVBvaW50LFxuICAgICAgdG9Qb2ludCxcbiAgICAgIGdldFByb3AsXG4gICAgICBwYXJlbnRNYXRyaXgsXG4gICAgICBtYXRyaXgsXG4gICAgICBiYm94O1xuXG4gIGlmIChzaW1wbGUpIHtcbiAgICBzY2FsZVggPSBzY2FsZVkgPSAxO1xuICAgIHJvdGF0aW9uID0gc2tld1ggPSAwO1xuICB9IGVsc2Uge1xuICAgIHBhcmVudE1hdHJpeCA9IF9nZXRJbnZlcnNlR2xvYmFsTWF0cml4KHBhcmVudCk7XG4gICAgbWF0cml4ID0gcGFyZW50TWF0cml4LmNsb25lKCkubXVsdGlwbHkodG9TdGF0ZS5jdG0gPyB0b1N0YXRlLm1hdHJpeC5jbG9uZSgpLm11bHRpcGx5KHRvU3RhdGUuY3RtKSA6IHRvU3RhdGUubWF0cml4KTsgLy8gcm9vdCBTVkcgZWxlbWVudHMgaGF2ZSBhIGN0bSB0aGF0IHdlIG11c3QgZmFjdG9yIG91dCAoZm9yIGV4YW1wbGUsIHZpZXdCb3g6XCIwIDAgOTQgOTRcIiB3aXRoIGEgd2lkdGggb2YgMjAwcHggd291bGQgc2NhbGUgdGhlIGludGVybmFscyBieSAyLjEyNyBidXQgd2hlbiB3ZSdyZSBtYXRjaGluZyB0aGUgc2l6ZSBvZiB0aGUgcm9vdCA8c3ZnPiBlbGVtZW50IGl0c2VsZiwgdGhhdCBzY2FsaW5nIHNob3VsZG4ndCBmYWN0b3IgaW4hKVxuXG4gICAgcm90YXRpb24gPSBfcm91bmQoTWF0aC5hdGFuMihtYXRyaXguYiwgbWF0cml4LmEpICogX1JBRDJERUcpO1xuICAgIHNrZXdYID0gX3JvdW5kKE1hdGguYXRhbjIobWF0cml4LmMsIG1hdHJpeC5kKSAqIF9SQUQyREVHICsgcm90YXRpb24pICUgMzYwOyAvLyBpbiB2ZXJ5IHJhcmUgY2FzZXMsIG1pbm9yIHJvdW5kaW5nIG1pZ2h0IGVuZCB1cCB3aXRoIDM2MCB3aGljaCBzaG91bGQgYmUgMC5cblxuICAgIHNjYWxlWCA9IE1hdGguc3FydChNYXRoLnBvdyhtYXRyaXguYSwgMikgKyBNYXRoLnBvdyhtYXRyaXguYiwgMikpO1xuICAgIHNjYWxlWSA9IE1hdGguc3FydChNYXRoLnBvdyhtYXRyaXguYywgMikgKyBNYXRoLnBvdyhtYXRyaXguZCwgMikpICogTWF0aC5jb3Moc2tld1ggKiBfREVHMlJBRCk7XG5cbiAgICBpZiAoZml0Q2hpbGQpIHtcbiAgICAgIGZpdENoaWxkID0gX3RvQXJyYXkoZml0Q2hpbGQpWzBdO1xuICAgICAgZ2V0UHJvcCA9IGdzYXAuZ2V0UHJvcGVydHkoZml0Q2hpbGQpO1xuICAgICAgYmJveCA9IGZpdENoaWxkLmdldEJCb3ggJiYgdHlwZW9mIGZpdENoaWxkLmdldEJCb3ggPT09IFwiZnVuY3Rpb25cIiAmJiBmaXRDaGlsZC5nZXRCQm94KCk7XG4gICAgICBkaW1lbnNpb25TdGF0ZSA9IHtcbiAgICAgICAgc2NhbGVYOiBnZXRQcm9wKFwic2NhbGVYXCIpLFxuICAgICAgICBzY2FsZVk6IGdldFByb3AoXCJzY2FsZVlcIiksXG4gICAgICAgIHdpZHRoOiBiYm94ID8gYmJveC53aWR0aCA6IE1hdGguY2VpbChwYXJzZUZsb2F0KGdldFByb3AoXCJ3aWR0aFwiLCBcInB4XCIpKSksXG4gICAgICAgIGhlaWdodDogYmJveCA/IGJib3guaGVpZ2h0IDogcGFyc2VGbG9hdChnZXRQcm9wKFwiaGVpZ2h0XCIsIFwicHhcIikpXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNhY2hlLnJvdGF0aW9uID0gcm90YXRpb24gKyBcImRlZ1wiO1xuICAgIGNhY2hlLnNrZXdYID0gc2tld1ggKyBcImRlZ1wiO1xuICB9XG5cbiAgaWYgKHNjYWxlKSB7XG4gICAgc2NhbGVYICo9IHdpZHRoID09PSBkaW1lbnNpb25TdGF0ZS53aWR0aCB8fCAhZGltZW5zaW9uU3RhdGUud2lkdGggPyAxIDogd2lkdGggLyBkaW1lbnNpb25TdGF0ZS53aWR0aDsgLy8gbm90ZSBpZiB3aWR0aHMgYXJlIGJvdGggMCwgd2Ugc2hvdWxkIG1ha2Ugc2NhbGVYIDEgLSBzb21lIGVsZW1lbnRzIGhhdmUgYm94LXNpemluZyB0aGF0IGluY29ycG9yYXRlcyBwYWRkaW5nLCBldGMuIGFuZCB3ZSBkb24ndCB3YW50IGl0IHRvIGNvbGxhcHNlIGluIHRoYXQgY2FzZS5cblxuICAgIHNjYWxlWSAqPSBoZWlnaHQgPT09IGRpbWVuc2lvblN0YXRlLmhlaWdodCB8fCAhZGltZW5zaW9uU3RhdGUuaGVpZ2h0ID8gMSA6IGhlaWdodCAvIGRpbWVuc2lvblN0YXRlLmhlaWdodDtcbiAgICBjYWNoZS5zY2FsZVggPSBzY2FsZVg7XG4gICAgY2FjaGUuc2NhbGVZID0gc2NhbGVZO1xuICB9IGVsc2Uge1xuICAgIHdpZHRoID0gX2Nsb3Nlc3RUZW50aCh3aWR0aCAqIHNjYWxlWCAvIGRpbWVuc2lvblN0YXRlLnNjYWxlWCwgMCk7XG4gICAgaGVpZ2h0ID0gX2Nsb3Nlc3RUZW50aChoZWlnaHQgKiBzY2FsZVkgLyBkaW1lbnNpb25TdGF0ZS5zY2FsZVksIDApO1xuICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSB3aWR0aCArIFwicHhcIjtcbiAgICBlbGVtZW50LnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgfSAvLyBpZiAoZnJvbVN0YXRlLmlzRml4ZWQpIHsgLy8gY29tbWVudGVkIG91dCBiZWNhdXNlIGl0J3Mgbm93IHRha2VuIGNhcmUgb2YgaW4gZ2V0R2xvYmFsTWF0cml4KCkgd2l0aCBhIGZsYWcgYXQgdGhlIGVuZC5cbiAgLy8gXHRlIC09IF9nZXREb2NTY3JvbGxMZWZ0KCk7XG4gIC8vIFx0ZiAtPSBfZ2V0RG9jU2Nyb2xsVG9wKCk7XG4gIC8vIH1cblxuXG4gIGFwcGx5UHJvcHMgJiYgX2FwcGx5UHJvcHMoZWxlbWVudCwgdG9TdGF0ZS5wcm9wcyk7XG5cbiAgaWYgKHNpbXBsZSkge1xuICAgIHggKz0gZSAtIGZyb21TdGF0ZS5tYXRyaXguZTtcbiAgICB5ICs9IGYgLSBmcm9tU3RhdGUubWF0cml4LmY7XG4gIH0gZWxzZSBpZiAoZGVlcCB8fCBwYXJlbnQgIT09IHRvU3RhdGUucGFyZW50KSB7XG4gICAgY2FjaGUucmVuZGVyVHJhbnNmb3JtKDEsIGNhY2hlKTtcbiAgICBtYXRyaXggPSBnZXRHbG9iYWxNYXRyaXgoZml0Q2hpbGQgfHwgZWxlbWVudCwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICBmcm9tUG9pbnQgPSBwYXJlbnRNYXRyaXguYXBwbHkoe1xuICAgICAgeDogbWF0cml4LmUsXG4gICAgICB5OiBtYXRyaXguZlxuICAgIH0pO1xuICAgIHRvUG9pbnQgPSBwYXJlbnRNYXRyaXguYXBwbHkoe1xuICAgICAgeDogZSxcbiAgICAgIHk6IGZcbiAgICB9KTtcbiAgICB4ICs9IHRvUG9pbnQueCAtIGZyb21Qb2ludC54O1xuICAgIHkgKz0gdG9Qb2ludC55IC0gZnJvbVBvaW50Lnk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXNlIGEgZmFzdGVyL2NoZWFwZXIgYWxnb3JpdGhtIGlmIHdlJ3JlIGp1c3QgbW92aW5nIHgveVxuICAgIHBhcmVudE1hdHJpeC5lID0gcGFyZW50TWF0cml4LmYgPSAwO1xuICAgIHRvUG9pbnQgPSBwYXJlbnRNYXRyaXguYXBwbHkoe1xuICAgICAgeDogZSAtIGZyb21TdGF0ZS5tYXRyaXguZSxcbiAgICAgIHk6IGYgLSBmcm9tU3RhdGUubWF0cml4LmZcbiAgICB9KTtcbiAgICB4ICs9IHRvUG9pbnQueDtcbiAgICB5ICs9IHRvUG9pbnQueTtcbiAgfVxuXG4gIHggPSBfY2xvc2VzdFRlbnRoKHgsIDAuMDIpO1xuICB5ID0gX2Nsb3Nlc3RUZW50aCh5LCAwLjAyKTtcblxuICBpZiAodmFycyAmJiAhKHZhcnMgaW5zdGFuY2VvZiBFbGVtZW50U3RhdGUpKSB7XG4gICAgLy8gcmV2ZXJ0XG4gICAgZWxlbWVudC5zdHlsZS5jc3NUZXh0ID0gY3NzVGV4dDtcbiAgICBlbGVtZW50LmdldEJCb3ggJiYgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtIHx8IFwiXCIpO1xuICAgIGNhY2hlLnVuY2FjaGUgPSAxO1xuICB9IGVsc2Uge1xuICAgIC8vIG9yIGFwcGx5IHRoZSB0cmFuc2Zvcm0gaW1tZWRpYXRlbHlcbiAgICBjYWNoZS54ID0geCArIFwicHhcIjtcbiAgICBjYWNoZS55ID0geSArIFwicHhcIjtcbiAgICBjYWNoZS5yZW5kZXJUcmFuc2Zvcm0oMSwgY2FjaGUpO1xuICB9XG5cbiAgaWYgKHZhcnMpIHtcbiAgICB2YXJzLnggPSB4O1xuICAgIHZhcnMueSA9IHk7XG4gICAgdmFycy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHZhcnMuc2tld1ggPSBza2V3WDtcblxuICAgIGlmIChzY2FsZSkge1xuICAgICAgdmFycy5zY2FsZVggPSBzY2FsZVg7XG4gICAgICB2YXJzLnNjYWxlWSA9IHNjYWxlWTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFycy53aWR0aCA9IHdpZHRoO1xuICAgICAgdmFycy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhcnMgfHwgY2FjaGU7XG59LFxuICAgIF9wYXJzZVN0YXRlID0gZnVuY3Rpb24gX3BhcnNlU3RhdGUodGFyZ2V0c09yU3RhdGUsIHZhcnMpIHtcbiAgcmV0dXJuIHRhcmdldHNPclN0YXRlIGluc3RhbmNlb2YgRmxpcFN0YXRlID8gdGFyZ2V0c09yU3RhdGUgOiBuZXcgRmxpcFN0YXRlKHRhcmdldHNPclN0YXRlLCB2YXJzKTtcbn0sXG4gICAgX2dldENoYW5naW5nRWxTdGF0ZSA9IGZ1bmN0aW9uIF9nZXRDaGFuZ2luZ0VsU3RhdGUodG9TdGF0ZSwgZnJvbVN0YXRlLCBpZCkge1xuICB2YXIgdG8xID0gdG9TdGF0ZS5pZExvb2t1cFtpZF0sXG4gICAgICB0bzIgPSB0b1N0YXRlLmFsdFtpZF07XG4gIHJldHVybiB0bzIuaXNWaXNpYmxlICYmICghKGZyb21TdGF0ZS5nZXRFbGVtZW50U3RhdGUodG8yLmVsZW1lbnQpIHx8IHRvMikuaXNWaXNpYmxlIHx8ICF0bzEuaXNWaXNpYmxlKSA/IHRvMiA6IHRvMTtcbn0sXG4gICAgX2JvZHlNZXRyaWNzID0gW10sXG4gICAgX2JvZHlQcm9wcyA9IFwid2lkdGgsaGVpZ2h0LG92ZXJmbG93WCxvdmVyZmxvd1lcIi5zcGxpdChcIixcIiksXG4gICAgX2JvZHlMb2NrZWQsXG4gICAgX2xvY2tCb2R5U2Nyb2xsID0gZnVuY3Rpb24gX2xvY2tCb2R5U2Nyb2xsKGxvY2spIHtcbiAgLy8gaWYgdGhlcmUncyBubyBzY3JvbGxiYXIsIHdlIHNob3VsZCBsb2NrIHRoYXQgc28gdGhhdCBtZWFzdXJlbWVudHMgZG9uJ3QgZ2V0IGFmZmVjdGVkIGJ5IHRlbXBvcmFyeSByZXBvc2l0aW9uaW5nLCBsaWtlIGlmIHNvbWV0aGluZyBpcyBjZW50ZXJlZCBpbiB0aGUgd2luZG93LlxuICBpZiAobG9jayAhPT0gX2JvZHlMb2NrZWQpIHtcbiAgICB2YXIgcyA9IF9ib2R5LnN0eWxlLFxuICAgICAgICB3ID0gX2JvZHkuY2xpZW50V2lkdGggPT09IHdpbmRvdy5vdXRlcldpZHRoLFxuICAgICAgICBoID0gX2JvZHkuY2xpZW50SGVpZ2h0ID09PSB3aW5kb3cub3V0ZXJIZWlnaHQsXG4gICAgICAgIGkgPSA0O1xuXG4gICAgaWYgKGxvY2sgJiYgKHcgfHwgaCkpIHtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgX2JvZHlNZXRyaWNzW2ldID0gc1tfYm9keVByb3BzW2ldXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHcpIHtcbiAgICAgICAgcy53aWR0aCA9IF9ib2R5LmNsaWVudFdpZHRoICsgXCJweFwiO1xuICAgICAgICBzLm92ZXJmbG93WSA9IFwiaGlkZGVuXCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChoKSB7XG4gICAgICAgIHMuaGVpZ2h0ID0gX2JvZHkuY2xpZW50SGVpZ2h0ICsgXCJweFwiO1xuICAgICAgICBzLm92ZXJmbG93WCA9IFwiaGlkZGVuXCI7XG4gICAgICB9XG5cbiAgICAgIF9ib2R5TG9ja2VkID0gbG9jaztcbiAgICB9IGVsc2UgaWYgKF9ib2R5TG9ja2VkKSB7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIF9ib2R5TWV0cmljc1tpXSA/IHNbX2JvZHlQcm9wc1tpXV0gPSBfYm9keU1ldHJpY3NbaV0gOiBzLnJlbW92ZVByb3BlcnR5KF9jYW1lbFRvRGFzaGVkKF9ib2R5UHJvcHNbaV0pKTtcbiAgICAgIH1cblxuICAgICAgX2JvZHlMb2NrZWQgPSBsb2NrO1xuICAgIH1cbiAgfVxufSxcbiAgICBfZnJvbVRvID0gZnVuY3Rpb24gX2Zyb21Ubyhmcm9tU3RhdGUsIHRvU3RhdGUsIHZhcnMsIHJlbGF0aXZlKSB7XG4gIC8vIHJlbGF0aXZlIGlzIC0xIGlmIFwiZnJvbSgpXCIsIGFuZCAxIGlmIFwidG8oKVwiXG4gIGZyb21TdGF0ZSBpbnN0YW5jZW9mIEZsaXBTdGF0ZSAmJiB0b1N0YXRlIGluc3RhbmNlb2YgRmxpcFN0YXRlIHx8IGNvbnNvbGUud2FybihcIk5vdCBhIHZhbGlkIHN0YXRlIG9iamVjdC5cIik7XG4gIHZhcnMgPSB2YXJzIHx8IHt9O1xuXG4gIHZhciBfdmFycyA9IHZhcnMsXG4gICAgICBjbGVhclByb3BzID0gX3ZhcnMuY2xlYXJQcm9wcyxcbiAgICAgIG9uRW50ZXIgPSBfdmFycy5vbkVudGVyLFxuICAgICAgb25MZWF2ZSA9IF92YXJzLm9uTGVhdmUsXG4gICAgICBhYnNvbHV0ZSA9IF92YXJzLmFic29sdXRlLFxuICAgICAgYWJzb2x1dGVPbkxlYXZlID0gX3ZhcnMuYWJzb2x1dGVPbkxlYXZlLFxuICAgICAgY3VzdG9tID0gX3ZhcnMuY3VzdG9tLFxuICAgICAgZGVsYXkgPSBfdmFycy5kZWxheSxcbiAgICAgIHBhdXNlZCA9IF92YXJzLnBhdXNlZCxcbiAgICAgIHJlcGVhdCA9IF92YXJzLnJlcGVhdCxcbiAgICAgIHJlcGVhdERlbGF5ID0gX3ZhcnMucmVwZWF0RGVsYXksXG4gICAgICB5b3lvID0gX3ZhcnMueW95byxcbiAgICAgIHRvZ2dsZUNsYXNzID0gX3ZhcnMudG9nZ2xlQ2xhc3MsXG4gICAgICBuZXN0ZWQgPSBfdmFycy5uZXN0ZWQsXG4gICAgICBfekluZGV4ID0gX3ZhcnMuekluZGV4LFxuICAgICAgc2NhbGUgPSBfdmFycy5zY2FsZSxcbiAgICAgIGZhZGUgPSBfdmFycy5mYWRlLFxuICAgICAgc3RhZ2dlciA9IF92YXJzLnN0YWdnZXIsXG4gICAgICBzcGluID0gX3ZhcnMuc3BpbixcbiAgICAgIHBydW5lID0gX3ZhcnMucHJ1bmUsXG4gICAgICBwcm9wcyA9IChcInByb3BzXCIgaW4gdmFycyA/IHZhcnMgOiBmcm9tU3RhdGUpLnByb3BzLFxuICAgICAgdHdlZW5WYXJzID0gX2NvcHkodmFycywgX3Jlc2VydmVkKSxcbiAgICAgIGFuaW1hdGlvbiA9IGdzYXAudGltZWxpbmUoe1xuICAgIGRlbGF5OiBkZWxheSxcbiAgICBwYXVzZWQ6IHBhdXNlZCxcbiAgICByZXBlYXQ6IHJlcGVhdCxcbiAgICByZXBlYXREZWxheTogcmVwZWF0RGVsYXksXG4gICAgeW95bzogeW95b1xuICB9KSxcbiAgICAgIHJlbWFpbmluZ1Byb3BzID0gdHdlZW5WYXJzLFxuICAgICAgZW50ZXJpbmcgPSBbXSxcbiAgICAgIGxlYXZpbmcgPSBbXSxcbiAgICAgIGNvbXBzID0gW10sXG4gICAgICBzd2FwT3V0VGFyZ2V0cyA9IFtdLFxuICAgICAgc3Bpbk51bSA9IHNwaW4gPT09IHRydWUgPyAxIDogc3BpbiB8fCAwLFxuICAgICAgc3BpbkZ1bmMgPSB0eXBlb2Ygc3BpbiA9PT0gXCJmdW5jdGlvblwiID8gc3BpbiA6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc3Bpbk51bTtcbiAgfSxcbiAgICAgIGludGVycnVwdGVkID0gZnJvbVN0YXRlLmludGVycnVwdGVkIHx8IHRvU3RhdGUuaW50ZXJydXB0ZWQsXG4gICAgICBhZGRGdW5jID0gYW5pbWF0aW9uW3JlbGF0aXZlICE9PSAxID8gXCJ0b1wiIDogXCJmcm9tXCJdLFxuICAgICAgdixcbiAgICAgIHAsXG4gICAgICBlbmRUaW1lLFxuICAgICAgaSxcbiAgICAgIGVsLFxuICAgICAgY29tcCxcbiAgICAgIHN0YXRlLFxuICAgICAgdGFyZ2V0cyxcbiAgICAgIGZpbmFsU3RhdGVzLFxuICAgICAgZnJvbU5vZGUsXG4gICAgICB0b05vZGUsXG4gICAgICBydW4sXG4gICAgICBhLFxuICAgICAgYjsgLy9yZWxhdGl2ZSB8fCAodG9TdGF0ZSA9IChuZXcgRmxpcFN0YXRlKHRvU3RhdGUudGFyZ2V0cywge3Byb3BzOiBwcm9wc30pKS5maXQodG9TdGF0ZSwgc2NhbGUpKTtcblxuXG4gIGZvciAocCBpbiB0b1N0YXRlLmlkTG9va3VwKSB7XG4gICAgdG9Ob2RlID0gIXRvU3RhdGUuYWx0W3BdID8gdG9TdGF0ZS5pZExvb2t1cFtwXSA6IF9nZXRDaGFuZ2luZ0VsU3RhdGUodG9TdGF0ZSwgZnJvbVN0YXRlLCBwKTtcbiAgICBlbCA9IHRvTm9kZS5lbGVtZW50O1xuICAgIGZyb21Ob2RlID0gZnJvbVN0YXRlLmlkTG9va3VwW3BdO1xuICAgIGZyb21TdGF0ZS5hbHRbcF0gJiYgZWwgPT09IGZyb21Ob2RlLmVsZW1lbnQgJiYgKGZyb21TdGF0ZS5hbHRbcF0uaXNWaXNpYmxlIHx8ICF0b05vZGUuaXNWaXNpYmxlKSAmJiAoZnJvbU5vZGUgPSBmcm9tU3RhdGUuYWx0W3BdKTtcblxuICAgIGlmIChmcm9tTm9kZSkge1xuICAgICAgY29tcCA9IHtcbiAgICAgICAgdDogZWwsXG4gICAgICAgIGI6IGZyb21Ob2RlLFxuICAgICAgICBhOiB0b05vZGUsXG4gICAgICAgIHNkOiBmcm9tTm9kZS5lbGVtZW50ID09PSBlbCA/IDAgOiB0b05vZGUuaXNWaXNpYmxlID8gMSA6IC0xXG4gICAgICB9O1xuICAgICAgY29tcHMucHVzaChjb21wKTtcblxuICAgICAgaWYgKGNvbXAuc2QpIHtcbiAgICAgICAgaWYgKGNvbXAuc2QgPCAwKSB7XG4gICAgICAgICAgY29tcC5iID0gdG9Ob2RlO1xuICAgICAgICAgIGNvbXAuYSA9IGZyb21Ob2RlO1xuICAgICAgICB9IC8vIGZvciBzd2FwcGluZyBlbGVtZW50cyB0aGF0IGdvdCBpbnRlcnJ1cHRlZCwgd2UgbXVzdCByZS1yZWNvcmQgdGhlIGlubGluZSBzdHlsZXMgdG8gZW5zdXJlIHRoZXkncmUgbm90IHRhaW50ZWQuIFJlbWVtYmVyLCAuYmF0Y2goKSBwZXJtaXRzIGdldFN0YXRlKCkgbm90IHRvIGZvcmNlIGluLXByb2dyZXNzIGZsaXBzIHRvIHRoZWlyIGVuZCBzdGF0ZS5cblxuXG4gICAgICAgIGludGVycnVwdGVkICYmIF9yZWNvcmRJbmxpbmVTdHlsZXMoY29tcC5iLCBwcm9wcyA/IF9tZW1vaXplZFJlbW92ZVByb3BzW3Byb3BzXSA6IF9yZW1vdmVQcm9wcyk7XG4gICAgICAgIGZhZGUgJiYgY29tcHMucHVzaChjb21wLnN3YXAgPSB7XG4gICAgICAgICAgdDogZnJvbU5vZGUuZWxlbWVudCxcbiAgICAgICAgICBiOiBjb21wLmIsXG4gICAgICAgICAgYTogY29tcC5hLFxuICAgICAgICAgIHNkOiAtY29tcC5zZCxcbiAgICAgICAgICBzd2FwOiBjb21wXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBlbC5fZmxpcCA9IGZyb21Ob2RlLmVsZW1lbnQuX2ZsaXAgPSBfYmF0Y2ggPyBfYmF0Y2gudGltZWxpbmUgOiBhbmltYXRpb247XG4gICAgfSBlbHNlIGlmICh0b05vZGUuaXNWaXNpYmxlKSB7XG4gICAgICBjb21wcy5wdXNoKHtcbiAgICAgICAgdDogZWwsXG4gICAgICAgIGI6IF9jb3B5KHRvTm9kZSwge1xuICAgICAgICAgIGlzVmlzaWJsZTogMVxuICAgICAgICB9KSxcbiAgICAgICAgYTogdG9Ob2RlLFxuICAgICAgICBzZDogMFxuICAgICAgfSk7IC8vIHRvIGluY2x1ZGUgaXQgaW4gdGhlIFwiZW50ZXJpbmdcIiBBcnJheSBhbmQgZG8gYWJzb2x1dGUgcG9zaXRpb25pbmcgaWYgbmVjZXNzYXJ5XG5cbiAgICAgIGVsLl9mbGlwID0gX2JhdGNoID8gX2JhdGNoLnRpbWVsaW5lIDogYW5pbWF0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHByb3BzICYmIChfbWVtb2l6ZWRQcm9wc1twcm9wc10gfHwgX21lbW9pemVQcm9wcyhwcm9wcykpLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gdHdlZW5WYXJzW3BdID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBjb21wc1tpXS5hLnByb3BzW3BdO1xuICAgIH07XG4gIH0pO1xuICBjb21wcy5maW5hbFN0YXRlcyA9IGZpbmFsU3RhdGVzID0gW107XG5cbiAgcnVuID0gZnVuY3Rpb24gcnVuKCkge1xuICAgIF9vcmRlckJ5RE9NRGVwdGgoY29tcHMpO1xuXG4gICAgX2xvY2tCb2R5U2Nyb2xsKHRydWUpOyAvLyBvdGhlcndpc2UsIG1lYXN1cmVtZW50cyBtYXkgZ2V0IHRocm93biBvZmYgd2hlbiB0aGluZ3MgZ2V0IGZpdC5cbiAgICAvLyBUT0RPOiBjYWNoZSB0aGUgbWF0cml4LCBlc3BlY2lhbGx5IGZvciBwYXJlbnQgYmVjYXVzZSBpdCdsbCBwcm9iYWJseSBnZXQgcmV1c2VkIHF1aXRlIGEgYml0LCBidXQgbG9jayBpdCB0byBhIHBhcnRpY3VsYXIgY3ljbGUoPykuXG5cblxuICAgIGZvciAoaSA9IDA7IGkgPCBjb21wcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29tcCA9IGNvbXBzW2ldO1xuICAgICAgYSA9IGNvbXAuYTtcbiAgICAgIGIgPSBjb21wLmI7XG5cbiAgICAgIGlmIChwcnVuZSAmJiAhYS5pc0RpZmZlcmVudChiKSkge1xuICAgICAgICAvLyBvbmx5IGZsaXAgaWYgdGhpbmdzIGNoYW5nZWQhIERvbid0IG9taXQgaXQgZnJvbSBjb21wcyBpbml0aWFsbHkgYmVjYXVzZSB0aGF0J2QgcHJldmVudCB0aGUgZWxlbWVudCBmcm9tIGJlaW5nIHBvc2l0aW9uZWQgYWJzb2x1dGVseSAoaWYgbmVjZXNzYXJ5KVxuICAgICAgICBjb21wcy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsID0gY29tcC50O1xuICAgICAgICBuZXN0ZWQgJiYgIShjb21wLnNkIDwgMCkgJiYgaSAmJiAoYS5tYXRyaXggPSBnZXRHbG9iYWxNYXRyaXgoZWwsIGZhbHNlLCBmYWxzZSwgdHJ1ZSkpOyAvLyBtb3ZpbmcgYSBwYXJlbnQgYWZmZWN0cyB0aGUgcG9zaXRpb24gb2YgY2hpbGRyZW5cblxuICAgICAgICBpZiAoY29tcC5zZCB8fCBiLmlzVmlzaWJsZSAmJiBhLmlzVmlzaWJsZSkge1xuICAgICAgICAgIGlmIChjb21wLnNkIDwgMCkge1xuICAgICAgICAgICAgLy8gc3dhcHBpbmcgT1VUIChzd2FwIGRpcmVjdGlvbiBvZiAtMSBpcyBvdXQpXG4gICAgICAgICAgICBzdGF0ZSA9IG5ldyBFbGVtZW50U3RhdGUoZWwsIHByb3BzLCBmcm9tU3RhdGUuc2ltcGxlKTtcblxuICAgICAgICAgICAgX2ZpdChzdGF0ZSwgYSwgc2NhbGUsIDAsIDAsIHN0YXRlKTtcblxuICAgICAgICAgICAgc3RhdGUubWF0cml4ID0gZ2V0R2xvYmFsTWF0cml4KGVsLCBmYWxzZSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgc3RhdGUuY3NzID0gY29tcC5iLmNzcztcbiAgICAgICAgICAgIGNvbXAuYSA9IGEgPSBzdGF0ZTtcbiAgICAgICAgICAgIGZhZGUgJiYgKGVsLnN0eWxlLm9wYWNpdHkgPSBpbnRlcnJ1cHRlZCA/IGIub3BhY2l0eSA6IGEub3BhY2l0eSk7XG4gICAgICAgICAgICBzdGFnZ2VyICYmIHN3YXBPdXRUYXJnZXRzLnB1c2goZWwpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29tcC5zZCA+IDAgJiYgZmFkZSkge1xuICAgICAgICAgICAgLy8gc3dhcHBpbmcgSU4gKHN3YXAgZGlyZWN0aW9uIG9mIDEgaXMgaW4pXG4gICAgICAgICAgICBlbC5zdHlsZS5vcGFjaXR5ID0gaW50ZXJydXB0ZWQgPyBhLm9wYWNpdHkgLSBiLm9wYWNpdHkgOiBcIjBcIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfZml0KGEsIGIsIHNjYWxlLCBwcm9wcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoYi5pc1Zpc2libGUgIT09IGEuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgLy8gZWl0aGVyIGVudGVyaW5nIG9yIGxlYXZpbmcgKG9uZSBzaWRlIGlzIGludmlzaWJsZSlcbiAgICAgICAgICBpZiAoIWIuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICAvLyBlbnRlcmluZ1xuICAgICAgICAgICAgYS5pc1Zpc2libGUgJiYgZW50ZXJpbmcucHVzaChhKTtcbiAgICAgICAgICAgIGNvbXBzLnNwbGljZShpLS0sIDEpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWEuaXNWaXNpYmxlKSB7XG4gICAgICAgICAgICAvLyBsZWF2aW5nXG4gICAgICAgICAgICBiLmNzcyA9IGEuY3NzO1xuICAgICAgICAgICAgbGVhdmluZy5wdXNoKGIpO1xuICAgICAgICAgICAgY29tcHMuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgICAgICBhYnNvbHV0ZSAmJiBuZXN0ZWQgJiYgX2ZpdChhLCBiLCBzY2FsZSwgcHJvcHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2NhbGUpIHtcbiAgICAgICAgICBlbC5zdHlsZS5tYXhXaWR0aCA9IE1hdGgubWF4KGEud2lkdGgsIGIud2lkdGgpICsgXCJweFwiO1xuICAgICAgICAgIGVsLnN0eWxlLm1heEhlaWdodCA9IE1hdGgubWF4KGEuaGVpZ2h0LCBiLmhlaWdodCkgKyBcInB4XCI7XG4gICAgICAgICAgZWwuc3R5bGUubWluV2lkdGggPSBNYXRoLm1pbihhLndpZHRoLCBiLndpZHRoKSArIFwicHhcIjtcbiAgICAgICAgICBlbC5zdHlsZS5taW5IZWlnaHQgPSBNYXRoLm1pbihhLmhlaWdodCwgYi5oZWlnaHQpICsgXCJweFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgbmVzdGVkICYmIHRvZ2dsZUNsYXNzICYmIGVsLmNsYXNzTGlzdC5hZGQodG9nZ2xlQ2xhc3MpO1xuICAgICAgfVxuXG4gICAgICBmaW5hbFN0YXRlcy5wdXNoKGEpO1xuICAgIH1cblxuICAgIHZhciBjbGFzc1RhcmdldHM7XG5cbiAgICBpZiAodG9nZ2xlQ2xhc3MpIHtcbiAgICAgIGNsYXNzVGFyZ2V0cyA9IGZpbmFsU3RhdGVzLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gcy5lbGVtZW50O1xuICAgICAgfSk7XG4gICAgICBuZXN0ZWQgJiYgY2xhc3NUYXJnZXRzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUuY2xhc3NMaXN0LnJlbW92ZSh0b2dnbGVDbGFzcyk7XG4gICAgICB9KTsgLy8gdGhlcmUgY291bGQgYmUgYSBkZWxheSwgc28gZG9uJ3QgbGVhdmUgdGhlIGNsYXNzZXMgYXBwbGllZCAod2UnbGwgZG8gaXQgaW4gYSB0aW1lbGluZSBjYWxsYmFjaylcbiAgICB9XG5cbiAgICBfbG9ja0JvZHlTY3JvbGwoZmFsc2UpO1xuXG4gICAgaWYgKHNjYWxlKSB7XG4gICAgICB0d2VlblZhcnMuc2NhbGVYID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBzW2ldLmEuc2NhbGVYO1xuICAgICAgfTtcblxuICAgICAgdHdlZW5WYXJzLnNjYWxlWSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBjb21wc1tpXS5hLnNjYWxlWTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHR3ZWVuVmFycy53aWR0aCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBjb21wc1tpXS5hLndpZHRoICsgXCJweFwiO1xuICAgICAgfTtcblxuICAgICAgdHdlZW5WYXJzLmhlaWdodCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiBjb21wc1tpXS5hLmhlaWdodCArIFwicHhcIjtcbiAgICAgIH07XG5cbiAgICAgIHR3ZWVuVmFycy5hdXRvUm91bmQgPSB2YXJzLmF1dG9Sb3VuZCB8fCBmYWxzZTtcbiAgICB9XG5cbiAgICB0d2VlblZhcnMueCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gY29tcHNbaV0uYS54ICsgXCJweFwiO1xuICAgIH07XG5cbiAgICB0d2VlblZhcnMueSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gY29tcHNbaV0uYS55ICsgXCJweFwiO1xuICAgIH07XG5cbiAgICB0d2VlblZhcnMucm90YXRpb24gPSBmdW5jdGlvbiAoaSkge1xuICAgICAgcmV0dXJuIGNvbXBzW2ldLmEucm90YXRpb24gKyAoc3BpbiA/IHNwaW5GdW5jKGksIHRhcmdldHNbaV0sIHRhcmdldHMpICogMzYwIDogMCk7XG4gICAgfTtcblxuICAgIHR3ZWVuVmFycy5za2V3WCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gY29tcHNbaV0uYS5za2V3WDtcbiAgICB9O1xuXG4gICAgdGFyZ2V0cyA9IGNvbXBzLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIGMudDtcbiAgICB9KTtcblxuICAgIGlmIChfekluZGV4IHx8IF96SW5kZXggPT09IDApIHtcbiAgICAgIHR3ZWVuVmFycy5tb2RpZmllcnMgPSB7XG4gICAgICAgIHpJbmRleDogZnVuY3Rpb24gekluZGV4KCkge1xuICAgICAgICAgIHJldHVybiBfekluZGV4O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdHdlZW5WYXJzLnpJbmRleCA9IF96SW5kZXg7XG4gICAgICB0d2VlblZhcnMuaW1tZWRpYXRlUmVuZGVyID0gdmFycy5pbW1lZGlhdGVSZW5kZXIgIT09IGZhbHNlO1xuICAgIH1cblxuICAgIGZhZGUgJiYgKHR3ZWVuVmFycy5vcGFjaXR5ID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBjb21wc1tpXS5zZCA8IDAgPyAwIDogY29tcHNbaV0uc2QgPiAwID8gY29tcHNbaV0uYS5vcGFjaXR5IDogXCIrPTBcIjtcbiAgICB9KTtcblxuICAgIGlmIChzd2FwT3V0VGFyZ2V0cy5sZW5ndGgpIHtcbiAgICAgIHN0YWdnZXIgPSBnc2FwLnV0aWxzLmRpc3RyaWJ1dGUoc3RhZ2dlcik7XG4gICAgICB2YXIgZHVtbXlBcnJheSA9IHRhcmdldHMuc2xpY2Uoc3dhcE91dFRhcmdldHMubGVuZ3RoKTtcblxuICAgICAgdHdlZW5WYXJzLnN0YWdnZXIgPSBmdW5jdGlvbiAoaSwgZWwpIHtcbiAgICAgICAgcmV0dXJuIHN0YWdnZXIofnN3YXBPdXRUYXJnZXRzLmluZGV4T2YoZWwpID8gdGFyZ2V0cy5pbmRleE9mKGNvbXBzW2ldLnN3YXAudCkgOiBpLCBlbCwgZHVtbXlBcnJheSk7XG4gICAgICB9O1xuICAgIH0gLy8gLy8gZm9yIHRlc3RpbmcuLi5cbiAgICAvLyBnc2FwLmRlbGF5ZWRDYWxsKHZhcnMuZGF0YSA/IDUwIDogMSwgZnVuY3Rpb24oKSB7XG4gICAgLy8gXHRhbmltYXRpb24uZXZlbnRDYWxsYmFjayhcIm9uQ29tcGxldGVcIiwgKCkgPT4gX3NldEZpbmFsU3RhdGVzKGNvbXBzLCAhY2xlYXJQcm9wcykpO1xuICAgIC8vIFx0YWRkRnVuYy5jYWxsKGFuaW1hdGlvbiwgdGFyZ2V0cywgdHdlZW5WYXJzLCAwKS5wbGF5KCk7XG4gICAgLy8gfSk7XG4gICAgLy8gcmV0dXJuO1xuXG5cbiAgICBfY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJldHVybiB2YXJzW25hbWVdICYmIGFuaW1hdGlvbi5ldmVudENhbGxiYWNrKG5hbWUsIHZhcnNbbmFtZV0sIHZhcnNbbmFtZSArIFwiUGFyYW1zXCJdKTtcbiAgICB9KTsgLy8gYXBwbHkgY2FsbGJhY2tzIHRvIHRoZSB0aW1lbGluZSwgbm90IHR3ZWVucyAoYmVjYXVzZSBcImN1c3RvbVwiIHRpbWluZyBjYW4gbWFrZSBtdWx0aXBsZSB0d2VlbnMpXG5cblxuICAgIGlmIChjdXN0b20gJiYgdGFyZ2V0cy5sZW5ndGgpIHtcbiAgICAgIC8vIGJ1c3Qgb3V0IHRoZSBjdXN0b20gcHJvcGVydGllcyBhcyB0aGVpciBvd24gdHdlZW5zIHNvIHRoZXkgY2FuIHVzZSBkaWZmZXJlbnQgZWFzZXMsIGR1cmF0aW9ucywgZXRjLlxuICAgICAgcmVtYWluaW5nUHJvcHMgPSBfY29weSh0d2VlblZhcnMsIF9yZXNlcnZlZCk7XG5cbiAgICAgIGlmIChcInNjYWxlXCIgaW4gY3VzdG9tKSB7XG4gICAgICAgIGN1c3RvbS5zY2FsZVggPSBjdXN0b20uc2NhbGVZID0gY3VzdG9tLnNjYWxlO1xuICAgICAgICBkZWxldGUgY3VzdG9tLnNjYWxlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHAgaW4gY3VzdG9tKSB7XG4gICAgICAgIHYgPSBfY29weShjdXN0b21bcF0sIF9maXRSZXNlcnZlZCk7XG4gICAgICAgIHZbcF0gPSB0d2VlblZhcnNbcF07XG4gICAgICAgICEoXCJkdXJhdGlvblwiIGluIHYpICYmIFwiZHVyYXRpb25cIiBpbiB0d2VlblZhcnMgJiYgKHYuZHVyYXRpb24gPSB0d2VlblZhcnMuZHVyYXRpb24pO1xuICAgICAgICB2LnN0YWdnZXIgPSB0d2VlblZhcnMuc3RhZ2dlcjtcbiAgICAgICAgYWRkRnVuYy5jYWxsKGFuaW1hdGlvbiwgdGFyZ2V0cywgdiwgMCk7XG4gICAgICAgIGRlbGV0ZSByZW1haW5pbmdQcm9wc1twXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0cy5sZW5ndGggfHwgbGVhdmluZy5sZW5ndGggfHwgZW50ZXJpbmcubGVuZ3RoKSB7XG4gICAgICB0b2dnbGVDbGFzcyAmJiBhbmltYXRpb24uYWRkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90b2dnbGVDbGFzcyhjbGFzc1RhcmdldHMsIHRvZ2dsZUNsYXNzLCBhbmltYXRpb24uX3pUaW1lIDwgMCA/IFwicmVtb3ZlXCIgOiBcImFkZFwiKTtcbiAgICAgIH0sIDApICYmICFwYXVzZWQgJiYgX3RvZ2dsZUNsYXNzKGNsYXNzVGFyZ2V0cywgdG9nZ2xlQ2xhc3MsIFwiYWRkXCIpO1xuICAgICAgdGFyZ2V0cy5sZW5ndGggJiYgYWRkRnVuYy5jYWxsKGFuaW1hdGlvbiwgdGFyZ2V0cywgcmVtYWluaW5nUHJvcHMsIDApO1xuICAgIH1cblxuICAgIF9oYW5kbGVDYWxsYmFjayhvbkVudGVyLCBlbnRlcmluZywgYW5pbWF0aW9uKTtcblxuICAgIF9oYW5kbGVDYWxsYmFjayhvbkxlYXZlLCBsZWF2aW5nLCBhbmltYXRpb24pO1xuXG4gICAgdmFyIGJhdGNoVGwgPSBfYmF0Y2ggJiYgX2JhdGNoLnRpbWVsaW5lO1xuXG4gICAgaWYgKGJhdGNoVGwpIHtcbiAgICAgIGJhdGNoVGwuYWRkKGFuaW1hdGlvbiwgMCk7XG5cbiAgICAgIF9iYXRjaC5fZmluYWwucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfc2V0RmluYWxTdGF0ZXMoY29tcHMsICFjbGVhclByb3BzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGVuZFRpbWUgPSBhbmltYXRpb24uZHVyYXRpb24oKTtcbiAgICBhbmltYXRpb24uY2FsbChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgZm9yd2FyZCA9IGFuaW1hdGlvbi50aW1lKCkgPj0gZW5kVGltZTtcbiAgICAgIGZvcndhcmQgJiYgIWJhdGNoVGwgJiYgX3NldEZpbmFsU3RhdGVzKGNvbXBzLCAhY2xlYXJQcm9wcyk7XG4gICAgICB0b2dnbGVDbGFzcyAmJiBfdG9nZ2xlQ2xhc3MoY2xhc3NUYXJnZXRzLCB0b2dnbGVDbGFzcywgZm9yd2FyZCA/IFwicmVtb3ZlXCIgOiBcImFkZFwiKTtcbiAgICB9KTtcbiAgfTtcblxuICBhYnNvbHV0ZU9uTGVhdmUgJiYgKGFic29sdXRlID0gY29tcHMuZmlsdGVyKGZ1bmN0aW9uIChjb21wKSB7XG4gICAgcmV0dXJuICFjb21wLnNkICYmICFjb21wLmEuaXNWaXNpYmxlICYmIGNvbXAuYi5pc1Zpc2libGU7XG4gIH0pLm1hcChmdW5jdGlvbiAoY29tcCkge1xuICAgIHJldHVybiBjb21wLmEuZWxlbWVudDtcbiAgfSkpO1xuXG4gIGlmIChfYmF0Y2gpIHtcbiAgICB2YXIgX2JhdGNoJF9hYnM7XG5cbiAgICBhYnNvbHV0ZSAmJiAoX2JhdGNoJF9hYnMgPSBfYmF0Y2guX2FicykucHVzaC5hcHBseShfYmF0Y2gkX2FicywgX2ZpbHRlckNvbXBzKGNvbXBzLCBhYnNvbHV0ZSkpO1xuXG4gICAgX2JhdGNoLl9ydW4ucHVzaChydW4pO1xuICB9IGVsc2Uge1xuICAgIGFic29sdXRlICYmIF9tYWtlQ29tcHNBYnNvbHV0ZShfZmlsdGVyQ29tcHMoY29tcHMsIGFic29sdXRlKSk7IC8vIHdoZW4gbWFraW5nIGFic29sdXRlLCB3ZSBtdXN0IGdvIGluIGEgdmVyeSBwYXJ0aWN1bGFyIG9yZGVyIHNvIHRoYXQgZG9jdW1lbnQgZmxvdyBjaGFuZ2VzIGRvbid0IGFmZmVjdCB0aGluZ3MuIERvbid0IG1ha2UgaXQgdmlzaWJsZSBpZiBib3RoIHRoZSBiZWZvcmUgYW5kIGFmdGVyIHN0YXRlcyBhcmUgaW52aXNpYmxlISBUaGVyZSdzIG5vIHBvaW50LCBhbmQgaXQgY291bGQgbWFrZSB0aGluZ3MgYXBwZWFyIHZpc2libGUgZHVyaW5nIHRoZSBmbGlwIHRoYXQgc2hvdWxkbid0IGJlLlxuXG4gICAgcnVuKCk7XG4gIH1cblxuICByZXR1cm4gX2JhdGNoID8gX2JhdGNoLnRpbWVsaW5lIDogYW5pbWF0aW9uO1xufSxcbiAgICBfaW50ZXJydXB0ID0gZnVuY3Rpb24gX2ludGVycnVwdCh0bCkge1xuICB0bC52YXJzLm9uSW50ZXJydXB0ICYmIHRsLnZhcnMub25JbnRlcnJ1cHQuYXBwbHkodGwsIHRsLnZhcnMub25JbnRlcnJ1cHRQYXJhbXMgfHwgW10pO1xuICB0bC5nZXRDaGlsZHJlbih0cnVlLCBmYWxzZSwgdHJ1ZSkuZm9yRWFjaChfaW50ZXJydXB0KTtcbn0sXG4gICAgX2tpbGxGbGlwID0gZnVuY3Rpb24gX2tpbGxGbGlwKHRsLCBhY3Rpb24pIHtcbiAgLy8gYWN0aW9uOiAwID0gbm90aGluZywgMSA9IGNvbXBsZXRlLCAyID0gb25seSBraWxsIChkb24ndCBjb21wbGV0ZSlcbiAgaWYgKHRsICYmIHRsLnByb2dyZXNzKCkgPCAxICYmICF0bC5wYXVzZWQoKSkge1xuICAgIGlmIChhY3Rpb24pIHtcbiAgICAgIF9pbnRlcnJ1cHQodGwpO1xuXG4gICAgICBhY3Rpb24gPCAyICYmIHRsLnByb2dyZXNzKDEpOyAvLyB3ZSBzaG91bGQgYWxzbyBraWxsIGl0IGluIGNhc2UgaXQgd2FzIGFkZGVkIHRvIGEgcGFyZW50IHRpbWVsaW5lLlxuXG4gICAgICB0bC5raWxsKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn0sXG4gICAgX2NyZWF0ZUxvb2t1cCA9IGZ1bmN0aW9uIF9jcmVhdGVMb29rdXAoc3RhdGUpIHtcbiAgdmFyIGxvb2t1cCA9IHN0YXRlLmlkTG9va3VwID0ge30sXG4gICAgICBhbHQgPSBzdGF0ZS5hbHQgPSB7fSxcbiAgICAgIGVsU3RhdGVzID0gc3RhdGUuZWxlbWVudFN0YXRlcyxcbiAgICAgIGkgPSBlbFN0YXRlcy5sZW5ndGgsXG4gICAgICBlbFN0YXRlO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBlbFN0YXRlID0gZWxTdGF0ZXNbaV07XG4gICAgbG9va3VwW2VsU3RhdGUuaWRdID8gYWx0W2VsU3RhdGUuaWRdID0gZWxTdGF0ZSA6IGxvb2t1cFtlbFN0YXRlLmlkXSA9IGVsU3RhdGU7XG4gIH1cbn07XG5cbnZhciBGbGlwU3RhdGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGbGlwU3RhdGUodGFyZ2V0cywgdmFycywgdGFyZ2V0c0FyZUVsZW1lbnRTdGF0ZXMpIHtcbiAgICB0aGlzLnByb3BzID0gdmFycyAmJiB2YXJzLnByb3BzO1xuICAgIHRoaXMuc2ltcGxlID0gISEodmFycyAmJiB2YXJzLnNpbXBsZSk7XG5cbiAgICBpZiAodGFyZ2V0c0FyZUVsZW1lbnRTdGF0ZXMpIHtcbiAgICAgIHRoaXMudGFyZ2V0cyA9IF9lbGVtZW50c0Zyb21FbGVtZW50U3RhdGVzKHRhcmdldHMpO1xuICAgICAgdGhpcy5lbGVtZW50U3RhdGVzID0gdGFyZ2V0cztcblxuICAgICAgX2NyZWF0ZUxvb2t1cCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50YXJnZXRzID0gX3RvQXJyYXkodGFyZ2V0cyk7XG4gICAgICB2YXIgc29mdCA9IHZhcnMgJiYgKHZhcnMua2lsbCA9PT0gZmFsc2UgfHwgdmFycy5iYXRjaCAmJiAhdmFycy5raWxsKTtcbiAgICAgIF9iYXRjaCAmJiAhc29mdCAmJiBfYmF0Y2guX2tpbGwucHVzaCh0aGlzKTtcbiAgICAgIHRoaXMudXBkYXRlKHNvZnQgfHwgISFfYmF0Y2gpOyAvLyB3aGVuIGJhdGNoaW5nLCBkb24ndCBmb3JjZSBpbi1wcm9ncmVzcyBmbGlwcyB0byB0aGVpciBlbmQ7IHdlIG5lZWQgdG8gZG8gdGhhdCBBRlRFUiBhbGwgZ2V0U3RhdGVzKCkgYXJlIGNhbGxlZC5cbiAgICB9XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRmxpcFN0YXRlLnByb3RvdHlwZTtcblxuICBfcHJvdG8udXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKHNvZnQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5lbGVtZW50U3RhdGVzID0gdGhpcy50YXJnZXRzLm1hcChmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJldHVybiBuZXcgRWxlbWVudFN0YXRlKGVsLCBfdGhpcy5wcm9wcywgX3RoaXMuc2ltcGxlKTtcbiAgICB9KTtcblxuICAgIF9jcmVhdGVMb29rdXAodGhpcyk7XG5cbiAgICB0aGlzLmludGVycnVwdChzb2Z0KTtcbiAgICB0aGlzLnJlY29yZElubGluZVN0eWxlcygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMudGFyZ2V0cy5sZW5ndGggPSB0aGlzLmVsZW1lbnRTdGF0ZXMubGVuZ3RoID0gMDtcblxuICAgIF9jcmVhdGVMb29rdXAodGhpcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uZml0ID0gZnVuY3Rpb24gZml0KHN0YXRlLCBzY2FsZSwgbmVzdGVkKSB7XG4gICAgdmFyIGVsU3RhdGVzSW5PcmRlciA9IF9vcmRlckJ5RE9NRGVwdGgodGhpcy5lbGVtZW50U3RhdGVzLnNsaWNlKDApLCBmYWxzZSwgdHJ1ZSksXG4gICAgICAgIHRvRWxTdGF0ZXMgPSAoc3RhdGUgfHwgdGhpcykuaWRMb29rdXAsXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBmcm9tTm9kZSxcbiAgICAgICAgdG9Ob2RlO1xuXG4gICAgZm9yICg7IGkgPCBlbFN0YXRlc0luT3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZyb21Ob2RlID0gZWxTdGF0ZXNJbk9yZGVyW2ldO1xuICAgICAgbmVzdGVkICYmIChmcm9tTm9kZS5tYXRyaXggPSBnZXRHbG9iYWxNYXRyaXgoZnJvbU5vZGUuZWxlbWVudCwgZmFsc2UsIGZhbHNlLCB0cnVlKSk7IC8vIG1vdmluZyBhIHBhcmVudCBhZmZlY3RzIHRoZSBwb3NpdGlvbiBvZiBjaGlsZHJlblxuXG4gICAgICB0b05vZGUgPSB0b0VsU3RhdGVzW2Zyb21Ob2RlLmlkXTtcbiAgICAgIHRvTm9kZSAmJiBfZml0KGZyb21Ob2RlLCB0b05vZGUsIHNjYWxlLCB0cnVlLCAwLCBmcm9tTm9kZSk7XG4gICAgICBmcm9tTm9kZS5tYXRyaXggPSBnZXRHbG9iYWxNYXRyaXgoZnJvbU5vZGUuZWxlbWVudCwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uZ2V0UHJvcGVydHkgPSBmdW5jdGlvbiBnZXRQcm9wZXJ0eShlbGVtZW50LCBwcm9wZXJ0eSkge1xuICAgIHZhciBlcyA9IHRoaXMuZ2V0RWxlbWVudFN0YXRlKGVsZW1lbnQpIHx8IF9lbXB0eU9iajtcblxuICAgIHJldHVybiAocHJvcGVydHkgaW4gZXMgPyBlcyA6IGVzLnByb3BzIHx8IF9lbXB0eU9iailbcHJvcGVydHldO1xuICB9O1xuXG4gIF9wcm90by5hZGQgPSBmdW5jdGlvbiBhZGQoc3RhdGUpIHtcbiAgICB2YXIgaSA9IHN0YXRlLnRhcmdldHMubGVuZ3RoLFxuICAgICAgICBsb29rdXAgPSB0aGlzLmlkTG9va3VwLFxuICAgICAgICBhbHQgPSB0aGlzLmFsdCxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIGVzLFxuICAgICAgICBlczI7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBlcyA9IHN0YXRlLmVsZW1lbnRTdGF0ZXNbaV07XG4gICAgICBlczIgPSBsb29rdXBbZXMuaWRdO1xuXG4gICAgICBpZiAoZXMyICYmIChlcy5lbGVtZW50ID09PSBlczIuZWxlbWVudCB8fCBhbHRbZXMuaWRdICYmIGFsdFtlcy5pZF0uZWxlbWVudCA9PT0gZXMuZWxlbWVudCkpIHtcbiAgICAgICAgLy8gaWYgdGhlIGZsaXAgaWQgaXMgYWxyZWFkeSBpbiB0aGlzIEZsaXBTdGF0ZSwgcmVwbGFjZSBpdCFcbiAgICAgICAgaW5kZXggPSB0aGlzLmVsZW1lbnRTdGF0ZXMuaW5kZXhPZihlcy5lbGVtZW50ID09PSBlczIuZWxlbWVudCA/IGVzMiA6IGFsdFtlcy5pZF0pO1xuICAgICAgICB0aGlzLnRhcmdldHMuc3BsaWNlKGluZGV4LCAxLCBzdGF0ZS50YXJnZXRzW2ldKTtcbiAgICAgICAgdGhpcy5lbGVtZW50U3RhdGVzLnNwbGljZShpbmRleCwgMSwgZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50YXJnZXRzLnB1c2goc3RhdGUudGFyZ2V0c1tpXSk7XG4gICAgICAgIHRoaXMuZWxlbWVudFN0YXRlcy5wdXNoKGVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0ZS5pbnRlcnJ1cHRlZCAmJiAodGhpcy5pbnRlcnJ1cHRlZCA9IHRydWUpO1xuICAgIHN0YXRlLnNpbXBsZSB8fCAodGhpcy5zaW1wbGUgPSBmYWxzZSk7XG5cbiAgICBfY3JlYXRlTG9va3VwKHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKHN0YXRlKSB7XG4gICAgdmFyIGwxID0gc3RhdGUuaWRMb29rdXAsXG4gICAgICAgIGwyID0gdGhpcy5pZExvb2t1cCxcbiAgICAgICAgdW5jaGFuZ2VkID0gW10sXG4gICAgICAgIGNoYW5nZWQgPSBbXSxcbiAgICAgICAgZW50ZXIgPSBbXSxcbiAgICAgICAgbGVhdmUgPSBbXSxcbiAgICAgICAgdGFyZ2V0cyA9IFtdLFxuICAgICAgICBhMSA9IHN0YXRlLmFsdCxcbiAgICAgICAgYTIgPSB0aGlzLmFsdCxcbiAgICAgICAgcGxhY2UgPSBmdW5jdGlvbiBwbGFjZShzMSwgczIsIGVsKSB7XG4gICAgICByZXR1cm4gKHMxLmlzVmlzaWJsZSAhPT0gczIuaXNWaXNpYmxlID8gczEuaXNWaXNpYmxlID8gZW50ZXIgOiBsZWF2ZSA6IHMxLmlzVmlzaWJsZSA/IGNoYW5nZWQgOiB1bmNoYW5nZWQpLnB1c2goZWwpICYmIHRhcmdldHMucHVzaChlbCk7XG4gICAgfSxcbiAgICAgICAgcGxhY2VJZkRvZXNOb3RFeGlzdCA9IGZ1bmN0aW9uIHBsYWNlSWZEb2VzTm90RXhpc3QoczEsIHMyLCBlbCkge1xuICAgICAgcmV0dXJuIHRhcmdldHMuaW5kZXhPZihlbCkgPCAwICYmIHBsYWNlKHMxLCBzMiwgZWwpO1xuICAgIH0sXG4gICAgICAgIHMxLFxuICAgICAgICBzMixcbiAgICAgICAgcCxcbiAgICAgICAgZWwsXG4gICAgICAgIHMxQWx0LFxuICAgICAgICBzMkFsdCxcbiAgICAgICAgYzEsXG4gICAgICAgIGMyO1xuXG4gICAgZm9yIChwIGluIGwxKSB7XG4gICAgICBzMUFsdCA9IGExW3BdO1xuICAgICAgczJBbHQgPSBhMltwXTtcbiAgICAgIHMxID0gIXMxQWx0ID8gbDFbcF0gOiBfZ2V0Q2hhbmdpbmdFbFN0YXRlKHN0YXRlLCB0aGlzLCBwKTtcbiAgICAgIGVsID0gczEuZWxlbWVudDtcbiAgICAgIHMyID0gbDJbcF07XG5cbiAgICAgIGlmIChzMkFsdCkge1xuICAgICAgICBjMiA9IHMyLmlzVmlzaWJsZSB8fCAhczJBbHQuaXNWaXNpYmxlICYmIGVsID09PSBzMi5lbGVtZW50ID8gczIgOiBzMkFsdDtcbiAgICAgICAgYzEgPSBzMUFsdCAmJiAhczEuaXNWaXNpYmxlICYmICFzMUFsdC5pc1Zpc2libGUgJiYgYzIuZWxlbWVudCA9PT0gczFBbHQuZWxlbWVudCA/IHMxQWx0IDogczE7IC8vYzEuZWxlbWVudCAhPT0gYzIuZWxlbWVudCAmJiBjMS5lbGVtZW50ID09PSBzMi5lbGVtZW50ICYmIChjMiA9IHMyKTtcblxuICAgICAgICBpZiAoYzEuaXNWaXNpYmxlICYmIGMyLmlzVmlzaWJsZSAmJiBjMS5lbGVtZW50ICE9PSBjMi5lbGVtZW50KSB7XG4gICAgICAgICAgLy8gc3dhcHBpbmcsIHNvIGZvcmNlIGludG8gXCJjaGFuZ2VkXCIgYXJyYXlcbiAgICAgICAgICAoYzEuaXNEaWZmZXJlbnQoYzIpID8gY2hhbmdlZCA6IHVuY2hhbmdlZCkucHVzaChjMS5lbGVtZW50LCBjMi5lbGVtZW50KTtcbiAgICAgICAgICB0YXJnZXRzLnB1c2goYzEuZWxlbWVudCwgYzIuZWxlbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGxhY2UoYzEsIGMyLCBjMS5lbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHMxQWx0ICYmIGMxLmVsZW1lbnQgPT09IHMxQWx0LmVsZW1lbnQgJiYgKHMxQWx0ID0gbDFbcF0pO1xuICAgICAgICBwbGFjZUlmRG9lc05vdEV4aXN0KGMxLmVsZW1lbnQgIT09IHMyLmVsZW1lbnQgJiYgczFBbHQgPyBzMUFsdCA6IGMxLCBzMiwgczIuZWxlbWVudCk7XG4gICAgICAgIHBsYWNlSWZEb2VzTm90RXhpc3QoczFBbHQgJiYgczFBbHQuZWxlbWVudCA9PT0gczJBbHQuZWxlbWVudCA/IHMxQWx0IDogYzEsIHMyQWx0LCBzMkFsdC5lbGVtZW50KTtcbiAgICAgICAgczFBbHQgJiYgcGxhY2VJZkRvZXNOb3RFeGlzdChzMUFsdCwgczJBbHQuZWxlbWVudCA9PT0gczFBbHQuZWxlbWVudCA/IHMyQWx0IDogczIsIHMxQWx0LmVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgIXMyID8gZW50ZXIucHVzaChlbCkgOiAhczIuaXNEaWZmZXJlbnQoczEpID8gdW5jaGFuZ2VkLnB1c2goZWwpIDogcGxhY2UoczEsIHMyLCBlbCk7XG4gICAgICAgIHMxQWx0ICYmIHBsYWNlSWZEb2VzTm90RXhpc3QoczFBbHQsIHMyLCBzMUFsdC5lbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHAgaW4gbDIpIHtcbiAgICAgIGlmICghbDFbcF0pIHtcbiAgICAgICAgbGVhdmUucHVzaChsMltwXS5lbGVtZW50KTtcbiAgICAgICAgYTJbcF0gJiYgbGVhdmUucHVzaChhMltwXS5lbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY2hhbmdlZDogY2hhbmdlZCxcbiAgICAgIHVuY2hhbmdlZDogdW5jaGFuZ2VkLFxuICAgICAgZW50ZXI6IGVudGVyLFxuICAgICAgbGVhdmU6IGxlYXZlXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8ucmVjb3JkSW5saW5lU3R5bGVzID0gZnVuY3Rpb24gcmVjb3JkSW5saW5lU3R5bGVzKCkge1xuICAgIHZhciBwcm9wcyA9IF9tZW1vaXplZFJlbW92ZVByb3BzW3RoaXMucHJvcHNdIHx8IF9yZW1vdmVQcm9wcyxcbiAgICAgICAgaSA9IHRoaXMuZWxlbWVudFN0YXRlcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBfcmVjb3JkSW5saW5lU3R5bGVzKHRoaXMuZWxlbWVudFN0YXRlc1tpXSwgcHJvcHMpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uaW50ZXJydXB0ID0gZnVuY3Rpb24gaW50ZXJydXB0KHNvZnQpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIC8vIHNvZnQgPSBET04nVCBmb3JjZSBpbi1wcm9ncmVzcyBmbGlwIGFuaW1hdGlvbnMgdG8gY29tcGxldGlvbiAobGlrZSB3aGVuIHJ1bm5pbmcgYSBiYXRjaCwgd2UgY2FuJ3QgaW1tZWRpYXRlbHkga2lsbCBmbGlwcyB3aGVuIGdldHRpbmcgc3RhdGVzIGJlY2F1c2UgaXQgY291bGQgY29udGFtaW5hdGUgcG9zaXRpb25pbmcgYW5kIG90aGVyIC5nZXRTdGF0ZSgpIGNhbGxzIHRoYXQgd2lsbCBydW4gaW4gdGhlIGJhdGNoICh3ZSBraWxsIEFGVEVSIGFsbCB0aGUgLmdldFN0YXRlKCkgY2FsbHMgY29tcGxldGUpLlxuICAgIHZhciB0aW1lbGluZXMgPSBbXTtcbiAgICB0aGlzLnRhcmdldHMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgdmFyIHRsID0gdC5fZmxpcCxcbiAgICAgICAgICBmb3VuZEluUHJvZ3Jlc3MgPSBfa2lsbEZsaXAodGwsIHNvZnQgPyAwIDogMSk7XG5cbiAgICAgIHNvZnQgJiYgZm91bmRJblByb2dyZXNzICYmIHRpbWVsaW5lcy5pbmRleE9mKHRsKSA8IDAgJiYgdGwuYWRkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgICB9KTtcbiAgICAgIGZvdW5kSW5Qcm9ncmVzcyAmJiB0aW1lbGluZXMucHVzaCh0bCk7XG4gICAgfSk7XG4gICAgIXNvZnQgJiYgdGltZWxpbmVzLmxlbmd0aCAmJiB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTsgLy8gaWYgd2UgZm91bmQgYW4gaW4tcHJvZ3Jlc3MgRmxpcCBhbmltYXRpb24sIHdlIG11c3QgcmVjb3JkIGFsbCB0aGUgdmFsdWVzIGluIHRoZWlyIGN1cnJlbnQgc3RhdGUgYXQgdGhhdCBwb2ludCBCVVQgd2Ugc2hvdWxkIHVwZGF0ZSB0aGUgaXNWaXNpYmxlIHZhbHVlIEFGVEVSIHB1c2hpbmcgdGhhdCBmbGlwIHRvIGNvbXBsZXRpb24gc28gdGhhdCBlbGVtZW50cyB0aGF0IGFyZSBlbnRlcmluZyBvciBsZWF2aW5nIHdpbGwgcG9wdWxhdGUgdGhvc2UgQXJyYXlzIHByb3Blcmx5LlxuXG4gICAgdGhpcy5pbnRlcnJ1cHRlZCB8fCAodGhpcy5pbnRlcnJ1cHRlZCA9ICEhdGltZWxpbmVzLmxlbmd0aCk7XG4gIH07XG5cbiAgX3Byb3RvLnVwZGF0ZVZpc2liaWxpdHkgPSBmdW5jdGlvbiB1cGRhdGVWaXNpYmlsaXR5KCkge1xuICAgIHRoaXMuZWxlbWVudFN0YXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChlcykge1xuICAgICAgdmFyIGIgPSBlcy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgZXMuaXNWaXNpYmxlID0gISEoYi53aWR0aCB8fCBiLmhlaWdodCB8fCBiLnRvcCB8fCBiLmxlZnQpO1xuICAgICAgZXMudW5jYWNoZSA9IDE7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmdldEVsZW1lbnRTdGF0ZSA9IGZ1bmN0aW9uIGdldEVsZW1lbnRTdGF0ZShlbGVtZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudFN0YXRlc1t0aGlzLnRhcmdldHMuaW5kZXhPZihfZ2V0RWwoZWxlbWVudCkpXTtcbiAgfTtcblxuICBfcHJvdG8ubWFrZUFic29sdXRlID0gZnVuY3Rpb24gbWFrZUFic29sdXRlKCkge1xuICAgIHJldHVybiBfb3JkZXJCeURPTURlcHRoKHRoaXMuZWxlbWVudFN0YXRlcy5zbGljZSgwKSwgdHJ1ZSwgdHJ1ZSkubWFwKF9tYWtlQWJzb2x1dGUpO1xuICB9O1xuXG4gIHJldHVybiBGbGlwU3RhdGU7XG59KCk7XG5cbnZhciBFbGVtZW50U3RhdGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFbGVtZW50U3RhdGUoZWxlbWVudCwgcHJvcHMsIHNpbXBsZSkge1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy51cGRhdGUocHJvcHMsIHNpbXBsZSk7XG4gIH1cblxuICB2YXIgX3Byb3RvMiA9IEVsZW1lbnRTdGF0ZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi5pc0RpZmZlcmVudCA9IGZ1bmN0aW9uIGlzRGlmZmVyZW50KHN0YXRlKSB7XG4gICAgdmFyIGIxID0gdGhpcy5ib3VuZHMsXG4gICAgICAgIGIyID0gc3RhdGUuYm91bmRzO1xuICAgIHJldHVybiBiMS50b3AgIT09IGIyLnRvcCB8fCBiMS5sZWZ0ICE9PSBiMi5sZWZ0IHx8IGIxLndpZHRoICE9PSBiMi53aWR0aCB8fCBiMS5oZWlnaHQgIT09IGIyLmhlaWdodCB8fCAhdGhpcy5tYXRyaXguZXF1YWxzKHN0YXRlLm1hdHJpeCkgfHwgdGhpcy5vcGFjaXR5ICE9PSBzdGF0ZS5vcGFjaXR5IHx8IHRoaXMucHJvcHMgJiYgc3RhdGUucHJvcHMgJiYgSlNPTi5zdHJpbmdpZnkodGhpcy5wcm9wcykgIT09IEpTT04uc3RyaW5naWZ5KHN0YXRlLnByb3BzKTtcbiAgfTtcblxuICBfcHJvdG8yLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShwcm9wcywgc2ltcGxlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBlbGVtZW50ID0gc2VsZi5lbGVtZW50LFxuICAgICAgICBnZXRQcm9wID0gZ3NhcC5nZXRQcm9wZXJ0eShlbGVtZW50KSxcbiAgICAgICAgY2FjaGUgPSBnc2FwLmNvcmUuZ2V0Q2FjaGUoZWxlbWVudCksXG4gICAgICAgIGJvdW5kcyA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIGJib3ggPSBlbGVtZW50LmdldEJCb3ggJiYgdHlwZW9mIGVsZW1lbnQuZ2V0QkJveCA9PT0gXCJmdW5jdGlvblwiICYmIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJzdmdcIiAmJiBlbGVtZW50LmdldEJCb3goKSxcbiAgICAgICAgbSA9IHNpbXBsZSA/IG5ldyBNYXRyaXgyRCgxLCAwLCAwLCAxLCBib3VuZHMubGVmdCArIF9nZXREb2NTY3JvbGxMZWZ0KCksIGJvdW5kcy50b3AgKyBfZ2V0RG9jU2Nyb2xsVG9wKCkpIDogZ2V0R2xvYmFsTWF0cml4KGVsZW1lbnQsIGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgc2VsZi5nZXRQcm9wID0gZ2V0UHJvcDtcbiAgICBzZWxmLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHNlbGYuaWQgPSBfZ2V0SUQoZWxlbWVudCk7XG4gICAgc2VsZi5tYXRyaXggPSBtO1xuICAgIHNlbGYuY2FjaGUgPSBjYWNoZTtcbiAgICBzZWxmLmJvdW5kcyA9IGJvdW5kcztcbiAgICBzZWxmLmlzVmlzaWJsZSA9ICEhKGJvdW5kcy53aWR0aCB8fCBib3VuZHMuaGVpZ2h0IHx8IGJvdW5kcy5sZWZ0IHx8IGJvdW5kcy50b3ApO1xuICAgIHNlbGYuZGlzcGxheSA9IGdldFByb3AoXCJkaXNwbGF5XCIpO1xuICAgIHNlbGYucG9zaXRpb24gPSBnZXRQcm9wKFwicG9zaXRpb25cIik7XG4gICAgc2VsZi5wYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgc2VsZi54ID0gZ2V0UHJvcChcInhcIik7XG4gICAgc2VsZi55ID0gZ2V0UHJvcChcInlcIik7XG4gICAgc2VsZi5zY2FsZVggPSBjYWNoZS5zY2FsZVg7XG4gICAgc2VsZi5zY2FsZVkgPSBjYWNoZS5zY2FsZVk7XG4gICAgc2VsZi5yb3RhdGlvbiA9IGdldFByb3AoXCJyb3RhdGlvblwiKTtcbiAgICBzZWxmLnNrZXdYID0gZ2V0UHJvcChcInNrZXdYXCIpO1xuICAgIHNlbGYub3BhY2l0eSA9IGdldFByb3AoXCJvcGFjaXR5XCIpO1xuICAgIHNlbGYud2lkdGggPSBiYm94ID8gYmJveC53aWR0aCA6IF9jbG9zZXN0VGVudGgoZ2V0UHJvcChcIndpZHRoXCIsIFwicHhcIiksIDAuMDQpOyAvLyByb3VuZCB1cCB0byB0aGUgY2xvc2VzdCAwLjEgc28gdGhhdCB0ZXh0IGRvZXNuJ3Qgd3JhcC5cblxuICAgIHNlbGYuaGVpZ2h0ID0gYmJveCA/IGJib3guaGVpZ2h0IDogX2Nsb3Nlc3RUZW50aChnZXRQcm9wKFwiaGVpZ2h0XCIsIFwicHhcIiksIDAuMDQpO1xuICAgIHByb3BzICYmIF9yZWNvcmRQcm9wcyhzZWxmLCBfbWVtb2l6ZWRQcm9wc1twcm9wc10gfHwgX21lbW9pemVQcm9wcyhwcm9wcykpO1xuICAgIHNlbGYuY3RtID0gZWxlbWVudC5nZXRDVE0gJiYgZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInN2Z1wiICYmIF9nZXRDVE0oZWxlbWVudCkuaW52ZXJzZSgpO1xuICAgIHNlbGYuc2ltcGxlID0gc2ltcGxlIHx8IF9yb3VuZChtLmEpID09PSAxICYmICFfcm91bmQobS5iKSAmJiAhX3JvdW5kKG0uYykgJiYgX3JvdW5kKG0uZCkgPT09IDE7IC8vIGFsbG93cyB1cyB0byBzcGVlZCB0aHJvdWdoIHNvbWUgb3RoZXIgdGFza3MgaWYgaXQncyBub3Qgc2NhbGUvcm90YXRlZFxuXG4gICAgc2VsZi51bmNhY2hlID0gMDtcbiAgfTtcblxuICByZXR1cm4gRWxlbWVudFN0YXRlO1xufSgpO1xuXG52YXIgRmxpcEFjdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZsaXBBY3Rpb24odmFycywgYmF0Y2gpIHtcbiAgICB0aGlzLnZhcnMgPSB2YXJzO1xuICAgIHRoaXMuYmF0Y2ggPSBiYXRjaDtcbiAgICB0aGlzLnN0YXRlcyA9IFtdO1xuICAgIHRoaXMudGltZWxpbmUgPSBiYXRjaC50aW1lbGluZTtcbiAgfVxuXG4gIHZhciBfcHJvdG8zID0gRmxpcEFjdGlvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMy5nZXRTdGF0ZUJ5SWQgPSBmdW5jdGlvbiBnZXRTdGF0ZUJ5SWQoaWQpIHtcbiAgICB2YXIgaSA9IHRoaXMuc3RhdGVzLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlc1tpXS5pZExvb2t1cFtpZF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8zLmtpbGwgPSBmdW5jdGlvbiBraWxsKCkge1xuICAgIHRoaXMuYmF0Y2gucmVtb3ZlKHRoaXMpO1xuICB9O1xuXG4gIHJldHVybiBGbGlwQWN0aW9uO1xufSgpO1xuXG52YXIgRmxpcEJhdGNoID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRmxpcEJhdGNoKGlkKSB7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuYWN0aW9ucyA9IFtdO1xuICAgIHRoaXMuX2tpbGwgPSBbXTtcbiAgICB0aGlzLl9maW5hbCA9IFtdO1xuICAgIHRoaXMuX2FicyA9IFtdO1xuICAgIHRoaXMuX3J1biA9IFtdO1xuICAgIHRoaXMuZGF0YSA9IHt9O1xuICAgIHRoaXMuc3RhdGUgPSBuZXcgRmxpcFN0YXRlKCk7XG4gICAgdGhpcy50aW1lbGluZSA9IGdzYXAudGltZWxpbmUoKTtcbiAgfVxuXG4gIHZhciBfcHJvdG80ID0gRmxpcEJhdGNoLnByb3RvdHlwZTtcblxuICBfcHJvdG80LmFkZCA9IGZ1bmN0aW9uIGFkZChjb25maWcpIHtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5hY3Rpb25zLmZpbHRlcihmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICByZXR1cm4gYWN0aW9uLnZhcnMgPT09IGNvbmZpZztcbiAgICB9KTtcblxuICAgIGlmIChyZXN1bHQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcmVzdWx0WzBdO1xuICAgIH1cblxuICAgIHJlc3VsdCA9IG5ldyBGbGlwQWN0aW9uKHR5cGVvZiBjb25maWcgPT09IFwiZnVuY3Rpb25cIiA/IHtcbiAgICAgIGFuaW1hdGU6IGNvbmZpZ1xuICAgIH0gOiBjb25maWcsIHRoaXMpO1xuICAgIHRoaXMuYWN0aW9ucy5wdXNoKHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBfcHJvdG80LnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShhY3Rpb24pIHtcbiAgICB2YXIgaSA9IHRoaXMuYWN0aW9ucy5pbmRleE9mKGFjdGlvbik7XG4gICAgaSA+PSAwICYmIHRoaXMuYWN0aW9ucy5zcGxpY2UoaSwgMSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvNC5nZXRTdGF0ZSA9IGZ1bmN0aW9uIGdldFN0YXRlKG1lcmdlKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB2YXIgcHJldkJhdGNoID0gX2JhdGNoLFxuICAgICAgICBwcmV2QWN0aW9uID0gX2JhdGNoQWN0aW9uO1xuICAgIF9iYXRjaCA9IHRoaXM7XG4gICAgdGhpcy5zdGF0ZS5jbGVhcigpO1xuICAgIHRoaXMuX2tpbGwubGVuZ3RoID0gMDtcbiAgICB0aGlzLmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICBpZiAoYWN0aW9uLnZhcnMuZ2V0U3RhdGUpIHtcbiAgICAgICAgYWN0aW9uLnN0YXRlcy5sZW5ndGggPSAwO1xuICAgICAgICBfYmF0Y2hBY3Rpb24gPSBhY3Rpb247XG4gICAgICAgIGFjdGlvbi5zdGF0ZSA9IGFjdGlvbi52YXJzLmdldFN0YXRlKGFjdGlvbik7XG4gICAgICB9XG5cbiAgICAgIG1lcmdlICYmIGFjdGlvbi5zdGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgICAgICByZXR1cm4gX3RoaXMzLnN0YXRlLmFkZChzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIF9iYXRjaEFjdGlvbiA9IHByZXZBY3Rpb247XG4gICAgX2JhdGNoID0gcHJldkJhdGNoO1xuICAgIHRoaXMua2lsbENvbmZsaWN0cygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzQuYW5pbWF0ZSA9IGZ1bmN0aW9uIGFuaW1hdGUoKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICB2YXIgcHJldkJhdGNoID0gX2JhdGNoLFxuICAgICAgICB0bCA9IHRoaXMudGltZWxpbmUsXG4gICAgICAgIGkgPSB0aGlzLmFjdGlvbnMubGVuZ3RoLFxuICAgICAgICBmaW5hbFN0YXRlcyxcbiAgICAgICAgZW5kVGltZTtcbiAgICBfYmF0Y2ggPSB0aGlzO1xuICAgIHRsLmNsZWFyKCk7XG4gICAgdGhpcy5fYWJzLmxlbmd0aCA9IHRoaXMuX2ZpbmFsLmxlbmd0aCA9IHRoaXMuX3J1bi5sZW5ndGggPSAwO1xuICAgIHRoaXMuYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhKSB7XG4gICAgICBhLnZhcnMuYW5pbWF0ZSAmJiBhLnZhcnMuYW5pbWF0ZShhKTtcbiAgICAgIHZhciBvbkVudGVyID0gYS52YXJzLm9uRW50ZXIsXG4gICAgICAgICAgb25MZWF2ZSA9IGEudmFycy5vbkxlYXZlLFxuICAgICAgICAgIHRhcmdldHMgPSBhLnRhcmdldHMsXG4gICAgICAgICAgcyxcbiAgICAgICAgICByZXN1bHQ7XG5cbiAgICAgIGlmICh0YXJnZXRzICYmIHRhcmdldHMubGVuZ3RoICYmIChvbkVudGVyIHx8IG9uTGVhdmUpKSB7XG4gICAgICAgIHMgPSBuZXcgRmxpcFN0YXRlKCk7XG4gICAgICAgIGEuc3RhdGVzLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHMuYWRkKHN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdCA9IHMuY29tcGFyZShGbGlwLmdldFN0YXRlKHRhcmdldHMpKTtcbiAgICAgICAgcmVzdWx0LmVudGVyLmxlbmd0aCAmJiBvbkVudGVyICYmIG9uRW50ZXIocmVzdWx0LmVudGVyKTtcbiAgICAgICAgcmVzdWx0LmxlYXZlLmxlbmd0aCAmJiBvbkxlYXZlICYmIG9uTGVhdmUocmVzdWx0LmxlYXZlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIF9tYWtlQ29tcHNBYnNvbHV0ZSh0aGlzLl9hYnMpO1xuXG4gICAgdGhpcy5fcnVuLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgIHJldHVybiBmKCk7XG4gICAgfSk7XG5cbiAgICBlbmRUaW1lID0gdGwuZHVyYXRpb24oKTtcbiAgICBmaW5hbFN0YXRlcyA9IHRoaXMuX2ZpbmFsLnNsaWNlKDApO1xuICAgIHRsLmFkZChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZW5kVGltZSA8PSB0bC50aW1lKCkpIHtcbiAgICAgICAgLy8gb25seSBjYWxsIGlmIG1vdmluZyBmb3J3YXJkIGluIHRoZSB0aW1lbGluZSAoaW4gY2FzZSBpdCdzIG5lc3RlZCBpbiBhIHRpbWVsaW5lIHRoYXQgZ2V0cyByZXZlcnNlZClcbiAgICAgICAgZmluYWxTdGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICAgIHJldHVybiBmKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF9mb3JFYWNoQmF0Y2goX3RoaXM0LCBcIm9uQ29tcGxldGVcIik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgX2JhdGNoID0gcHJldkJhdGNoO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcy5hY3Rpb25zW2ldLnZhcnMub25jZSAmJiB0aGlzLmFjdGlvbnNbaV0ua2lsbCgpO1xuICAgIH1cblxuICAgIF9mb3JFYWNoQmF0Y2godGhpcywgXCJvblN0YXJ0XCIpO1xuXG4gICAgdGwucmVzdGFydCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzQubG9hZFN0YXRlID0gZnVuY3Rpb24gbG9hZFN0YXRlKGRvbmUpIHtcbiAgICBkb25lIHx8IChkb25lID0gZnVuY3Rpb24gZG9uZSgpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgIHRoaXMuYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoYy52YXJzLmxvYWRTdGF0ZSkge1xuICAgICAgICB2YXIgaSxcbiAgICAgICAgICAgIGYgPSBmdW5jdGlvbiBmKHRhcmdldHMpIHtcbiAgICAgICAgICB0YXJnZXRzICYmIChjLnRhcmdldHMgPSB0YXJnZXRzKTtcbiAgICAgICAgICBpID0gcXVldWUuaW5kZXhPZihmKTtcblxuICAgICAgICAgIGlmICh+aSkge1xuICAgICAgICAgICAgcXVldWUuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgcXVldWUubGVuZ3RoIHx8IGRvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcXVldWUucHVzaChmKTtcbiAgICAgICAgYy52YXJzLmxvYWRTdGF0ZShmKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBxdWV1ZS5sZW5ndGggfHwgZG9uZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzQuc2V0U3RhdGUgPSBmdW5jdGlvbiBzZXRTdGF0ZSgpIHtcbiAgICB0aGlzLmFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIGMudGFyZ2V0cyA9IGMudmFycy5zZXRTdGF0ZSAmJiBjLnZhcnMuc2V0U3RhdGUoYyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvNC5raWxsQ29uZmxpY3RzID0gZnVuY3Rpb24ga2lsbENvbmZsaWN0cyhzb2Z0KSB7XG4gICAgdGhpcy5zdGF0ZS5pbnRlcnJ1cHQoc29mdCk7XG5cbiAgICB0aGlzLl9raWxsLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICByZXR1cm4gc3RhdGUuaW50ZXJydXB0KHNvZnQpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvNC5ydW4gPSBmdW5jdGlvbiBydW4oc2tpcEdldFN0YXRlLCBtZXJnZSkge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMgIT09IF9iYXRjaCkge1xuICAgICAgc2tpcEdldFN0YXRlIHx8IHRoaXMuZ2V0U3RhdGUobWVyZ2UpO1xuICAgICAgdGhpcy5sb2FkU3RhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIV90aGlzNS5fa2lsbGVkKSB7XG4gICAgICAgICAgX3RoaXM1LnNldFN0YXRlKCk7XG5cbiAgICAgICAgICBfdGhpczUuYW5pbWF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG80LmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoc3RhdGVPbmx5KSB7XG4gICAgdGhpcy5zdGF0ZS5jbGVhcigpO1xuICAgIHN0YXRlT25seSB8fCAodGhpcy5hY3Rpb25zLmxlbmd0aCA9IDApO1xuICB9O1xuXG4gIF9wcm90bzQuZ2V0U3RhdGVCeUlkID0gZnVuY3Rpb24gZ2V0U3RhdGVCeUlkKGlkKSB7XG4gICAgdmFyIGkgPSB0aGlzLmFjdGlvbnMubGVuZ3RoLFxuICAgICAgICBzO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgcyA9IHRoaXMuYWN0aW9uc1tpXS5nZXRTdGF0ZUJ5SWQoaWQpO1xuXG4gICAgICBpZiAocykge1xuICAgICAgICByZXR1cm4gcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5pZExvb2t1cFtpZF0gJiYgdGhpcy5zdGF0ZTtcbiAgfTtcblxuICBfcHJvdG80LmtpbGwgPSBmdW5jdGlvbiBraWxsKCkge1xuICAgIHRoaXMuX2tpbGxlZCA9IDE7XG4gICAgdGhpcy5jbGVhcigpO1xuICAgIGRlbGV0ZSBfYmF0Y2hMb29rdXBbdGhpcy5pZF07XG4gIH07XG5cbiAgcmV0dXJuIEZsaXBCYXRjaDtcbn0oKTtcblxuZXhwb3J0IHZhciBGbGlwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRmxpcCgpIHt9XG5cbiAgRmxpcC5nZXRTdGF0ZSA9IGZ1bmN0aW9uIGdldFN0YXRlKHRhcmdldHMsIHZhcnMpIHtcbiAgICB2YXIgc3RhdGUgPSBfcGFyc2VTdGF0ZSh0YXJnZXRzLCB2YXJzKTtcblxuICAgIF9iYXRjaEFjdGlvbiAmJiBfYmF0Y2hBY3Rpb24uc3RhdGVzLnB1c2goc3RhdGUpO1xuICAgIHZhcnMgJiYgdmFycy5iYXRjaCAmJiBGbGlwLmJhdGNoKHZhcnMuYmF0Y2gpLnN0YXRlLmFkZChzdGF0ZSk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9O1xuXG4gIEZsaXAuZnJvbSA9IGZ1bmN0aW9uIGZyb20oc3RhdGUsIHZhcnMpIHtcbiAgICB2YXJzID0gdmFycyB8fCB7fTtcbiAgICBcImNsZWFyUHJvcHNcIiBpbiB2YXJzIHx8ICh2YXJzLmNsZWFyUHJvcHMgPSB0cnVlKTtcbiAgICByZXR1cm4gX2Zyb21UbyhzdGF0ZSwgX3BhcnNlU3RhdGUodmFycy50YXJnZXRzIHx8IHN0YXRlLnRhcmdldHMsIHtcbiAgICAgIHByb3BzOiB2YXJzLnByb3BzIHx8IHN0YXRlLnByb3BzLFxuICAgICAgc2ltcGxlOiB2YXJzLnNpbXBsZSxcbiAgICAgIGtpbGw6ICEhdmFycy5raWxsXG4gICAgfSksIHZhcnMsIC0xKTtcbiAgfTtcblxuICBGbGlwLnRvID0gZnVuY3Rpb24gdG8oc3RhdGUsIHZhcnMpIHtcbiAgICByZXR1cm4gX2Zyb21UbyhzdGF0ZSwgX3BhcnNlU3RhdGUodmFycy50YXJnZXRzIHx8IHN0YXRlLnRhcmdldHMsIHtcbiAgICAgIHByb3BzOiB2YXJzLnByb3BzIHx8IHN0YXRlLnByb3BzLFxuICAgICAgc2ltcGxlOiB2YXJzLnNpbXBsZSxcbiAgICAgIGtpbGw6ICEhdmFycy5raWxsXG4gICAgfSksIHZhcnMsIDEpO1xuICB9O1xuXG4gIEZsaXAuZnJvbVRvID0gZnVuY3Rpb24gZnJvbVRvKGZyb21TdGF0ZSwgdG9TdGF0ZSwgdmFycykge1xuICAgIHJldHVybiBfZnJvbVRvKGZyb21TdGF0ZSwgdG9TdGF0ZSwgdmFycyk7XG4gIH07XG5cbiAgRmxpcC5maXQgPSBmdW5jdGlvbiBmaXQoZnJvbUVsLCB0b0VsLCB2YXJzKSB7XG4gICAgdmFyIHYgPSB2YXJzID8gX2NvcHkodmFycywgX2ZpdFJlc2VydmVkKSA6IHt9LFxuICAgICAgICBfcmVmID0gdmFycyB8fCB2LFxuICAgICAgICBhYnNvbHV0ZSA9IF9yZWYuYWJzb2x1dGUsXG4gICAgICAgIHNjYWxlID0gX3JlZi5zY2FsZSxcbiAgICAgICAgZ2V0VmFycyA9IF9yZWYuZ2V0VmFycyxcbiAgICAgICAgcHJvcHMgPSBfcmVmLnByb3BzLFxuICAgICAgICBydW5CYWNrd2FyZHMgPSBfcmVmLnJ1bkJhY2t3YXJkcyxcbiAgICAgICAgb25Db21wbGV0ZSA9IF9yZWYub25Db21wbGV0ZSxcbiAgICAgICAgc2ltcGxlID0gX3JlZi5zaW1wbGUsXG4gICAgICAgIGZpdENoaWxkID0gdmFycyAmJiB2YXJzLmZpdENoaWxkICYmIF9nZXRFbCh2YXJzLmZpdENoaWxkKSxcbiAgICAgICAgYmVmb3JlID0gX3BhcnNlRWxlbWVudFN0YXRlKHRvRWwsIHByb3BzLCBzaW1wbGUsIGZyb21FbCksXG4gICAgICAgIGFmdGVyID0gX3BhcnNlRWxlbWVudFN0YXRlKGZyb21FbCwgMCwgc2ltcGxlLCBiZWZvcmUpLFxuICAgICAgICBpbmxpbmVQcm9wcyA9IHByb3BzID8gX21lbW9pemVkUmVtb3ZlUHJvcHNbcHJvcHNdIDogX3JlbW92ZVByb3BzO1xuXG4gICAgcHJvcHMgJiYgX2FwcGx5UHJvcHModiwgYmVmb3JlLnByb3BzKTtcblxuICAgIGlmIChydW5CYWNrd2FyZHMpIHtcbiAgICAgIF9yZWNvcmRJbmxpbmVTdHlsZXMoYWZ0ZXIsIGlubGluZVByb3BzKTtcblxuICAgICAgXCJpbW1lZGlhdGVSZW5kZXJcIiBpbiB2IHx8ICh2LmltbWVkaWF0ZVJlbmRlciA9IHRydWUpO1xuXG4gICAgICB2Lm9uQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF9hcHBseUlubGluZVN0eWxlcyhhZnRlcik7XG5cbiAgICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGFic29sdXRlICYmIF9tYWtlQWJzb2x1dGUoYWZ0ZXIsIGJlZm9yZSk7XG4gICAgdiA9IF9maXQoYWZ0ZXIsIGJlZm9yZSwgc2NhbGUgfHwgZml0Q2hpbGQsIHByb3BzLCBmaXRDaGlsZCwgdi5kdXJhdGlvbiB8fCBnZXRWYXJzID8gdiA6IDApO1xuICAgIHJldHVybiBnZXRWYXJzID8gdiA6IHYuZHVyYXRpb24gPyBnc2FwLnRvKGFmdGVyLmVsZW1lbnQsIHYpIDogbnVsbDtcbiAgfTtcblxuICBGbGlwLm1ha2VBYnNvbHV0ZSA9IGZ1bmN0aW9uIG1ha2VBYnNvbHV0ZSh0YXJnZXRzT3JTdGF0ZXMsIHZhcnMpIHtcbiAgICByZXR1cm4gKHRhcmdldHNPclN0YXRlcyBpbnN0YW5jZW9mIEZsaXBTdGF0ZSA/IHRhcmdldHNPclN0YXRlcyA6IG5ldyBGbGlwU3RhdGUodGFyZ2V0c09yU3RhdGVzLCB2YXJzKSkubWFrZUFic29sdXRlKCk7XG4gIH07XG5cbiAgRmxpcC5iYXRjaCA9IGZ1bmN0aW9uIGJhdGNoKGlkKSB7XG4gICAgaWQgfHwgKGlkID0gXCJkZWZhdWx0XCIpO1xuICAgIHJldHVybiBfYmF0Y2hMb29rdXBbaWRdIHx8IChfYmF0Y2hMb29rdXBbaWRdID0gbmV3IEZsaXBCYXRjaChpZCkpO1xuICB9O1xuXG4gIEZsaXAua2lsbEZsaXBzT2YgPSBmdW5jdGlvbiBraWxsRmxpcHNPZih0YXJnZXRzLCBjb21wbGV0ZSkge1xuICAgICh0YXJnZXRzIGluc3RhbmNlb2YgRmxpcFN0YXRlID8gdGFyZ2V0cy50YXJnZXRzIDogX3RvQXJyYXkodGFyZ2V0cykpLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0ICYmIF9raWxsRmxpcCh0Ll9mbGlwLCBjb21wbGV0ZSAhPT0gZmFsc2UgPyAxIDogMik7XG4gICAgfSk7XG4gIH07XG5cbiAgRmxpcC5pc0ZsaXBwaW5nID0gZnVuY3Rpb24gaXNGbGlwcGluZyh0YXJnZXQpIHtcbiAgICB2YXIgZiA9IEZsaXAuZ2V0QnlUYXJnZXQodGFyZ2V0KTtcbiAgICByZXR1cm4gISFmICYmIGYuaXNBY3RpdmUoKTtcbiAgfTtcblxuICBGbGlwLmdldEJ5VGFyZ2V0ID0gZnVuY3Rpb24gZ2V0QnlUYXJnZXQodGFyZ2V0KSB7XG4gICAgcmV0dXJuIChfZ2V0RWwodGFyZ2V0KSB8fCBfZW1wdHlPYmopLl9mbGlwO1xuICB9O1xuXG4gIEZsaXAuZ2V0RWxlbWVudFN0YXRlID0gZnVuY3Rpb24gZ2V0RWxlbWVudFN0YXRlKHRhcmdldCwgcHJvcHMpIHtcbiAgICByZXR1cm4gbmV3IEVsZW1lbnRTdGF0ZShfZ2V0RWwodGFyZ2V0KSwgcHJvcHMpO1xuICB9O1xuXG4gIEZsaXAuY29udmVydENvb3JkaW5hdGVzID0gZnVuY3Rpb24gY29udmVydENvb3JkaW5hdGVzKGZyb21FbGVtZW50LCB0b0VsZW1lbnQsIHBvaW50KSB7XG4gICAgdmFyIG0gPSBnZXRHbG9iYWxNYXRyaXgodG9FbGVtZW50LCB0cnVlLCB0cnVlKS5tdWx0aXBseShnZXRHbG9iYWxNYXRyaXgoZnJvbUVsZW1lbnQpKTtcbiAgICByZXR1cm4gcG9pbnQgPyBtLmFwcGx5KHBvaW50KSA6IG07XG4gIH07XG5cbiAgRmxpcC5yZWdpc3RlciA9IGZ1bmN0aW9uIHJlZ2lzdGVyKGNvcmUpIHtcbiAgICBfYm9keSA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudC5ib2R5O1xuXG4gICAgaWYgKF9ib2R5KSB7XG4gICAgICBnc2FwID0gY29yZTtcblxuICAgICAgX3NldERvYyhfYm9keSk7XG5cbiAgICAgIF90b0FycmF5ID0gZ3NhcC51dGlscy50b0FycmF5O1xuICAgICAgdmFyIHNuYXAgPSBnc2FwLnV0aWxzLnNuYXAoMC4xKTtcblxuICAgICAgX2Nsb3Nlc3RUZW50aCA9IGZ1bmN0aW9uIF9jbG9zZXN0VGVudGgodmFsdWUsIGFkZCkge1xuICAgICAgICByZXR1cm4gc25hcChwYXJzZUZsb2F0KHZhbHVlKSArIGFkZCk7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gRmxpcDtcbn0oKTtcbkZsaXAudmVyc2lvbiA9IFwiMy45LjFcIjsgLy8gZnVuY3Rpb24gd2hlbkltYWdlc0xvYWQoZWwsIGZ1bmMpIHtcbi8vIFx0bGV0IHBlbmRpbmcgPSBbXSxcbi8vIFx0XHRvbkxvYWQgPSBlID0+IHtcbi8vIFx0XHRcdHBlbmRpbmcuc3BsaWNlKHBlbmRpbmcuaW5kZXhPZihlLnRhcmdldCksIDEpO1xuLy8gXHRcdFx0ZS50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgb25Mb2FkKTtcbi8vIFx0XHRcdHBlbmRpbmcubGVuZ3RoIHx8IGZ1bmMoKTtcbi8vIFx0XHR9O1xuLy8gXHRnc2FwLnV0aWxzLnRvQXJyYXkoZWwudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImltZ1wiID8gZWwgOiBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiaW1nXCIpKS5mb3JFYWNoKGltZyA9PiBpbWcuY29tcGxldGUgfHwgaW1nLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIG9uTG9hZCkgfHwgcGVuZGluZy5wdXNoKGltZykpO1xuLy8gXHRwZW5kaW5nLmxlbmd0aCB8fCBmdW5jKCk7XG4vLyB9XG5cbnR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93LmdzYXAgJiYgd2luZG93LmdzYXAucmVnaXN0ZXJQbHVnaW4oRmxpcCk7XG5leHBvcnQgeyBGbGlwIGFzIGRlZmF1bHQgfTsiLCIvKiFcbiAqIE1vdGlvblBhdGhQbHVnaW4gMy45LjFcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjEsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG5pbXBvcnQgeyBnZXRSYXdQYXRoLCBjYWNoZVJhd1BhdGhNZWFzdXJlbWVudHMsIGdldFBvc2l0aW9uT25QYXRoLCBwb2ludHNUb1NlZ21lbnQsIGZsYXRQb2ludHNUb1NlZ21lbnQsIHNsaWNlUmF3UGF0aCwgc3RyaW5nVG9SYXdQYXRoLCByYXdQYXRoVG9TdHJpbmcsIHRyYW5zZm9ybVJhd1BhdGgsIGNvbnZlcnRUb1BhdGggYXMgX2NvbnZlcnRUb1BhdGggfSBmcm9tIFwiLi91dGlscy9wYXRocy5qc1wiO1xuaW1wb3J0IHsgZ2V0R2xvYmFsTWF0cml4IH0gZnJvbSBcIi4vdXRpbHMvbWF0cml4LmpzXCI7XG5cbnZhciBfeFByb3BzID0gXCJ4LHRyYW5zbGF0ZVgsbGVmdCxtYXJnaW5MZWZ0LHhQZXJjZW50XCIuc3BsaXQoXCIsXCIpLFxuICAgIF95UHJvcHMgPSBcInksdHJhbnNsYXRlWSx0b3AsbWFyZ2luVG9wLHlQZXJjZW50XCIuc3BsaXQoXCIsXCIpLFxuICAgIF9ERUcyUkFEID0gTWF0aC5QSSAvIDE4MCxcbiAgICBnc2FwLFxuICAgIFByb3BUd2VlbixcbiAgICBfZ2V0VW5pdCxcbiAgICBfdG9BcnJheSxcbiAgICBfZ2V0R1NBUCA9IGZ1bmN0aW9uIF9nZXRHU0FQKCkge1xuICByZXR1cm4gZ3NhcCB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcDtcbn0sXG4gICAgX3BvcHVsYXRlU2VnbWVudEZyb21BcnJheSA9IGZ1bmN0aW9uIF9wb3B1bGF0ZVNlZ21lbnRGcm9tQXJyYXkoc2VnbWVudCwgdmFsdWVzLCBwcm9wZXJ0eSwgbW9kZSkge1xuICAvL21vZGU6IDAgPSB4IGJ1dCBkb24ndCBmaWxsIHkgeWV0LCAxID0geSwgMiA9IHggYW5kIGZpbGwgeSB3aXRoIDAuXG4gIHZhciBsID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIHNpID0gbW9kZSA9PT0gMiA/IDAgOiBtb2RlLFxuICAgICAgaSA9IDAsXG4gICAgICB2O1xuXG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgc2VnbWVudFtzaV0gPSB2ID0gcGFyc2VGbG9hdCh2YWx1ZXNbaV1bcHJvcGVydHldKTtcbiAgICBtb2RlID09PSAyICYmIChzZWdtZW50W3NpICsgMV0gPSAwKTtcbiAgICBzaSArPSAyO1xuICB9XG5cbiAgcmV0dXJuIHNlZ21lbnQ7XG59LFxuICAgIF9nZXRQcm9wTnVtID0gZnVuY3Rpb24gX2dldFByb3BOdW0odGFyZ2V0LCBwcm9wLCB1bml0KSB7XG4gIHJldHVybiBwYXJzZUZsb2F0KHRhcmdldC5fZ3NhcC5nZXQodGFyZ2V0LCBwcm9wLCB1bml0IHx8IFwicHhcIikpIHx8IDA7XG59LFxuICAgIF9yZWxhdGl2aXplID0gZnVuY3Rpb24gX3JlbGF0aXZpemUoc2VnbWVudCkge1xuICB2YXIgeCA9IHNlZ21lbnRbMF0sXG4gICAgICB5ID0gc2VnbWVudFsxXSxcbiAgICAgIGk7XG5cbiAgZm9yIChpID0gMjsgaSA8IHNlZ21lbnQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB4ID0gc2VnbWVudFtpXSArPSB4O1xuICAgIHkgPSBzZWdtZW50W2kgKyAxXSArPSB5O1xuICB9XG59LFxuICAgIC8vIGZlZWQgaW4gYW4gYXJyYXkgb2YgcXVhZHJhdGljIGJlemllciBwb2ludHMgbGlrZSBbe3g6IDAsIHk6IDB9LCAuLi5dIGFuZCBpdCdsbCBjb252ZXJ0IGl0IHRvIGN1YmljIGJlemllclxuLy8gX3F1YWRUb0N1YmljID0gcG9pbnRzID0+IHtcbi8vIFx0bGV0IGN1YmljID0gW10sXG4vLyBcdFx0bCA9IHBvaW50cy5sZW5ndGggLSAxLFxuLy8gXHRcdGkgPSAxLFxuLy8gXHRcdGEsIGIsIGM7XG4vLyBcdGZvciAoOyBpIDwgbDsgaSs9Mikge1xuLy8gXHRcdGEgPSBwb2ludHNbaS0xXTtcbi8vIFx0XHRiID0gcG9pbnRzW2ldO1xuLy8gXHRcdGMgPSBwb2ludHNbaSsxXTtcbi8vIFx0XHRjdWJpYy5wdXNoKGEsIHt4OiAoMiAqIGIueCArIGEueCkgLyAzLCB5OiAoMiAqIGIueSArIGEueSkgLyAzfSwge3g6ICgyICogYi54ICsgYy54KSAvIDMsIHk6ICgyICogYi55ICsgYy55KSAvIDN9KTtcbi8vIFx0fVxuLy8gXHRjdWJpYy5wdXNoKHBvaW50c1tsXSk7XG4vLyBcdHJldHVybiBjdWJpYztcbi8vIH0sXG5fc2VnbWVudFRvUmF3UGF0aCA9IGZ1bmN0aW9uIF9zZWdtZW50VG9SYXdQYXRoKHBsdWdpbiwgc2VnbWVudCwgdGFyZ2V0LCB4LCB5LCBzbGljZXIsIHZhcnMsIHVuaXRYLCB1bml0WSkge1xuICBpZiAodmFycy50eXBlID09PSBcImN1YmljXCIpIHtcbiAgICBzZWdtZW50ID0gW3NlZ21lbnRdO1xuICB9IGVsc2Uge1xuICAgIHZhcnMuZnJvbUN1cnJlbnQgIT09IGZhbHNlICYmIHNlZ21lbnQudW5zaGlmdChfZ2V0UHJvcE51bSh0YXJnZXQsIHgsIHVuaXRYKSwgeSA/IF9nZXRQcm9wTnVtKHRhcmdldCwgeSwgdW5pdFkpIDogMCk7XG4gICAgdmFycy5yZWxhdGl2ZSAmJiBfcmVsYXRpdml6ZShzZWdtZW50KTtcbiAgICB2YXIgcG9pbnRGdW5jID0geSA/IHBvaW50c1RvU2VnbWVudCA6IGZsYXRQb2ludHNUb1NlZ21lbnQ7XG4gICAgc2VnbWVudCA9IFtwb2ludEZ1bmMoc2VnbWVudCwgdmFycy5jdXJ2aW5lc3MpXTtcbiAgfVxuXG4gIHNlZ21lbnQgPSBzbGljZXIoX2FsaWduKHNlZ21lbnQsIHRhcmdldCwgdmFycykpO1xuXG4gIF9hZGREaW1lbnNpb25hbFByb3BUd2VlbihwbHVnaW4sIHRhcmdldCwgeCwgc2VnbWVudCwgXCJ4XCIsIHVuaXRYKTtcblxuICB5ICYmIF9hZGREaW1lbnNpb25hbFByb3BUd2VlbihwbHVnaW4sIHRhcmdldCwgeSwgc2VnbWVudCwgXCJ5XCIsIHVuaXRZKTtcbiAgcmV0dXJuIGNhY2hlUmF3UGF0aE1lYXN1cmVtZW50cyhzZWdtZW50LCB2YXJzLnJlc29sdXRpb24gfHwgKHZhcnMuY3VydmluZXNzID09PSAwID8gMjAgOiAxMikpOyAvL3doZW4gY3VydmluZXNzIGlzIDAsIGl0IGNyZWF0ZXMgY29udHJvbCBwb2ludHMgcmlnaHQgb24gdG9wIG9mIHRoZSBhbmNob3JzIHdoaWNoIG1ha2VzIGl0IG1vcmUgc2Vuc2l0aXZlIHRvIHJlc29sdXRpb24sIHRodXMgd2UgY2hhbmdlIHRoZSBkZWZhdWx0IGFjY29yZGluZ2x5LlxufSxcbiAgICBfZW1wdHlGdW5jID0gZnVuY3Rpb24gX2VtcHR5RnVuYyh2KSB7XG4gIHJldHVybiB2O1xufSxcbiAgICBfbnVtRXhwID0gL1stK1xcLl0qXFxkK1xcLj8oPzplLXxlXFwrKT9cXGQqL2csXG4gICAgX29yaWdpblRvUG9pbnQgPSBmdW5jdGlvbiBfb3JpZ2luVG9Qb2ludChlbGVtZW50LCBvcmlnaW4sIHBhcmVudE1hdHJpeCkge1xuICAvLyBvcmlnaW4gaXMgYW4gYXJyYXkgb2Ygbm9ybWFsaXplZCB2YWx1ZXMgKDAtMSkgaW4gcmVsYXRpb24gdG8gdGhlIHdpZHRoL2hlaWdodCwgc28gWzAuNSwgMC41XSB3b3VsZCBiZSB0aGUgY2VudGVyLiBJdCBjYW4gYWxzbyBiZSBcImF1dG9cIiBpbiB3aGljaCBjYXNlIGl0IHdpbGwgYmUgdGhlIHRvcCBsZWZ0IHVubGVzcyBpdCdzIGEgPHBhdGg+LCB3aGVuIGl0IHdpbGwgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcGF0aCBpdHNlbGYuXG4gIHZhciBtID0gZ2V0R2xvYmFsTWF0cml4KGVsZW1lbnQpLFxuICAgICAgeCA9IDAsXG4gICAgICB5ID0gMCxcbiAgICAgIHN2ZztcblxuICBpZiAoKGVsZW1lbnQudGFnTmFtZSArIFwiXCIpLnRvTG93ZXJDYXNlKCkgPT09IFwic3ZnXCIpIHtcbiAgICBzdmcgPSBlbGVtZW50LnZpZXdCb3guYmFzZVZhbDtcbiAgICBzdmcud2lkdGggfHwgKHN2ZyA9IHtcbiAgICAgIHdpZHRoOiArZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiKSxcbiAgICAgIGhlaWdodDogK2VsZW1lbnQuZ2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIpXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgc3ZnID0gb3JpZ2luICYmIGVsZW1lbnQuZ2V0QkJveCAmJiBlbGVtZW50LmdldEJCb3goKTtcbiAgfVxuXG4gIGlmIChvcmlnaW4gJiYgb3JpZ2luICE9PSBcImF1dG9cIikge1xuICAgIHggPSBvcmlnaW4ucHVzaCA/IG9yaWdpblswXSAqIChzdmcgPyBzdmcud2lkdGggOiBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDApIDogb3JpZ2luLng7XG4gICAgeSA9IG9yaWdpbi5wdXNoID8gb3JpZ2luWzFdICogKHN2ZyA/IHN2Zy5oZWlnaHQgOiBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAwKSA6IG9yaWdpbi55O1xuICB9XG5cbiAgcmV0dXJuIHBhcmVudE1hdHJpeC5hcHBseSh4IHx8IHkgPyBtLmFwcGx5KHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfSkgOiB7XG4gICAgeDogbS5lLFxuICAgIHk6IG0uZlxuICB9KTtcbn0sXG4gICAgX2dldEFsaWduTWF0cml4ID0gZnVuY3Rpb24gX2dldEFsaWduTWF0cml4KGZyb21FbGVtZW50LCB0b0VsZW1lbnQsIGZyb21PcmlnaW4sIHRvT3JpZ2luKSB7XG4gIHZhciBwYXJlbnRNYXRyaXggPSBnZXRHbG9iYWxNYXRyaXgoZnJvbUVsZW1lbnQucGFyZW50Tm9kZSwgdHJ1ZSwgdHJ1ZSksXG4gICAgICBtID0gcGFyZW50TWF0cml4LmNsb25lKCkubXVsdGlwbHkoZ2V0R2xvYmFsTWF0cml4KHRvRWxlbWVudCkpLFxuICAgICAgZnJvbVBvaW50ID0gX29yaWdpblRvUG9pbnQoZnJvbUVsZW1lbnQsIGZyb21PcmlnaW4sIHBhcmVudE1hdHJpeCksXG4gICAgICBfb3JpZ2luVG9Qb2ludDIgPSBfb3JpZ2luVG9Qb2ludCh0b0VsZW1lbnQsIHRvT3JpZ2luLCBwYXJlbnRNYXRyaXgpLFxuICAgICAgeCA9IF9vcmlnaW5Ub1BvaW50Mi54LFxuICAgICAgeSA9IF9vcmlnaW5Ub1BvaW50Mi55LFxuICAgICAgcDtcblxuICBtLmUgPSBtLmYgPSAwO1xuXG4gIGlmICh0b09yaWdpbiA9PT0gXCJhdXRvXCIgJiYgdG9FbGVtZW50LmdldFRvdGFsTGVuZ3RoICYmIHRvRWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwicGF0aFwiKSB7XG4gICAgcCA9IHRvRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkXCIpLm1hdGNoKF9udW1FeHApIHx8IFtdO1xuICAgIHAgPSBtLmFwcGx5KHtcbiAgICAgIHg6ICtwWzBdLFxuICAgICAgeTogK3BbMV1cbiAgICB9KTtcbiAgICB4ICs9IHAueDtcbiAgICB5ICs9IHAueTtcbiAgfVxuXG4gIGlmIChwIHx8IHRvRWxlbWVudC5nZXRCQm94ICYmIGZyb21FbGVtZW50LmdldEJCb3ggJiYgdG9FbGVtZW50Lm93bmVyU1ZHRWxlbWVudCA9PT0gZnJvbUVsZW1lbnQub3duZXJTVkdFbGVtZW50KSB7XG4gICAgcCA9IG0uYXBwbHkodG9FbGVtZW50LmdldEJCb3goKSk7XG4gICAgeCAtPSBwLng7XG4gICAgeSAtPSBwLnk7XG4gIH1cblxuICBtLmUgPSB4IC0gZnJvbVBvaW50Lng7XG4gIG0uZiA9IHkgLSBmcm9tUG9pbnQueTtcbiAgcmV0dXJuIG07XG59LFxuICAgIF9hbGlnbiA9IGZ1bmN0aW9uIF9hbGlnbihyYXdQYXRoLCB0YXJnZXQsIF9yZWYpIHtcbiAgdmFyIGFsaWduID0gX3JlZi5hbGlnbixcbiAgICAgIG1hdHJpeCA9IF9yZWYubWF0cml4LFxuICAgICAgb2Zmc2V0WCA9IF9yZWYub2Zmc2V0WCxcbiAgICAgIG9mZnNldFkgPSBfcmVmLm9mZnNldFksXG4gICAgICBhbGlnbk9yaWdpbiA9IF9yZWYuYWxpZ25PcmlnaW47XG5cbiAgdmFyIHggPSByYXdQYXRoWzBdWzBdLFxuICAgICAgeSA9IHJhd1BhdGhbMF1bMV0sXG4gICAgICBjdXJYID0gX2dldFByb3BOdW0odGFyZ2V0LCBcInhcIiksXG4gICAgICBjdXJZID0gX2dldFByb3BOdW0odGFyZ2V0LCBcInlcIiksXG4gICAgICBhbGlnblRhcmdldCxcbiAgICAgIG0sXG4gICAgICBwO1xuXG4gIGlmICghcmF3UGF0aCB8fCAhcmF3UGF0aC5sZW5ndGgpIHtcbiAgICByZXR1cm4gZ2V0UmF3UGF0aChcIk0wLDBMMCwwXCIpO1xuICB9XG5cbiAgaWYgKGFsaWduKSB7XG4gICAgaWYgKGFsaWduID09PSBcInNlbGZcIiB8fCAoYWxpZ25UYXJnZXQgPSBfdG9BcnJheShhbGlnbilbMF0gfHwgdGFyZ2V0KSA9PT0gdGFyZ2V0KSB7XG4gICAgICB0cmFuc2Zvcm1SYXdQYXRoKHJhd1BhdGgsIDEsIDAsIDAsIDEsIGN1clggLSB4LCBjdXJZIC0geSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhbGlnbk9yaWdpbiAmJiBhbGlnbk9yaWdpblsyXSAhPT0gZmFsc2UpIHtcbiAgICAgICAgZ3NhcC5zZXQodGFyZ2V0LCB7XG4gICAgICAgICAgdHJhbnNmb3JtT3JpZ2luOiBhbGlnbk9yaWdpblswXSAqIDEwMCArIFwiJSBcIiArIGFsaWduT3JpZ2luWzFdICogMTAwICsgXCIlXCJcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGlnbk9yaWdpbiA9IFtfZ2V0UHJvcE51bSh0YXJnZXQsIFwieFBlcmNlbnRcIikgLyAtMTAwLCBfZ2V0UHJvcE51bSh0YXJnZXQsIFwieVBlcmNlbnRcIikgLyAtMTAwXTtcbiAgICAgIH1cblxuICAgICAgbSA9IF9nZXRBbGlnbk1hdHJpeCh0YXJnZXQsIGFsaWduVGFyZ2V0LCBhbGlnbk9yaWdpbiwgXCJhdXRvXCIpO1xuICAgICAgcCA9IG0uYXBwbHkoe1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5XG4gICAgICB9KTtcbiAgICAgIHRyYW5zZm9ybVJhd1BhdGgocmF3UGF0aCwgbS5hLCBtLmIsIG0uYywgbS5kLCBjdXJYICsgbS5lIC0gKHAueCAtIG0uZSksIGN1clkgKyBtLmYgLSAocC55IC0gbS5mKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG1hdHJpeCkge1xuICAgIHRyYW5zZm9ybVJhd1BhdGgocmF3UGF0aCwgbWF0cml4LmEsIG1hdHJpeC5iLCBtYXRyaXguYywgbWF0cml4LmQsIG1hdHJpeC5lLCBtYXRyaXguZik7XG4gIH0gZWxzZSBpZiAob2Zmc2V0WCB8fCBvZmZzZXRZKSB7XG4gICAgdHJhbnNmb3JtUmF3UGF0aChyYXdQYXRoLCAxLCAwLCAwLCAxLCBvZmZzZXRYIHx8IDAsIG9mZnNldFkgfHwgMCk7XG4gIH1cblxuICByZXR1cm4gcmF3UGF0aDtcbn0sXG4gICAgX2FkZERpbWVuc2lvbmFsUHJvcFR3ZWVuID0gZnVuY3Rpb24gX2FkZERpbWVuc2lvbmFsUHJvcFR3ZWVuKHBsdWdpbiwgdGFyZ2V0LCBwcm9wZXJ0eSwgcmF3UGF0aCwgcGF0aFByb3BlcnR5LCBmb3JjZVVuaXQpIHtcbiAgdmFyIGNhY2hlID0gdGFyZ2V0Ll9nc2FwLFxuICAgICAgaGFybmVzcyA9IGNhY2hlLmhhcm5lc3MsXG4gICAgICBhbGlhcyA9IGhhcm5lc3MgJiYgaGFybmVzcy5hbGlhc2VzICYmIGhhcm5lc3MuYWxpYXNlc1twcm9wZXJ0eV0sXG4gICAgICBwcm9wID0gYWxpYXMgJiYgYWxpYXMuaW5kZXhPZihcIixcIikgPCAwID8gYWxpYXMgOiBwcm9wZXJ0eSxcbiAgICAgIHB0ID0gcGx1Z2luLl9wdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgdGFyZ2V0LCBwcm9wLCAwLCAwLCBfZW1wdHlGdW5jLCAwLCBjYWNoZS5zZXQodGFyZ2V0LCBwcm9wLCBwbHVnaW4pKTtcbiAgcHQudSA9IF9nZXRVbml0KGNhY2hlLmdldCh0YXJnZXQsIHByb3AsIGZvcmNlVW5pdCkpIHx8IDA7XG4gIHB0LnBhdGggPSByYXdQYXRoO1xuICBwdC5wcCA9IHBhdGhQcm9wZXJ0eTtcblxuICBwbHVnaW4uX3Byb3BzLnB1c2gocHJvcCk7XG59LFxuICAgIF9zbGljZU1vZGlmaWVyID0gZnVuY3Rpb24gX3NsaWNlTW9kaWZpZXIoc3RhcnQsIGVuZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHJhd1BhdGgpIHtcbiAgICByZXR1cm4gc3RhcnQgfHwgZW5kICE9PSAxID8gc2xpY2VSYXdQYXRoKHJhd1BhdGgsIHN0YXJ0LCBlbmQpIDogcmF3UGF0aDtcbiAgfTtcbn07XG5cbmV4cG9ydCB2YXIgTW90aW9uUGF0aFBsdWdpbiA9IHtcbiAgdmVyc2lvbjogXCIzLjkuMVwiLFxuICBuYW1lOiBcIm1vdGlvblBhdGhcIixcbiAgcmVnaXN0ZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyKGNvcmUsIFBsdWdpbiwgcHJvcFR3ZWVuKSB7XG4gICAgZ3NhcCA9IGNvcmU7XG4gICAgX2dldFVuaXQgPSBnc2FwLnV0aWxzLmdldFVuaXQ7XG4gICAgX3RvQXJyYXkgPSBnc2FwLnV0aWxzLnRvQXJyYXk7XG4gICAgUHJvcFR3ZWVuID0gcHJvcFR3ZWVuO1xuICB9LFxuICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFycykge1xuICAgIGlmICghZ3NhcCkge1xuICAgICAgY29uc29sZS53YXJuKFwiUGxlYXNlIGdzYXAucmVnaXN0ZXJQbHVnaW4oTW90aW9uUGF0aFBsdWdpbilcIik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCEodHlwZW9mIHZhcnMgPT09IFwib2JqZWN0XCIgJiYgIXZhcnMuc3R5bGUpIHx8ICF2YXJzLnBhdGgpIHtcbiAgICAgIHZhcnMgPSB7XG4gICAgICAgIHBhdGg6IHZhcnNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHJhd1BhdGhzID0gW10sXG4gICAgICAgIF92YXJzID0gdmFycyxcbiAgICAgICAgcGF0aCA9IF92YXJzLnBhdGgsXG4gICAgICAgIGF1dG9Sb3RhdGUgPSBfdmFycy5hdXRvUm90YXRlLFxuICAgICAgICB1bml0WCA9IF92YXJzLnVuaXRYLFxuICAgICAgICB1bml0WSA9IF92YXJzLnVuaXRZLFxuICAgICAgICB4ID0gX3ZhcnMueCxcbiAgICAgICAgeSA9IF92YXJzLnksXG4gICAgICAgIGZpcnN0T2JqID0gcGF0aFswXSxcbiAgICAgICAgc2xpY2VyID0gX3NsaWNlTW9kaWZpZXIodmFycy5zdGFydCwgXCJlbmRcIiBpbiB2YXJzID8gdmFycy5lbmQgOiAxKSxcbiAgICAgICAgcmF3UGF0aCxcbiAgICAgICAgcDtcblxuICAgIHRoaXMucmF3UGF0aHMgPSByYXdQYXRocztcbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcblxuICAgIGlmICh0aGlzLnJvdGF0ZSA9IGF1dG9Sb3RhdGUgfHwgYXV0b1JvdGF0ZSA9PT0gMCkge1xuICAgICAgLy9nZXQgdGhlIHJvdGF0aW9uYWwgZGF0YSBGSVJTVCBzbyB0aGF0IHRoZSBzZXRUcmFuc2Zvcm0oKSBtZXRob2QgaXMgY2FsbGVkIGluIHRoZSBjb3JyZWN0IG9yZGVyIGluIHRoZSByZW5kZXIoKSBsb29wIC0gcm90YXRpb24gZ2V0cyBzZXQgbGFzdC5cbiAgICAgIHRoaXMuck9mZnNldCA9IHBhcnNlRmxvYXQoYXV0b1JvdGF0ZSkgfHwgMDtcbiAgICAgIHRoaXMucmFkaWFucyA9ICEhdmFycy51c2VSYWRpYW5zO1xuICAgICAgdGhpcy5yUHJvcCA9IHZhcnMucm90YXRpb24gfHwgXCJyb3RhdGlvblwiOyAvLyByb3RhdGlvbiBwcm9wZXJ0eVxuXG4gICAgICB0aGlzLnJTZXQgPSB0YXJnZXQuX2dzYXAuc2V0KHRhcmdldCwgdGhpcy5yUHJvcCwgdGhpcyk7IC8vIHJvdGF0aW9uIHNldHRlclxuXG4gICAgICB0aGlzLnJ1ID0gX2dldFVuaXQodGFyZ2V0Ll9nc2FwLmdldCh0YXJnZXQsIHRoaXMuclByb3ApKSB8fCAwOyAvLyByb3RhdGlvbiB1bml0c1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KHBhdGgpICYmICEoXCJjbG9zZWRcIiBpbiBwYXRoKSAmJiB0eXBlb2YgZmlyc3RPYmogIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGZvciAocCBpbiBmaXJzdE9iaikge1xuICAgICAgICBpZiAoIXggJiYgfl94UHJvcHMuaW5kZXhPZihwKSkge1xuICAgICAgICAgIHggPSBwO1xuICAgICAgICB9IGVsc2UgaWYgKCF5ICYmIH5feVByb3BzLmluZGV4T2YocCkpIHtcbiAgICAgICAgICB5ID0gcDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoeCAmJiB5KSB7XG4gICAgICAgIC8vY29ycmVsYXRlZCB2YWx1ZXNcbiAgICAgICAgcmF3UGF0aHMucHVzaChfc2VnbWVudFRvUmF3UGF0aCh0aGlzLCBfcG9wdWxhdGVTZWdtZW50RnJvbUFycmF5KF9wb3B1bGF0ZVNlZ21lbnRGcm9tQXJyYXkoW10sIHBhdGgsIHgsIDApLCBwYXRoLCB5LCAxKSwgdGFyZ2V0LCB4LCB5LCBzbGljZXIsIHZhcnMsIHVuaXRYIHx8IF9nZXRVbml0KHBhdGhbMF1beF0pLCB1bml0WSB8fCBfZ2V0VW5pdChwYXRoWzBdW3ldKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IHkgPSAwO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHAgaW4gZmlyc3RPYmopIHtcbiAgICAgICAgcCAhPT0geCAmJiBwICE9PSB5ICYmIHJhd1BhdGhzLnB1c2goX3NlZ21lbnRUb1Jhd1BhdGgodGhpcywgX3BvcHVsYXRlU2VnbWVudEZyb21BcnJheShbXSwgcGF0aCwgcCwgMiksIHRhcmdldCwgcCwgMCwgc2xpY2VyLCB2YXJzLCBfZ2V0VW5pdChwYXRoWzBdW3BdKSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByYXdQYXRoID0gc2xpY2VyKF9hbGlnbihnZXRSYXdQYXRoKHZhcnMucGF0aCksIHRhcmdldCwgdmFycykpO1xuICAgICAgY2FjaGVSYXdQYXRoTWVhc3VyZW1lbnRzKHJhd1BhdGgsIHZhcnMucmVzb2x1dGlvbik7XG4gICAgICByYXdQYXRocy5wdXNoKHJhd1BhdGgpO1xuXG4gICAgICBfYWRkRGltZW5zaW9uYWxQcm9wVHdlZW4odGhpcywgdGFyZ2V0LCB2YXJzLnggfHwgXCJ4XCIsIHJhd1BhdGgsIFwieFwiLCB2YXJzLnVuaXRYIHx8IFwicHhcIik7XG5cbiAgICAgIF9hZGREaW1lbnNpb25hbFByb3BUd2Vlbih0aGlzLCB0YXJnZXQsIHZhcnMueSB8fCBcInlcIiwgcmF3UGF0aCwgXCJ5XCIsIHZhcnMudW5pdFkgfHwgXCJweFwiKTtcbiAgICB9XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKHJhdGlvLCBkYXRhKSB7XG4gICAgdmFyIHJhd1BhdGhzID0gZGF0YS5yYXdQYXRocyxcbiAgICAgICAgaSA9IHJhd1BhdGhzLmxlbmd0aCxcbiAgICAgICAgcHQgPSBkYXRhLl9wdDtcblxuICAgIGlmIChyYXRpbyA+IDEpIHtcbiAgICAgIHJhdGlvID0gMTtcbiAgICB9IGVsc2UgaWYgKHJhdGlvIDwgMCkge1xuICAgICAgcmF0aW8gPSAwO1xuICAgIH1cblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGdldFBvc2l0aW9uT25QYXRoKHJhd1BhdGhzW2ldLCByYXRpbywgIWkgJiYgZGF0YS5yb3RhdGUsIHJhd1BhdGhzW2ldKTtcbiAgICB9XG5cbiAgICB3aGlsZSAocHQpIHtcbiAgICAgIHB0LnNldChwdC50LCBwdC5wLCBwdC5wYXRoW3B0LnBwXSArIHB0LnUsIHB0LmQsIHJhdGlvKTtcbiAgICAgIHB0ID0gcHQuX25leHQ7XG4gICAgfVxuXG4gICAgZGF0YS5yb3RhdGUgJiYgZGF0YS5yU2V0KGRhdGEudGFyZ2V0LCBkYXRhLnJQcm9wLCByYXdQYXRoc1swXS5hbmdsZSAqIChkYXRhLnJhZGlhbnMgPyBfREVHMlJBRCA6IDEpICsgZGF0YS5yT2Zmc2V0ICsgZGF0YS5ydSwgZGF0YSwgcmF0aW8pO1xuICB9LFxuICBnZXRMZW5ndGg6IGZ1bmN0aW9uIGdldExlbmd0aChwYXRoKSB7XG4gICAgcmV0dXJuIGNhY2hlUmF3UGF0aE1lYXN1cmVtZW50cyhnZXRSYXdQYXRoKHBhdGgpKS50b3RhbExlbmd0aDtcbiAgfSxcbiAgc2xpY2VSYXdQYXRoOiBzbGljZVJhd1BhdGgsXG4gIGdldFJhd1BhdGg6IGdldFJhd1BhdGgsXG4gIHBvaW50c1RvU2VnbWVudDogcG9pbnRzVG9TZWdtZW50LFxuICBzdHJpbmdUb1Jhd1BhdGg6IHN0cmluZ1RvUmF3UGF0aCxcbiAgcmF3UGF0aFRvU3RyaW5nOiByYXdQYXRoVG9TdHJpbmcsXG4gIHRyYW5zZm9ybVJhd1BhdGg6IHRyYW5zZm9ybVJhd1BhdGgsXG4gIGdldEdsb2JhbE1hdHJpeDogZ2V0R2xvYmFsTWF0cml4LFxuICBnZXRQb3NpdGlvbk9uUGF0aDogZ2V0UG9zaXRpb25PblBhdGgsXG4gIGNhY2hlUmF3UGF0aE1lYXN1cmVtZW50czogY2FjaGVSYXdQYXRoTWVhc3VyZW1lbnRzLFxuICBjb252ZXJ0VG9QYXRoOiBmdW5jdGlvbiBjb252ZXJ0VG9QYXRoKHRhcmdldHMsIHN3YXApIHtcbiAgICByZXR1cm4gX3RvQXJyYXkodGFyZ2V0cykubWFwKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIHJldHVybiBfY29udmVydFRvUGF0aCh0YXJnZXQsIHN3YXAgIT09IGZhbHNlKTtcbiAgICB9KTtcbiAgfSxcbiAgY29udmVydENvb3JkaW5hdGVzOiBmdW5jdGlvbiBjb252ZXJ0Q29vcmRpbmF0ZXMoZnJvbUVsZW1lbnQsIHRvRWxlbWVudCwgcG9pbnQpIHtcbiAgICB2YXIgbSA9IGdldEdsb2JhbE1hdHJpeCh0b0VsZW1lbnQsIHRydWUsIHRydWUpLm11bHRpcGx5KGdldEdsb2JhbE1hdHJpeChmcm9tRWxlbWVudCkpO1xuICAgIHJldHVybiBwb2ludCA/IG0uYXBwbHkocG9pbnQpIDogbTtcbiAgfSxcbiAgZ2V0QWxpZ25NYXRyaXg6IF9nZXRBbGlnbk1hdHJpeCxcbiAgZ2V0UmVsYXRpdmVQb3NpdGlvbjogZnVuY3Rpb24gZ2V0UmVsYXRpdmVQb3NpdGlvbihmcm9tRWxlbWVudCwgdG9FbGVtZW50LCBmcm9tT3JpZ2luLCB0b09yaWdpbikge1xuICAgIHZhciBtID0gX2dldEFsaWduTWF0cml4KGZyb21FbGVtZW50LCB0b0VsZW1lbnQsIGZyb21PcmlnaW4sIHRvT3JpZ2luKTtcblxuICAgIHJldHVybiB7XG4gICAgICB4OiBtLmUsXG4gICAgICB5OiBtLmZcbiAgICB9O1xuICB9LFxuICBhcnJheVRvUmF3UGF0aDogZnVuY3Rpb24gYXJyYXlUb1Jhd1BhdGgodmFsdWUsIHZhcnMpIHtcbiAgICB2YXJzID0gdmFycyB8fCB7fTtcblxuICAgIHZhciBzZWdtZW50ID0gX3BvcHVsYXRlU2VnbWVudEZyb21BcnJheShfcG9wdWxhdGVTZWdtZW50RnJvbUFycmF5KFtdLCB2YWx1ZSwgdmFycy54IHx8IFwieFwiLCAwKSwgdmFsdWUsIHZhcnMueSB8fCBcInlcIiwgMSk7XG5cbiAgICB2YXJzLnJlbGF0aXZlICYmIF9yZWxhdGl2aXplKHNlZ21lbnQpO1xuICAgIHJldHVybiBbdmFycy50eXBlID09PSBcImN1YmljXCIgPyBzZWdtZW50IDogcG9pbnRzVG9TZWdtZW50KHNlZ21lbnQsIHZhcnMuY3VydmluZXNzKV07XG4gIH1cbn07XG5fZ2V0R1NBUCgpICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4oTW90aW9uUGF0aFBsdWdpbik7XG5leHBvcnQgeyBNb3Rpb25QYXRoUGx1Z2luIGFzIGRlZmF1bHQgfTsiLCIvKiFcbiAqIFBpeGlQbHVnaW4gMy45LjFcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjEsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG52YXIgZ3NhcCxcbiAgICBfd2luLFxuICAgIF9zcGxpdENvbG9yLFxuICAgIF9jb3JlSW5pdHRlZCxcbiAgICBfUElYSSxcbiAgICBQcm9wVHdlZW4sXG4gICAgX2dldFNldHRlcixcbiAgICBfaXNWNCxcbiAgICBfd2luZG93RXhpc3RzID0gZnVuY3Rpb24gX3dpbmRvd0V4aXN0cygpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG59LFxuICAgIF9nZXRHU0FQID0gZnVuY3Rpb24gX2dldEdTQVAoKSB7XG4gIHJldHVybiBnc2FwIHx8IF93aW5kb3dFeGlzdHMoKSAmJiAoZ3NhcCA9IHdpbmRvdy5nc2FwKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luICYmIGdzYXA7XG59LFxuICAgIF9pc0Z1bmN0aW9uID0gZnVuY3Rpb24gX2lzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiO1xufSxcbiAgICBfd2FybiA9IGZ1bmN0aW9uIF93YXJuKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbn0sXG4gICAgX2lkTWF0cml4ID0gWzEsIDAsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDAsIDEsIDBdLFxuICAgIF9sdW1SID0gMC4yMTI2NzEsXG4gICAgX2x1bUcgPSAwLjcxNTE2MCxcbiAgICBfbHVtQiA9IDAuMDcyMTY5LFxuICAgIF9hcHBseU1hdHJpeCA9IGZ1bmN0aW9uIF9hcHBseU1hdHJpeChtLCBtMikge1xuICB2YXIgdGVtcCA9IFtdLFxuICAgICAgaSA9IDAsXG4gICAgICB6ID0gMCxcbiAgICAgIHksXG4gICAgICB4O1xuXG4gIGZvciAoeSA9IDA7IHkgPCA0OyB5KyspIHtcbiAgICBmb3IgKHggPSAwOyB4IDwgNTsgeCsrKSB7XG4gICAgICB6ID0geCA9PT0gNCA/IG1baSArIDRdIDogMDtcbiAgICAgIHRlbXBbaSArIHhdID0gbVtpXSAqIG0yW3hdICsgbVtpICsgMV0gKiBtMlt4ICsgNV0gKyBtW2kgKyAyXSAqIG0yW3ggKyAxMF0gKyBtW2kgKyAzXSAqIG0yW3ggKyAxNV0gKyB6O1xuICAgIH1cblxuICAgIGkgKz0gNTtcbiAgfVxuXG4gIHJldHVybiB0ZW1wO1xufSxcbiAgICBfc2V0U2F0dXJhdGlvbiA9IGZ1bmN0aW9uIF9zZXRTYXR1cmF0aW9uKG0sIG4pIHtcbiAgdmFyIGludiA9IDEgLSBuLFxuICAgICAgciA9IGludiAqIF9sdW1SLFxuICAgICAgZyA9IGludiAqIF9sdW1HLFxuICAgICAgYiA9IGludiAqIF9sdW1CO1xuICByZXR1cm4gX2FwcGx5TWF0cml4KFtyICsgbiwgZywgYiwgMCwgMCwgciwgZyArIG4sIGIsIDAsIDAsIHIsIGcsIGIgKyBuLCAwLCAwLCAwLCAwLCAwLCAxLCAwXSwgbSk7XG59LFxuICAgIF9jb2xvcml6ZSA9IGZ1bmN0aW9uIF9jb2xvcml6ZShtLCBjb2xvciwgYW1vdW50KSB7XG4gIHZhciBjID0gX3NwbGl0Q29sb3IoY29sb3IpLFxuICAgICAgciA9IGNbMF0gLyAyNTUsXG4gICAgICBnID0gY1sxXSAvIDI1NSxcbiAgICAgIGIgPSBjWzJdIC8gMjU1LFxuICAgICAgaW52ID0gMSAtIGFtb3VudDtcblxuICByZXR1cm4gX2FwcGx5TWF0cml4KFtpbnYgKyBhbW91bnQgKiByICogX2x1bVIsIGFtb3VudCAqIHIgKiBfbHVtRywgYW1vdW50ICogciAqIF9sdW1CLCAwLCAwLCBhbW91bnQgKiBnICogX2x1bVIsIGludiArIGFtb3VudCAqIGcgKiBfbHVtRywgYW1vdW50ICogZyAqIF9sdW1CLCAwLCAwLCBhbW91bnQgKiBiICogX2x1bVIsIGFtb3VudCAqIGIgKiBfbHVtRywgaW52ICsgYW1vdW50ICogYiAqIF9sdW1CLCAwLCAwLCAwLCAwLCAwLCAxLCAwXSwgbSk7XG59LFxuICAgIF9zZXRIdWUgPSBmdW5jdGlvbiBfc2V0SHVlKG0sIG4pIHtcbiAgbiAqPSBNYXRoLlBJIC8gMTgwO1xuICB2YXIgYyA9IE1hdGguY29zKG4pLFxuICAgICAgcyA9IE1hdGguc2luKG4pO1xuICByZXR1cm4gX2FwcGx5TWF0cml4KFtfbHVtUiArIGMgKiAoMSAtIF9sdW1SKSArIHMgKiAtX2x1bVIsIF9sdW1HICsgYyAqIC1fbHVtRyArIHMgKiAtX2x1bUcsIF9sdW1CICsgYyAqIC1fbHVtQiArIHMgKiAoMSAtIF9sdW1CKSwgMCwgMCwgX2x1bVIgKyBjICogLV9sdW1SICsgcyAqIDAuMTQzLCBfbHVtRyArIGMgKiAoMSAtIF9sdW1HKSArIHMgKiAwLjE0LCBfbHVtQiArIGMgKiAtX2x1bUIgKyBzICogLTAuMjgzLCAwLCAwLCBfbHVtUiArIGMgKiAtX2x1bVIgKyBzICogLSgxIC0gX2x1bVIpLCBfbHVtRyArIGMgKiAtX2x1bUcgKyBzICogX2x1bUcsIF9sdW1CICsgYyAqICgxIC0gX2x1bUIpICsgcyAqIF9sdW1CLCAwLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAxXSwgbSk7XG59LFxuICAgIF9zZXRDb250cmFzdCA9IGZ1bmN0aW9uIF9zZXRDb250cmFzdChtLCBuKSB7XG4gIHJldHVybiBfYXBwbHlNYXRyaXgoW24sIDAsIDAsIDAsIDAuNSAqICgxIC0gbiksIDAsIG4sIDAsIDAsIDAuNSAqICgxIC0gbiksIDAsIDAsIG4sIDAsIDAuNSAqICgxIC0gbiksIDAsIDAsIDAsIDEsIDBdLCBtKTtcbn0sXG4gICAgX2dldEZpbHRlciA9IGZ1bmN0aW9uIF9nZXRGaWx0ZXIodGFyZ2V0LCB0eXBlKSB7XG4gIHZhciBmaWx0ZXJDbGFzcyA9IF9QSVhJLmZpbHRlcnNbdHlwZV0sXG4gICAgICBmaWx0ZXJzID0gdGFyZ2V0LmZpbHRlcnMgfHwgW10sXG4gICAgICBpID0gZmlsdGVycy5sZW5ndGgsXG4gICAgICBmaWx0ZXI7XG4gIGZpbHRlckNsYXNzIHx8IF93YXJuKHR5cGUgKyBcIiBub3QgZm91bmQuIFBpeGlQbHVnaW4ucmVnaXN0ZXJQSVhJKFBJWEkpXCIpO1xuXG4gIHdoaWxlICgtLWkgPiAtMSkge1xuICAgIGlmIChmaWx0ZXJzW2ldIGluc3RhbmNlb2YgZmlsdGVyQ2xhc3MpIHtcbiAgICAgIHJldHVybiBmaWx0ZXJzW2ldO1xuICAgIH1cbiAgfVxuXG4gIGZpbHRlciA9IG5ldyBmaWx0ZXJDbGFzcygpO1xuXG4gIGlmICh0eXBlID09PSBcIkJsdXJGaWx0ZXJcIikge1xuICAgIGZpbHRlci5ibHVyID0gMDtcbiAgfVxuXG4gIGZpbHRlcnMucHVzaChmaWx0ZXIpO1xuICB0YXJnZXQuZmlsdGVycyA9IGZpbHRlcnM7XG4gIHJldHVybiBmaWx0ZXI7XG59LFxuICAgIF9hZGRDb2xvck1hdHJpeEZpbHRlckNhY2hlVHdlZW4gPSBmdW5jdGlvbiBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKHAsIHBsdWdpbiwgY2FjaGUsIHZhcnMpIHtcbiAgLy93ZSBjYWNoZSB0aGUgQ29sb3JNYXRyaXhGaWx0ZXIgY29tcG9uZW50cyBpbiBhIF9nc0NvbG9yTWF0cml4RmlsdGVyIG9iamVjdCBhdHRhY2hlZCB0byB0aGUgdGFyZ2V0IG9iamVjdCBzbyB0aGF0IGl0J3MgZWFzeSB0byBncmFiIHRoZSBjdXJyZW50IHZhbHVlIGF0IGFueSB0aW1lLlxuICBwbHVnaW4uYWRkKGNhY2hlLCBwLCBjYWNoZVtwXSwgdmFyc1twXSk7XG5cbiAgcGx1Z2luLl9wcm9wcy5wdXNoKHApO1xufSxcbiAgICBfYXBwbHlCcmlnaHRuZXNzVG9NYXRyaXggPSBmdW5jdGlvbiBfYXBwbHlCcmlnaHRuZXNzVG9NYXRyaXgoYnJpZ2h0bmVzcywgbWF0cml4KSB7XG4gIHZhciB0ZW1wID0gbmV3IF9QSVhJLmZpbHRlcnMuQ29sb3JNYXRyaXhGaWx0ZXIoKTtcbiAgdGVtcC5tYXRyaXggPSBtYXRyaXg7XG4gIHRlbXAuYnJpZ2h0bmVzcyhicmlnaHRuZXNzLCB0cnVlKTtcbiAgcmV0dXJuIHRlbXAubWF0cml4O1xufSxcbiAgICBfY29weSA9IGZ1bmN0aW9uIF9jb3B5KG9iaikge1xuICB2YXIgY29weSA9IHt9LFxuICAgICAgcDtcblxuICBmb3IgKHAgaW4gb2JqKSB7XG4gICAgY29weVtwXSA9IG9ialtwXTtcbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufSxcbiAgICBfQ01GZGVmYXVsdHMgPSB7XG4gIGNvbnRyYXN0OiAxLFxuICBzYXR1cmF0aW9uOiAxLFxuICBjb2xvcml6ZUFtb3VudDogMCxcbiAgY29sb3JpemU6IFwicmdiKDI1NSwyNTUsMjU1KVwiLFxuICBodWU6IDAsXG4gIGJyaWdodG5lc3M6IDFcbn0sXG4gICAgX3BhcnNlQ29sb3JNYXRyaXhGaWx0ZXIgPSBmdW5jdGlvbiBfcGFyc2VDb2xvck1hdHJpeEZpbHRlcih0YXJnZXQsIHYsIHBnKSB7XG4gIHZhciBmaWx0ZXIgPSBfZ2V0RmlsdGVyKHRhcmdldCwgXCJDb2xvck1hdHJpeEZpbHRlclwiKSxcbiAgICAgIGNhY2hlID0gdGFyZ2V0Ll9nc0NvbG9yTWF0cml4RmlsdGVyID0gdGFyZ2V0Ll9nc0NvbG9yTWF0cml4RmlsdGVyIHx8IF9jb3B5KF9DTUZkZWZhdWx0cyksXG4gICAgICBjb21iaW5lID0gdi5jb21iaW5lQ01GICYmICEoXCJjb2xvck1hdHJpeEZpbHRlclwiIGluIHYgJiYgIXYuY29sb3JNYXRyaXhGaWx0ZXIpLFxuICAgICAgaSxcbiAgICAgIG1hdHJpeCxcbiAgICAgIHN0YXJ0TWF0cml4O1xuXG4gIHN0YXJ0TWF0cml4ID0gZmlsdGVyLm1hdHJpeDtcblxuICBpZiAodi5yZXNvbHV0aW9uKSB7XG4gICAgZmlsdGVyLnJlc29sdXRpb24gPSB2LnJlc29sdXRpb247XG4gIH1cblxuICBpZiAodi5tYXRyaXggJiYgdi5tYXRyaXgubGVuZ3RoID09PSBzdGFydE1hdHJpeC5sZW5ndGgpIHtcbiAgICBtYXRyaXggPSB2Lm1hdHJpeDtcblxuICAgIGlmIChjYWNoZS5jb250cmFzdCAhPT0gMSkge1xuICAgICAgX2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbihcImNvbnRyYXN0XCIsIHBnLCBjYWNoZSwgX0NNRmRlZmF1bHRzKTtcbiAgICB9XG5cbiAgICBpZiAoY2FjaGUuaHVlKSB7XG4gICAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwiaHVlXCIsIHBnLCBjYWNoZSwgX0NNRmRlZmF1bHRzKTtcbiAgICB9XG5cbiAgICBpZiAoY2FjaGUuYnJpZ2h0bmVzcyAhPT0gMSkge1xuICAgICAgX2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbihcImJyaWdodG5lc3NcIiwgcGcsIGNhY2hlLCBfQ01GZGVmYXVsdHMpO1xuICAgIH1cblxuICAgIGlmIChjYWNoZS5jb2xvcml6ZUFtb3VudCkge1xuICAgICAgX2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbihcImNvbG9yaXplXCIsIHBnLCBjYWNoZSwgX0NNRmRlZmF1bHRzKTtcblxuICAgICAgX2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbihcImNvbG9yaXplQW1vdW50XCIsIHBnLCBjYWNoZSwgX0NNRmRlZmF1bHRzKTtcbiAgICB9XG5cbiAgICBpZiAoY2FjaGUuc2F0dXJhdGlvbiAhPT0gMSkge1xuICAgICAgX2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbihcInNhdHVyYXRpb25cIiwgcGcsIGNhY2hlLCBfQ01GZGVmYXVsdHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXRyaXggPSBfaWRNYXRyaXguc2xpY2UoKTtcblxuICAgIGlmICh2LmNvbnRyYXN0ICE9IG51bGwpIHtcbiAgICAgIG1hdHJpeCA9IF9zZXRDb250cmFzdChtYXRyaXgsICt2LmNvbnRyYXN0KTtcblxuICAgICAgX2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbihcImNvbnRyYXN0XCIsIHBnLCBjYWNoZSwgdik7XG4gICAgfSBlbHNlIGlmIChjYWNoZS5jb250cmFzdCAhPT0gMSkge1xuICAgICAgaWYgKGNvbWJpbmUpIHtcbiAgICAgICAgbWF0cml4ID0gX3NldENvbnRyYXN0KG1hdHJpeCwgY2FjaGUuY29udHJhc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbihcImNvbnRyYXN0XCIsIHBnLCBjYWNoZSwgX0NNRmRlZmF1bHRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodi5odWUgIT0gbnVsbCkge1xuICAgICAgbWF0cml4ID0gX3NldEh1ZShtYXRyaXgsICt2Lmh1ZSk7XG5cbiAgICAgIF9hZGRDb2xvck1hdHJpeEZpbHRlckNhY2hlVHdlZW4oXCJodWVcIiwgcGcsIGNhY2hlLCB2KTtcbiAgICB9IGVsc2UgaWYgKGNhY2hlLmh1ZSkge1xuICAgICAgaWYgKGNvbWJpbmUpIHtcbiAgICAgICAgbWF0cml4ID0gX3NldEh1ZShtYXRyaXgsIGNhY2hlLmh1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwiaHVlXCIsIHBnLCBjYWNoZSwgX0NNRmRlZmF1bHRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodi5icmlnaHRuZXNzICE9IG51bGwpIHtcbiAgICAgIG1hdHJpeCA9IF9hcHBseUJyaWdodG5lc3NUb01hdHJpeCgrdi5icmlnaHRuZXNzLCBtYXRyaXgpO1xuXG4gICAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwiYnJpZ2h0bmVzc1wiLCBwZywgY2FjaGUsIHYpO1xuICAgIH0gZWxzZSBpZiAoY2FjaGUuYnJpZ2h0bmVzcyAhPT0gMSkge1xuICAgICAgaWYgKGNvbWJpbmUpIHtcbiAgICAgICAgbWF0cml4ID0gX2FwcGx5QnJpZ2h0bmVzc1RvTWF0cml4KGNhY2hlLmJyaWdodG5lc3MsIG1hdHJpeCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwiYnJpZ2h0bmVzc1wiLCBwZywgY2FjaGUsIF9DTUZkZWZhdWx0cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHYuY29sb3JpemUgIT0gbnVsbCkge1xuICAgICAgdi5jb2xvcml6ZUFtb3VudCA9IFwiY29sb3JpemVBbW91bnRcIiBpbiB2ID8gK3YuY29sb3JpemVBbW91bnQgOiAxO1xuICAgICAgbWF0cml4ID0gX2NvbG9yaXplKG1hdHJpeCwgdi5jb2xvcml6ZSwgdi5jb2xvcml6ZUFtb3VudCk7XG5cbiAgICAgIF9hZGRDb2xvck1hdHJpeEZpbHRlckNhY2hlVHdlZW4oXCJjb2xvcml6ZVwiLCBwZywgY2FjaGUsIHYpO1xuXG4gICAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwiY29sb3JpemVBbW91bnRcIiwgcGcsIGNhY2hlLCB2KTtcbiAgICB9IGVsc2UgaWYgKGNhY2hlLmNvbG9yaXplQW1vdW50KSB7XG4gICAgICBpZiAoY29tYmluZSkge1xuICAgICAgICBtYXRyaXggPSBfY29sb3JpemUobWF0cml4LCBjYWNoZS5jb2xvcml6ZSwgY2FjaGUuY29sb3JpemVBbW91bnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbihcImNvbG9yaXplXCIsIHBnLCBjYWNoZSwgX0NNRmRlZmF1bHRzKTtcblxuICAgICAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwiY29sb3JpemVBbW91bnRcIiwgcGcsIGNhY2hlLCBfQ01GZGVmYXVsdHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh2LnNhdHVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgbWF0cml4ID0gX3NldFNhdHVyYXRpb24obWF0cml4LCArdi5zYXR1cmF0aW9uKTtcblxuICAgICAgX2FkZENvbG9yTWF0cml4RmlsdGVyQ2FjaGVUd2VlbihcInNhdHVyYXRpb25cIiwgcGcsIGNhY2hlLCB2KTtcbiAgICB9IGVsc2UgaWYgKGNhY2hlLnNhdHVyYXRpb24gIT09IDEpIHtcbiAgICAgIGlmIChjb21iaW5lKSB7XG4gICAgICAgIG1hdHJpeCA9IF9zZXRTYXR1cmF0aW9uKG1hdHJpeCwgY2FjaGUuc2F0dXJhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkQ29sb3JNYXRyaXhGaWx0ZXJDYWNoZVR3ZWVuKFwic2F0dXJhdGlvblwiLCBwZywgY2FjaGUsIF9DTUZkZWZhdWx0cyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaSA9IG1hdHJpeC5sZW5ndGg7XG5cbiAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgaWYgKG1hdHJpeFtpXSAhPT0gc3RhcnRNYXRyaXhbaV0pIHtcbiAgICAgIHBnLmFkZChzdGFydE1hdHJpeCwgaSwgc3RhcnRNYXRyaXhbaV0sIG1hdHJpeFtpXSwgXCJjb2xvck1hdHJpeEZpbHRlclwiKTtcbiAgICB9XG4gIH1cblxuICBwZy5fcHJvcHMucHVzaChcImNvbG9yTWF0cml4RmlsdGVyXCIpO1xufSxcbiAgICBfcmVuZGVyQ29sb3IgPSBmdW5jdGlvbiBfcmVuZGVyQ29sb3IocmF0aW8sIF9yZWYpIHtcbiAgdmFyIHQgPSBfcmVmLnQsXG4gICAgICBwID0gX3JlZi5wLFxuICAgICAgY29sb3IgPSBfcmVmLmNvbG9yLFxuICAgICAgc2V0ID0gX3JlZi5zZXQ7XG4gIHNldCh0LCBwLCBjb2xvclswXSA8PCAxNiB8IGNvbG9yWzFdIDw8IDggfCBjb2xvclsyXSk7XG59LFxuICAgIF9yZW5kZXJEaXJ0eUNhY2hlID0gZnVuY3Rpb24gX3JlbmRlckRpcnR5Q2FjaGUocmF0aW8sIF9yZWYyKSB7XG4gIHZhciBnID0gX3JlZjIuZztcblxuICBpZiAoZykge1xuICAgIC8vaW4gb3JkZXIgZm9yIFBpeGlKUyB0byBhY3R1YWxseSByZWRyYXcgR3JhcGhpY3NEYXRhLCB3ZSd2ZSBnb3R0YSBpbmNyZW1lbnQgdGhlIFwiZGlydHlcIiBhbmQgXCJjbGVhckRpcnR5XCIgdmFsdWVzLiBJZiB3ZSBkb24ndCBkbyB0aGlzLCB0aGUgdmFsdWVzIHdpbGwgYmUgdHdlZW4gcHJvcGVybHksIGJ1dCBub3QgcmVuZGVyZWQuXG4gICAgZy5kaXJ0eSsrO1xuICAgIGcuY2xlYXJEaXJ0eSsrO1xuICB9XG59LFxuICAgIF9yZW5kZXJBdXRvQWxwaGEgPSBmdW5jdGlvbiBfcmVuZGVyQXV0b0FscGhhKHJhdGlvLCBkYXRhKSB7XG4gIGRhdGEudC52aXNpYmxlID0gISFkYXRhLnQuYWxwaGE7XG59LFxuICAgIF9hZGRDb2xvclR3ZWVuID0gZnVuY3Rpb24gX2FkZENvbG9yVHdlZW4odGFyZ2V0LCBwLCB2YWx1ZSwgcGx1Z2luKSB7XG4gIHZhciBjdXJyZW50VmFsdWUgPSB0YXJnZXRbcF0sXG4gICAgICBzdGFydENvbG9yID0gX3NwbGl0Q29sb3IoX2lzRnVuY3Rpb24oY3VycmVudFZhbHVlKSA/IHRhcmdldFtwLmluZGV4T2YoXCJzZXRcIikgfHwgIV9pc0Z1bmN0aW9uKHRhcmdldFtcImdldFwiICsgcC5zdWJzdHIoMyldKSA/IHAgOiBcImdldFwiICsgcC5zdWJzdHIoMyldKCkgOiBjdXJyZW50VmFsdWUpLFxuICAgICAgZW5kQ29sb3IgPSBfc3BsaXRDb2xvcih2YWx1ZSk7XG5cbiAgcGx1Z2luLl9wdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgdGFyZ2V0LCBwLCAwLCAwLCBfcmVuZGVyQ29sb3IsIHtcbiAgICB0OiB0YXJnZXQsXG4gICAgcDogcCxcbiAgICBjb2xvcjogc3RhcnRDb2xvcixcbiAgICBzZXQ6IF9nZXRTZXR0ZXIodGFyZ2V0LCBwKVxuICB9KTtcbiAgcGx1Z2luLmFkZChzdGFydENvbG9yLCAwLCBzdGFydENvbG9yWzBdLCBlbmRDb2xvclswXSk7XG4gIHBsdWdpbi5hZGQoc3RhcnRDb2xvciwgMSwgc3RhcnRDb2xvclsxXSwgZW5kQ29sb3JbMV0pO1xuICBwbHVnaW4uYWRkKHN0YXJ0Q29sb3IsIDIsIHN0YXJ0Q29sb3JbMl0sIGVuZENvbG9yWzJdKTtcbn0sXG4gICAgX2NvbG9yUHJvcHMgPSB7XG4gIHRpbnQ6IDEsXG4gIGxpbmVDb2xvcjogMSxcbiAgZmlsbENvbG9yOiAxXG59LFxuICAgIF94eUNvbnRleHRzID0gXCJwb3NpdGlvbixzY2FsZSxza2V3LHBpdm90LGFuY2hvcix0aWxlUG9zaXRpb24sdGlsZVNjYWxlXCIuc3BsaXQoXCIsXCIpLFxuICAgIF9jb250ZXh0cyA9IHtcbiAgeDogXCJwb3NpdGlvblwiLFxuICB5OiBcInBvc2l0aW9uXCIsXG4gIHRpbGVYOiBcInRpbGVQb3NpdGlvblwiLFxuICB0aWxlWTogXCJ0aWxlUG9zaXRpb25cIlxufSxcbiAgICBfY29sb3JNYXRyaXhGaWx0ZXJQcm9wcyA9IHtcbiAgY29sb3JNYXRyaXhGaWx0ZXI6IDEsXG4gIHNhdHVyYXRpb246IDEsXG4gIGNvbnRyYXN0OiAxLFxuICBodWU6IDEsXG4gIGNvbG9yaXplOiAxLFxuICBjb2xvcml6ZUFtb3VudDogMSxcbiAgYnJpZ2h0bmVzczogMSxcbiAgY29tYmluZUNNRjogMVxufSxcbiAgICBfREVHMlJBRCA9IE1hdGguUEkgLyAxODAsXG4gICAgX2lzU3RyaW5nID0gZnVuY3Rpb24gX2lzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCI7XG59LFxuICAgIF9kZWdyZWVzVG9SYWRpYW5zID0gZnVuY3Rpb24gX2RlZ3JlZXNUb1JhZGlhbnModmFsdWUpIHtcbiAgcmV0dXJuIF9pc1N0cmluZyh2YWx1ZSkgJiYgdmFsdWUuY2hhckF0KDEpID09PSBcIj1cIiA/IHZhbHVlLnN1YnN0cigwLCAyKSArIHBhcnNlRmxvYXQodmFsdWUuc3Vic3RyKDIpKSAqIF9ERUcyUkFEIDogdmFsdWUgKiBfREVHMlJBRDtcbn0sXG4gICAgX3JlbmRlclByb3BXaXRoRW5kID0gZnVuY3Rpb24gX3JlbmRlclByb3BXaXRoRW5kKHJhdGlvLCBkYXRhKSB7XG4gIHJldHVybiBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgcmF0aW8gPT09IDEgPyBkYXRhLmUgOiBNYXRoLnJvdW5kKChkYXRhLnMgKyBkYXRhLmMgKiByYXRpbykgKiAxMDAwMDApIC8gMTAwMDAwLCBkYXRhKTtcbn0sXG4gICAgX2FkZFJvdGF0aW9uYWxQcm9wVHdlZW4gPSBmdW5jdGlvbiBfYWRkUm90YXRpb25hbFByb3BUd2VlbihwbHVnaW4sIHRhcmdldCwgcHJvcGVydHksIHN0YXJ0TnVtLCBlbmRWYWx1ZSwgcmFkaWFucykge1xuICB2YXIgY2FwID0gMzYwICogKHJhZGlhbnMgPyBfREVHMlJBRCA6IDEpLFxuICAgICAgaXNTdHJpbmcgPSBfaXNTdHJpbmcoZW5kVmFsdWUpLFxuICAgICAgcmVsYXRpdmUgPSBpc1N0cmluZyAmJiBlbmRWYWx1ZS5jaGFyQXQoMSkgPT09IFwiPVwiID8gKyhlbmRWYWx1ZS5jaGFyQXQoMCkgKyBcIjFcIikgOiAwLFxuICAgICAgZW5kTnVtID0gcGFyc2VGbG9hdChyZWxhdGl2ZSA/IGVuZFZhbHVlLnN1YnN0cigyKSA6IGVuZFZhbHVlKSAqIChyYWRpYW5zID8gX0RFRzJSQUQgOiAxKSxcbiAgICAgIGNoYW5nZSA9IHJlbGF0aXZlID8gZW5kTnVtICogcmVsYXRpdmUgOiBlbmROdW0gLSBzdGFydE51bSxcbiAgICAgIGZpbmFsVmFsdWUgPSBzdGFydE51bSArIGNoYW5nZSxcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIHB0O1xuXG4gIGlmIChpc1N0cmluZykge1xuICAgIGRpcmVjdGlvbiA9IGVuZFZhbHVlLnNwbGl0KFwiX1wiKVsxXTtcblxuICAgIGlmIChkaXJlY3Rpb24gPT09IFwic2hvcnRcIikge1xuICAgICAgY2hhbmdlICU9IGNhcDtcblxuICAgICAgaWYgKGNoYW5nZSAhPT0gY2hhbmdlICUgKGNhcCAvIDIpKSB7XG4gICAgICAgIGNoYW5nZSArPSBjaGFuZ2UgPCAwID8gY2FwIDogLWNhcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGlyZWN0aW9uID09PSBcImN3XCIgJiYgY2hhbmdlIDwgMCkge1xuICAgICAgY2hhbmdlID0gKGNoYW5nZSArIGNhcCAqIDFlMTApICUgY2FwIC0gfn4oY2hhbmdlIC8gY2FwKSAqIGNhcDtcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gXCJjY3dcIiAmJiBjaGFuZ2UgPiAwKSB7XG4gICAgICBjaGFuZ2UgPSAoY2hhbmdlIC0gY2FwICogMWUxMCkgJSBjYXAgLSB+fihjaGFuZ2UgLyBjYXApICogY2FwO1xuICAgIH1cbiAgfVxuXG4gIHBsdWdpbi5fcHQgPSBwdCA9IG5ldyBQcm9wVHdlZW4ocGx1Z2luLl9wdCwgdGFyZ2V0LCBwcm9wZXJ0eSwgc3RhcnROdW0sIGNoYW5nZSwgX3JlbmRlclByb3BXaXRoRW5kKTtcbiAgcHQuZSA9IGZpbmFsVmFsdWU7XG4gIHJldHVybiBwdDtcbn0sXG4gICAgX2luaXRDb3JlID0gZnVuY3Rpb24gX2luaXRDb3JlKCkge1xuICBpZiAoX3dpbmRvd0V4aXN0cygpKSB7XG4gICAgX3dpbiA9IHdpbmRvdztcbiAgICBnc2FwID0gX2dldEdTQVAoKTtcbiAgICBfUElYSSA9IF9jb3JlSW5pdHRlZCA9IF9QSVhJIHx8IF93aW4uUElYSTtcbiAgICBfaXNWNCA9IF9QSVhJICYmIF9QSVhJLlZFUlNJT04gJiYgX1BJWEkuVkVSU0lPTi5jaGFyQXQoMCkgPT09IFwiNFwiO1xuXG4gICAgX3NwbGl0Q29sb3IgPSBmdW5jdGlvbiBfc3BsaXRDb2xvcihjb2xvcikge1xuICAgICAgcmV0dXJuIGdzYXAudXRpbHMuc3BsaXRDb2xvcigoY29sb3IgKyBcIlwiKS5zdWJzdHIoMCwgMikgPT09IFwiMHhcIiA/IFwiI1wiICsgY29sb3Iuc3Vic3RyKDIpIDogY29sb3IpO1xuICAgIH07IC8vIHNvbWUgY29sb3JzIGluIFBJWEkgYXJlIHJlcG9ydGVkIGFzIFwiMHhGRjQ0MjFcIiBpbnN0ZWFkIG9mIFwiI0ZGNDQyMVwiLlxuXG4gIH1cbn0sXG4gICAgaSxcbiAgICBwOyAvL2NvbnRleHQgc2V0dXAuLi5cblxuXG5mb3IgKGkgPSAwOyBpIDwgX3h5Q29udGV4dHMubGVuZ3RoOyBpKyspIHtcbiAgcCA9IF94eUNvbnRleHRzW2ldO1xuICBfY29udGV4dHNbcCArIFwiWFwiXSA9IHA7XG4gIF9jb250ZXh0c1twICsgXCJZXCJdID0gcDtcbn1cblxuZXhwb3J0IHZhciBQaXhpUGx1Z2luID0ge1xuICB2ZXJzaW9uOiBcIjMuOS4xXCIsXG4gIG5hbWU6IFwicGl4aVwiLFxuICByZWdpc3RlcjogZnVuY3Rpb24gcmVnaXN0ZXIoY29yZSwgUGx1Z2luLCBwcm9wVHdlZW4pIHtcbiAgICBnc2FwID0gY29yZTtcbiAgICBQcm9wVHdlZW4gPSBwcm9wVHdlZW47XG4gICAgX2dldFNldHRlciA9IFBsdWdpbi5nZXRTZXR0ZXI7XG5cbiAgICBfaW5pdENvcmUoKTtcbiAgfSxcbiAgcmVnaXN0ZXJQSVhJOiBmdW5jdGlvbiByZWdpc3RlclBJWEkocGl4aSkge1xuICAgIF9QSVhJID0gcGl4aTtcbiAgfSxcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCh0YXJnZXQsIHZhbHVlcywgdHdlZW4sIGluZGV4LCB0YXJnZXRzKSB7XG4gICAgX1BJWEkgfHwgX2luaXRDb3JlKCk7XG5cbiAgICBpZiAoIV9QSVhJIHx8ICEodGFyZ2V0IGluc3RhbmNlb2YgX1BJWEkuRGlzcGxheU9iamVjdCkpIHtcbiAgICAgIGNvbnNvbGUud2Fybih0YXJnZXQsIFwiaXMgbm90IGEgRGlzcGxheU9iamVjdCBvciBQSVhJIHdhcyBub3QgZm91bmQuIFBpeGlQbHVnaW4ucmVnaXN0ZXJQSVhJKFBJWEkpO1wiKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY29udGV4dCwgYXhpcywgdmFsdWUsIGNvbG9yTWF0cml4LCBmaWx0ZXIsIHAsIHBhZGRpbmcsIGksIGRhdGE7XG5cbiAgICBmb3IgKHAgaW4gdmFsdWVzKSB7XG4gICAgICBjb250ZXh0ID0gX2NvbnRleHRzW3BdO1xuICAgICAgdmFsdWUgPSB2YWx1ZXNbcF07XG5cbiAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgIGF4aXMgPSB+cC5jaGFyQXQocC5sZW5ndGggLSAxKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJ4XCIpID8gXCJ4XCIgOiBcInlcIjtcbiAgICAgICAgdGhpcy5hZGQodGFyZ2V0W2NvbnRleHRdLCBheGlzLCB0YXJnZXRbY29udGV4dF1bYXhpc10sIGNvbnRleHQgPT09IFwic2tld1wiID8gX2RlZ3JlZXNUb1JhZGlhbnModmFsdWUpIDogdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChwID09PSBcInNjYWxlXCIgfHwgcCA9PT0gXCJhbmNob3JcIiB8fCBwID09PSBcInBpdm90XCIgfHwgcCA9PT0gXCJ0aWxlU2NhbGVcIikge1xuICAgICAgICB0aGlzLmFkZCh0YXJnZXRbcF0sIFwieFwiLCB0YXJnZXRbcF0ueCwgdmFsdWUpO1xuICAgICAgICB0aGlzLmFkZCh0YXJnZXRbcF0sIFwieVwiLCB0YXJnZXRbcF0ueSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChwID09PSBcInJvdGF0aW9uXCIgfHwgcCA9PT0gXCJhbmdsZVwiKSB7XG4gICAgICAgIC8vUElYSSBleHBlY3RzIHJvdGF0aW9uIGluIHJhZGlhbnMsIGJ1dCBhcyBhIGNvbnZlbmllbmNlIHdlIGxldCBmb2xrcyBkZWZpbmUgaXQgaW4gZGVncmVlcyBhbmQgd2UgZG8gdGhlIGNvbnZlcnNpb24uXG4gICAgICAgIF9hZGRSb3RhdGlvbmFsUHJvcFR3ZWVuKHRoaXMsIHRhcmdldCwgcCwgdGFyZ2V0W3BdLCB2YWx1ZSwgcCA9PT0gXCJyb3RhdGlvblwiKTtcbiAgICAgIH0gZWxzZSBpZiAoX2NvbG9yTWF0cml4RmlsdGVyUHJvcHNbcF0pIHtcbiAgICAgICAgaWYgKCFjb2xvck1hdHJpeCkge1xuICAgICAgICAgIF9wYXJzZUNvbG9yTWF0cml4RmlsdGVyKHRhcmdldCwgdmFsdWVzLmNvbG9yTWF0cml4RmlsdGVyIHx8IHZhbHVlcywgdGhpcyk7XG5cbiAgICAgICAgICBjb2xvck1hdHJpeCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocCA9PT0gXCJibHVyXCIgfHwgcCA9PT0gXCJibHVyWFwiIHx8IHAgPT09IFwiYmx1cllcIiB8fCBwID09PSBcImJsdXJQYWRkaW5nXCIpIHtcbiAgICAgICAgZmlsdGVyID0gX2dldEZpbHRlcih0YXJnZXQsIFwiQmx1ckZpbHRlclwiKTtcbiAgICAgICAgdGhpcy5hZGQoZmlsdGVyLCBwLCBmaWx0ZXJbcF0sIHZhbHVlKTtcblxuICAgICAgICBpZiAodmFsdWVzLmJsdXJQYWRkaW5nICE9PSAwKSB7XG4gICAgICAgICAgcGFkZGluZyA9IHZhbHVlcy5ibHVyUGFkZGluZyB8fCBNYXRoLm1heChmaWx0ZXJbcF0sIHZhbHVlKSAqIDI7XG4gICAgICAgICAgaSA9IHRhcmdldC5maWx0ZXJzLmxlbmd0aDtcblxuICAgICAgICAgIHdoaWxlICgtLWkgPiAtMSkge1xuICAgICAgICAgICAgdGFyZ2V0LmZpbHRlcnNbaV0ucGFkZGluZyA9IE1hdGgubWF4KHRhcmdldC5maWx0ZXJzW2ldLnBhZGRpbmcsIHBhZGRpbmcpOyAvL2lmIHdlIGRvbid0IGV4cGFuZCB0aGUgcGFkZGluZyBvbiBhbGwgdGhlIGZpbHRlcnMsIGl0IGNhbiBsb29rIGNsaXBwZWQuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKF9jb2xvclByb3BzW3BdKSB7XG4gICAgICAgIGlmICgocCA9PT0gXCJsaW5lQ29sb3JcIiB8fCBwID09PSBcImZpbGxDb2xvclwiKSAmJiB0YXJnZXQgaW5zdGFuY2VvZiBfUElYSS5HcmFwaGljcykge1xuICAgICAgICAgIGRhdGEgPSAodGFyZ2V0Lmdlb21ldHJ5IHx8IHRhcmdldCkuZ3JhcGhpY3NEYXRhOyAvL1wiZ2VvbWV0cnlcIiB3YXMgaW50cm9kdWNlZCBpbiBQSVhJIHZlcnNpb24gNVxuXG4gICAgICAgICAgdGhpcy5fcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCB0YXJnZXQsIHAsIDAsIDAsIF9yZW5kZXJEaXJ0eUNhY2hlLCB7XG4gICAgICAgICAgICBnOiB0YXJnZXQuZ2VvbWV0cnkgfHwgdGFyZ2V0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaSA9IGRhdGEubGVuZ3RoO1xuXG4gICAgICAgICAgd2hpbGUgKC0taSA+IC0xKSB7XG4gICAgICAgICAgICBfYWRkQ29sb3JUd2VlbihfaXNWNCA/IGRhdGFbaV0gOiBkYXRhW2ldW3Auc3Vic3RyKDAsIDQpICsgXCJTdHlsZVwiXSwgX2lzVjQgPyBwIDogXCJjb2xvclwiLCB2YWx1ZSwgdGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9hZGRDb2xvclR3ZWVuKHRhcmdldCwgcCwgdmFsdWUsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHAgPT09IFwiYXV0b0FscGhhXCIpIHtcbiAgICAgICAgdGhpcy5fcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCB0YXJnZXQsIFwidmlzaWJsZVwiLCAwLCAwLCBfcmVuZGVyQXV0b0FscGhhKTtcbiAgICAgICAgdGhpcy5hZGQodGFyZ2V0LCBcImFscGhhXCIsIHRhcmdldC5hbHBoYSwgdmFsdWUpO1xuXG4gICAgICAgIHRoaXMuX3Byb3BzLnB1c2goXCJhbHBoYVwiLCBcInZpc2libGVcIik7XG4gICAgICB9IGVsc2UgaWYgKHAgIT09IFwicmVzb2x1dGlvblwiKSB7XG4gICAgICAgIHRoaXMuYWRkKHRhcmdldCwgcCwgXCJnZXRcIiwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9wcm9wcy5wdXNoKHApO1xuICAgIH1cbiAgfVxufTtcbl9nZXRHU0FQKCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbihQaXhpUGx1Z2luKTtcbmV4cG9ydCB7IFBpeGlQbHVnaW4gYXMgZGVmYXVsdCB9OyIsIi8qIVxuICogU2Nyb2xsVG9QbHVnaW4gMy45LjFcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAyMDA4LTIwMjEsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG52YXIgZ3NhcCxcbiAgICBfY29yZUluaXR0ZWQsXG4gICAgX3dpbmRvdyxcbiAgICBfZG9jRWwsXG4gICAgX2JvZHksXG4gICAgX3RvQXJyYXksXG4gICAgX2NvbmZpZyxcbiAgICBfd2luZG93RXhpc3RzID0gZnVuY3Rpb24gX3dpbmRvd0V4aXN0cygpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG59LFxuICAgIF9nZXRHU0FQID0gZnVuY3Rpb24gX2dldEdTQVAoKSB7XG4gIHJldHVybiBnc2FwIHx8IF93aW5kb3dFeGlzdHMoKSAmJiAoZ3NhcCA9IHdpbmRvdy5nc2FwKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luICYmIGdzYXA7XG59LFxuICAgIF9pc1N0cmluZyA9IGZ1bmN0aW9uIF9pc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xufSxcbiAgICBfaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIF9pc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcbn0sXG4gICAgX21heCA9IGZ1bmN0aW9uIF9tYXgoZWxlbWVudCwgYXhpcykge1xuICB2YXIgZGltID0gYXhpcyA9PT0gXCJ4XCIgPyBcIldpZHRoXCIgOiBcIkhlaWdodFwiLFxuICAgICAgc2Nyb2xsID0gXCJzY3JvbGxcIiArIGRpbSxcbiAgICAgIGNsaWVudCA9IFwiY2xpZW50XCIgKyBkaW07XG4gIHJldHVybiBlbGVtZW50ID09PSBfd2luZG93IHx8IGVsZW1lbnQgPT09IF9kb2NFbCB8fCBlbGVtZW50ID09PSBfYm9keSA/IE1hdGgubWF4KF9kb2NFbFtzY3JvbGxdLCBfYm9keVtzY3JvbGxdKSAtIChfd2luZG93W1wiaW5uZXJcIiArIGRpbV0gfHwgX2RvY0VsW2NsaWVudF0gfHwgX2JvZHlbY2xpZW50XSkgOiBlbGVtZW50W3Njcm9sbF0gLSBlbGVtZW50W1wib2Zmc2V0XCIgKyBkaW1dO1xufSxcbiAgICBfYnVpbGRHZXR0ZXIgPSBmdW5jdGlvbiBfYnVpbGRHZXR0ZXIoZSwgYXhpcykge1xuICAvL3Bhc3MgaW4gYW4gZWxlbWVudCBhbmQgYW4gYXhpcyAoXCJ4XCIgb3IgXCJ5XCIpIGFuZCBpdCdsbCByZXR1cm4gYSBnZXR0ZXIgZnVuY3Rpb24gZm9yIHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhhdCBlbGVtZW50IChsaWtlIHNjcm9sbFRvcCBvciBzY3JvbGxMZWZ0LCBhbHRob3VnaCBpZiB0aGUgZWxlbWVudCBpcyB0aGUgd2luZG93LCBpdCdsbCB1c2UgdGhlIHBhZ2VYT2Zmc2V0L3BhZ2VZT2Zmc2V0IG9yIHRoZSBkb2N1bWVudEVsZW1lbnQncyBzY3JvbGxUb3Avc2Nyb2xsTGVmdCBvciBkb2N1bWVudC5ib2R5J3MuIEJhc2ljYWxseSB0aGlzIHN0cmVhbWxpbmVzIHRoaW5ncyBhbmQgbWFrZXMgYSB2ZXJ5IGZhc3QgZ2V0dGVyIGFjcm9zcyBicm93c2Vycy5cbiAgdmFyIHAgPSBcInNjcm9sbFwiICsgKGF4aXMgPT09IFwieFwiID8gXCJMZWZ0XCIgOiBcIlRvcFwiKTtcblxuICBpZiAoZSA9PT0gX3dpbmRvdykge1xuICAgIGlmIChlLnBhZ2VYT2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgIHAgPSBcInBhZ2VcIiArIGF4aXMudG9VcHBlckNhc2UoKSArIFwiT2Zmc2V0XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGUgPSBfZG9jRWxbcF0gIT0gbnVsbCA/IF9kb2NFbCA6IF9ib2R5O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGVbcF07XG4gIH07XG59LFxuICAgIF9jbGVhbiA9IGZ1bmN0aW9uIF9jbGVhbih2YWx1ZSwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cykge1xuICBfaXNGdW5jdGlvbih2YWx1ZSkgJiYgKHZhbHVlID0gdmFsdWUoaW5kZXgsIHRhcmdldCwgdGFyZ2V0cykpO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gX2lzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZSAhPT0gXCJtYXhcIiAmJiB2YWx1ZS5jaGFyQXQoMSkgIT09IFwiPVwiID8ge1xuICAgICAgeDogdmFsdWUsXG4gICAgICB5OiB2YWx1ZVxuICAgIH0gOiB7XG4gICAgICB5OiB2YWx1ZVxuICAgIH07IC8vaWYgd2UgZG9uJ3QgcmVjZWl2ZSBhbiBvYmplY3QgYXMgdGhlIHBhcmFtZXRlciwgYXNzdW1lIHRoZSB1c2VyIGludGVuZHMgXCJ5XCIuXG4gIH0gZWxzZSBpZiAodmFsdWUubm9kZVR5cGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeTogdmFsdWUsXG4gICAgICB4OiB2YWx1ZVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9LFxuICAgICAgICBwO1xuXG4gICAgZm9yIChwIGluIHZhbHVlKSB7XG4gICAgICByZXN1bHRbcF0gPSBwICE9PSBcIm9uQXV0b0tpbGxcIiAmJiBfaXNGdW5jdGlvbih2YWx1ZVtwXSkgPyB2YWx1ZVtwXShpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKSA6IHZhbHVlW3BdO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0sXG4gICAgX2dldE9mZnNldCA9IGZ1bmN0aW9uIF9nZXRPZmZzZXQoZWxlbWVudCwgY29udGFpbmVyKSB7XG4gIGVsZW1lbnQgPSBfdG9BcnJheShlbGVtZW50KVswXTtcblxuICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSB7XG4gICAgcmV0dXJuIGNvbnNvbGUud2FybihcInNjcm9sbFRvIHRhcmdldCBkb2Vzbid0IGV4aXN0LiBVc2luZyAwXCIpIHx8IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgfVxuXG4gIHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIGlzUm9vdCA9ICFjb250YWluZXIgfHwgY29udGFpbmVyID09PSBfd2luZG93IHx8IGNvbnRhaW5lciA9PT0gX2JvZHksXG4gICAgICBjUmVjdCA9IGlzUm9vdCA/IHtcbiAgICB0b3A6IF9kb2NFbC5jbGllbnRUb3AgLSAoX3dpbmRvdy5wYWdlWU9mZnNldCB8fCBfZG9jRWwuc2Nyb2xsVG9wIHx8IF9ib2R5LnNjcm9sbFRvcCB8fCAwKSxcbiAgICBsZWZ0OiBfZG9jRWwuY2xpZW50TGVmdCAtIChfd2luZG93LnBhZ2VYT2Zmc2V0IHx8IF9kb2NFbC5zY3JvbGxMZWZ0IHx8IF9ib2R5LnNjcm9sbExlZnQgfHwgMClcbiAgfSA6IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgeDogcmVjdC5sZWZ0IC0gY1JlY3QubGVmdCxcbiAgICB5OiByZWN0LnRvcCAtIGNSZWN0LnRvcFxuICB9O1xuXG4gIGlmICghaXNSb290ICYmIGNvbnRhaW5lcikge1xuICAgIC8vb25seSBhZGQgdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIGlmIGl0J3Mgbm90IHRoZSB3aW5kb3cvYm9keS5cbiAgICBvZmZzZXRzLnggKz0gX2J1aWxkR2V0dGVyKGNvbnRhaW5lciwgXCJ4XCIpKCk7XG4gICAgb2Zmc2V0cy55ICs9IF9idWlsZEdldHRlcihjb250YWluZXIsIFwieVwiKSgpO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldHM7XG59LFxuICAgIF9wYXJzZVZhbCA9IGZ1bmN0aW9uIF9wYXJzZVZhbCh2YWx1ZSwgdGFyZ2V0LCBheGlzLCBjdXJyZW50VmFsLCBvZmZzZXQpIHtcbiAgcmV0dXJuICFpc05hTih2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiID8gcGFyc2VGbG9hdCh2YWx1ZSkgLSBvZmZzZXQgOiBfaXNTdHJpbmcodmFsdWUpICYmIHZhbHVlLmNoYXJBdCgxKSA9PT0gXCI9XCIgPyBwYXJzZUZsb2F0KHZhbHVlLnN1YnN0cigyKSkgKiAodmFsdWUuY2hhckF0KDApID09PSBcIi1cIiA/IC0xIDogMSkgKyBjdXJyZW50VmFsIC0gb2Zmc2V0IDogdmFsdWUgPT09IFwibWF4XCIgPyBfbWF4KHRhcmdldCwgYXhpcykgLSBvZmZzZXQgOiBNYXRoLm1pbihfbWF4KHRhcmdldCwgYXhpcyksIF9nZXRPZmZzZXQodmFsdWUsIHRhcmdldClbYXhpc10gLSBvZmZzZXQpO1xufSxcbiAgICBfaW5pdENvcmUgPSBmdW5jdGlvbiBfaW5pdENvcmUoKSB7XG4gIGdzYXAgPSBfZ2V0R1NBUCgpO1xuXG4gIGlmIChfd2luZG93RXhpc3RzKCkgJiYgZ3NhcCAmJiBkb2N1bWVudC5ib2R5KSB7XG4gICAgX3dpbmRvdyA9IHdpbmRvdztcbiAgICBfYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgX2RvY0VsID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIF90b0FycmF5ID0gZ3NhcC51dGlscy50b0FycmF5O1xuICAgIGdzYXAuY29uZmlnKHtcbiAgICAgIGF1dG9LaWxsVGhyZXNob2xkOiA3XG4gICAgfSk7XG4gICAgX2NvbmZpZyA9IGdzYXAuY29uZmlnKCk7XG4gICAgX2NvcmVJbml0dGVkID0gMTtcbiAgfVxufTtcblxuZXhwb3J0IHZhciBTY3JvbGxUb1BsdWdpbiA9IHtcbiAgdmVyc2lvbjogXCIzLjkuMVwiLFxuICBuYW1lOiBcInNjcm9sbFRvXCIsXG4gIHJhd1ZhcnM6IDEsXG4gIHJlZ2lzdGVyOiBmdW5jdGlvbiByZWdpc3Rlcihjb3JlKSB7XG4gICAgZ3NhcCA9IGNvcmU7XG5cbiAgICBfaW5pdENvcmUoKTtcbiAgfSxcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCh0YXJnZXQsIHZhbHVlLCB0d2VlbiwgaW5kZXgsIHRhcmdldHMpIHtcbiAgICBfY29yZUluaXR0ZWQgfHwgX2luaXRDb3JlKCk7XG4gICAgdmFyIGRhdGEgPSB0aGlzLFxuICAgICAgICBzbmFwVHlwZSA9IGdzYXAuZ2V0UHJvcGVydHkodGFyZ2V0LCBcInNjcm9sbFNuYXBUeXBlXCIpO1xuICAgIGRhdGEuaXNXaW4gPSB0YXJnZXQgPT09IF93aW5kb3c7XG4gICAgZGF0YS50YXJnZXQgPSB0YXJnZXQ7XG4gICAgZGF0YS50d2VlbiA9IHR3ZWVuO1xuICAgIHZhbHVlID0gX2NsZWFuKHZhbHVlLCBpbmRleCwgdGFyZ2V0LCB0YXJnZXRzKTtcbiAgICBkYXRhLnZhcnMgPSB2YWx1ZTtcbiAgICBkYXRhLmF1dG9LaWxsID0gISF2YWx1ZS5hdXRvS2lsbDtcbiAgICBkYXRhLmdldFggPSBfYnVpbGRHZXR0ZXIodGFyZ2V0LCBcInhcIik7XG4gICAgZGF0YS5nZXRZID0gX2J1aWxkR2V0dGVyKHRhcmdldCwgXCJ5XCIpO1xuICAgIGRhdGEueCA9IGRhdGEueFByZXYgPSBkYXRhLmdldFgoKTtcbiAgICBkYXRhLnkgPSBkYXRhLnlQcmV2ID0gZGF0YS5nZXRZKCk7XG5cbiAgICBpZiAoc25hcFR5cGUgJiYgc25hcFR5cGUgIT09IFwibm9uZVwiKSB7XG4gICAgICAvLyBkaXNhYmxlIHNjcm9sbCBzbmFwcGluZyB0byBhdm9pZCBzdHJhbmdlIGJlaGF2aW9yXG4gICAgICBkYXRhLnNuYXAgPSAxO1xuICAgICAgZGF0YS5zbmFwSW5saW5lID0gdGFyZ2V0LnN0eWxlLnNjcm9sbFNuYXBUeXBlO1xuICAgICAgdGFyZ2V0LnN0eWxlLnNjcm9sbFNuYXBUeXBlID0gXCJub25lXCI7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlLnggIT0gbnVsbCkge1xuICAgICAgZGF0YS5hZGQoZGF0YSwgXCJ4XCIsIGRhdGEueCwgX3BhcnNlVmFsKHZhbHVlLngsIHRhcmdldCwgXCJ4XCIsIGRhdGEueCwgdmFsdWUub2Zmc2V0WCB8fCAwKSwgaW5kZXgsIHRhcmdldHMpO1xuXG4gICAgICBkYXRhLl9wcm9wcy5wdXNoKFwic2Nyb2xsVG9feFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YS5za2lwWCA9IDE7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlLnkgIT0gbnVsbCkge1xuICAgICAgZGF0YS5hZGQoZGF0YSwgXCJ5XCIsIGRhdGEueSwgX3BhcnNlVmFsKHZhbHVlLnksIHRhcmdldCwgXCJ5XCIsIGRhdGEueSwgdmFsdWUub2Zmc2V0WSB8fCAwKSwgaW5kZXgsIHRhcmdldHMpO1xuXG4gICAgICBkYXRhLl9wcm9wcy5wdXNoKFwic2Nyb2xsVG9feVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YS5za2lwWSA9IDE7XG4gICAgfVxuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihyYXRpbywgZGF0YSkge1xuICAgIHZhciBwdCA9IGRhdGEuX3B0LFxuICAgICAgICB0YXJnZXQgPSBkYXRhLnRhcmdldCxcbiAgICAgICAgdHdlZW4gPSBkYXRhLnR3ZWVuLFxuICAgICAgICBhdXRvS2lsbCA9IGRhdGEuYXV0b0tpbGwsXG4gICAgICAgIHhQcmV2ID0gZGF0YS54UHJldixcbiAgICAgICAgeVByZXYgPSBkYXRhLnlQcmV2LFxuICAgICAgICBpc1dpbiA9IGRhdGEuaXNXaW4sXG4gICAgICAgIHNuYXAgPSBkYXRhLnNuYXAsXG4gICAgICAgIHNuYXBJbmxpbmUgPSBkYXRhLnNuYXBJbmxpbmUsXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHlEaWYsXG4gICAgICAgIHhEaWYsXG4gICAgICAgIHRocmVzaG9sZDtcblxuICAgIHdoaWxlIChwdCkge1xuICAgICAgcHQucihyYXRpbywgcHQuZCk7XG4gICAgICBwdCA9IHB0Ll9uZXh0O1xuICAgIH1cblxuICAgIHggPSBpc1dpbiB8fCAhZGF0YS5za2lwWCA/IGRhdGEuZ2V0WCgpIDogeFByZXY7XG4gICAgeSA9IGlzV2luIHx8ICFkYXRhLnNraXBZID8gZGF0YS5nZXRZKCkgOiB5UHJldjtcbiAgICB5RGlmID0geSAtIHlQcmV2O1xuICAgIHhEaWYgPSB4IC0geFByZXY7XG4gICAgdGhyZXNob2xkID0gX2NvbmZpZy5hdXRvS2lsbFRocmVzaG9sZDtcblxuICAgIGlmIChkYXRhLnggPCAwKSB7XG4gICAgICAvL2Nhbid0IHNjcm9sbCB0byBhIHBvc2l0aW9uIGxlc3MgdGhhbiAwISBNaWdodCBoYXBwZW4gaWYgc29tZW9uZSB1c2VzIGEgQmFjay5lYXNlT3V0IG9yIEVsYXN0aWMuZWFzZU91dCB3aGVuIHNjcm9sbGluZyBiYWNrIHRvIHRoZSB0b3Agb2YgdGhlIHBhZ2UgKGZvciBleGFtcGxlKVxuICAgICAgZGF0YS54ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS55IDwgMCkge1xuICAgICAgZGF0YS55ID0gMDtcbiAgICB9XG5cbiAgICBpZiAoYXV0b0tpbGwpIHtcbiAgICAgIC8vbm90ZTogaU9TIGhhcyBhIGJ1ZyB0aGF0IHRocm93cyBvZmYgdGhlIHNjcm9sbCBieSBzZXZlcmFsIHBpeGVscywgc28gd2UgbmVlZCB0byBjaGVjayBpZiBpdCdzIHdpdGhpbiA3IHBpeGVscyBvZiB0aGUgcHJldmlvdXMgb25lIHRoYXQgd2Ugc2V0IGluc3RlYWQgb2YganVzdCBsb29raW5nIGZvciBhbiBleGFjdCBtYXRjaC5cbiAgICAgIGlmICghZGF0YS5za2lwWCAmJiAoeERpZiA+IHRocmVzaG9sZCB8fCB4RGlmIDwgLXRocmVzaG9sZCkgJiYgeCA8IF9tYXgodGFyZ2V0LCBcInhcIikpIHtcbiAgICAgICAgZGF0YS5za2lwWCA9IDE7IC8vaWYgdGhlIHVzZXIgc2Nyb2xscyBzZXBhcmF0ZWx5LCB3ZSBzaG91bGQgc3RvcCB0d2VlbmluZyFcbiAgICAgIH1cblxuICAgICAgaWYgKCFkYXRhLnNraXBZICYmICh5RGlmID4gdGhyZXNob2xkIHx8IHlEaWYgPCAtdGhyZXNob2xkKSAmJiB5IDwgX21heCh0YXJnZXQsIFwieVwiKSkge1xuICAgICAgICBkYXRhLnNraXBZID0gMTsgLy9pZiB0aGUgdXNlciBzY3JvbGxzIHNlcGFyYXRlbHksIHdlIHNob3VsZCBzdG9wIHR3ZWVuaW5nIVxuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YS5za2lwWCAmJiBkYXRhLnNraXBZKSB7XG4gICAgICAgIHR3ZWVuLmtpbGwoKTtcbiAgICAgICAgZGF0YS52YXJzLm9uQXV0b0tpbGwgJiYgZGF0YS52YXJzLm9uQXV0b0tpbGwuYXBwbHkodHdlZW4sIGRhdGEudmFycy5vbkF1dG9LaWxsUGFyYW1zIHx8IFtdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNXaW4pIHtcbiAgICAgIF93aW5kb3cuc2Nyb2xsVG8oIWRhdGEuc2tpcFggPyBkYXRhLnggOiB4LCAhZGF0YS5za2lwWSA/IGRhdGEueSA6IHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhLnNraXBZIHx8ICh0YXJnZXQuc2Nyb2xsVG9wID0gZGF0YS55KTtcbiAgICAgIGRhdGEuc2tpcFggfHwgKHRhcmdldC5zY3JvbGxMZWZ0ID0gZGF0YS54KTtcbiAgICB9XG5cbiAgICBpZiAoc25hcCAmJiAocmF0aW8gPT09IDEgfHwgcmF0aW8gPT09IDApKSB7XG4gICAgICB5ID0gdGFyZ2V0LnNjcm9sbFRvcDtcbiAgICAgIHggPSB0YXJnZXQuc2Nyb2xsTGVmdDtcbiAgICAgIHNuYXBJbmxpbmUgPyB0YXJnZXQuc3R5bGUuc2Nyb2xsU25hcFR5cGUgPSBzbmFwSW5saW5lIDogdGFyZ2V0LnN0eWxlLnJlbW92ZVByb3BlcnR5KFwic2Nyb2xsLXNuYXAtdHlwZVwiKTtcbiAgICAgIHRhcmdldC5zY3JvbGxUb3AgPSB5ICsgMTsgLy8gYnVnIGluIFNhZmFyaSBjYXVzZXMgdGhlIGVsZW1lbnQgdG8gdG90YWxseSByZXNldCBpdHMgc2Nyb2xsIHBvc2l0aW9uIHdoZW4gc2Nyb2xsLXNuYXAtdHlwZSBjaGFuZ2VzLCBzbyB3ZSBuZWVkIHRvIHNldCBpdCB0byBhIHNsaWdodGx5IGRpZmZlcmVudCB2YWx1ZSBhbmQgdGhlbiBiYWNrIGFnYWluIHRvIHdvcmsgYXJvdW5kIHRoaXMgYnVnLlxuXG4gICAgICB0YXJnZXQuc2Nyb2xsTGVmdCA9IHggKyAxO1xuICAgICAgdGFyZ2V0LnNjcm9sbFRvcCA9IHk7XG4gICAgICB0YXJnZXQuc2Nyb2xsTGVmdCA9IHg7XG4gICAgfVxuXG4gICAgZGF0YS54UHJldiA9IGRhdGEueDtcbiAgICBkYXRhLnlQcmV2ID0gZGF0YS55O1xuICB9LFxuICBraWxsOiBmdW5jdGlvbiBraWxsKHByb3BlcnR5KSB7XG4gICAgdmFyIGJvdGggPSBwcm9wZXJ0eSA9PT0gXCJzY3JvbGxUb1wiO1xuXG4gICAgaWYgKGJvdGggfHwgcHJvcGVydHkgPT09IFwic2Nyb2xsVG9feFwiKSB7XG4gICAgICB0aGlzLnNraXBYID0gMTtcbiAgICB9XG5cbiAgICBpZiAoYm90aCB8fCBwcm9wZXJ0eSA9PT0gXCJzY3JvbGxUb195XCIpIHtcbiAgICAgIHRoaXMuc2tpcFkgPSAxO1xuICAgIH1cbiAgfVxufTtcblNjcm9sbFRvUGx1Z2luLm1heCA9IF9tYXg7XG5TY3JvbGxUb1BsdWdpbi5nZXRPZmZzZXQgPSBfZ2V0T2Zmc2V0O1xuU2Nyb2xsVG9QbHVnaW4uYnVpbGRHZXR0ZXIgPSBfYnVpbGRHZXR0ZXI7XG5fZ2V0R1NBUCgpICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4oU2Nyb2xsVG9QbHVnaW4pO1xuZXhwb3J0IHsgU2Nyb2xsVG9QbHVnaW4gYXMgZGVmYXVsdCB9OyIsIi8qIVxuICogU2Nyb2xsVHJpZ2dlciAzLjkuMVxuICogaHR0cHM6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMDgtMjAyMSwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbnZhciBnc2FwLFxuICAgIF9jb3JlSW5pdHRlZCxcbiAgICBfd2luLFxuICAgIF9kb2MsXG4gICAgX2RvY0VsLFxuICAgIF9ib2R5LFxuICAgIF9yb290LFxuICAgIF9yZXNpemVEZWxheSxcbiAgICBfdG9BcnJheSxcbiAgICBfY2xhbXAsXG4gICAgX3RpbWUyLFxuICAgIF9zeW5jSW50ZXJ2YWwsXG4gICAgX3JlZnJlc2hpbmcsXG4gICAgX3BvaW50ZXJJc0Rvd24sXG4gICAgX3RyYW5zZm9ybVByb3AsXG4gICAgX2ksXG4gICAgX3ByZXZXaWR0aCxcbiAgICBfcHJldkhlaWdodCxcbiAgICBfYXV0b1JlZnJlc2gsXG4gICAgX3NvcnQsXG4gICAgX3N1cHByZXNzT3ZlcndyaXRlcyxcbiAgICBfaWdub3JlUmVzaXplLFxuICAgIF9saW1pdENhbGxiYWNrcyxcbiAgICAvLyBpZiB0cnVlLCB3ZSdsbCBvbmx5IHRyaWdnZXIgY2FsbGJhY2tzIGlmIHRoZSBhY3RpdmUgc3RhdGUgdG9nZ2xlcywgc28gaWYgeW91IHNjcm9sbCBpbW1lZGlhdGVseSBwYXN0IGJvdGggdGhlIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb25zIG9mIGEgU2Nyb2xsVHJpZ2dlciAodGh1cyBpbmFjdGl2ZSB0byBpbmFjdGl2ZSksIG5laXRoZXIgaXRzIG9uRW50ZXIgbm9yIG9uTGVhdmUgd2lsbCBiZSBjYWxsZWQuIFRoaXMgaXMgdXNlZnVsIGR1cmluZyBzdGFydHVwLlxuX3N0YXJ0dXAgPSAxLFxuICAgIF9wcm94aWVzID0gW10sXG4gICAgX3Njcm9sbGVycyA9IFtdLFxuICAgIF9nZXRUaW1lID0gRGF0ZS5ub3csXG4gICAgX3RpbWUxID0gX2dldFRpbWUoKSxcbiAgICBfbGFzdFNjcm9sbFRpbWUgPSAwLFxuICAgIF9lbmFibGVkID0gMSxcbiAgICBfcGFzc1Rocm91Z2ggPSBmdW5jdGlvbiBfcGFzc1Rocm91Z2godikge1xuICByZXR1cm4gdjtcbn0sXG4gICAgX2dldFRhcmdldCA9IGZ1bmN0aW9uIF9nZXRUYXJnZXQodCkge1xuICByZXR1cm4gX3RvQXJyYXkodClbMF0gfHwgKF9pc1N0cmluZyh0KSAmJiBnc2FwLmNvbmZpZygpLm51bGxUYXJnZXRXYXJuICE9PSBmYWxzZSA/IGNvbnNvbGUud2FybihcIkVsZW1lbnQgbm90IGZvdW5kOlwiLCB0KSA6IG51bGwpO1xufSxcbiAgICBfcm91bmQgPSBmdW5jdGlvbiBfcm91bmQodmFsdWUpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiAxMDAwMDApIC8gMTAwMDAwIHx8IDA7XG59LFxuICAgIF93aW5kb3dFeGlzdHMgPSBmdW5jdGlvbiBfd2luZG93RXhpc3RzKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbn0sXG4gICAgX2dldEdTQVAgPSBmdW5jdGlvbiBfZ2V0R1NBUCgpIHtcbiAgcmV0dXJuIGdzYXAgfHwgX3dpbmRvd0V4aXN0cygpICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcDtcbn0sXG4gICAgX2lzVmlld3BvcnQgPSBmdW5jdGlvbiBfaXNWaWV3cG9ydChlKSB7XG4gIHJldHVybiAhIX5fcm9vdC5pbmRleE9mKGUpO1xufSxcbiAgICBfZ2V0UHJveHlQcm9wID0gZnVuY3Rpb24gX2dldFByb3h5UHJvcChlbGVtZW50LCBwcm9wZXJ0eSkge1xuICByZXR1cm4gfl9wcm94aWVzLmluZGV4T2YoZWxlbWVudCkgJiYgX3Byb3hpZXNbX3Byb3hpZXMuaW5kZXhPZihlbGVtZW50KSArIDFdW3Byb3BlcnR5XTtcbn0sXG4gICAgX2dldFNjcm9sbEZ1bmMgPSBmdW5jdGlvbiBfZ2V0U2Nyb2xsRnVuYyhlbGVtZW50LCBfcmVmKSB7XG4gIHZhciBzID0gX3JlZi5zLFxuICAgICAgc2MgPSBfcmVmLnNjO1xuXG4gIC8vIHdlIHN0b3JlIHRoZSBzY3JvbGxlciBmdW5jdGlvbnMgaW4gYSBhbHRlcm5hdGluZyBzZXF1ZW5jZWQgQXJyYXkgbGlrZSBbZWxlbWVudCwgdmVydGljYWxTY3JvbGxGdW5jLCBob3Jpem9udGFsU2Nyb2xsRnVuYywgLi4uXSBzbyB0aGF0IHdlIGNhbiBtaW5pbWl6ZSBtZW1vcnksIG1heGltaXplIHBlcmZvcm1hbmNlLCBhbmQgd2UgYWxzbyByZWNvcmQgdGhlIGxhc3QgcG9zaXRpb24gYXMgYSBcIi5yZWNcIiBwcm9wZXJ0eSBpbiBvcmRlciB0byByZXZlcnQgdG8gdGhhdCBhZnRlciByZWZyZXNoaW5nIHRvIGVuc3VyZSB0aGluZ3MgZG9uJ3Qgc2hpZnQgYXJvdW5kLlxuICB2YXIgaSA9IF9zY3JvbGxlcnMuaW5kZXhPZihlbGVtZW50KSxcbiAgICAgIG9mZnNldCA9IHNjID09PSBfdmVydGljYWwuc2MgPyAxIDogMjtcblxuICAhfmkgJiYgKGkgPSBfc2Nyb2xsZXJzLnB1c2goZWxlbWVudCkgLSAxKTtcbiAgcmV0dXJuIF9zY3JvbGxlcnNbaSArIG9mZnNldF0gfHwgKF9zY3JvbGxlcnNbaSArIG9mZnNldF0gPSBfZ2V0UHJveHlQcm9wKGVsZW1lbnQsIHMpIHx8IChfaXNWaWV3cG9ydChlbGVtZW50KSA/IHNjIDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBlbGVtZW50W3NdID0gdmFsdWUgOiBlbGVtZW50W3NdO1xuICB9KSk7XG59LFxuICAgIF9nZXRCb3VuZHNGdW5jID0gZnVuY3Rpb24gX2dldEJvdW5kc0Z1bmMoZWxlbWVudCkge1xuICByZXR1cm4gX2dldFByb3h5UHJvcChlbGVtZW50LCBcImdldEJvdW5kaW5nQ2xpZW50UmVjdFwiKSB8fCAoX2lzVmlld3BvcnQoZWxlbWVudCkgPyBmdW5jdGlvbiAoKSB7XG4gICAgX3dpbk9mZnNldHMud2lkdGggPSBfd2luLmlubmVyV2lkdGg7XG4gICAgX3dpbk9mZnNldHMuaGVpZ2h0ID0gX3dpbi5pbm5lckhlaWdodDtcbiAgICByZXR1cm4gX3dpbk9mZnNldHM7XG4gIH0gOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9nZXRCb3VuZHMoZWxlbWVudCk7XG4gIH0pO1xufSxcbiAgICBfZ2V0U2l6ZUZ1bmMgPSBmdW5jdGlvbiBfZ2V0U2l6ZUZ1bmMoc2Nyb2xsZXIsIGlzVmlld3BvcnQsIF9yZWYyKSB7XG4gIHZhciBkID0gX3JlZjIuZCxcbiAgICAgIGQyID0gX3JlZjIuZDIsXG4gICAgICBhID0gX3JlZjIuYTtcbiAgcmV0dXJuIChhID0gX2dldFByb3h5UHJvcChzY3JvbGxlciwgXCJnZXRCb3VuZGluZ0NsaWVudFJlY3RcIikpID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhKClbZF07XG4gIH0gOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIChpc1ZpZXdwb3J0ID8gX3dpbltcImlubmVyXCIgKyBkMl0gOiBzY3JvbGxlcltcImNsaWVudFwiICsgZDJdKSB8fCAwO1xuICB9O1xufSxcbiAgICBfZ2V0T2Zmc2V0c0Z1bmMgPSBmdW5jdGlvbiBfZ2V0T2Zmc2V0c0Z1bmMoZWxlbWVudCwgaXNWaWV3cG9ydCkge1xuICByZXR1cm4gIWlzVmlld3BvcnQgfHwgfl9wcm94aWVzLmluZGV4T2YoZWxlbWVudCkgPyBfZ2V0Qm91bmRzRnVuYyhlbGVtZW50KSA6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3dpbk9mZnNldHM7XG4gIH07XG59LFxuICAgIF9tYXhTY3JvbGwgPSBmdW5jdGlvbiBfbWF4U2Nyb2xsKGVsZW1lbnQsIF9yZWYzKSB7XG4gIHZhciBzID0gX3JlZjMucyxcbiAgICAgIGQyID0gX3JlZjMuZDIsXG4gICAgICBkID0gX3JlZjMuZCxcbiAgICAgIGEgPSBfcmVmMy5hO1xuICByZXR1cm4gKHMgPSBcInNjcm9sbFwiICsgZDIpICYmIChhID0gX2dldFByb3h5UHJvcChlbGVtZW50LCBzKSkgPyBhKCkgLSBfZ2V0Qm91bmRzRnVuYyhlbGVtZW50KSgpW2RdIDogX2lzVmlld3BvcnQoZWxlbWVudCkgPyAoX2JvZHlbc10gfHwgX2RvY0VsW3NdKSAtIChfd2luW1wiaW5uZXJcIiArIGQyXSB8fCBfZG9jRWxbXCJjbGllbnRcIiArIGQyXSB8fCBfYm9keVtcImNsaWVudFwiICsgZDJdKSA6IGVsZW1lbnRbc10gLSBlbGVtZW50W1wib2Zmc2V0XCIgKyBkMl07XG59LFxuICAgIF9pdGVyYXRlQXV0b1JlZnJlc2ggPSBmdW5jdGlvbiBfaXRlcmF0ZUF1dG9SZWZyZXNoKGZ1bmMsIGV2ZW50cykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IF9hdXRvUmVmcmVzaC5sZW5ndGg7IGkgKz0gMykge1xuICAgICghZXZlbnRzIHx8IH5ldmVudHMuaW5kZXhPZihfYXV0b1JlZnJlc2hbaSArIDFdKSkgJiYgZnVuYyhfYXV0b1JlZnJlc2hbaV0sIF9hdXRvUmVmcmVzaFtpICsgMV0sIF9hdXRvUmVmcmVzaFtpICsgMl0pO1xuICB9XG59LFxuICAgIF9pc1N0cmluZyA9IGZ1bmN0aW9uIF9pc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xufSxcbiAgICBfaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIF9pc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIjtcbn0sXG4gICAgX2lzTnVtYmVyID0gZnVuY3Rpb24gX2lzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCI7XG59LFxuICAgIF9pc09iamVjdCA9IGZ1bmN0aW9uIF9pc09iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiO1xufSxcbiAgICBfY2FsbElmRnVuYyA9IGZ1bmN0aW9uIF9jYWxsSWZGdW5jKHZhbHVlKSB7XG4gIHJldHVybiBfaXNGdW5jdGlvbih2YWx1ZSkgJiYgdmFsdWUoKTtcbn0sXG4gICAgX2NvbWJpbmVGdW5jID0gZnVuY3Rpb24gX2NvbWJpbmVGdW5jKGYxLCBmMikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQxID0gX2NhbGxJZkZ1bmMoZjEpLFxuICAgICAgICByZXN1bHQyID0gX2NhbGxJZkZ1bmMoZjIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIF9jYWxsSWZGdW5jKHJlc3VsdDEpO1xuXG4gICAgICBfY2FsbElmRnVuYyhyZXN1bHQyKTtcbiAgICB9O1xuICB9O1xufSxcbiAgICBfZW5kQW5pbWF0aW9uID0gZnVuY3Rpb24gX2VuZEFuaW1hdGlvbihhbmltYXRpb24sIHJldmVyc2VkLCBwYXVzZSkge1xuICByZXR1cm4gYW5pbWF0aW9uICYmIGFuaW1hdGlvbi5wcm9ncmVzcyhyZXZlcnNlZCA/IDAgOiAxKSAmJiBwYXVzZSAmJiBhbmltYXRpb24ucGF1c2UoKTtcbn0sXG4gICAgX2NhbGxiYWNrID0gZnVuY3Rpb24gX2NhbGxiYWNrKHNlbGYsIGZ1bmMpIHtcbiAgaWYgKHNlbGYuZW5hYmxlZCkge1xuICAgIHZhciByZXN1bHQgPSBmdW5jKHNlbGYpO1xuICAgIHJlc3VsdCAmJiByZXN1bHQudG90YWxUaW1lICYmIChzZWxmLmNhbGxiYWNrQW5pbWF0aW9uID0gcmVzdWx0KTtcbiAgfVxufSxcbiAgICBfYWJzID0gTWF0aC5hYnMsXG4gICAgX3Njcm9sbExlZnQgPSBcInNjcm9sbExlZnRcIixcbiAgICBfc2Nyb2xsVG9wID0gXCJzY3JvbGxUb3BcIixcbiAgICBfbGVmdCA9IFwibGVmdFwiLFxuICAgIF90b3AgPSBcInRvcFwiLFxuICAgIF9yaWdodCA9IFwicmlnaHRcIixcbiAgICBfYm90dG9tID0gXCJib3R0b21cIixcbiAgICBfd2lkdGggPSBcIndpZHRoXCIsXG4gICAgX2hlaWdodCA9IFwiaGVpZ2h0XCIsXG4gICAgX1JpZ2h0ID0gXCJSaWdodFwiLFxuICAgIF9MZWZ0ID0gXCJMZWZ0XCIsXG4gICAgX1RvcCA9IFwiVG9wXCIsXG4gICAgX0JvdHRvbSA9IFwiQm90dG9tXCIsXG4gICAgX3BhZGRpbmcgPSBcInBhZGRpbmdcIixcbiAgICBfbWFyZ2luID0gXCJtYXJnaW5cIixcbiAgICBfV2lkdGggPSBcIldpZHRoXCIsXG4gICAgX0hlaWdodCA9IFwiSGVpZ2h0XCIsXG4gICAgX3B4ID0gXCJweFwiLFxuICAgIF9ob3Jpem9udGFsID0ge1xuICBzOiBfc2Nyb2xsTGVmdCxcbiAgcDogX2xlZnQsXG4gIHAyOiBfTGVmdCxcbiAgb3M6IF9yaWdodCxcbiAgb3MyOiBfUmlnaHQsXG4gIGQ6IF93aWR0aCxcbiAgZDI6IF9XaWR0aCxcbiAgYTogXCJ4XCIsXG4gIHNjOiBmdW5jdGlvbiBzYyh2YWx1ZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gX3dpbi5zY3JvbGxUbyh2YWx1ZSwgX3ZlcnRpY2FsLnNjKCkpIDogX3dpbi5wYWdlWE9mZnNldCB8fCBfZG9jW19zY3JvbGxMZWZ0XSB8fCBfZG9jRWxbX3Njcm9sbExlZnRdIHx8IF9ib2R5W19zY3JvbGxMZWZ0XSB8fCAwO1xuICB9XG59LFxuICAgIF92ZXJ0aWNhbCA9IHtcbiAgczogX3Njcm9sbFRvcCxcbiAgcDogX3RvcCxcbiAgcDI6IF9Ub3AsXG4gIG9zOiBfYm90dG9tLFxuICBvczI6IF9Cb3R0b20sXG4gIGQ6IF9oZWlnaHQsXG4gIGQyOiBfSGVpZ2h0LFxuICBhOiBcInlcIixcbiAgb3A6IF9ob3Jpem9udGFsLFxuICBzYzogZnVuY3Rpb24gc2ModmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IF93aW4uc2Nyb2xsVG8oX2hvcml6b250YWwuc2MoKSwgdmFsdWUpIDogX3dpbi5wYWdlWU9mZnNldCB8fCBfZG9jW19zY3JvbGxUb3BdIHx8IF9kb2NFbFtfc2Nyb2xsVG9wXSB8fCBfYm9keVtfc2Nyb2xsVG9wXSB8fCAwO1xuICB9XG59LFxuICAgIF9nZXRDb21wdXRlZFN0eWxlID0gZnVuY3Rpb24gX2dldENvbXB1dGVkU3R5bGUoZWxlbWVudCkge1xuICByZXR1cm4gX3dpbi5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xufSxcbiAgICBfbWFrZVBvc2l0aW9uYWJsZSA9IGZ1bmN0aW9uIF9tYWtlUG9zaXRpb25hYmxlKGVsZW1lbnQpIHtcbiAgLy8gaWYgdGhlIGVsZW1lbnQgYWxyZWFkeSBoYXMgcG9zaXRpb246IGFic29sdXRlIG9yIGZpeGVkLCBsZWF2ZSB0aGF0LCBvdGhlcndpc2UgbWFrZSBpdCBwb3NpdGlvbjogcmVsYXRpdmVcbiAgdmFyIHBvc2l0aW9uID0gX2dldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb247XG5cbiAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9IHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiA/IHBvc2l0aW9uIDogXCJyZWxhdGl2ZVwiO1xufSxcbiAgICBfc2V0RGVmYXVsdHMgPSBmdW5jdGlvbiBfc2V0RGVmYXVsdHMob2JqLCBkZWZhdWx0cykge1xuICBmb3IgKHZhciBwIGluIGRlZmF1bHRzKSB7XG4gICAgcCBpbiBvYmogfHwgKG9ialtwXSA9IGRlZmF1bHRzW3BdKTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59LFxuICAgIF9nZXRCb3VuZHMgPSBmdW5jdGlvbiBfZ2V0Qm91bmRzKGVsZW1lbnQsIHdpdGhvdXRUcmFuc2Zvcm1zKSB7XG4gIHZhciB0d2VlbiA9IHdpdGhvdXRUcmFuc2Zvcm1zICYmIF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpW190cmFuc2Zvcm1Qcm9wXSAhPT0gXCJtYXRyaXgoMSwgMCwgMCwgMSwgMCwgMClcIiAmJiBnc2FwLnRvKGVsZW1lbnQsIHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgeFBlcmNlbnQ6IDAsXG4gICAgeVBlcmNlbnQ6IDAsXG4gICAgcm90YXRpb246IDAsXG4gICAgcm90YXRpb25YOiAwLFxuICAgIHJvdGF0aW9uWTogMCxcbiAgICBzY2FsZTogMSxcbiAgICBza2V3WDogMCxcbiAgICBza2V3WTogMFxuICB9KS5wcm9ncmVzcygxKSxcbiAgICAgIGJvdW5kcyA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHR3ZWVuICYmIHR3ZWVuLnByb2dyZXNzKDApLmtpbGwoKTtcbiAgcmV0dXJuIGJvdW5kcztcbn0sXG4gICAgX2dldFNpemUgPSBmdW5jdGlvbiBfZ2V0U2l6ZShlbGVtZW50LCBfcmVmNCkge1xuICB2YXIgZDIgPSBfcmVmNC5kMjtcbiAgcmV0dXJuIGVsZW1lbnRbXCJvZmZzZXRcIiArIGQyXSB8fCBlbGVtZW50W1wiY2xpZW50XCIgKyBkMl0gfHwgMDtcbn0sXG4gICAgX2dldExhYmVsUmF0aW9BcnJheSA9IGZ1bmN0aW9uIF9nZXRMYWJlbFJhdGlvQXJyYXkodGltZWxpbmUpIHtcbiAgdmFyIGEgPSBbXSxcbiAgICAgIGxhYmVscyA9IHRpbWVsaW5lLmxhYmVscyxcbiAgICAgIGR1cmF0aW9uID0gdGltZWxpbmUuZHVyYXRpb24oKSxcbiAgICAgIHA7XG5cbiAgZm9yIChwIGluIGxhYmVscykge1xuICAgIGEucHVzaChsYWJlbHNbcF0gLyBkdXJhdGlvbik7XG4gIH1cblxuICByZXR1cm4gYTtcbn0sXG4gICAgX2dldENsb3Nlc3RMYWJlbCA9IGZ1bmN0aW9uIF9nZXRDbG9zZXN0TGFiZWwoYW5pbWF0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gZ3NhcC51dGlscy5zbmFwKF9nZXRMYWJlbFJhdGlvQXJyYXkoYW5pbWF0aW9uKSwgdmFsdWUpO1xuICB9O1xufSxcbiAgICBfc25hcERpcmVjdGlvbmFsID0gZnVuY3Rpb24gX3NuYXBEaXJlY3Rpb25hbChzbmFwSW5jcmVtZW50T3JBcnJheSkge1xuICB2YXIgc25hcCA9IGdzYXAudXRpbHMuc25hcChzbmFwSW5jcmVtZW50T3JBcnJheSksXG4gICAgICBhID0gQXJyYXkuaXNBcnJheShzbmFwSW5jcmVtZW50T3JBcnJheSkgJiYgc25hcEluY3JlbWVudE9yQXJyYXkuc2xpY2UoMCkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhIC0gYjtcbiAgfSk7XG4gIHJldHVybiBhID8gZnVuY3Rpb24gKHZhbHVlLCBkaXJlY3Rpb24sIHRocmVzaG9sZCkge1xuICAgIGlmICh0aHJlc2hvbGQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyZXNob2xkID0gMWUtMztcbiAgICB9XG5cbiAgICB2YXIgaTtcblxuICAgIGlmICghZGlyZWN0aW9uKSB7XG4gICAgICByZXR1cm4gc25hcCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGRpcmVjdGlvbiA+IDApIHtcbiAgICAgIHZhbHVlIC09IHRocmVzaG9sZDsgLy8gdG8gYXZvaWQgcm91bmRpbmcgZXJyb3JzLiBJZiB3ZSdyZSB0b28gc3RyaWN0LCBpdCBtaWdodCBzbmFwIGZvcndhcmQsIHRoZW4gaW1tZWRpYXRlbHkgYWdhaW4sIGFuZCBhZ2Fpbi5cblxuICAgICAgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0gPj0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gYVtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYVtpIC0gMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGkgPSBhLmxlbmd0aDtcbiAgICAgIHZhbHVlICs9IHRocmVzaG9sZDtcblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpZiAoYVtpXSA8PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBhW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFbMF07XG4gIH0gOiBmdW5jdGlvbiAodmFsdWUsIGRpcmVjdGlvbiwgdGhyZXNob2xkKSB7XG4gICAgaWYgKHRocmVzaG9sZCA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJlc2hvbGQgPSAxZS0zO1xuICAgIH1cblxuICAgIHZhciBzbmFwcGVkID0gc25hcCh2YWx1ZSk7XG4gICAgcmV0dXJuICFkaXJlY3Rpb24gfHwgTWF0aC5hYnMoc25hcHBlZCAtIHZhbHVlKSA8IHRocmVzaG9sZCB8fCBzbmFwcGVkIC0gdmFsdWUgPCAwID09PSBkaXJlY3Rpb24gPCAwID8gc25hcHBlZCA6IHNuYXAoZGlyZWN0aW9uIDwgMCA/IHZhbHVlIC0gc25hcEluY3JlbWVudE9yQXJyYXkgOiB2YWx1ZSArIHNuYXBJbmNyZW1lbnRPckFycmF5KTtcbiAgfTtcbn0sXG4gICAgX2dldExhYmVsQXREaXJlY3Rpb24gPSBmdW5jdGlvbiBfZ2V0TGFiZWxBdERpcmVjdGlvbih0aW1lbGluZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlLCBzdCkge1xuICAgIHJldHVybiBfc25hcERpcmVjdGlvbmFsKF9nZXRMYWJlbFJhdGlvQXJyYXkodGltZWxpbmUpKSh2YWx1ZSwgc3QuZGlyZWN0aW9uKTtcbiAgfTtcbn0sXG4gICAgX211bHRpTGlzdGVuZXIgPSBmdW5jdGlvbiBfbXVsdGlMaXN0ZW5lcihmdW5jLCBlbGVtZW50LCB0eXBlcywgY2FsbGJhY2spIHtcbiAgcmV0dXJuIHR5cGVzLnNwbGl0KFwiLFwiKS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgcmV0dXJuIGZ1bmMoZWxlbWVudCwgdHlwZSwgY2FsbGJhY2spO1xuICB9KTtcbn0sXG4gICAgX2FkZExpc3RlbmVyID0gZnVuY3Rpb24gX2FkZExpc3RlbmVyKGVsZW1lbnQsIHR5cGUsIGZ1bmMpIHtcbiAgcmV0dXJuIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jLCB7XG4gICAgcGFzc2l2ZTogdHJ1ZVxuICB9KTtcbn0sXG4gICAgX3JlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gX3JlbW92ZUxpc3RlbmVyKGVsZW1lbnQsIHR5cGUsIGZ1bmMpIHtcbiAgcmV0dXJuIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jKTtcbn0sXG4gICAgX21hcmtlckRlZmF1bHRzID0ge1xuICBzdGFydENvbG9yOiBcImdyZWVuXCIsXG4gIGVuZENvbG9yOiBcInJlZFwiLFxuICBpbmRlbnQ6IDAsXG4gIGZvbnRTaXplOiBcIjE2cHhcIixcbiAgZm9udFdlaWdodDogXCJub3JtYWxcIlxufSxcbiAgICBfZGVmYXVsdHMgPSB7XG4gIHRvZ2dsZUFjdGlvbnM6IFwicGxheVwiLFxuICBhbnRpY2lwYXRlUGluOiAwXG59LFxuICAgIF9rZXl3b3JkcyA9IHtcbiAgdG9wOiAwLFxuICBsZWZ0OiAwLFxuICBjZW50ZXI6IDAuNSxcbiAgYm90dG9tOiAxLFxuICByaWdodDogMVxufSxcbiAgICBfb2Zmc2V0VG9QeCA9IGZ1bmN0aW9uIF9vZmZzZXRUb1B4KHZhbHVlLCBzaXplKSB7XG4gIGlmIChfaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIGVxSW5kZXggPSB2YWx1ZS5pbmRleE9mKFwiPVwiKSxcbiAgICAgICAgcmVsYXRpdmUgPSB+ZXFJbmRleCA/ICsodmFsdWUuY2hhckF0KGVxSW5kZXggLSAxKSArIDEpICogcGFyc2VGbG9hdCh2YWx1ZS5zdWJzdHIoZXFJbmRleCArIDEpKSA6IDA7XG5cbiAgICBpZiAofmVxSW5kZXgpIHtcbiAgICAgIHZhbHVlLmluZGV4T2YoXCIlXCIpID4gZXFJbmRleCAmJiAocmVsYXRpdmUgKj0gc2l6ZSAvIDEwMCk7XG4gICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cigwLCBlcUluZGV4IC0gMSk7XG4gICAgfVxuXG4gICAgdmFsdWUgPSByZWxhdGl2ZSArICh2YWx1ZSBpbiBfa2V5d29yZHMgPyBfa2V5d29yZHNbdmFsdWVdICogc2l6ZSA6IH52YWx1ZS5pbmRleE9mKFwiJVwiKSA/IHBhcnNlRmxvYXQodmFsdWUpICogc2l6ZSAvIDEwMCA6IHBhcnNlRmxvYXQodmFsdWUpIHx8IDApO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufSxcbiAgICBfY3JlYXRlTWFya2VyID0gZnVuY3Rpb24gX2NyZWF0ZU1hcmtlcih0eXBlLCBuYW1lLCBjb250YWluZXIsIGRpcmVjdGlvbiwgX3JlZjUsIG9mZnNldCwgbWF0Y2hXaWR0aEVsLCBjb250YWluZXJBbmltYXRpb24pIHtcbiAgdmFyIHN0YXJ0Q29sb3IgPSBfcmVmNS5zdGFydENvbG9yLFxuICAgICAgZW5kQ29sb3IgPSBfcmVmNS5lbmRDb2xvcixcbiAgICAgIGZvbnRTaXplID0gX3JlZjUuZm9udFNpemUsXG4gICAgICBpbmRlbnQgPSBfcmVmNS5pbmRlbnQsXG4gICAgICBmb250V2VpZ2h0ID0gX3JlZjUuZm9udFdlaWdodDtcblxuICB2YXIgZSA9IF9kb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgIHVzZUZpeGVkUG9zaXRpb24gPSBfaXNWaWV3cG9ydChjb250YWluZXIpIHx8IF9nZXRQcm94eVByb3AoY29udGFpbmVyLCBcInBpblR5cGVcIikgPT09IFwiZml4ZWRcIixcbiAgICAgIGlzU2Nyb2xsZXIgPSB0eXBlLmluZGV4T2YoXCJzY3JvbGxlclwiKSAhPT0gLTEsXG4gICAgICBwYXJlbnQgPSB1c2VGaXhlZFBvc2l0aW9uID8gX2JvZHkgOiBjb250YWluZXIsXG4gICAgICBpc1N0YXJ0ID0gdHlwZS5pbmRleE9mKFwic3RhcnRcIikgIT09IC0xLFxuICAgICAgY29sb3IgPSBpc1N0YXJ0ID8gc3RhcnRDb2xvciA6IGVuZENvbG9yLFxuICAgICAgY3NzID0gXCJib3JkZXItY29sb3I6XCIgKyBjb2xvciArIFwiO2ZvbnQtc2l6ZTpcIiArIGZvbnRTaXplICsgXCI7Y29sb3I6XCIgKyBjb2xvciArIFwiO2ZvbnQtd2VpZ2h0OlwiICsgZm9udFdlaWdodCArIFwiO3BvaW50ZXItZXZlbnRzOm5vbmU7d2hpdGUtc3BhY2U6bm93cmFwO2ZvbnQtZmFtaWx5OnNhbnMtc2VyaWYsQXJpYWw7ei1pbmRleDoxMDAwO3BhZGRpbmc6NHB4IDhweDtib3JkZXItd2lkdGg6MDtib3JkZXItc3R5bGU6c29saWQ7XCI7XG5cbiAgY3NzICs9IFwicG9zaXRpb246XCIgKyAoKGlzU2Nyb2xsZXIgfHwgY29udGFpbmVyQW5pbWF0aW9uKSAmJiB1c2VGaXhlZFBvc2l0aW9uID8gXCJmaXhlZDtcIiA6IFwiYWJzb2x1dGU7XCIpO1xuICAoaXNTY3JvbGxlciB8fCBjb250YWluZXJBbmltYXRpb24gfHwgIXVzZUZpeGVkUG9zaXRpb24pICYmIChjc3MgKz0gKGRpcmVjdGlvbiA9PT0gX3ZlcnRpY2FsID8gX3JpZ2h0IDogX2JvdHRvbSkgKyBcIjpcIiArIChvZmZzZXQgKyBwYXJzZUZsb2F0KGluZGVudCkpICsgXCJweDtcIik7XG4gIG1hdGNoV2lkdGhFbCAmJiAoY3NzICs9IFwiYm94LXNpemluZzpib3JkZXItYm94O3RleHQtYWxpZ246bGVmdDt3aWR0aDpcIiArIG1hdGNoV2lkdGhFbC5vZmZzZXRXaWR0aCArIFwicHg7XCIpO1xuICBlLl9pc1N0YXJ0ID0gaXNTdGFydDtcbiAgZS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcImdzYXAtbWFya2VyLVwiICsgdHlwZSArIChuYW1lID8gXCIgbWFya2VyLVwiICsgbmFtZSA6IFwiXCIpKTtcbiAgZS5zdHlsZS5jc3NUZXh0ID0gY3NzO1xuICBlLmlubmVyVGV4dCA9IG5hbWUgfHwgbmFtZSA9PT0gMCA/IHR5cGUgKyBcIi1cIiArIG5hbWUgOiB0eXBlO1xuICBwYXJlbnQuY2hpbGRyZW5bMF0gPyBwYXJlbnQuaW5zZXJ0QmVmb3JlKGUsIHBhcmVudC5jaGlsZHJlblswXSkgOiBwYXJlbnQuYXBwZW5kQ2hpbGQoZSk7XG4gIGUuX29mZnNldCA9IGVbXCJvZmZzZXRcIiArIGRpcmVjdGlvbi5vcC5kMl07XG5cbiAgX3Bvc2l0aW9uTWFya2VyKGUsIDAsIGRpcmVjdGlvbiwgaXNTdGFydCk7XG5cbiAgcmV0dXJuIGU7XG59LFxuICAgIF9wb3NpdGlvbk1hcmtlciA9IGZ1bmN0aW9uIF9wb3NpdGlvbk1hcmtlcihtYXJrZXIsIHN0YXJ0LCBkaXJlY3Rpb24sIGZsaXBwZWQpIHtcbiAgdmFyIHZhcnMgPSB7XG4gICAgZGlzcGxheTogXCJibG9ja1wiXG4gIH0sXG4gICAgICBzaWRlID0gZGlyZWN0aW9uW2ZsaXBwZWQgPyBcIm9zMlwiIDogXCJwMlwiXSxcbiAgICAgIG9wcG9zaXRlU2lkZSA9IGRpcmVjdGlvbltmbGlwcGVkID8gXCJwMlwiIDogXCJvczJcIl07XG4gIG1hcmtlci5faXNGbGlwcGVkID0gZmxpcHBlZDtcbiAgdmFyc1tkaXJlY3Rpb24uYSArIFwiUGVyY2VudFwiXSA9IGZsaXBwZWQgPyAtMTAwIDogMDtcbiAgdmFyc1tkaXJlY3Rpb24uYV0gPSBmbGlwcGVkID8gXCIxcHhcIiA6IDA7XG4gIHZhcnNbXCJib3JkZXJcIiArIHNpZGUgKyBfV2lkdGhdID0gMTtcbiAgdmFyc1tcImJvcmRlclwiICsgb3Bwb3NpdGVTaWRlICsgX1dpZHRoXSA9IDA7XG4gIHZhcnNbZGlyZWN0aW9uLnBdID0gc3RhcnQgKyBcInB4XCI7XG4gIGdzYXAuc2V0KG1hcmtlciwgdmFycyk7XG59LFxuICAgIF90cmlnZ2VycyA9IFtdLFxuICAgIF9pZHMgPSB7fSxcbiAgICBfc3luYyA9IGZ1bmN0aW9uIF9zeW5jKCkge1xuICByZXR1cm4gX2dldFRpbWUoKSAtIF9sYXN0U2Nyb2xsVGltZSA+IDM0ICYmIF91cGRhdGVBbGwoKTtcbn0sXG4gICAgX29uU2Nyb2xsID0gZnVuY3Rpb24gX29uU2Nyb2xsKCkge1xuICAvLyBwcmV2aW91c2x5LCB3ZSB0cmllZCB0byBvcHRpbWl6ZSBwZXJmb3JtYW5jZSBieSBiYXRjaGluZy9kZWZlcnJpbmcgdG8gdGhlIG5leHQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCksIGJ1dCBkaXNjb3ZlcmVkIHRoYXQgU2FmYXJpIGhhcyBhIGZldyBidWdzIHRoYXQgbWFrZSB0aGlzIHVud29ya2FibGUgKGVzcGVjaWFsbHkgb24gaU9TKS4gU2VlIGh0dHBzOi8vY29kZXBlbi5pby9HcmVlblNvY2svcGVuLzE2YzQzNWIxMmVmMDljMzgxMjUyMDQ4MThlN2I0NWZjP2VkaXRvcnM9MDAxMFxuICBfdXBkYXRlQWxsKCk7XG5cbiAgX2xhc3RTY3JvbGxUaW1lIHx8IF9kaXNwYXRjaChcInNjcm9sbFN0YXJ0XCIpO1xuICBfbGFzdFNjcm9sbFRpbWUgPSBfZ2V0VGltZSgpO1xufSxcbiAgICBfb25SZXNpemUgPSBmdW5jdGlvbiBfb25SZXNpemUoKSB7XG4gIHJldHVybiAhX3JlZnJlc2hpbmcgJiYgIV9pZ25vcmVSZXNpemUgJiYgIV9kb2MuZnVsbHNjcmVlbkVsZW1lbnQgJiYgX3Jlc2l6ZURlbGF5LnJlc3RhcnQodHJ1ZSk7XG59LFxuICAgIC8vIGlnbm9yZSByZXNpemVzIHRyaWdnZXJlZCBieSByZWZyZXNoKClcbl9saXN0ZW5lcnMgPSB7fSxcbiAgICBfZW1wdHlBcnJheSA9IFtdLFxuICAgIF9tZWRpYSA9IFtdLFxuICAgIF9jcmVhdGluZ01lZGlhLFxuICAgIC8vIHdoZW4gU2Nyb2xsVHJpZ2dlci5tYXRjaE1lZGlhKCkgaXMgY2FsbGVkLCB3ZSByZWNvcmQgdGhlIGN1cnJlbnQgbWVkaWEga2V5IGhlcmUgKGxpa2UgXCIobWluLXdpZHRoOiA4MDBweClcIikgc28gdGhhdCB3ZSBjYW4gYXNzaWduIGl0IHRvIGV2ZXJ5dGhpbmcgdGhhdCdzIGNyZWF0ZWQgZHVyaW5nIHRoYXQgY2FsbC4gVGhlbiB3ZSBjYW4gcmV2ZXJ0IGp1c3QgdGhvc2Ugd2hlbiBuZWNlc3NhcnkuIEluIHRoZSBTY3JvbGxUcmlnZ2VyJ3MgaW5pdCgpIGNhbGwsIHRoZSBfY3JlYXRpbmdNZWRpYSBpcyByZWNvcmRlZCBhcyBhIFwibWVkaWFcIiBwcm9wZXJ0eSBvbiB0aGUgaW5zdGFuY2UuXG5fbGFzdE1lZGlhVGljayxcbiAgICBfb25NZWRpYUNoYW5nZSA9IGZ1bmN0aW9uIF9vbk1lZGlhQ2hhbmdlKGUpIHtcbiAgdmFyIHRpY2sgPSBnc2FwLnRpY2tlci5mcmFtZSxcbiAgICAgIG1hdGNoZXMgPSBbXSxcbiAgICAgIGkgPSAwLFxuICAgICAgaW5kZXg7XG5cbiAgaWYgKF9sYXN0TWVkaWFUaWNrICE9PSB0aWNrIHx8IF9zdGFydHVwKSB7XG4gICAgX3JldmVydEFsbCgpO1xuXG4gICAgZm9yICg7IGkgPCBfbWVkaWEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgIGluZGV4ID0gX3dpbi5tYXRjaE1lZGlhKF9tZWRpYVtpXSkubWF0Y2hlcztcblxuICAgICAgaWYgKGluZGV4ICE9PSBfbWVkaWFbaSArIDNdKSB7XG4gICAgICAgIC8vIG5vdGU6IHNvbWUgYnJvd3NlcnMgZmlyZSB0aGUgbWF0Y2hNZWRpYSBldmVudCBtdWx0aXBsZSB0aW1lcywgbGlrZSB3aGVuIGdvaW5nIGZ1bGwgc2NyZWVuLCBzbyB3ZSBzaG91bGRuJ3QgY2FsbCB0aGUgZnVuY3Rpb24gbXVsdGlwbGUgdGltZXMuIENoZWNrIHRvIHNlZSBpZiBpdCdzIGFscmVhZHkgbWF0Y2hlZC5cbiAgICAgICAgX21lZGlhW2kgKyAzXSA9IGluZGV4O1xuICAgICAgICBpbmRleCA/IG1hdGNoZXMucHVzaChpKSA6IF9yZXZlcnRBbGwoMSwgX21lZGlhW2ldKSB8fCBfaXNGdW5jdGlvbihfbWVkaWFbaSArIDJdKSAmJiBfbWVkaWFbaSArIDJdKCk7IC8vIEZpcmVmb3ggZG9lc24ndCB1cGRhdGUgdGhlIFwibWF0Y2hlc1wiIHByb3BlcnR5IG9mIHRoZSBNZWRpYVF1ZXJ5TGlzdCBvYmplY3QgY29ycmVjdGx5IC0gaXQgb25seSBkb2VzIHNvIGFzIGl0IGNhbGxzIGl0cyBjaGFuZ2UgaGFuZGxlciAtIHNvIHdlIG11c3QgcmUtY3JlYXRlIGEgbWVkaWEgcXVlcnkgaGVyZSB0byBlbnN1cmUgaXQncyBhY2N1cmF0ZS5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBfcmV2ZXJ0UmVjb3JkZWQoKTsgLy8gaW4gY2FzZSBraWxsaW5nL3JldmVydGluZyBhbnkgb2YgdGhlIGFuaW1hdGlvbnMgYWN0dWFsbHkgYWRkZWQgaW5saW5lIHN0eWxlcyBiYWNrLlxuXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbWF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaW5kZXggPSBtYXRjaGVzW2ldO1xuICAgICAgX2NyZWF0aW5nTWVkaWEgPSBfbWVkaWFbaW5kZXhdO1xuICAgICAgX21lZGlhW2luZGV4ICsgMl0gPSBfbWVkaWFbaW5kZXggKyAxXShlKTtcbiAgICB9XG5cbiAgICBfY3JlYXRpbmdNZWRpYSA9IDA7XG4gICAgX2NvcmVJbml0dGVkICYmIF9yZWZyZXNoQWxsKDAsIDEpO1xuICAgIF9sYXN0TWVkaWFUaWNrID0gdGljaztcblxuICAgIF9kaXNwYXRjaChcIm1hdGNoTWVkaWFcIik7XG4gIH1cbn0sXG4gICAgX3NvZnRSZWZyZXNoID0gZnVuY3Rpb24gX3NvZnRSZWZyZXNoKCkge1xuICByZXR1cm4gX3JlbW92ZUxpc3RlbmVyKFNjcm9sbFRyaWdnZXIsIFwic2Nyb2xsRW5kXCIsIF9zb2Z0UmVmcmVzaCkgfHwgX3JlZnJlc2hBbGwodHJ1ZSk7XG59LFxuICAgIF9kaXNwYXRjaCA9IGZ1bmN0aW9uIF9kaXNwYXRjaCh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzW3R5cGVdICYmIF9saXN0ZW5lcnNbdHlwZV0ubWFwKGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIGYoKTtcbiAgfSkgfHwgX2VtcHR5QXJyYXk7XG59LFxuICAgIF9zYXZlZFN0eWxlcyA9IFtdLFxuICAgIC8vIHdoZW4gU2Nyb2xsVHJpZ2dlci5zYXZlU3R5bGVzKCkgaXMgY2FsbGVkLCB0aGUgaW5saW5lIHN0eWxlcyBhcmUgcmVjb3JkZWQgaW4gdGhpcyBBcnJheSBpbiBhIHNlcXVlbnRpYWwgZm9ybWF0IGxpa2UgW2VsZW1lbnQsIGNzc1RleHQsIGdzQ2FjaGUsIG1lZGlhXS4gVGhpcyBrZWVwcyBpdCB2ZXJ5IG1lbW9yeS1lZmZpY2llbnQgYW5kIGZhc3QgdG8gaXRlcmF0ZSB0aHJvdWdoLlxuX3JldmVydFJlY29yZGVkID0gZnVuY3Rpb24gX3JldmVydFJlY29yZGVkKG1lZGlhKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgX3NhdmVkU3R5bGVzLmxlbmd0aDsgaSArPSA1KSB7XG4gICAgaWYgKCFtZWRpYSB8fCBfc2F2ZWRTdHlsZXNbaSArIDRdID09PSBtZWRpYSkge1xuICAgICAgX3NhdmVkU3R5bGVzW2ldLnN0eWxlLmNzc1RleHQgPSBfc2F2ZWRTdHlsZXNbaSArIDFdO1xuICAgICAgX3NhdmVkU3R5bGVzW2ldLmdldEJCb3ggJiYgX3NhdmVkU3R5bGVzW2ldLnNldEF0dHJpYnV0ZShcInRyYW5zZm9ybVwiLCBfc2F2ZWRTdHlsZXNbaSArIDJdIHx8IFwiXCIpO1xuICAgICAgX3NhdmVkU3R5bGVzW2kgKyAzXS51bmNhY2hlID0gMTtcbiAgICB9XG4gIH1cbn0sXG4gICAgX3JldmVydEFsbCA9IGZ1bmN0aW9uIF9yZXZlcnRBbGwoa2lsbCwgbWVkaWEpIHtcbiAgdmFyIHRyaWdnZXI7XG5cbiAgZm9yIChfaSA9IDA7IF9pIDwgX3RyaWdnZXJzLmxlbmd0aDsgX2krKykge1xuICAgIHRyaWdnZXIgPSBfdHJpZ2dlcnNbX2ldO1xuXG4gICAgaWYgKCFtZWRpYSB8fCB0cmlnZ2VyLm1lZGlhID09PSBtZWRpYSkge1xuICAgICAgaWYgKGtpbGwpIHtcbiAgICAgICAgdHJpZ2dlci5raWxsKDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJpZ2dlci5yZXZlcnQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBtZWRpYSAmJiBfcmV2ZXJ0UmVjb3JkZWQobWVkaWEpO1xuICBtZWRpYSB8fCBfZGlzcGF0Y2goXCJyZXZlcnRcIik7XG59LFxuICAgIF9jbGVhclNjcm9sbE1lbW9yeSA9IGZ1bmN0aW9uIF9jbGVhclNjcm9sbE1lbW9yeSgpIHtcbiAgcmV0dXJuIF9zY3JvbGxlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiAmJiAob2JqLnJlYyA9IDApO1xuICB9KTtcbn0sXG4gICAgLy8gemVyby1vdXQgYWxsIHRoZSByZWNvcmRlZCBzY3JvbGwgcG9zaXRpb25zLiBEb24ndCB1c2UgX3RyaWdnZXJzIGJlY2F1c2UgaWYsIGZvciBleGFtcGxlLCAubWF0Y2hNZWRpYSgpIGlzIHVzZWQgdG8gY3JlYXRlIHNvbWUgU2Nyb2xsVHJpZ2dlcnMgYW5kIHRoZW4gdGhlIHVzZXIgcmVzaXplcyBhbmQgaXQgcmVtb3ZlcyBBTEwgU2Nyb2xsVHJpZ2dlcnMsIGFuZCB0aGVuIGdvIGJhY2sgdG8gYSBzaXplIHdoZXJlIHRoZXJlIGFyZSBTY3JvbGxUcmlnZ2VycywgaXQgd291bGQgaGF2ZSBrZXB0IHRoZSBwb3NpdGlvbihzKSBzYXZlZCBmcm9tIHRoZSBpbml0aWFsIHN0YXRlLlxuX3JlZnJlc2hpbmdBbGwsXG4gICAgX3JlZnJlc2hBbGwgPSBmdW5jdGlvbiBfcmVmcmVzaEFsbChmb3JjZSwgc2tpcFJldmVydCkge1xuICBpZiAoX2xhc3RTY3JvbGxUaW1lICYmICFmb3JjZSkge1xuICAgIF9hZGRMaXN0ZW5lcihTY3JvbGxUcmlnZ2VyLCBcInNjcm9sbEVuZFwiLCBfc29mdFJlZnJlc2gpO1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgX3JlZnJlc2hpbmdBbGwgPSB0cnVlO1xuXG4gIHZhciByZWZyZXNoSW5pdHMgPSBfZGlzcGF0Y2goXCJyZWZyZXNoSW5pdFwiKTtcblxuICBfc29ydCAmJiBTY3JvbGxUcmlnZ2VyLnNvcnQoKTtcbiAgc2tpcFJldmVydCB8fCBfcmV2ZXJ0QWxsKCk7XG5cbiAgX3RyaWdnZXJzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdC5yZWZyZXNoKCk7XG4gIH0pOyAvLyBkb24ndCBsb29wIHdpdGggX2kgYmVjYXVzZSBkdXJpbmcgYSByZWZyZXNoKCkgc29tZW9uZSBjb3VsZCBjYWxsIFNjcm9sbFRyaWdnZXIudXBkYXRlKCkgd2hpY2ggd291bGQgaXRlcmF0ZSB0aHJvdWdoIF9pIHJlc3VsdGluZyBpbiBhIHNraXAuXG5cblxuICBfdHJpZ2dlcnMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0LnZhcnMuZW5kID09PSBcIm1heFwiICYmIHQuc2V0UG9zaXRpb25zKHQuc3RhcnQsIF9tYXhTY3JvbGwodC5zY3JvbGxlciwgdC5fZGlyKSk7XG4gIH0pOyAvLyB0aGUgc2Nyb2xsZXIncyBtYXggc2Nyb2xsIHBvc2l0aW9uIG1heSBjaGFuZ2UgYWZ0ZXIgYWxsIHRoZSBTY3JvbGxUcmlnZ2VycyByZWZyZXNoZWQgKGxpa2UgcGlubmluZyBjb3VsZCBwdXNoIGl0IGRvd24pLCBzbyB3ZSBuZWVkIHRvIGxvb3AgYmFjayBhbmQgY29ycmVjdCBhbnkgd2l0aCBlbmQ6IFwibWF4XCIuXG5cblxuICByZWZyZXNoSW5pdHMuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIHJlc3VsdCAmJiByZXN1bHQucmVuZGVyICYmIHJlc3VsdC5yZW5kZXIoLTEpO1xuICB9KTsgLy8gaWYgdGhlIG9uUmVmcmVzaEluaXQoKSByZXR1cm5zIGFuIGFuaW1hdGlvbiAodHlwaWNhbGx5IGEgZ3NhcC5zZXQoKSksIHJldmVydCBpdC4gVGhpcyBtYWtlcyBpdCBlYXN5IHRvIHB1dCB0aGluZ3MgaW4gYSBjZXJ0YWluIHNwb3QgYmVmb3JlIHJlZnJlc2hpbmcgZm9yIG1lYXN1cmVtZW50IHB1cnBvc2VzLCBhbmQgdGhlbiBwdXQgdGhpbmdzIGJhY2suXG5cbiAgX2NsZWFyU2Nyb2xsTWVtb3J5KCk7XG5cbiAgX3Jlc2l6ZURlbGF5LnBhdXNlKCk7XG5cbiAgX3JlZnJlc2hpbmdBbGwgPSBmYWxzZTtcblxuICBfZGlzcGF0Y2goXCJyZWZyZXNoXCIpO1xufSxcbiAgICBfbGFzdFNjcm9sbCA9IDAsXG4gICAgX2RpcmVjdGlvbiA9IDEsXG4gICAgX3VwZGF0ZUFsbCA9IGZ1bmN0aW9uIF91cGRhdGVBbGwoKSB7XG4gIGlmICghX3JlZnJlc2hpbmdBbGwpIHtcbiAgICB2YXIgbCA9IF90cmlnZ2Vycy5sZW5ndGgsXG4gICAgICAgIHRpbWUgPSBfZ2V0VGltZSgpLFxuICAgICAgICByZWNvcmRWZWxvY2l0eSA9IHRpbWUgLSBfdGltZTEgPj0gNTAsXG4gICAgICAgIHNjcm9sbCA9IGwgJiYgX3RyaWdnZXJzWzBdLnNjcm9sbCgpO1xuXG4gICAgX2RpcmVjdGlvbiA9IF9sYXN0U2Nyb2xsID4gc2Nyb2xsID8gLTEgOiAxO1xuICAgIF9sYXN0U2Nyb2xsID0gc2Nyb2xsO1xuXG4gICAgaWYgKHJlY29yZFZlbG9jaXR5KSB7XG4gICAgICBpZiAoX2xhc3RTY3JvbGxUaW1lICYmICFfcG9pbnRlcklzRG93biAmJiB0aW1lIC0gX2xhc3RTY3JvbGxUaW1lID4gMjAwKSB7XG4gICAgICAgIF9sYXN0U2Nyb2xsVGltZSA9IDA7XG5cbiAgICAgICAgX2Rpc3BhdGNoKFwic2Nyb2xsRW5kXCIpO1xuICAgICAgfVxuXG4gICAgICBfdGltZTIgPSBfdGltZTE7XG4gICAgICBfdGltZTEgPSB0aW1lO1xuICAgIH1cblxuICAgIGlmIChfZGlyZWN0aW9uIDwgMCkge1xuICAgICAgX2kgPSBsO1xuXG4gICAgICB3aGlsZSAoX2ktLSA+IDApIHtcbiAgICAgICAgX3RyaWdnZXJzW19pXSAmJiBfdHJpZ2dlcnNbX2ldLnVwZGF0ZSgwLCByZWNvcmRWZWxvY2l0eSk7XG4gICAgICB9XG5cbiAgICAgIF9kaXJlY3Rpb24gPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKF9pID0gMDsgX2kgPCBsOyBfaSsrKSB7XG4gICAgICAgIF90cmlnZ2Vyc1tfaV0gJiYgX3RyaWdnZXJzW19pXS51cGRhdGUoMCwgcmVjb3JkVmVsb2NpdHkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSxcbiAgICBfcHJvcE5hbWVzVG9Db3B5ID0gW19sZWZ0LCBfdG9wLCBfYm90dG9tLCBfcmlnaHQsIF9tYXJnaW4gKyBfQm90dG9tLCBfbWFyZ2luICsgX1JpZ2h0LCBfbWFyZ2luICsgX1RvcCwgX21hcmdpbiArIF9MZWZ0LCBcImRpc3BsYXlcIiwgXCJmbGV4U2hyaW5rXCIsIFwiZmxvYXRcIiwgXCJ6SW5kZXhcIiwgXCJncmlkQ29sdW1uU3RhcnRcIiwgXCJncmlkQ29sdW1uRW5kXCIsIFwiZ3JpZFJvd1N0YXJ0XCIsIFwiZ3JpZFJvd0VuZFwiLCBcImdyaWRBcmVhXCIsIFwianVzdGlmeVNlbGZcIiwgXCJhbGlnblNlbGZcIiwgXCJwbGFjZVNlbGZcIiwgXCJvcmRlclwiXSxcbiAgICBfc3RhdGVQcm9wcyA9IF9wcm9wTmFtZXNUb0NvcHkuY29uY2F0KFtfd2lkdGgsIF9oZWlnaHQsIFwiYm94U2l6aW5nXCIsIFwibWF4XCIgKyBfV2lkdGgsIFwibWF4XCIgKyBfSGVpZ2h0LCBcInBvc2l0aW9uXCIsIF9tYXJnaW4sIF9wYWRkaW5nLCBfcGFkZGluZyArIF9Ub3AsIF9wYWRkaW5nICsgX1JpZ2h0LCBfcGFkZGluZyArIF9Cb3R0b20sIF9wYWRkaW5nICsgX0xlZnRdKSxcbiAgICBfc3dhcFBpbk91dCA9IGZ1bmN0aW9uIF9zd2FwUGluT3V0KHBpbiwgc3BhY2VyLCBzdGF0ZSkge1xuICBfc2V0U3RhdGUoc3RhdGUpO1xuXG4gIHZhciBjYWNoZSA9IHBpbi5fZ3NhcDtcblxuICBpZiAoY2FjaGUuc3BhY2VySXNOYXRpdmUpIHtcbiAgICBfc2V0U3RhdGUoY2FjaGUuc3BhY2VyU3RhdGUpO1xuICB9IGVsc2UgaWYgKHBpbi5wYXJlbnROb2RlID09PSBzcGFjZXIpIHtcbiAgICB2YXIgcGFyZW50ID0gc3BhY2VyLnBhcmVudE5vZGU7XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHBpbiwgc3BhY2VyKTtcbiAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChzcGFjZXIpO1xuICAgIH1cbiAgfVxufSxcbiAgICBfc3dhcFBpbkluID0gZnVuY3Rpb24gX3N3YXBQaW5JbihwaW4sIHNwYWNlciwgY3MsIHNwYWNlclN0YXRlKSB7XG4gIGlmIChwaW4ucGFyZW50Tm9kZSAhPT0gc3BhY2VyKSB7XG4gICAgdmFyIGkgPSBfcHJvcE5hbWVzVG9Db3B5Lmxlbmd0aCxcbiAgICAgICAgc3BhY2VyU3R5bGUgPSBzcGFjZXIuc3R5bGUsXG4gICAgICAgIHBpblN0eWxlID0gcGluLnN0eWxlLFxuICAgICAgICBwO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgcCA9IF9wcm9wTmFtZXNUb0NvcHlbaV07XG4gICAgICBzcGFjZXJTdHlsZVtwXSA9IGNzW3BdO1xuICAgIH1cblxuICAgIHNwYWNlclN0eWxlLnBvc2l0aW9uID0gY3MucG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiA/IFwiYWJzb2x1dGVcIiA6IFwicmVsYXRpdmVcIjtcbiAgICBjcy5kaXNwbGF5ID09PSBcImlubGluZVwiICYmIChzcGFjZXJTdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIik7XG4gICAgcGluU3R5bGVbX2JvdHRvbV0gPSBwaW5TdHlsZVtfcmlnaHRdID0gc3BhY2VyU3R5bGUuZmxleEJhc2lzID0gXCJhdXRvXCI7XG4gICAgc3BhY2VyU3R5bGUub3ZlcmZsb3cgPSBcInZpc2libGVcIjtcbiAgICBzcGFjZXJTdHlsZS5ib3hTaXppbmcgPSBcImJvcmRlci1ib3hcIjtcbiAgICBzcGFjZXJTdHlsZVtfd2lkdGhdID0gX2dldFNpemUocGluLCBfaG9yaXpvbnRhbCkgKyBfcHg7XG4gICAgc3BhY2VyU3R5bGVbX2hlaWdodF0gPSBfZ2V0U2l6ZShwaW4sIF92ZXJ0aWNhbCkgKyBfcHg7XG4gICAgc3BhY2VyU3R5bGVbX3BhZGRpbmddID0gcGluU3R5bGVbX21hcmdpbl0gPSBwaW5TdHlsZVtfdG9wXSA9IHBpblN0eWxlW19sZWZ0XSA9IFwiMFwiO1xuXG4gICAgX3NldFN0YXRlKHNwYWNlclN0YXRlKTtcblxuICAgIHBpblN0eWxlW193aWR0aF0gPSBwaW5TdHlsZVtcIm1heFwiICsgX1dpZHRoXSA9IGNzW193aWR0aF07XG4gICAgcGluU3R5bGVbX2hlaWdodF0gPSBwaW5TdHlsZVtcIm1heFwiICsgX0hlaWdodF0gPSBjc1tfaGVpZ2h0XTtcbiAgICBwaW5TdHlsZVtfcGFkZGluZ10gPSBjc1tfcGFkZGluZ107XG4gICAgcGluLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNwYWNlciwgcGluKTtcbiAgICBzcGFjZXIuYXBwZW5kQ2hpbGQocGluKTtcbiAgfVxufSxcbiAgICBfY2Fwc0V4cCA9IC8oW0EtWl0pL2csXG4gICAgX3NldFN0YXRlID0gZnVuY3Rpb24gX3NldFN0YXRlKHN0YXRlKSB7XG4gIGlmIChzdGF0ZSkge1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnQuc3R5bGUsXG4gICAgICAgIGwgPSBzdGF0ZS5sZW5ndGgsXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBwLFxuICAgICAgICB2YWx1ZTtcbiAgICAoc3RhdGUudC5fZ3NhcCB8fCBnc2FwLmNvcmUuZ2V0Q2FjaGUoc3RhdGUudCkpLnVuY2FjaGUgPSAxOyAvLyBvdGhlcndpc2UgdHJhbnNmb3JtcyBtYXkgYmUgb2ZmXG5cbiAgICBmb3IgKDsgaSA8IGw7IGkgKz0gMikge1xuICAgICAgdmFsdWUgPSBzdGF0ZVtpICsgMV07XG4gICAgICBwID0gc3RhdGVbaV07XG5cbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBzdHlsZVtwXSA9IHZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChzdHlsZVtwXSkge1xuICAgICAgICBzdHlsZS5yZW1vdmVQcm9wZXJ0eShwLnJlcGxhY2UoX2NhcHNFeHAsIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSxcbiAgICBfZ2V0U3RhdGUgPSBmdW5jdGlvbiBfZ2V0U3RhdGUoZWxlbWVudCkge1xuICAvLyByZXR1cm5zIGFuIEFycmF5IHdpdGggYWx0ZXJuYXRpbmcgdmFsdWVzIGxpa2UgW3Byb3BlcnR5LCB2YWx1ZSwgcHJvcGVydHksIHZhbHVlXSBhbmQgYSBcInRcIiBwcm9wZXJ0eSBwb2ludGluZyB0byB0aGUgdGFyZ2V0IChlbGVtZW50KS4gTWFrZXMgaXQgZmFzdCBhbmQgY2hlYXAuXG4gIHZhciBsID0gX3N0YXRlUHJvcHMubGVuZ3RoLFxuICAgICAgc3R5bGUgPSBlbGVtZW50LnN0eWxlLFxuICAgICAgc3RhdGUgPSBbXSxcbiAgICAgIGkgPSAwO1xuXG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgc3RhdGUucHVzaChfc3RhdGVQcm9wc1tpXSwgc3R5bGVbX3N0YXRlUHJvcHNbaV1dKTtcbiAgfVxuXG4gIHN0YXRlLnQgPSBlbGVtZW50O1xuICByZXR1cm4gc3RhdGU7XG59LFxuICAgIF9jb3B5U3RhdGUgPSBmdW5jdGlvbiBfY29weVN0YXRlKHN0YXRlLCBvdmVycmlkZSwgb21pdE9mZnNldHMpIHtcbiAgdmFyIHJlc3VsdCA9IFtdLFxuICAgICAgbCA9IHN0YXRlLmxlbmd0aCxcbiAgICAgIGkgPSBvbWl0T2Zmc2V0cyA/IDggOiAwLFxuICAgICAgLy8gc2tpcCB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20gaWYgb21pdE9mZnNldHMgaXMgdHJ1ZVxuICBwO1xuXG4gIGZvciAoOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgcCA9IHN0YXRlW2ldO1xuICAgIHJlc3VsdC5wdXNoKHAsIHAgaW4gb3ZlcnJpZGUgPyBvdmVycmlkZVtwXSA6IHN0YXRlW2kgKyAxXSk7XG4gIH1cblxuICByZXN1bHQudCA9IHN0YXRlLnQ7XG4gIHJldHVybiByZXN1bHQ7XG59LFxuICAgIF93aW5PZmZzZXRzID0ge1xuICBsZWZ0OiAwLFxuICB0b3A6IDBcbn0sXG4gICAgLy8gLy8gcG90ZW50aWFsIGZ1dHVyZSBmZWF0dXJlICg/KSBBbGxvdyB1c2VycyB0byBjYWxjdWxhdGUgd2hlcmUgYSB0cmlnZ2VyIGhpdHMgKHNjcm9sbCBwb3NpdGlvbikgbGlrZSBnZXRTY3JvbGxQb3NpdGlvbihcIiNpZFwiLCBcInRvcCBib3R0b21cIilcbi8vIF9nZXRTY3JvbGxQb3NpdGlvbiA9ICh0cmlnZ2VyLCBwb3NpdGlvbiwge3Njcm9sbGVyLCBjb250YWluZXJBbmltYXRpb24sIGhvcml6b250YWx9KSA9PiB7XG4vLyBcdHNjcm9sbGVyID0gX2dldFRhcmdldChzY3JvbGxlciB8fCBfd2luKTtcbi8vIFx0bGV0IGRpcmVjdGlvbiA9IGhvcml6b250YWwgPyBfaG9yaXpvbnRhbCA6IF92ZXJ0aWNhbCxcbi8vIFx0XHRpc1ZpZXdwb3J0ID0gX2lzVmlld3BvcnQoc2Nyb2xsZXIpO1xuLy8gXHRfZ2V0U2l6ZUZ1bmMoc2Nyb2xsZXIsIGlzVmlld3BvcnQsIGRpcmVjdGlvbik7XG4vLyBcdHJldHVybiBfcGFyc2VQb3NpdGlvbihwb3NpdGlvbiwgX2dldFRhcmdldCh0cmlnZ2VyKSwgX2dldFNpemVGdW5jKHNjcm9sbGVyLCBpc1ZpZXdwb3J0LCBkaXJlY3Rpb24pKCksIGRpcmVjdGlvbiwgX2dldFNjcm9sbEZ1bmMoc2Nyb2xsZXIsIGRpcmVjdGlvbikoKSwgMCwgMCwgMCwgX2dldE9mZnNldHNGdW5jKHNjcm9sbGVyLCBpc1ZpZXdwb3J0KSgpLCBpc1ZpZXdwb3J0ID8gMCA6IHBhcnNlRmxvYXQoX2dldENvbXB1dGVkU3R5bGUoc2Nyb2xsZXIpW1wiYm9yZGVyXCIgKyBkaXJlY3Rpb24ucDIgKyBfV2lkdGhdKSB8fCAwLCAwLCBjb250YWluZXJBbmltYXRpb24gPyBjb250YWluZXJBbmltYXRpb24uZHVyYXRpb24oKSA6IF9tYXhTY3JvbGwoc2Nyb2xsZXIpLCBjb250YWluZXJBbmltYXRpb24pO1xuLy8gfSxcbl9wYXJzZVBvc2l0aW9uID0gZnVuY3Rpb24gX3BhcnNlUG9zaXRpb24odmFsdWUsIHRyaWdnZXIsIHNjcm9sbGVyU2l6ZSwgZGlyZWN0aW9uLCBzY3JvbGwsIG1hcmtlciwgbWFya2VyU2Nyb2xsZXIsIHNlbGYsIHNjcm9sbGVyQm91bmRzLCBib3JkZXJXaWR0aCwgdXNlRml4ZWRQb3NpdGlvbiwgc2Nyb2xsZXJNYXgsIGNvbnRhaW5lckFuaW1hdGlvbikge1xuICBfaXNGdW5jdGlvbih2YWx1ZSkgJiYgKHZhbHVlID0gdmFsdWUoc2VsZikpO1xuXG4gIGlmIChfaXNTdHJpbmcodmFsdWUpICYmIHZhbHVlLnN1YnN0cigwLCAzKSA9PT0gXCJtYXhcIikge1xuICAgIHZhbHVlID0gc2Nyb2xsZXJNYXggKyAodmFsdWUuY2hhckF0KDQpID09PSBcIj1cIiA/IF9vZmZzZXRUb1B4KFwiMFwiICsgdmFsdWUuc3Vic3RyKDMpLCBzY3JvbGxlclNpemUpIDogMCk7XG4gIH1cblxuICB2YXIgdGltZSA9IGNvbnRhaW5lckFuaW1hdGlvbiA/IGNvbnRhaW5lckFuaW1hdGlvbi50aW1lKCkgOiAwLFxuICAgICAgcDEsXG4gICAgICBwMixcbiAgICAgIGVsZW1lbnQ7XG4gIGNvbnRhaW5lckFuaW1hdGlvbiAmJiBjb250YWluZXJBbmltYXRpb24uc2VlaygwKTtcblxuICBpZiAoIV9pc051bWJlcih2YWx1ZSkpIHtcbiAgICBfaXNGdW5jdGlvbih0cmlnZ2VyKSAmJiAodHJpZ2dlciA9IHRyaWdnZXIoc2VsZikpO1xuICAgIHZhciBvZmZzZXRzID0gdmFsdWUuc3BsaXQoXCIgXCIpLFxuICAgICAgICBib3VuZHMsXG4gICAgICAgIGxvY2FsT2Zmc2V0LFxuICAgICAgICBnbG9iYWxPZmZzZXQsXG4gICAgICAgIGRpc3BsYXk7XG4gICAgZWxlbWVudCA9IF9nZXRUYXJnZXQodHJpZ2dlcikgfHwgX2JvZHk7XG4gICAgYm91bmRzID0gX2dldEJvdW5kcyhlbGVtZW50KSB8fCB7fTtcblxuICAgIGlmICgoIWJvdW5kcyB8fCAhYm91bmRzLmxlZnQgJiYgIWJvdW5kcy50b3ApICYmIF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmRpc3BsYXkgPT09IFwibm9uZVwiKSB7XG4gICAgICAvLyBpZiBkaXNwbGF5IGlzIFwibm9uZVwiLCBpdCB3b24ndCByZXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgcHJvcGVybHlcbiAgICAgIGRpc3BsYXkgPSBlbGVtZW50LnN0eWxlLmRpc3BsYXk7XG4gICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICBib3VuZHMgPSBfZ2V0Qm91bmRzKGVsZW1lbnQpO1xuICAgICAgZGlzcGxheSA/IGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IGRpc3BsYXkgOiBlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KFwiZGlzcGxheVwiKTtcbiAgICB9XG5cbiAgICBsb2NhbE9mZnNldCA9IF9vZmZzZXRUb1B4KG9mZnNldHNbMF0sIGJvdW5kc1tkaXJlY3Rpb24uZF0pO1xuICAgIGdsb2JhbE9mZnNldCA9IF9vZmZzZXRUb1B4KG9mZnNldHNbMV0gfHwgXCIwXCIsIHNjcm9sbGVyU2l6ZSk7XG4gICAgdmFsdWUgPSBib3VuZHNbZGlyZWN0aW9uLnBdIC0gc2Nyb2xsZXJCb3VuZHNbZGlyZWN0aW9uLnBdIC0gYm9yZGVyV2lkdGggKyBsb2NhbE9mZnNldCArIHNjcm9sbCAtIGdsb2JhbE9mZnNldDtcbiAgICBtYXJrZXJTY3JvbGxlciAmJiBfcG9zaXRpb25NYXJrZXIobWFya2VyU2Nyb2xsZXIsIGdsb2JhbE9mZnNldCwgZGlyZWN0aW9uLCBzY3JvbGxlclNpemUgLSBnbG9iYWxPZmZzZXQgPCAyMCB8fCBtYXJrZXJTY3JvbGxlci5faXNTdGFydCAmJiBnbG9iYWxPZmZzZXQgPiAyMCk7XG4gICAgc2Nyb2xsZXJTaXplIC09IHNjcm9sbGVyU2l6ZSAtIGdsb2JhbE9mZnNldDsgLy8gYWRqdXN0IGZvciB0aGUgbWFya2VyXG4gIH0gZWxzZSBpZiAobWFya2VyU2Nyb2xsZXIpIHtcbiAgICBfcG9zaXRpb25NYXJrZXIobWFya2VyU2Nyb2xsZXIsIHNjcm9sbGVyU2l6ZSwgZGlyZWN0aW9uLCB0cnVlKTtcbiAgfVxuXG4gIGlmIChtYXJrZXIpIHtcbiAgICB2YXIgcG9zaXRpb24gPSB2YWx1ZSArIHNjcm9sbGVyU2l6ZSxcbiAgICAgICAgaXNTdGFydCA9IG1hcmtlci5faXNTdGFydDtcbiAgICBwMSA9IFwic2Nyb2xsXCIgKyBkaXJlY3Rpb24uZDI7XG5cbiAgICBfcG9zaXRpb25NYXJrZXIobWFya2VyLCBwb3NpdGlvbiwgZGlyZWN0aW9uLCBpc1N0YXJ0ICYmIHBvc2l0aW9uID4gMjAgfHwgIWlzU3RhcnQgJiYgKHVzZUZpeGVkUG9zaXRpb24gPyBNYXRoLm1heChfYm9keVtwMV0sIF9kb2NFbFtwMV0pIDogbWFya2VyLnBhcmVudE5vZGVbcDFdKSA8PSBwb3NpdGlvbiArIDEpO1xuXG4gICAgaWYgKHVzZUZpeGVkUG9zaXRpb24pIHtcbiAgICAgIHNjcm9sbGVyQm91bmRzID0gX2dldEJvdW5kcyhtYXJrZXJTY3JvbGxlcik7XG4gICAgICB1c2VGaXhlZFBvc2l0aW9uICYmIChtYXJrZXIuc3R5bGVbZGlyZWN0aW9uLm9wLnBdID0gc2Nyb2xsZXJCb3VuZHNbZGlyZWN0aW9uLm9wLnBdIC0gZGlyZWN0aW9uLm9wLm0gLSBtYXJrZXIuX29mZnNldCArIF9weCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbnRhaW5lckFuaW1hdGlvbiAmJiBlbGVtZW50KSB7XG4gICAgcDEgPSBfZ2V0Qm91bmRzKGVsZW1lbnQpO1xuICAgIGNvbnRhaW5lckFuaW1hdGlvbi5zZWVrKHNjcm9sbGVyTWF4KTtcbiAgICBwMiA9IF9nZXRCb3VuZHMoZWxlbWVudCk7XG4gICAgY29udGFpbmVyQW5pbWF0aW9uLl9jYVNjcm9sbERpc3QgPSBwMVtkaXJlY3Rpb24ucF0gLSBwMltkaXJlY3Rpb24ucF07XG4gICAgdmFsdWUgPSB2YWx1ZSAvIGNvbnRhaW5lckFuaW1hdGlvbi5fY2FTY3JvbGxEaXN0ICogc2Nyb2xsZXJNYXg7XG4gIH1cblxuICBjb250YWluZXJBbmltYXRpb24gJiYgY29udGFpbmVyQW5pbWF0aW9uLnNlZWsodGltZSk7XG4gIHJldHVybiBjb250YWluZXJBbmltYXRpb24gPyB2YWx1ZSA6IE1hdGgucm91bmQodmFsdWUpO1xufSxcbiAgICBfcHJlZml4RXhwID0gLyg/OndlYmtpdHxtb3p8bGVuZ3RofGNzc1RleHR8aW5zZXQpL2ksXG4gICAgX3JlcGFyZW50ID0gZnVuY3Rpb24gX3JlcGFyZW50KGVsZW1lbnQsIHBhcmVudCwgdG9wLCBsZWZ0KSB7XG4gIGlmIChlbGVtZW50LnBhcmVudE5vZGUgIT09IHBhcmVudCkge1xuICAgIHZhciBzdHlsZSA9IGVsZW1lbnQuc3R5bGUsXG4gICAgICAgIHAsXG4gICAgICAgIGNzO1xuXG4gICAgaWYgKHBhcmVudCA9PT0gX2JvZHkpIHtcbiAgICAgIGVsZW1lbnQuX3N0T3JpZyA9IHN0eWxlLmNzc1RleHQ7IC8vIHJlY29yZCBvcmlnaW5hbCBpbmxpbmUgc3R5bGVzIHNvIHdlIGNhbiByZXZlcnQgdGhlbSBsYXRlclxuXG4gICAgICBjcyA9IF9nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuXG4gICAgICBmb3IgKHAgaW4gY3MpIHtcbiAgICAgICAgLy8gbXVzdCBjb3B5IGFsbCByZWxldmFudCBzdHlsZXMgdG8gZW5zdXJlIHRoYXQgbm90aGluZyBjaGFuZ2VzIHZpc3VhbGx5IHdoZW4gd2UgcmVwYXJlbnQgdG8gdGhlIDxib2R5Pi4gU2tpcCB0aGUgdmVuZG9yIHByZWZpeGVkIG9uZXMuXG4gICAgICAgIGlmICghK3AgJiYgIV9wcmVmaXhFeHAudGVzdChwKSAmJiBjc1twXSAmJiB0eXBlb2Ygc3R5bGVbcF0gPT09IFwic3RyaW5nXCIgJiYgcCAhPT0gXCIwXCIpIHtcbiAgICAgICAgICBzdHlsZVtwXSA9IGNzW3BdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0eWxlLnRvcCA9IHRvcDtcbiAgICAgIHN0eWxlLmxlZnQgPSBsZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS5jc3NUZXh0ID0gZWxlbWVudC5fc3RPcmlnO1xuICAgIH1cblxuICAgIGdzYXAuY29yZS5nZXRDYWNoZShlbGVtZW50KS51bmNhY2hlID0gMTtcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gIH1cbn0sXG4gICAgLy8gX21lcmdlQW5pbWF0aW9ucyA9IGFuaW1hdGlvbnMgPT4ge1xuLy8gXHRsZXQgdGwgPSBnc2FwLnRpbWVsaW5lKHtzbW9vdGhDaGlsZFRpbWluZzogdHJ1ZX0pLnN0YXJ0VGltZShNYXRoLm1pbiguLi5hbmltYXRpb25zLm1hcChhID0+IGEuZ2xvYmFsVGltZSgwKSkpKTtcbi8vIFx0YW5pbWF0aW9ucy5mb3JFYWNoKGEgPT4ge2xldCB0aW1lID0gYS50b3RhbFRpbWUoKTsgdGwuYWRkKGEpOyBhLnRvdGFsVGltZSh0aW1lKTsgfSk7XG4vLyBcdHRsLnNtb290aENoaWxkVGltaW5nID0gZmFsc2U7XG4vLyBcdHJldHVybiB0bDtcbi8vIH0sXG4vLyByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byB0d2VlbiB0aGUgc2Nyb2xsIHBvc2l0aW9uIGluIHRoZSBkaXJlY3Rpb24gcHJvdmlkZWQsIGFuZCB3aGVuIGRvaW5nIHNvIGl0J2xsIGFkZCBhIC50d2VlbiBwcm9wZXJ0eSB0byB0aGUgRlVOQ1RJT04gaXRzZWxmLCBhbmQgcmVtb3ZlIGl0IHdoZW4gdGhlIHR3ZWVuIGNvbXBsZXRlcyBvciBnZXRzIGtpbGxlZC4gVGhpcyBnaXZlcyB1cyBhIHdheSB0byBoYXZlIG11bHRpcGxlIFNjcm9sbFRyaWdnZXJzIHVzZSBhIGNlbnRyYWwgZnVuY3Rpb24gZm9yIGFueSBnaXZlbiBzY3JvbGxlciBhbmQgc2VlIGlmIHRoZXJlJ3MgYSBzY3JvbGwgdHdlZW4gcnVubmluZyAod2hpY2ggd291bGQgYWZmZWN0IGlmL2hvdyB0aGluZ3MgZ2V0IHVwZGF0ZWQpXG5fZ2V0VHdlZW5DcmVhdG9yID0gZnVuY3Rpb24gX2dldFR3ZWVuQ3JlYXRvcihzY3JvbGxlciwgZGlyZWN0aW9uKSB7XG4gIHZhciBnZXRTY3JvbGwgPSBfZ2V0U2Nyb2xsRnVuYyhzY3JvbGxlciwgZGlyZWN0aW9uKSxcbiAgICAgIHByb3AgPSBcIl9zY3JvbGxcIiArIGRpcmVjdGlvbi5wMixcbiAgICAgIC8vIGFkZCBhIHR3ZWVuYWJsZSBwcm9wZXJ0eSB0byB0aGUgc2Nyb2xsZXIgdGhhdCdzIGEgZ2V0dGVyL3NldHRlciBmdW5jdGlvbiwgbGlrZSBfc2Nyb2xsVG9wIG9yIF9zY3JvbGxMZWZ0LiBUaGlzIHdheSwgaWYgc29tZW9uZSBkb2VzIGdzYXAua2lsbFR3ZWVuc09mKHNjcm9sbGVyKSBpdCdsbCBraWxsIHRoZSBzY3JvbGwgdHdlZW4uXG4gIGxhc3RTY3JvbGwxLFxuICAgICAgbGFzdFNjcm9sbDIsXG4gICAgICBnZXRUd2VlbiA9IGZ1bmN0aW9uIGdldFR3ZWVuKHNjcm9sbFRvLCB2YXJzLCBpbml0aWFsVmFsdWUsIGNoYW5nZTEsIGNoYW5nZTIpIHtcbiAgICB2YXIgdHdlZW4gPSBnZXRUd2Vlbi50d2VlbixcbiAgICAgICAgb25Db21wbGV0ZSA9IHZhcnMub25Db21wbGV0ZSxcbiAgICAgICAgbW9kaWZpZXJzID0ge307XG4gICAgdHdlZW4gJiYgdHdlZW4ua2lsbCgpO1xuICAgIGxhc3RTY3JvbGwxID0gTWF0aC5yb3VuZChpbml0aWFsVmFsdWUpO1xuICAgIHZhcnNbcHJvcF0gPSBzY3JvbGxUbztcbiAgICB2YXJzLm1vZGlmaWVycyA9IG1vZGlmaWVycztcblxuICAgIG1vZGlmaWVyc1twcm9wXSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgdmFsdWUgPSBfcm91bmQoZ2V0U2Nyb2xsKCkpOyAvLyByb3VuZCBiZWNhdXNlIGluIHNvbWUgW3ZlcnkgdW5jb21tb25dIFdpbmRvd3MgZW52aXJvbm1lbnRzLCBpdCBjYW4gZ2V0IHJlcG9ydGVkIHdpdGggZGVjaW1hbHMgZXZlbiB0aG91Z2ggaXQgd2FzIHNldCB3aXRob3V0LlxuXG4gICAgICBpZiAodmFsdWUgIT09IGxhc3RTY3JvbGwxICYmIHZhbHVlICE9PSBsYXN0U2Nyb2xsMiAmJiBNYXRoLmFicyh2YWx1ZSAtIGxhc3RTY3JvbGwxKSA+IDIgJiYgTWF0aC5hYnModmFsdWUgLSBsYXN0U2Nyb2xsMikgPiAyKSB7XG4gICAgICAgIC8vIGlmIHRoZSB1c2VyIHNjcm9sbHMsIGtpbGwgdGhlIHR3ZWVuLiBpT1MgU2FmYXJpIGludGVybWl0dGVudGx5IG1pc3JlcG9ydHMgdGhlIHNjcm9sbCBwb3NpdGlvbiwgaXQgbWF5IGJlIHRoZSBtb3N0IHJlY2VudGx5LXNldCBvbmUgb3IgdGhlIG9uZSBiZWZvcmUgdGhhdCEgV2hlbiBTYWZhcmkgaXMgem9vbWVkIChDTUQtKyksIGl0IG9mdGVuIG1pc3JlcG9ydHMgYXMgMSBwaXhlbCBvZmYgdG9vISBTbyBpZiB3ZSBzZXQgdGhlIHNjcm9sbCBwb3NpdGlvbiB0byAxMjUsIGZvciBleGFtcGxlLCBpdCdsbCBhY3R1YWxseSByZXBvcnQgaXQgYXMgMTI0LlxuICAgICAgICB0d2Vlbi5raWxsKCk7XG4gICAgICAgIGdldFR3ZWVuLnR3ZWVuID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gaW5pdGlhbFZhbHVlICsgY2hhbmdlMSAqIHR3ZWVuLnJhdGlvICsgY2hhbmdlMiAqIHR3ZWVuLnJhdGlvICogdHdlZW4ucmF0aW87XG4gICAgICB9XG5cbiAgICAgIGxhc3RTY3JvbGwyID0gbGFzdFNjcm9sbDE7XG4gICAgICByZXR1cm4gbGFzdFNjcm9sbDEgPSBfcm91bmQodmFsdWUpO1xuICAgIH07XG5cbiAgICB2YXJzLm9uQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBnZXRUd2Vlbi50d2VlbiA9IDA7XG4gICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUuY2FsbCh0d2Vlbik7XG4gICAgfTtcblxuICAgIHR3ZWVuID0gZ2V0VHdlZW4udHdlZW4gPSBnc2FwLnRvKHNjcm9sbGVyLCB2YXJzKTtcbiAgICByZXR1cm4gdHdlZW47XG4gIH07XG5cbiAgc2Nyb2xsZXJbcHJvcF0gPSBnZXRTY3JvbGw7XG5cbiAgX2FkZExpc3RlbmVyKHNjcm9sbGVyLCBcIndoZWVsXCIsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2V0VHdlZW4udHdlZW4gJiYgZ2V0VHdlZW4udHdlZW4ua2lsbCgpICYmIChnZXRUd2Vlbi50d2VlbiA9IDApO1xuICB9KTsgLy8gV2luZG93cyBtYWNoaW5lcyBoYW5kbGUgbW91c2V3aGVlbCBzY3JvbGxpbmcgaW4gY2h1bmtzIChsaWtlIFwiMyBsaW5lcyBwZXIgc2Nyb2xsXCIpIG1lYW5pbmcgdGhlIHR5cGljYWwgc3RyYXRlZ3kgZm9yIGNhbmNlbGxpbmcgdGhlIHNjcm9sbCBpc24ndCBhcyBzZW5zaXRpdmUuIEl0J3MgbXVjaCBtb3JlIGxpa2VseSB0byBtYXRjaCBvbmUgb2YgdGhlIHByZXZpb3VzIDIgc2Nyb2xsIGV2ZW50IHBvc2l0aW9ucy4gU28gd2Uga2lsbCBhbnkgc25hcHBpbmcgYXMgc29vbiBhcyB0aGVyZSdzIGEgd2hlZWwgZXZlbnQuXG5cblxuICByZXR1cm4gZ2V0VHdlZW47XG59O1xuXG5faG9yaXpvbnRhbC5vcCA9IF92ZXJ0aWNhbDtcbmV4cG9ydCB2YXIgU2Nyb2xsVHJpZ2dlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNjcm9sbFRyaWdnZXIodmFycywgYW5pbWF0aW9uKSB7XG4gICAgX2NvcmVJbml0dGVkIHx8IFNjcm9sbFRyaWdnZXIucmVnaXN0ZXIoZ3NhcCkgfHwgY29uc29sZS53YXJuKFwiUGxlYXNlIGdzYXAucmVnaXN0ZXJQbHVnaW4oU2Nyb2xsVHJpZ2dlcilcIik7XG4gICAgdGhpcy5pbml0KHZhcnMsIGFuaW1hdGlvbik7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU2Nyb2xsVHJpZ2dlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmluaXQgPSBmdW5jdGlvbiBpbml0KHZhcnMsIGFuaW1hdGlvbikge1xuICAgIHRoaXMucHJvZ3Jlc3MgPSB0aGlzLnN0YXJ0ID0gMDtcbiAgICB0aGlzLnZhcnMgJiYgdGhpcy5raWxsKDEpOyAvLyBpbiBjYXNlIGl0J3MgYmVpbmcgaW5pdHRlZCBhZ2FpblxuXG4gICAgaWYgKCFfZW5hYmxlZCkge1xuICAgICAgdGhpcy51cGRhdGUgPSB0aGlzLnJlZnJlc2ggPSB0aGlzLmtpbGwgPSBfcGFzc1Rocm91Z2g7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFycyA9IF9zZXREZWZhdWx0cyhfaXNTdHJpbmcodmFycykgfHwgX2lzTnVtYmVyKHZhcnMpIHx8IHZhcnMubm9kZVR5cGUgPyB7XG4gICAgICB0cmlnZ2VyOiB2YXJzXG4gICAgfSA6IHZhcnMsIF9kZWZhdWx0cyk7XG5cbiAgICB2YXIgX3ZhcnMgPSB2YXJzLFxuICAgICAgICBvblVwZGF0ZSA9IF92YXJzLm9uVXBkYXRlLFxuICAgICAgICB0b2dnbGVDbGFzcyA9IF92YXJzLnRvZ2dsZUNsYXNzLFxuICAgICAgICBpZCA9IF92YXJzLmlkLFxuICAgICAgICBvblRvZ2dsZSA9IF92YXJzLm9uVG9nZ2xlLFxuICAgICAgICBvblJlZnJlc2ggPSBfdmFycy5vblJlZnJlc2gsXG4gICAgICAgIHNjcnViID0gX3ZhcnMuc2NydWIsXG4gICAgICAgIHRyaWdnZXIgPSBfdmFycy50cmlnZ2VyLFxuICAgICAgICBwaW4gPSBfdmFycy5waW4sXG4gICAgICAgIHBpblNwYWNpbmcgPSBfdmFycy5waW5TcGFjaW5nLFxuICAgICAgICBpbnZhbGlkYXRlT25SZWZyZXNoID0gX3ZhcnMuaW52YWxpZGF0ZU9uUmVmcmVzaCxcbiAgICAgICAgYW50aWNpcGF0ZVBpbiA9IF92YXJzLmFudGljaXBhdGVQaW4sXG4gICAgICAgIG9uU2NydWJDb21wbGV0ZSA9IF92YXJzLm9uU2NydWJDb21wbGV0ZSxcbiAgICAgICAgb25TbmFwQ29tcGxldGUgPSBfdmFycy5vblNuYXBDb21wbGV0ZSxcbiAgICAgICAgb25jZSA9IF92YXJzLm9uY2UsXG4gICAgICAgIHNuYXAgPSBfdmFycy5zbmFwLFxuICAgICAgICBwaW5SZXBhcmVudCA9IF92YXJzLnBpblJlcGFyZW50LFxuICAgICAgICBwaW5TcGFjZXIgPSBfdmFycy5waW5TcGFjZXIsXG4gICAgICAgIGNvbnRhaW5lckFuaW1hdGlvbiA9IF92YXJzLmNvbnRhaW5lckFuaW1hdGlvbixcbiAgICAgICAgZmFzdFNjcm9sbEVuZCA9IF92YXJzLmZhc3RTY3JvbGxFbmQsXG4gICAgICAgIHByZXZlbnRPdmVybGFwcyA9IF92YXJzLnByZXZlbnRPdmVybGFwcyxcbiAgICAgICAgZGlyZWN0aW9uID0gdmFycy5ob3Jpem9udGFsIHx8IHZhcnMuY29udGFpbmVyQW5pbWF0aW9uICYmIHZhcnMuaG9yaXpvbnRhbCAhPT0gZmFsc2UgPyBfaG9yaXpvbnRhbCA6IF92ZXJ0aWNhbCxcbiAgICAgICAgaXNUb2dnbGUgPSAhc2NydWIgJiYgc2NydWIgIT09IDAsXG4gICAgICAgIHNjcm9sbGVyID0gX2dldFRhcmdldCh2YXJzLnNjcm9sbGVyIHx8IF93aW4pLFxuICAgICAgICBzY3JvbGxlckNhY2hlID0gZ3NhcC5jb3JlLmdldENhY2hlKHNjcm9sbGVyKSxcbiAgICAgICAgaXNWaWV3cG9ydCA9IF9pc1ZpZXdwb3J0KHNjcm9sbGVyKSxcbiAgICAgICAgdXNlRml4ZWRQb3NpdGlvbiA9IChcInBpblR5cGVcIiBpbiB2YXJzID8gdmFycy5waW5UeXBlIDogX2dldFByb3h5UHJvcChzY3JvbGxlciwgXCJwaW5UeXBlXCIpIHx8IGlzVmlld3BvcnQgJiYgXCJmaXhlZFwiKSA9PT0gXCJmaXhlZFwiLFxuICAgICAgICBjYWxsYmFja3MgPSBbdmFycy5vbkVudGVyLCB2YXJzLm9uTGVhdmUsIHZhcnMub25FbnRlckJhY2ssIHZhcnMub25MZWF2ZUJhY2tdLFxuICAgICAgICB0b2dnbGVBY3Rpb25zID0gaXNUb2dnbGUgJiYgdmFycy50b2dnbGVBY3Rpb25zLnNwbGl0KFwiIFwiKSxcbiAgICAgICAgbWFya2VycyA9IFwibWFya2Vyc1wiIGluIHZhcnMgPyB2YXJzLm1hcmtlcnMgOiBfZGVmYXVsdHMubWFya2VycyxcbiAgICAgICAgYm9yZGVyV2lkdGggPSBpc1ZpZXdwb3J0ID8gMCA6IHBhcnNlRmxvYXQoX2dldENvbXB1dGVkU3R5bGUoc2Nyb2xsZXIpW1wiYm9yZGVyXCIgKyBkaXJlY3Rpb24ucDIgKyBfV2lkdGhdKSB8fCAwLFxuICAgICAgICBzZWxmID0gdGhpcyxcbiAgICAgICAgb25SZWZyZXNoSW5pdCA9IHZhcnMub25SZWZyZXNoSW5pdCAmJiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdmFycy5vblJlZnJlc2hJbml0KHNlbGYpO1xuICAgIH0sXG4gICAgICAgIGdldFNjcm9sbGVyU2l6ZSA9IF9nZXRTaXplRnVuYyhzY3JvbGxlciwgaXNWaWV3cG9ydCwgZGlyZWN0aW9uKSxcbiAgICAgICAgZ2V0U2Nyb2xsZXJPZmZzZXRzID0gX2dldE9mZnNldHNGdW5jKHNjcm9sbGVyLCBpc1ZpZXdwb3J0KSxcbiAgICAgICAgbGFzdFNuYXAgPSAwLFxuICAgICAgICBzY3JvbGxGdW5jID0gX2dldFNjcm9sbEZ1bmMoc2Nyb2xsZXIsIGRpcmVjdGlvbiksXG4gICAgICAgIHR3ZWVuVG8sXG4gICAgICAgIHBpbkNhY2hlLFxuICAgICAgICBzbmFwRnVuYyxcbiAgICAgICAgc2Nyb2xsMSxcbiAgICAgICAgc2Nyb2xsMixcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGVuZCxcbiAgICAgICAgbWFya2VyU3RhcnQsXG4gICAgICAgIG1hcmtlckVuZCxcbiAgICAgICAgbWFya2VyU3RhcnRUcmlnZ2VyLFxuICAgICAgICBtYXJrZXJFbmRUcmlnZ2VyLFxuICAgICAgICBtYXJrZXJWYXJzLFxuICAgICAgICBjaGFuZ2UsXG4gICAgICAgIHBpbk9yaWdpbmFsU3RhdGUsXG4gICAgICAgIHBpbkFjdGl2ZVN0YXRlLFxuICAgICAgICBwaW5TdGF0ZSxcbiAgICAgICAgc3BhY2VyLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIHBpbkdldHRlcixcbiAgICAgICAgcGluU2V0dGVyLFxuICAgICAgICBwaW5TdGFydCxcbiAgICAgICAgcGluQ2hhbmdlLFxuICAgICAgICBzcGFjaW5nU3RhcnQsXG4gICAgICAgIHNwYWNlclN0YXRlLFxuICAgICAgICBtYXJrZXJTdGFydFNldHRlcixcbiAgICAgICAgbWFya2VyRW5kU2V0dGVyLFxuICAgICAgICBjcyxcbiAgICAgICAgc25hcDEsXG4gICAgICAgIHNuYXAyLFxuICAgICAgICBzY3J1YlR3ZWVuLFxuICAgICAgICBzY3J1YlNtb290aCxcbiAgICAgICAgc25hcER1ckNsYW1wLFxuICAgICAgICBzbmFwRGVsYXllZENhbGwsXG4gICAgICAgIHByZXZQcm9ncmVzcyxcbiAgICAgICAgcHJldlNjcm9sbCxcbiAgICAgICAgcHJldkFuaW1Qcm9ncmVzcyxcbiAgICAgICAgY2FNYXJrZXJTZXR0ZXI7XG5cbiAgICBzZWxmLm1lZGlhID0gX2NyZWF0aW5nTWVkaWE7XG4gICAgc2VsZi5fZGlyID0gZGlyZWN0aW9uO1xuICAgIGFudGljaXBhdGVQaW4gKj0gNDU7XG4gICAgc2VsZi5zY3JvbGxlciA9IHNjcm9sbGVyO1xuICAgIHNlbGYuc2Nyb2xsID0gY29udGFpbmVyQW5pbWF0aW9uID8gY29udGFpbmVyQW5pbWF0aW9uLnRpbWUuYmluZChjb250YWluZXJBbmltYXRpb24pIDogc2Nyb2xsRnVuYztcbiAgICBzY3JvbGwxID0gc2Nyb2xsRnVuYygpO1xuICAgIHNlbGYudmFycyA9IHZhcnM7XG4gICAgYW5pbWF0aW9uID0gYW5pbWF0aW9uIHx8IHZhcnMuYW5pbWF0aW9uO1xuICAgIFwicmVmcmVzaFByaW9yaXR5XCIgaW4gdmFycyAmJiAoX3NvcnQgPSAxKTtcbiAgICBzY3JvbGxlckNhY2hlLnR3ZWVuU2Nyb2xsID0gc2Nyb2xsZXJDYWNoZS50d2VlblNjcm9sbCB8fCB7XG4gICAgICB0b3A6IF9nZXRUd2VlbkNyZWF0b3Ioc2Nyb2xsZXIsIF92ZXJ0aWNhbCksXG4gICAgICBsZWZ0OiBfZ2V0VHdlZW5DcmVhdG9yKHNjcm9sbGVyLCBfaG9yaXpvbnRhbClcbiAgICB9O1xuICAgIHNlbGYudHdlZW5UbyA9IHR3ZWVuVG8gPSBzY3JvbGxlckNhY2hlLnR3ZWVuU2Nyb2xsW2RpcmVjdGlvbi5wXTtcblxuICAgIGlmIChhbmltYXRpb24pIHtcbiAgICAgIGFuaW1hdGlvbi52YXJzLmxhenkgPSBmYWxzZTtcbiAgICAgIGFuaW1hdGlvbi5faW5pdHRlZCB8fCBhbmltYXRpb24udmFycy5pbW1lZGlhdGVSZW5kZXIgIT09IGZhbHNlICYmIHZhcnMuaW1tZWRpYXRlUmVuZGVyICE9PSBmYWxzZSAmJiBhbmltYXRpb24ucmVuZGVyKDAsIHRydWUsIHRydWUpO1xuICAgICAgc2VsZi5hbmltYXRpb24gPSBhbmltYXRpb24ucGF1c2UoKTtcbiAgICAgIGFuaW1hdGlvbi5zY3JvbGxUcmlnZ2VyID0gc2VsZjtcbiAgICAgIHNjcnViU21vb3RoID0gX2lzTnVtYmVyKHNjcnViKSAmJiBzY3J1YjtcbiAgICAgIHNjcnViU21vb3RoICYmIChzY3J1YlR3ZWVuID0gZ3NhcC50byhhbmltYXRpb24sIHtcbiAgICAgICAgZWFzZTogXCJwb3dlcjNcIixcbiAgICAgICAgZHVyYXRpb246IHNjcnViU21vb3RoLFxuICAgICAgICBvbkNvbXBsZXRlOiBmdW5jdGlvbiBvbkNvbXBsZXRlKCkge1xuICAgICAgICAgIHJldHVybiBvblNjcnViQ29tcGxldGUgJiYgb25TY3J1YkNvbXBsZXRlKHNlbGYpO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgICBzbmFwMSA9IDA7XG4gICAgICBpZCB8fCAoaWQgPSBhbmltYXRpb24udmFycy5pZCk7XG4gICAgfVxuXG4gICAgX3RyaWdnZXJzLnB1c2goc2VsZik7XG5cbiAgICBpZiAoc25hcCkge1xuICAgICAgaWYgKCFfaXNPYmplY3Qoc25hcCkgfHwgc25hcC5wdXNoKSB7XG4gICAgICAgIHNuYXAgPSB7XG4gICAgICAgICAgc25hcFRvOiBzbmFwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIFwic2Nyb2xsQmVoYXZpb3JcIiBpbiBfYm9keS5zdHlsZSAmJiBnc2FwLnNldChpc1ZpZXdwb3J0ID8gW19ib2R5LCBfZG9jRWxdIDogc2Nyb2xsZXIsIHtcbiAgICAgICAgc2Nyb2xsQmVoYXZpb3I6IFwiYXV0b1wiXG4gICAgICB9KTsgLy8gc21vb3RoIHNjcm9sbGluZyBkb2Vzbid0IHdvcmsgd2l0aCBzbmFwLlxuXG4gICAgICBzbmFwRnVuYyA9IF9pc0Z1bmN0aW9uKHNuYXAuc25hcFRvKSA/IHNuYXAuc25hcFRvIDogc25hcC5zbmFwVG8gPT09IFwibGFiZWxzXCIgPyBfZ2V0Q2xvc2VzdExhYmVsKGFuaW1hdGlvbikgOiBzbmFwLnNuYXBUbyA9PT0gXCJsYWJlbHNEaXJlY3Rpb25hbFwiID8gX2dldExhYmVsQXREaXJlY3Rpb24oYW5pbWF0aW9uKSA6IHNuYXAuZGlyZWN0aW9uYWwgIT09IGZhbHNlID8gZnVuY3Rpb24gKHZhbHVlLCBzdCkge1xuICAgICAgICByZXR1cm4gX3NuYXBEaXJlY3Rpb25hbChzbmFwLnNuYXBUbykodmFsdWUsIHN0LmRpcmVjdGlvbik7XG4gICAgICB9IDogZ3NhcC51dGlscy5zbmFwKHNuYXAuc25hcFRvKTtcbiAgICAgIHNuYXBEdXJDbGFtcCA9IHNuYXAuZHVyYXRpb24gfHwge1xuICAgICAgICBtaW46IDAuMSxcbiAgICAgICAgbWF4OiAyXG4gICAgICB9O1xuICAgICAgc25hcER1ckNsYW1wID0gX2lzT2JqZWN0KHNuYXBEdXJDbGFtcCkgPyBfY2xhbXAoc25hcER1ckNsYW1wLm1pbiwgc25hcER1ckNsYW1wLm1heCkgOiBfY2xhbXAoc25hcER1ckNsYW1wLCBzbmFwRHVyQ2xhbXApO1xuICAgICAgc25hcERlbGF5ZWRDYWxsID0gZ3NhcC5kZWxheWVkQ2FsbChzbmFwLmRlbGF5IHx8IHNjcnViU21vb3RoIC8gMiB8fCAwLjEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKHNlbGYuZ2V0VmVsb2NpdHkoKSkgPCAxMCAmJiAhX3BvaW50ZXJJc0Rvd24gJiYgbGFzdFNuYXAgIT09IHNjcm9sbEZ1bmMoKSkge1xuICAgICAgICAgIHZhciB0b3RhbFByb2dyZXNzID0gYW5pbWF0aW9uICYmICFpc1RvZ2dsZSA/IGFuaW1hdGlvbi50b3RhbFByb2dyZXNzKCkgOiBzZWxmLnByb2dyZXNzLFxuICAgICAgICAgICAgICB2ZWxvY2l0eSA9ICh0b3RhbFByb2dyZXNzIC0gc25hcDIpIC8gKF9nZXRUaW1lKCkgLSBfdGltZTIpICogMTAwMCB8fCAwLFxuICAgICAgICAgICAgICBjaGFuZ2UxID0gZ3NhcC51dGlscy5jbGFtcCgtc2VsZi5wcm9ncmVzcywgMSAtIHNlbGYucHJvZ3Jlc3MsIF9hYnModmVsb2NpdHkgLyAyKSAqIHZlbG9jaXR5IC8gMC4xODUpLFxuICAgICAgICAgICAgICBuYXR1cmFsRW5kID0gc2VsZi5wcm9ncmVzcyArIChzbmFwLmluZXJ0aWEgPT09IGZhbHNlID8gMCA6IGNoYW5nZTEpLFxuICAgICAgICAgICAgICBlbmRWYWx1ZSA9IF9jbGFtcCgwLCAxLCBzbmFwRnVuYyhuYXR1cmFsRW5kLCBzZWxmKSksXG4gICAgICAgICAgICAgIHNjcm9sbCA9IHNjcm9sbEZ1bmMoKSxcbiAgICAgICAgICAgICAgZW5kU2Nyb2xsID0gTWF0aC5yb3VuZChzdGFydCArIGVuZFZhbHVlICogY2hhbmdlKSxcbiAgICAgICAgICAgICAgX3NuYXAgPSBzbmFwLFxuICAgICAgICAgICAgICBvblN0YXJ0ID0gX3NuYXAub25TdGFydCxcbiAgICAgICAgICAgICAgX29uSW50ZXJydXB0ID0gX3NuYXAub25JbnRlcnJ1cHQsXG4gICAgICAgICAgICAgIF9vbkNvbXBsZXRlID0gX3NuYXAub25Db21wbGV0ZSxcbiAgICAgICAgICAgICAgdHdlZW4gPSB0d2VlblRvLnR3ZWVuO1xuXG4gICAgICAgICAgaWYgKHNjcm9sbCA8PSBlbmQgJiYgc2Nyb2xsID49IHN0YXJ0ICYmIGVuZFNjcm9sbCAhPT0gc2Nyb2xsKSB7XG4gICAgICAgICAgICBpZiAodHdlZW4gJiYgIXR3ZWVuLl9pbml0dGVkICYmIHR3ZWVuLmRhdGEgPD0gX2FicyhlbmRTY3JvbGwgLSBzY3JvbGwpKSB7XG4gICAgICAgICAgICAgIC8vIHRoZXJlJ3MgYW4gb3ZlcmxhcHBpbmcgc25hcCEgU28gd2UgbXVzdCBmaWd1cmUgb3V0IHdoaWNoIG9uZSBpcyBjbG9zZXIgYW5kIGxldCB0aGF0IHR3ZWVuIGxpdmUuXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNuYXAuaW5lcnRpYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgY2hhbmdlMSA9IGVuZFZhbHVlIC0gc2VsZi5wcm9ncmVzcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHdlZW5UbyhlbmRTY3JvbGwsIHtcbiAgICAgICAgICAgICAgZHVyYXRpb246IHNuYXBEdXJDbGFtcChfYWJzKE1hdGgubWF4KF9hYnMobmF0dXJhbEVuZCAtIHRvdGFsUHJvZ3Jlc3MpLCBfYWJzKGVuZFZhbHVlIC0gdG90YWxQcm9ncmVzcykpICogMC4xODUgLyB2ZWxvY2l0eSAvIDAuMDUgfHwgMCkpLFxuICAgICAgICAgICAgICBlYXNlOiBzbmFwLmVhc2UgfHwgXCJwb3dlcjNcIixcbiAgICAgICAgICAgICAgZGF0YTogX2FicyhlbmRTY3JvbGwgLSBzY3JvbGwpLFxuICAgICAgICAgICAgICAvLyByZWNvcmQgdGhlIGRpc3RhbmNlIHNvIHRoYXQgaWYgYW5vdGhlciBzbmFwIHR3ZWVuIG9jY3VycyAoY29uZmxpY3QpIHdlIGNhbiBwcmlvcml0aXplIHRoZSBjbG9zZXN0IHNuYXAuXG4gICAgICAgICAgICAgIG9uSW50ZXJydXB0OiBmdW5jdGlvbiBvbkludGVycnVwdCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc25hcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSkgJiYgX29uSW50ZXJydXB0ICYmIF9vbkludGVycnVwdChzZWxmKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgb25Db21wbGV0ZTogZnVuY3Rpb24gb25Db21wbGV0ZSgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIGxhc3RTbmFwID0gc2Nyb2xsRnVuYygpO1xuICAgICAgICAgICAgICAgIHNuYXAxID0gc25hcDIgPSBhbmltYXRpb24gJiYgIWlzVG9nZ2xlID8gYW5pbWF0aW9uLnRvdGFsUHJvZ3Jlc3MoKSA6IHNlbGYucHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgb25TbmFwQ29tcGxldGUgJiYgb25TbmFwQ29tcGxldGUoc2VsZik7XG4gICAgICAgICAgICAgICAgX29uQ29tcGxldGUgJiYgX29uQ29tcGxldGUoc2VsZik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHNjcm9sbCwgY2hhbmdlMSAqIGNoYW5nZSwgZW5kU2Nyb2xsIC0gc2Nyb2xsIC0gY2hhbmdlMSAqIGNoYW5nZSk7XG4gICAgICAgICAgICBvblN0YXJ0ICYmIG9uU3RhcnQoc2VsZiwgdHdlZW5Uby50d2Vlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNlbGYuaXNBY3RpdmUpIHtcbiAgICAgICAgICBzbmFwRGVsYXllZENhbGwucmVzdGFydCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSkucGF1c2UoKTtcbiAgICB9XG5cbiAgICBpZCAmJiAoX2lkc1tpZF0gPSBzZWxmKTtcbiAgICB0cmlnZ2VyID0gc2VsZi50cmlnZ2VyID0gX2dldFRhcmdldCh0cmlnZ2VyIHx8IHBpbik7XG4gICAgcGluID0gcGluID09PSB0cnVlID8gdHJpZ2dlciA6IF9nZXRUYXJnZXQocGluKTtcbiAgICBfaXNTdHJpbmcodG9nZ2xlQ2xhc3MpICYmICh0b2dnbGVDbGFzcyA9IHtcbiAgICAgIHRhcmdldHM6IHRyaWdnZXIsXG4gICAgICBjbGFzc05hbWU6IHRvZ2dsZUNsYXNzXG4gICAgfSk7XG5cbiAgICBpZiAocGluKSB7XG4gICAgICBwaW5TcGFjaW5nID09PSBmYWxzZSB8fCBwaW5TcGFjaW5nID09PSBfbWFyZ2luIHx8IChwaW5TcGFjaW5nID0gIXBpblNwYWNpbmcgJiYgX2dldENvbXB1dGVkU3R5bGUocGluLnBhcmVudE5vZGUpLmRpc3BsYXkgPT09IFwiZmxleFwiID8gZmFsc2UgOiBfcGFkZGluZyk7IC8vIGlmIHRoZSBwYXJlbnQgaXMgZGlzcGxheTogZmxleCwgZG9uJ3QgYXBwbHkgcGluU3BhY2luZyBieSBkZWZhdWx0LlxuXG4gICAgICBzZWxmLnBpbiA9IHBpbjtcbiAgICAgIHZhcnMuZm9yY2UzRCAhPT0gZmFsc2UgJiYgZ3NhcC5zZXQocGluLCB7XG4gICAgICAgIGZvcmNlM0Q6IHRydWVcbiAgICAgIH0pO1xuICAgICAgcGluQ2FjaGUgPSBnc2FwLmNvcmUuZ2V0Q2FjaGUocGluKTtcblxuICAgICAgaWYgKCFwaW5DYWNoZS5zcGFjZXIpIHtcbiAgICAgICAgLy8gcmVjb3JkIHRoZSBzcGFjZXIgYW5kIHBpbk9yaWdpbmFsU3RhdGUgb24gdGhlIGNhY2hlIGluIGNhc2Ugc29tZW9uZSB0cmllcyBwaW5uaW5nIHRoZSBzYW1lIGVsZW1lbnQgd2l0aCBNVUxUSVBMRSBTY3JvbGxUcmlnZ2VycyAtIHdlIGRvbid0IHdhbnQgdG8gaGF2ZSBtdWx0aXBsZSBzcGFjZXJzIG9yIHJlY29yZCB0aGUgXCJvcmlnaW5hbFwiIHBpbiBzdGF0ZSBhZnRlciBpdCBoYXMgYWxyZWFkeSBiZWVuIGFmZmVjdGVkIGJ5IGFub3RoZXIgU2Nyb2xsVHJpZ2dlci5cbiAgICAgICAgaWYgKHBpblNwYWNlcikge1xuICAgICAgICAgIHBpblNwYWNlciA9IF9nZXRUYXJnZXQocGluU3BhY2VyKTtcbiAgICAgICAgICBwaW5TcGFjZXIgJiYgIXBpblNwYWNlci5ub2RlVHlwZSAmJiAocGluU3BhY2VyID0gcGluU3BhY2VyLmN1cnJlbnQgfHwgcGluU3BhY2VyLm5hdGl2ZUVsZW1lbnQpOyAvLyBmb3IgUmVhY3QgJiBBbmd1bGFyXG5cbiAgICAgICAgICBwaW5DYWNoZS5zcGFjZXJJc05hdGl2ZSA9ICEhcGluU3BhY2VyO1xuICAgICAgICAgIHBpblNwYWNlciAmJiAocGluQ2FjaGUuc3BhY2VyU3RhdGUgPSBfZ2V0U3RhdGUocGluU3BhY2VyKSk7XG4gICAgICAgIH1cblxuICAgICAgICBwaW5DYWNoZS5zcGFjZXIgPSBzcGFjZXIgPSBwaW5TcGFjZXIgfHwgX2RvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBzcGFjZXIuY2xhc3NMaXN0LmFkZChcInBpbi1zcGFjZXJcIik7XG4gICAgICAgIGlkICYmIHNwYWNlci5jbGFzc0xpc3QuYWRkKFwicGluLXNwYWNlci1cIiArIGlkKTtcbiAgICAgICAgcGluQ2FjaGUucGluU3RhdGUgPSBwaW5PcmlnaW5hbFN0YXRlID0gX2dldFN0YXRlKHBpbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwaW5PcmlnaW5hbFN0YXRlID0gcGluQ2FjaGUucGluU3RhdGU7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuc3BhY2VyID0gc3BhY2VyID0gcGluQ2FjaGUuc3BhY2VyO1xuICAgICAgY3MgPSBfZ2V0Q29tcHV0ZWRTdHlsZShwaW4pO1xuICAgICAgc3BhY2luZ1N0YXJ0ID0gY3NbcGluU3BhY2luZyArIGRpcmVjdGlvbi5vczJdO1xuICAgICAgcGluR2V0dGVyID0gZ3NhcC5nZXRQcm9wZXJ0eShwaW4pO1xuICAgICAgcGluU2V0dGVyID0gZ3NhcC5xdWlja1NldHRlcihwaW4sIGRpcmVjdGlvbi5hLCBfcHgpOyAvLyBwaW4uZmlyc3RDaGlsZCAmJiAhX21heFNjcm9sbChwaW4sIGRpcmVjdGlvbikgJiYgKHBpbi5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCIpOyAvLyBwcm90ZWN0cyBmcm9tIGNvbGxhcHNpbmcgbWFyZ2lucywgYnV0IGNhbiBoYXZlIHVuaW50ZW5kZWQgY29uc2VxdWVuY2VzIGFzIGRlbW9uc3RyYXRlZCBoZXJlOiBodHRwczovL2NvZGVwZW4uaW8vR3JlZW5Tb2NrL3Blbi8xZTQyYzdhNzNiZmE0MDlkMmNmMWUxODRlN2E0MjQ4ZCBzbyBpdCB3YXMgcmVtb3ZlZCBpbiBmYXZvciBvZiBqdXN0IHRlbGxpbmcgcGVvcGxlIHRvIHNldCB1cCB0aGVpciBDU1MgdG8gYXZvaWQgdGhlIGNvbGxhcHNpbmcgbWFyZ2lucyAob3ZlcmZsb3c6IGhpZGRlbiB8IGF1dG8gaXMganVzdCBvbmUgb3B0aW9uLiBBbm90aGVyIGlzIGJvcmRlci10b3A6IDFweCBzb2xpZCB0cmFuc3BhcmVudCkuXG5cbiAgICAgIF9zd2FwUGluSW4ocGluLCBzcGFjZXIsIGNzKTtcblxuICAgICAgcGluU3RhdGUgPSBfZ2V0U3RhdGUocGluKTtcbiAgICB9XG5cbiAgICBpZiAobWFya2Vycykge1xuICAgICAgbWFya2VyVmFycyA9IF9pc09iamVjdChtYXJrZXJzKSA/IF9zZXREZWZhdWx0cyhtYXJrZXJzLCBfbWFya2VyRGVmYXVsdHMpIDogX21hcmtlckRlZmF1bHRzO1xuICAgICAgbWFya2VyU3RhcnRUcmlnZ2VyID0gX2NyZWF0ZU1hcmtlcihcInNjcm9sbGVyLXN0YXJ0XCIsIGlkLCBzY3JvbGxlciwgZGlyZWN0aW9uLCBtYXJrZXJWYXJzLCAwKTtcbiAgICAgIG1hcmtlckVuZFRyaWdnZXIgPSBfY3JlYXRlTWFya2VyKFwic2Nyb2xsZXItZW5kXCIsIGlkLCBzY3JvbGxlciwgZGlyZWN0aW9uLCBtYXJrZXJWYXJzLCAwLCBtYXJrZXJTdGFydFRyaWdnZXIpO1xuICAgICAgb2Zmc2V0ID0gbWFya2VyU3RhcnRUcmlnZ2VyW1wib2Zmc2V0XCIgKyBkaXJlY3Rpb24ub3AuZDJdO1xuICAgICAgbWFya2VyU3RhcnQgPSBfY3JlYXRlTWFya2VyKFwic3RhcnRcIiwgaWQsIHNjcm9sbGVyLCBkaXJlY3Rpb24sIG1hcmtlclZhcnMsIG9mZnNldCwgMCwgY29udGFpbmVyQW5pbWF0aW9uKTtcbiAgICAgIG1hcmtlckVuZCA9IF9jcmVhdGVNYXJrZXIoXCJlbmRcIiwgaWQsIHNjcm9sbGVyLCBkaXJlY3Rpb24sIG1hcmtlclZhcnMsIG9mZnNldCwgMCwgY29udGFpbmVyQW5pbWF0aW9uKTtcbiAgICAgIGNvbnRhaW5lckFuaW1hdGlvbiAmJiAoY2FNYXJrZXJTZXR0ZXIgPSBnc2FwLnF1aWNrU2V0dGVyKFttYXJrZXJTdGFydCwgbWFya2VyRW5kXSwgZGlyZWN0aW9uLmEsIF9weCkpO1xuXG4gICAgICBpZiAoIXVzZUZpeGVkUG9zaXRpb24gJiYgIShfcHJveGllcy5sZW5ndGggJiYgX2dldFByb3h5UHJvcChzY3JvbGxlciwgXCJmaXhlZE1hcmtlcnNcIikgPT09IHRydWUpKSB7XG4gICAgICAgIF9tYWtlUG9zaXRpb25hYmxlKGlzVmlld3BvcnQgPyBfYm9keSA6IHNjcm9sbGVyKTtcblxuICAgICAgICBnc2FwLnNldChbbWFya2VyU3RhcnRUcmlnZ2VyLCBtYXJrZXJFbmRUcmlnZ2VyXSwge1xuICAgICAgICAgIGZvcmNlM0Q6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIG1hcmtlclN0YXJ0U2V0dGVyID0gZ3NhcC5xdWlja1NldHRlcihtYXJrZXJTdGFydFRyaWdnZXIsIGRpcmVjdGlvbi5hLCBfcHgpO1xuICAgICAgICBtYXJrZXJFbmRTZXR0ZXIgPSBnc2FwLnF1aWNrU2V0dGVyKG1hcmtlckVuZFRyaWdnZXIsIGRpcmVjdGlvbi5hLCBfcHgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb250YWluZXJBbmltYXRpb24pIHtcbiAgICAgIHZhciBvbGRPblVwZGF0ZSA9IGNvbnRhaW5lckFuaW1hdGlvbi52YXJzLm9uVXBkYXRlLFxuICAgICAgICAgIG9sZFBhcmFtcyA9IGNvbnRhaW5lckFuaW1hdGlvbi52YXJzLm9uVXBkYXRlUGFyYW1zO1xuICAgICAgY29udGFpbmVyQW5pbWF0aW9uLmV2ZW50Q2FsbGJhY2soXCJvblVwZGF0ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYudXBkYXRlKDAsIDAsIDEpO1xuICAgICAgICBvbGRPblVwZGF0ZSAmJiBvbGRPblVwZGF0ZS5hcHBseShvbGRQYXJhbXMgfHwgW10pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2VsZi5wcmV2aW91cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdHJpZ2dlcnNbX3RyaWdnZXJzLmluZGV4T2Yoc2VsZikgLSAxXTtcbiAgICB9O1xuXG4gICAgc2VsZi5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF90cmlnZ2Vyc1tfdHJpZ2dlcnMuaW5kZXhPZihzZWxmKSArIDFdO1xuICAgIH07XG5cbiAgICBzZWxmLnJldmVydCA9IGZ1bmN0aW9uIChyZXZlcnQpIHtcbiAgICAgIHZhciByID0gcmV2ZXJ0ICE9PSBmYWxzZSB8fCAhc2VsZi5lbmFibGVkLFxuICAgICAgICAgIHByZXZSZWZyZXNoaW5nID0gX3JlZnJlc2hpbmc7XG5cbiAgICAgIGlmIChyICE9PSBzZWxmLmlzUmV2ZXJ0ZWQpIHtcbiAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICBzZWxmLnNjcm9sbC5yZWMgfHwgKHNlbGYuc2Nyb2xsLnJlYyA9IHNjcm9sbEZ1bmMoKSk7XG4gICAgICAgICAgcHJldlNjcm9sbCA9IE1hdGgubWF4KHNjcm9sbEZ1bmMoKSwgc2VsZi5zY3JvbGwucmVjIHx8IDApOyAvLyByZWNvcmQgdGhlIHNjcm9sbCBzbyB3ZSBjYW4gcmV2ZXJ0IGxhdGVyIChyZXBvc2l0aW9uaW5nL3Bpbm5pbmcgdGhpbmdzIGNhbiBhZmZlY3Qgc2Nyb2xsIHBvc2l0aW9uKS4gSW4gdGhlIHN0YXRpYyByZWZyZXNoKCkgbWV0aG9kLCB3ZSBmaXJzdCByZWNvcmQgYWxsIHRoZSBzY3JvbGwgcG9zaXRpb25zIGFzIGEgcmVmZXJlbmNlLlxuXG4gICAgICAgICAgcHJldlByb2dyZXNzID0gc2VsZi5wcm9ncmVzcztcbiAgICAgICAgICBwcmV2QW5pbVByb2dyZXNzID0gYW5pbWF0aW9uICYmIGFuaW1hdGlvbi5wcm9ncmVzcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgbWFya2VyU3RhcnQgJiYgW21hcmtlclN0YXJ0LCBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0VHJpZ2dlciwgbWFya2VyRW5kVHJpZ2dlcl0uZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgICAgICAgIHJldHVybiBtLnN0eWxlLmRpc3BsYXkgPSByID8gXCJub25lXCIgOiBcImJsb2NrXCI7XG4gICAgICAgIH0pO1xuICAgICAgICByICYmIChfcmVmcmVzaGluZyA9IDEpO1xuICAgICAgICBzZWxmLnVwZGF0ZShyKTsgLy8gbWFrZSBzdXJlIHRoZSBwaW4gaXMgYmFjayBpbiBpdHMgb3JpZ2luYWwgcG9zaXRpb24gc28gdGhhdCBhbGwgdGhlIG1lYXN1cmVtZW50cyBhcmUgY29ycmVjdC5cblxuICAgICAgICBfcmVmcmVzaGluZyA9IHByZXZSZWZyZXNoaW5nO1xuICAgICAgICBwaW4gJiYgKHIgPyBfc3dhcFBpbk91dChwaW4sIHNwYWNlciwgcGluT3JpZ2luYWxTdGF0ZSkgOiAoIXBpblJlcGFyZW50IHx8ICFzZWxmLmlzQWN0aXZlKSAmJiBfc3dhcFBpbkluKHBpbiwgc3BhY2VyLCBfZ2V0Q29tcHV0ZWRTdHlsZShwaW4pLCBzcGFjZXJTdGF0ZSkpO1xuICAgICAgICBzZWxmLmlzUmV2ZXJ0ZWQgPSByO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxmLnJlZnJlc2ggPSBmdW5jdGlvbiAoc29mdCwgZm9yY2UpIHtcbiAgICAgIGlmICgoX3JlZnJlc2hpbmcgfHwgIXNlbGYuZW5hYmxlZCkgJiYgIWZvcmNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHBpbiAmJiBzb2Z0ICYmIF9sYXN0U2Nyb2xsVGltZSkge1xuICAgICAgICBfYWRkTGlzdGVuZXIoU2Nyb2xsVHJpZ2dlciwgXCJzY3JvbGxFbmRcIiwgX3NvZnRSZWZyZXNoKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF9yZWZyZXNoaW5nID0gMTtcbiAgICAgIHNjcnViVHdlZW4gJiYgc2NydWJUd2Vlbi5wYXVzZSgpO1xuICAgICAgaW52YWxpZGF0ZU9uUmVmcmVzaCAmJiBhbmltYXRpb24gJiYgYW5pbWF0aW9uLnRpbWUoLTAuMDEsIHRydWUpLmludmFsaWRhdGUoKTtcbiAgICAgIHNlbGYuaXNSZXZlcnRlZCB8fCBzZWxmLnJldmVydCgpO1xuXG4gICAgICB2YXIgc2l6ZSA9IGdldFNjcm9sbGVyU2l6ZSgpLFxuICAgICAgICAgIHNjcm9sbGVyQm91bmRzID0gZ2V0U2Nyb2xsZXJPZmZzZXRzKCksXG4gICAgICAgICAgbWF4ID0gY29udGFpbmVyQW5pbWF0aW9uID8gY29udGFpbmVyQW5pbWF0aW9uLmR1cmF0aW9uKCkgOiBfbWF4U2Nyb2xsKHNjcm9sbGVyLCBkaXJlY3Rpb24pLFxuICAgICAgICAgIG9mZnNldCA9IDAsXG4gICAgICAgICAgb3RoZXJQaW5PZmZzZXQgPSAwLFxuICAgICAgICAgIHBhcnNlZEVuZCA9IHZhcnMuZW5kLFxuICAgICAgICAgIHBhcnNlZEVuZFRyaWdnZXIgPSB2YXJzLmVuZFRyaWdnZXIgfHwgdHJpZ2dlcixcbiAgICAgICAgICBwYXJzZWRTdGFydCA9IHZhcnMuc3RhcnQgfHwgKHZhcnMuc3RhcnQgPT09IDAgfHwgIXRyaWdnZXIgPyAwIDogcGluID8gXCIwIDBcIiA6IFwiMCAxMDAlXCIpLFxuICAgICAgICAgIHBpbm5lZENvbnRhaW5lciA9IHZhcnMucGlubmVkQ29udGFpbmVyICYmIF9nZXRUYXJnZXQodmFycy5waW5uZWRDb250YWluZXIpLFxuICAgICAgICAgIHRyaWdnZXJJbmRleCA9IHRyaWdnZXIgJiYgTWF0aC5tYXgoMCwgX3RyaWdnZXJzLmluZGV4T2Yoc2VsZikpIHx8IDAsXG4gICAgICAgICAgaSA9IHRyaWdnZXJJbmRleCxcbiAgICAgICAgICBjcyxcbiAgICAgICAgICBib3VuZHMsXG4gICAgICAgICAgc2Nyb2xsLFxuICAgICAgICAgIGlzVmVydGljYWwsXG4gICAgICAgICAgb3ZlcnJpZGUsXG4gICAgICAgICAgY3VyVHJpZ2dlcixcbiAgICAgICAgICBjdXJQaW4sXG4gICAgICAgICAgb3Bwb3NpdGVTY3JvbGwsXG4gICAgICAgICAgaW5pdHRlZCxcbiAgICAgICAgICByZXZlcnRlZFBpbnM7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgLy8gdXNlciBtaWdodCB0cnkgdG8gcGluIHRoZSBzYW1lIGVsZW1lbnQgbW9yZSB0aGFuIG9uY2UsIHNvIHdlIG11c3QgZmluZCBhbnkgcHJpb3IgdHJpZ2dlcnMgd2l0aCB0aGUgc2FtZSBwaW4sIHJldmVydCB0aGVtLCBhbmQgZGV0ZXJtaW5lIGhvdyBsb25nIHRoZXkncmUgcGlubmluZyBzbyB0aGF0IHdlIGNhbiBvZmZzZXQgdGhpbmdzIGFwcHJvcHJpYXRlbHkuIE1ha2Ugc3VyZSB3ZSByZXZlcnQgZnJvbSBsYXN0IHRvIGZpcnN0IHNvIHRoYXQgdGhpbmdzIFwicmV3aW5kXCIgcHJvcGVybHkuXG4gICAgICAgIGN1clRyaWdnZXIgPSBfdHJpZ2dlcnNbaV07XG4gICAgICAgIGN1clRyaWdnZXIuZW5kIHx8IGN1clRyaWdnZXIucmVmcmVzaCgwLCAxKSB8fCAoX3JlZnJlc2hpbmcgPSAxKTsgLy8gaWYgaXQncyBhIHRpbWVsaW5lLWJhc2VkIHRyaWdnZXIgdGhhdCBoYXNuJ3QgYmVlbiBmdWxseSBpbml0aWFsaXplZCB5ZXQgYmVjYXVzZSBpdCdzIHdhaXRpbmcgZm9yIDEgdGljaywganVzdCBmb3JjZSB0aGUgcmVmcmVzaCgpIGhlcmUsIG90aGVyd2lzZSBpZiBpdCBjb250YWlucyBhIHBpbiB0aGF0J3Mgc3VwcG9zZWQgdG8gYWZmZWN0IG90aGVyIFNjcm9sbFRyaWdnZXJzIGZ1cnRoZXIgZG93biB0aGUgcGFnZSwgdGhleSB3b24ndCBiZSBhZGp1c3RlZCBwcm9wZXJseS5cblxuICAgICAgICBjdXJQaW4gPSBjdXJUcmlnZ2VyLnBpbjtcblxuICAgICAgICBpZiAoY3VyUGluICYmIChjdXJQaW4gPT09IHRyaWdnZXIgfHwgY3VyUGluID09PSBwaW4pICYmICFjdXJUcmlnZ2VyLmlzUmV2ZXJ0ZWQpIHtcbiAgICAgICAgICByZXZlcnRlZFBpbnMgfHwgKHJldmVydGVkUGlucyA9IFtdKTtcbiAgICAgICAgICByZXZlcnRlZFBpbnMudW5zaGlmdChjdXJUcmlnZ2VyKTsgLy8gd2UnbGwgcmV2ZXJ0IGZyb20gZmlyc3QgdG8gbGFzdCB0byBtYWtlIHN1cmUgdGhpbmdzIHJlYWNoIHRoZWlyIGVuZCBzdGF0ZSBwcm9wZXJseVxuXG4gICAgICAgICAgY3VyVHJpZ2dlci5yZXZlcnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfaXNGdW5jdGlvbihwYXJzZWRTdGFydCkgJiYgKHBhcnNlZFN0YXJ0ID0gcGFyc2VkU3RhcnQoc2VsZikpO1xuICAgICAgc3RhcnQgPSBfcGFyc2VQb3NpdGlvbihwYXJzZWRTdGFydCwgdHJpZ2dlciwgc2l6ZSwgZGlyZWN0aW9uLCBzY3JvbGxGdW5jKCksIG1hcmtlclN0YXJ0LCBtYXJrZXJTdGFydFRyaWdnZXIsIHNlbGYsIHNjcm9sbGVyQm91bmRzLCBib3JkZXJXaWR0aCwgdXNlRml4ZWRQb3NpdGlvbiwgbWF4LCBjb250YWluZXJBbmltYXRpb24pIHx8IChwaW4gPyAtMC4wMDEgOiAwKTtcbiAgICAgIF9pc0Z1bmN0aW9uKHBhcnNlZEVuZCkgJiYgKHBhcnNlZEVuZCA9IHBhcnNlZEVuZChzZWxmKSk7XG5cbiAgICAgIGlmIChfaXNTdHJpbmcocGFyc2VkRW5kKSAmJiAhcGFyc2VkRW5kLmluZGV4T2YoXCIrPVwiKSkge1xuICAgICAgICBpZiAofnBhcnNlZEVuZC5pbmRleE9mKFwiIFwiKSkge1xuICAgICAgICAgIHBhcnNlZEVuZCA9IChfaXNTdHJpbmcocGFyc2VkU3RhcnQpID8gcGFyc2VkU3RhcnQuc3BsaXQoXCIgXCIpWzBdIDogXCJcIikgKyBwYXJzZWRFbmQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Zmc2V0ID0gX29mZnNldFRvUHgocGFyc2VkRW5kLnN1YnN0cigyKSwgc2l6ZSk7XG4gICAgICAgICAgcGFyc2VkRW5kID0gX2lzU3RyaW5nKHBhcnNlZFN0YXJ0KSA/IHBhcnNlZFN0YXJ0IDogc3RhcnQgKyBvZmZzZXQ7IC8vIF9wYXJzZVBvc2l0aW9uIHdvbid0IGZhY3RvciBpbiB0aGUgb2Zmc2V0IGlmIHRoZSBzdGFydCBpcyBhIG51bWJlciwgc28gZG8gaXQgaGVyZS5cblxuICAgICAgICAgIHBhcnNlZEVuZFRyaWdnZXIgPSB0cmlnZ2VyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVuZCA9IE1hdGgubWF4KHN0YXJ0LCBfcGFyc2VQb3NpdGlvbihwYXJzZWRFbmQgfHwgKHBhcnNlZEVuZFRyaWdnZXIgPyBcIjEwMCUgMFwiIDogbWF4KSwgcGFyc2VkRW5kVHJpZ2dlciwgc2l6ZSwgZGlyZWN0aW9uLCBzY3JvbGxGdW5jKCkgKyBvZmZzZXQsIG1hcmtlckVuZCwgbWFya2VyRW5kVHJpZ2dlciwgc2VsZiwgc2Nyb2xsZXJCb3VuZHMsIGJvcmRlcldpZHRoLCB1c2VGaXhlZFBvc2l0aW9uLCBtYXgsIGNvbnRhaW5lckFuaW1hdGlvbikpIHx8IC0wLjAwMTtcbiAgICAgIGNoYW5nZSA9IGVuZCAtIHN0YXJ0IHx8IChzdGFydCAtPSAwLjAxKSAmJiAwLjAwMTtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgICBpID0gdHJpZ2dlckluZGV4O1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGN1clRyaWdnZXIgPSBfdHJpZ2dlcnNbaV07XG4gICAgICAgIGN1clBpbiA9IGN1clRyaWdnZXIucGluO1xuXG4gICAgICAgIGlmIChjdXJQaW4gJiYgY3VyVHJpZ2dlci5zdGFydCAtIGN1clRyaWdnZXIuX3BpblB1c2ggPCBzdGFydCAmJiAhY29udGFpbmVyQW5pbWF0aW9uKSB7XG4gICAgICAgICAgY3MgPSBjdXJUcmlnZ2VyLmVuZCAtIGN1clRyaWdnZXIuc3RhcnQ7XG5cbiAgICAgICAgICBpZiAoKGN1clBpbiA9PT0gdHJpZ2dlciB8fCBjdXJQaW4gPT09IHBpbm5lZENvbnRhaW5lcikgJiYgIV9pc051bWJlcihwYXJzZWRTdGFydCkpIHtcbiAgICAgICAgICAgIC8vIG51bWVyaWMgc3RhcnQgdmFsdWVzIHNob3VsZG4ndCBiZSBvZmZzZXQgYXQgYWxsIC0gdHJlYXQgdGhlbSBhcyBhYnNvbHV0ZVxuICAgICAgICAgICAgb2Zmc2V0ICs9IGNzICogKDEgLSBjdXJUcmlnZ2VyLnByb2dyZXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdXJQaW4gPT09IHBpbiAmJiAob3RoZXJQaW5PZmZzZXQgKz0gY3MpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0YXJ0ICs9IG9mZnNldDtcbiAgICAgIGVuZCArPSBvZmZzZXQ7XG4gICAgICBzZWxmLl9waW5QdXNoID0gb3RoZXJQaW5PZmZzZXQ7XG5cbiAgICAgIGlmIChtYXJrZXJTdGFydCAmJiBvZmZzZXQpIHtcbiAgICAgICAgLy8gb2Zmc2V0IHRoZSBtYXJrZXJzIGlmIG5lY2Vzc2FyeVxuICAgICAgICBjcyA9IHt9O1xuICAgICAgICBjc1tkaXJlY3Rpb24uYV0gPSBcIis9XCIgKyBvZmZzZXQ7XG4gICAgICAgIHBpbm5lZENvbnRhaW5lciAmJiAoY3NbZGlyZWN0aW9uLnBdID0gXCItPVwiICsgc2Nyb2xsRnVuYygpKTtcbiAgICAgICAgZ3NhcC5zZXQoW21hcmtlclN0YXJ0LCBtYXJrZXJFbmRdLCBjcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwaW4pIHtcbiAgICAgICAgY3MgPSBfZ2V0Q29tcHV0ZWRTdHlsZShwaW4pO1xuICAgICAgICBpc1ZlcnRpY2FsID0gZGlyZWN0aW9uID09PSBfdmVydGljYWw7XG4gICAgICAgIHNjcm9sbCA9IHNjcm9sbEZ1bmMoKTsgLy8gcmVjYWxjdWxhdGUgYmVjYXVzZSB0aGUgdHJpZ2dlcnMgY2FuIGFmZmVjdCB0aGUgc2Nyb2xsXG5cbiAgICAgICAgcGluU3RhcnQgPSBwYXJzZUZsb2F0KHBpbkdldHRlcihkaXJlY3Rpb24uYSkpICsgb3RoZXJQaW5PZmZzZXQ7XG4gICAgICAgICFtYXggJiYgZW5kID4gMSAmJiAoKGlzVmlld3BvcnQgPyBfYm9keSA6IHNjcm9sbGVyKS5zdHlsZVtcIm92ZXJmbG93LVwiICsgZGlyZWN0aW9uLmFdID0gXCJzY3JvbGxcIik7IC8vIG1ha2VzIHN1cmUgdGhlIHNjcm9sbGVyIGhhcyBhIHNjcm9sbGJhciwgb3RoZXJ3aXNlIGlmIHNvbWV0aGluZyBoYXMgd2lkdGg6IDEwMCUsIGZvciBleGFtcGxlLCBpdCB3b3VsZCBiZSB0b28gYmlnIChleGNsdWRlIHRoZSBzY3JvbGxiYXIpLiBTZWUgaHR0cHM6Ly9ncmVlbnNvY2suY29tL2ZvcnVtcy90b3BpYy8yNTE4Mi1zY3JvbGx0cmlnZ2VyLXdpZHRoLW9mLXBhZ2UtaW5jcmVhc2Utd2hlcmUtbWFya2Vycy1hcmUtc2V0LXRvLWZhbHNlL1xuXG4gICAgICAgIF9zd2FwUGluSW4ocGluLCBzcGFjZXIsIGNzKTtcblxuICAgICAgICBwaW5TdGF0ZSA9IF9nZXRTdGF0ZShwaW4pOyAvLyB0cmFuc2Zvcm1zIHdpbGwgaW50ZXJmZXJlIHdpdGggdGhlIHRvcC9sZWZ0L3JpZ2h0L2JvdHRvbSBwbGFjZW1lbnQsIHNvIHJlbW92ZSB0aGVtIHRlbXBvcmFyaWx5LiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSBmYWN0b3JzIGluIHRyYW5zZm9ybXMuXG5cbiAgICAgICAgYm91bmRzID0gX2dldEJvdW5kcyhwaW4sIHRydWUpO1xuICAgICAgICBvcHBvc2l0ZVNjcm9sbCA9IHVzZUZpeGVkUG9zaXRpb24gJiYgX2dldFNjcm9sbEZ1bmMoc2Nyb2xsZXIsIGlzVmVydGljYWwgPyBfaG9yaXpvbnRhbCA6IF92ZXJ0aWNhbCkoKTtcblxuICAgICAgICBpZiAocGluU3BhY2luZykge1xuICAgICAgICAgIHNwYWNlclN0YXRlID0gW3BpblNwYWNpbmcgKyBkaXJlY3Rpb24ub3MyLCBjaGFuZ2UgKyBvdGhlclBpbk9mZnNldCArIF9weF07XG4gICAgICAgICAgc3BhY2VyU3RhdGUudCA9IHNwYWNlcjtcbiAgICAgICAgICBpID0gcGluU3BhY2luZyA9PT0gX3BhZGRpbmcgPyBfZ2V0U2l6ZShwaW4sIGRpcmVjdGlvbikgKyBjaGFuZ2UgKyBvdGhlclBpbk9mZnNldCA6IDA7XG4gICAgICAgICAgaSAmJiBzcGFjZXJTdGF0ZS5wdXNoKGRpcmVjdGlvbi5kLCBpICsgX3B4KTsgLy8gZm9yIGJveC1zaXppbmc6IGJvcmRlci1ib3ggKG11c3QgaW5jbHVkZSBwYWRkaW5nKS5cblxuICAgICAgICAgIF9zZXRTdGF0ZShzcGFjZXJTdGF0ZSk7XG5cbiAgICAgICAgICB1c2VGaXhlZFBvc2l0aW9uICYmIHNjcm9sbEZ1bmMocHJldlNjcm9sbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXNlRml4ZWRQb3NpdGlvbikge1xuICAgICAgICAgIG92ZXJyaWRlID0ge1xuICAgICAgICAgICAgdG9wOiBib3VuZHMudG9wICsgKGlzVmVydGljYWwgPyBzY3JvbGwgLSBzdGFydCA6IG9wcG9zaXRlU2Nyb2xsKSArIF9weCxcbiAgICAgICAgICAgIGxlZnQ6IGJvdW5kcy5sZWZ0ICsgKGlzVmVydGljYWwgPyBvcHBvc2l0ZVNjcm9sbCA6IHNjcm9sbCAtIHN0YXJ0KSArIF9weCxcbiAgICAgICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgICAgICBwb3NpdGlvbjogXCJmaXhlZFwiXG4gICAgICAgICAgfTtcbiAgICAgICAgICBvdmVycmlkZVtfd2lkdGhdID0gb3ZlcnJpZGVbXCJtYXhcIiArIF9XaWR0aF0gPSBNYXRoLmNlaWwoYm91bmRzLndpZHRoKSArIF9weDtcbiAgICAgICAgICBvdmVycmlkZVtfaGVpZ2h0XSA9IG92ZXJyaWRlW1wibWF4XCIgKyBfSGVpZ2h0XSA9IE1hdGguY2VpbChib3VuZHMuaGVpZ2h0KSArIF9weDtcbiAgICAgICAgICBvdmVycmlkZVtfbWFyZ2luXSA9IG92ZXJyaWRlW19tYXJnaW4gKyBfVG9wXSA9IG92ZXJyaWRlW19tYXJnaW4gKyBfUmlnaHRdID0gb3ZlcnJpZGVbX21hcmdpbiArIF9Cb3R0b21dID0gb3ZlcnJpZGVbX21hcmdpbiArIF9MZWZ0XSA9IFwiMFwiO1xuICAgICAgICAgIG92ZXJyaWRlW19wYWRkaW5nXSA9IGNzW19wYWRkaW5nXTtcbiAgICAgICAgICBvdmVycmlkZVtfcGFkZGluZyArIF9Ub3BdID0gY3NbX3BhZGRpbmcgKyBfVG9wXTtcbiAgICAgICAgICBvdmVycmlkZVtfcGFkZGluZyArIF9SaWdodF0gPSBjc1tfcGFkZGluZyArIF9SaWdodF07XG4gICAgICAgICAgb3ZlcnJpZGVbX3BhZGRpbmcgKyBfQm90dG9tXSA9IGNzW19wYWRkaW5nICsgX0JvdHRvbV07XG4gICAgICAgICAgb3ZlcnJpZGVbX3BhZGRpbmcgKyBfTGVmdF0gPSBjc1tfcGFkZGluZyArIF9MZWZ0XTtcbiAgICAgICAgICBwaW5BY3RpdmVTdGF0ZSA9IF9jb3B5U3RhdGUocGluT3JpZ2luYWxTdGF0ZSwgb3ZlcnJpZGUsIHBpblJlcGFyZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbmltYXRpb24pIHtcbiAgICAgICAgICAvLyB0aGUgYW5pbWF0aW9uIG1pZ2h0IGJlIGFmZmVjdGluZyB0aGUgdHJhbnNmb3JtLCBzbyB3ZSBtdXN0IGp1bXAgdG8gdGhlIGVuZCwgY2hlY2sgdGhlIHZhbHVlLCBhbmQgY29tcGVuc2F0ZSBhY2NvcmRpbmdseS4gT3RoZXJ3aXNlLCB3aGVuIGl0IGJlY29tZXMgdW5waW5uZWQsIHRoZSBwaW5TZXR0ZXIoKSB3aWxsIGdldCBzZXQgdG8gYSB2YWx1ZSB0aGF0IGRvZXNuJ3QgaW5jbHVkZSB3aGF0ZXZlciB0aGUgYW5pbWF0aW9uIGRpZC5cbiAgICAgICAgICBpbml0dGVkID0gYW5pbWF0aW9uLl9pbml0dGVkOyAvLyBpZiBub3QsIHdlIG11c3QgaW52YWxpZGF0ZSgpIGFmdGVyIHRoaXMgc3RlcCwgb3RoZXJ3aXNlIGl0IGNvdWxkIGxvY2sgaW4gc3RhcnRpbmcgdmFsdWVzIHByZW1hdHVyZWx5LlxuXG4gICAgICAgICAgX3N1cHByZXNzT3ZlcndyaXRlcygxKTtcblxuICAgICAgICAgIGFuaW1hdGlvbi5yZW5kZXIoYW5pbWF0aW9uLmR1cmF0aW9uKCksIHRydWUsIHRydWUpO1xuICAgICAgICAgIHBpbkNoYW5nZSA9IHBpbkdldHRlcihkaXJlY3Rpb24uYSkgLSBwaW5TdGFydCArIGNoYW5nZSArIG90aGVyUGluT2Zmc2V0O1xuICAgICAgICAgIGNoYW5nZSAhPT0gcGluQ2hhbmdlICYmIHBpbkFjdGl2ZVN0YXRlLnNwbGljZShwaW5BY3RpdmVTdGF0ZS5sZW5ndGggLSAyLCAyKTsgLy8gdHJhbnNmb3JtIGlzIHRoZSBsYXN0IHByb3BlcnR5L3ZhbHVlIHNldCBpbiB0aGUgc3RhdGUgQXJyYXkuIFNpbmNlIHRoZSBhbmltYXRpb24gaXMgY29udHJvbGxpbmcgdGhhdCwgd2Ugc2hvdWxkIG9taXQgaXQuXG5cbiAgICAgICAgICBhbmltYXRpb24ucmVuZGVyKDAsIHRydWUsIHRydWUpO1xuICAgICAgICAgIGluaXR0ZWQgfHwgYW5pbWF0aW9uLmludmFsaWRhdGUoKTtcblxuICAgICAgICAgIF9zdXBwcmVzc092ZXJ3cml0ZXMoMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGluQ2hhbmdlID0gY2hhbmdlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRyaWdnZXIgJiYgc2Nyb2xsRnVuYygpICYmICFjb250YWluZXJBbmltYXRpb24pIHtcbiAgICAgICAgLy8gaXQgbWF5IGJlIElOU0lERSBhIHBpbm5lZCBlbGVtZW50LCBzbyB3YWxrIHVwIHRoZSB0cmVlIGFuZCBsb29rIGZvciBhbnkgZWxlbWVudHMgd2l0aCBfcGluT2Zmc2V0IHRvIGNvbXBlbnNhdGUgYmVjYXVzZSBhbnl0aGluZyB3aXRoIHBpblNwYWNpbmcgdGhhdCdzIGFscmVhZHkgc2Nyb2xsZWQgd291bGQgdGhyb3cgb2ZmIHRoZSBtZWFzdXJlbWVudHMgaW4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgYm91bmRzID0gdHJpZ2dlci5wYXJlbnROb2RlO1xuXG4gICAgICAgIHdoaWxlIChib3VuZHMgJiYgYm91bmRzICE9PSBfYm9keSkge1xuICAgICAgICAgIGlmIChib3VuZHMuX3Bpbk9mZnNldCkge1xuICAgICAgICAgICAgc3RhcnQgLT0gYm91bmRzLl9waW5PZmZzZXQ7XG4gICAgICAgICAgICBlbmQgLT0gYm91bmRzLl9waW5PZmZzZXQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYm91bmRzID0gYm91bmRzLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV2ZXJ0ZWRQaW5zICYmIHJldmVydGVkUGlucy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LnJldmVydChmYWxzZSk7XG4gICAgICB9KTtcbiAgICAgIHNlbGYuc3RhcnQgPSBzdGFydDtcbiAgICAgIHNlbGYuZW5kID0gZW5kO1xuICAgICAgc2Nyb2xsMSA9IHNjcm9sbDIgPSBzY3JvbGxGdW5jKCk7IC8vIHJlc2V0IHZlbG9jaXR5XG5cbiAgICAgIGlmICghY29udGFpbmVyQW5pbWF0aW9uKSB7XG4gICAgICAgIHNjcm9sbDEgPCBwcmV2U2Nyb2xsICYmIHNjcm9sbEZ1bmMocHJldlNjcm9sbCk7XG4gICAgICAgIHNlbGYuc2Nyb2xsLnJlYyA9IDA7XG4gICAgICB9XG5cbiAgICAgIHNlbGYucmV2ZXJ0KGZhbHNlKTtcbiAgICAgIF9yZWZyZXNoaW5nID0gMDtcbiAgICAgIGFuaW1hdGlvbiAmJiBpc1RvZ2dsZSAmJiBhbmltYXRpb24uX2luaXR0ZWQgJiYgYW5pbWF0aW9uLnByb2dyZXNzKCkgIT09IHByZXZBbmltUHJvZ3Jlc3MgJiYgYW5pbWF0aW9uLnByb2dyZXNzKHByZXZBbmltUHJvZ3Jlc3MsIHRydWUpLnJlbmRlcihhbmltYXRpb24udGltZSgpLCB0cnVlLCB0cnVlKTsgLy8gbXVzdCBmb3JjZSBhIHJlLXJlbmRlciBiZWNhdXNlIGlmIHNhdmVTdHlsZXMoKSB3YXMgdXNlZCBvbiB0aGUgdGFyZ2V0KHMpLCB0aGUgc3R5bGVzIGNvdWxkIGhhdmUgYmVlbiB3aXBlZCBvdXQgZHVyaW5nIHRoZSByZWZyZXNoKCkuXG5cbiAgICAgIGlmIChwcmV2UHJvZ3Jlc3MgIT09IHNlbGYucHJvZ3Jlc3MgfHwgY29udGFpbmVyQW5pbWF0aW9uKSB7XG4gICAgICAgIC8vIGVuc3VyZXMgdGhhdCB0aGUgZGlyZWN0aW9uIGlzIHNldCBwcm9wZXJseSAod2hlbiByZWZyZXNoaW5nLCBwcm9ncmVzcyBpcyBzZXQgYmFjayB0byAwIGluaXRpYWxseSwgdGhlbiBiYWNrIGFnYWluIHRvIHdoZXJldmVyIGl0IG5lZWRzIHRvIGJlKSBhbmQgdGhhdCBjYWxsYmFja3MgYXJlIHRyaWdnZXJlZC5cbiAgICAgICAgYW5pbWF0aW9uICYmICFpc1RvZ2dsZSAmJiBhbmltYXRpb24udG90YWxQcm9ncmVzcyhwcmV2UHJvZ3Jlc3MsIHRydWUpOyAvLyB0byBhdm9pZCBpc3N1ZXMgd2hlcmUgYW5pbWF0aW9uIGNhbGxiYWNrcyBsaWtlIG9uU3RhcnQgYXJlbid0IHRyaWdnZXJlZC5cblxuICAgICAgICBzZWxmLnByb2dyZXNzID0gcHJldlByb2dyZXNzO1xuICAgICAgICBzZWxmLnVwZGF0ZSgwLCAwLCAxKTtcbiAgICAgIH1cblxuICAgICAgcGluICYmIHBpblNwYWNpbmcgJiYgKHNwYWNlci5fcGluT2Zmc2V0ID0gTWF0aC5yb3VuZChzZWxmLnByb2dyZXNzICogcGluQ2hhbmdlKSk7XG4gICAgICBvblJlZnJlc2ggJiYgb25SZWZyZXNoKHNlbGYpO1xuICAgIH07XG5cbiAgICBzZWxmLmdldFZlbG9jaXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIChzY3JvbGxGdW5jKCkgLSBzY3JvbGwyKSAvIChfZ2V0VGltZSgpIC0gX3RpbWUyKSAqIDEwMDAgfHwgMDtcbiAgICB9O1xuXG4gICAgc2VsZi5lbmRBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBfZW5kQW5pbWF0aW9uKHNlbGYuY2FsbGJhY2tBbmltYXRpb24pO1xuXG4gICAgICBpZiAoYW5pbWF0aW9uKSB7XG4gICAgICAgIHNjcnViVHdlZW4gPyBzY3J1YlR3ZWVuLnByb2dyZXNzKDEpIDogIWFuaW1hdGlvbi5wYXVzZWQoKSA/IF9lbmRBbmltYXRpb24oYW5pbWF0aW9uLCBhbmltYXRpb24ucmV2ZXJzZWQoKSkgOiBpc1RvZ2dsZSB8fCBfZW5kQW5pbWF0aW9uKGFuaW1hdGlvbiwgc2VsZi5kaXJlY3Rpb24gPCAwLCAxKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc2VsZi5sYWJlbFRvU2Nyb2xsID0gZnVuY3Rpb24gKGxhYmVsKSB7XG4gICAgICByZXR1cm4gYW5pbWF0aW9uICYmIGFuaW1hdGlvbi5sYWJlbHMgJiYgKHN0YXJ0IHx8IHNlbGYucmVmcmVzaCgpIHx8IHN0YXJ0KSArIGFuaW1hdGlvbi5sYWJlbHNbbGFiZWxdIC8gYW5pbWF0aW9uLmR1cmF0aW9uKCkgKiBjaGFuZ2UgfHwgMDtcbiAgICB9O1xuXG4gICAgc2VsZi5nZXRUcmFpbGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgaSA9IF90cmlnZ2Vycy5pbmRleE9mKHNlbGYpLFxuICAgICAgICAgIGEgPSBzZWxmLmRpcmVjdGlvbiA+IDAgPyBfdHJpZ2dlcnMuc2xpY2UoMCwgaSkucmV2ZXJzZSgpIDogX3RyaWdnZXJzLnNsaWNlKGkgKyAxKTtcblxuICAgICAgcmV0dXJuIF9pc1N0cmluZyhuYW1lKSA/IGEuZmlsdGVyKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LnZhcnMucHJldmVudE92ZXJsYXBzID09PSBuYW1lO1xuICAgICAgfSkgOiBhO1xuICAgIH07XG5cbiAgICBzZWxmLnVwZGF0ZSA9IGZ1bmN0aW9uIChyZXNldCwgcmVjb3JkVmVsb2NpdHksIGZvcmNlRmFrZSkge1xuICAgICAgaWYgKGNvbnRhaW5lckFuaW1hdGlvbiAmJiAhZm9yY2VGYWtlICYmICFyZXNldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzY3JvbGwgPSBzZWxmLnNjcm9sbCgpLFxuICAgICAgICAgIHAgPSByZXNldCA/IDAgOiAoc2Nyb2xsIC0gc3RhcnQpIC8gY2hhbmdlLFxuICAgICAgICAgIGNsaXBwZWQgPSBwIDwgMCA/IDAgOiBwID4gMSA/IDEgOiBwIHx8IDAsXG4gICAgICAgICAgcHJldlByb2dyZXNzID0gc2VsZi5wcm9ncmVzcyxcbiAgICAgICAgICBpc0FjdGl2ZSxcbiAgICAgICAgICB3YXNBY3RpdmUsXG4gICAgICAgICAgdG9nZ2xlU3RhdGUsXG4gICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgIHN0YXRlQ2hhbmdlZCxcbiAgICAgICAgICB0b2dnbGVkLFxuICAgICAgICAgIGlzQXRNYXgsXG4gICAgICAgICAgaXNUYWtpbmdBY3Rpb247XG5cbiAgICAgIGlmIChyZWNvcmRWZWxvY2l0eSkge1xuICAgICAgICBzY3JvbGwyID0gc2Nyb2xsMTtcbiAgICAgICAgc2Nyb2xsMSA9IGNvbnRhaW5lckFuaW1hdGlvbiA/IHNjcm9sbEZ1bmMoKSA6IHNjcm9sbDtcblxuICAgICAgICBpZiAoc25hcCkge1xuICAgICAgICAgIHNuYXAyID0gc25hcDE7XG4gICAgICAgICAgc25hcDEgPSBhbmltYXRpb24gJiYgIWlzVG9nZ2xlID8gYW5pbWF0aW9uLnRvdGFsUHJvZ3Jlc3MoKSA6IGNsaXBwZWQ7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gYW50aWNpcGF0ZSB0aGUgcGlubmluZyBhIGZldyB0aWNrcyBhaGVhZCBvZiB0aW1lIGJhc2VkIG9uIHZlbG9jaXR5IHRvIGF2b2lkIGEgdmlzdWFsIGdsaXRjaCBkdWUgdG8gdGhlIGZhY3QgdGhhdCBtb3N0IGJyb3dzZXJzIGRvIHNjcm9sbGluZyBvbiBhIHNlcGFyYXRlIHRocmVhZCAobm90IHN5bmNlZCB3aXRoIHJlcXVlc3RBbmltYXRpb25GcmFtZSkuXG5cblxuICAgICAgYW50aWNpcGF0ZVBpbiAmJiAhY2xpcHBlZCAmJiBwaW4gJiYgIV9yZWZyZXNoaW5nICYmICFfc3RhcnR1cCAmJiBfbGFzdFNjcm9sbFRpbWUgJiYgc3RhcnQgPCBzY3JvbGwgKyAoc2Nyb2xsIC0gc2Nyb2xsMikgLyAoX2dldFRpbWUoKSAtIF90aW1lMikgKiBhbnRpY2lwYXRlUGluICYmIChjbGlwcGVkID0gMC4wMDAxKTtcblxuICAgICAgaWYgKGNsaXBwZWQgIT09IHByZXZQcm9ncmVzcyAmJiBzZWxmLmVuYWJsZWQpIHtcbiAgICAgICAgaXNBY3RpdmUgPSBzZWxmLmlzQWN0aXZlID0gISFjbGlwcGVkICYmIGNsaXBwZWQgPCAxO1xuICAgICAgICB3YXNBY3RpdmUgPSAhIXByZXZQcm9ncmVzcyAmJiBwcmV2UHJvZ3Jlc3MgPCAxO1xuICAgICAgICB0b2dnbGVkID0gaXNBY3RpdmUgIT09IHdhc0FjdGl2ZTtcbiAgICAgICAgc3RhdGVDaGFuZ2VkID0gdG9nZ2xlZCB8fCAhIWNsaXBwZWQgIT09ICEhcHJldlByb2dyZXNzOyAvLyBjb3VsZCBnbyBmcm9tIHN0YXJ0IGFsbCB0aGUgd2F5IHRvIGVuZCwgdGh1cyBpdCBkaWRuJ3QgdG9nZ2xlIGJ1dCBpdCBkaWQgY2hhbmdlIHN0YXRlIGluIGEgc2Vuc2UgKG1heSBuZWVkIHRvIGZpcmUgYSBjYWxsYmFjaylcblxuICAgICAgICBzZWxmLmRpcmVjdGlvbiA9IGNsaXBwZWQgPiBwcmV2UHJvZ3Jlc3MgPyAxIDogLTE7XG4gICAgICAgIHNlbGYucHJvZ3Jlc3MgPSBjbGlwcGVkO1xuXG4gICAgICAgIGlmIChzdGF0ZUNoYW5nZWQgJiYgIV9yZWZyZXNoaW5nKSB7XG4gICAgICAgICAgdG9nZ2xlU3RhdGUgPSBjbGlwcGVkICYmICFwcmV2UHJvZ3Jlc3MgPyAwIDogY2xpcHBlZCA9PT0gMSA/IDEgOiBwcmV2UHJvZ3Jlc3MgPT09IDEgPyAyIDogMzsgLy8gMCA9IGVudGVyLCAxID0gbGVhdmUsIDIgPSBlbnRlckJhY2ssIDMgPSBsZWF2ZUJhY2sgKHdlIHByaW9yaXRpemUgdGhlIEZJUlNUIGVuY291bnRlciwgdGh1cyBpZiB5b3Ugc2Nyb2xsIHJlYWxseSBmYXN0IHBhc3QgdGhlIG9uRW50ZXIgYW5kIG9uTGVhdmUgaW4gb25lIHRpY2ssIGl0J2QgcHJpb3JpdGl6ZSBvbkVudGVyLlxuXG4gICAgICAgICAgaWYgKGlzVG9nZ2xlKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSAhdG9nZ2xlZCAmJiB0b2dnbGVBY3Rpb25zW3RvZ2dsZVN0YXRlICsgMV0gIT09IFwibm9uZVwiICYmIHRvZ2dsZUFjdGlvbnNbdG9nZ2xlU3RhdGUgKyAxXSB8fCB0b2dnbGVBY3Rpb25zW3RvZ2dsZVN0YXRlXTsgLy8gaWYgaXQgZGlkbid0IHRvZ2dsZSwgdGhhdCBtZWFucyBpdCBzaG90IHJpZ2h0IHBhc3QgYW5kIHNpbmNlIHdlIHByaW9yaXRpemUgdGhlIFwiZW50ZXJcIiBhY3Rpb24sIHdlIHNob3VsZCBzd2l0Y2ggdG8gdGhlIFwibGVhdmVcIiBpbiB0aGlzIGNhc2UgKGJ1dCBvbmx5IGlmIG9uZSBpcyBkZWZpbmVkKVxuXG4gICAgICAgICAgICBpc1Rha2luZ0FjdGlvbiA9IGFuaW1hdGlvbiAmJiAoYWN0aW9uID09PSBcImNvbXBsZXRlXCIgfHwgYWN0aW9uID09PSBcInJlc2V0XCIgfHwgYWN0aW9uIGluIGFuaW1hdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcHJldmVudE92ZXJsYXBzICYmIHRvZ2dsZWQgJiYgKGlzVGFraW5nQWN0aW9uIHx8IHNjcnViIHx8ICFhbmltYXRpb24pICYmIChfaXNGdW5jdGlvbihwcmV2ZW50T3ZlcmxhcHMpID8gcHJldmVudE92ZXJsYXBzKHNlbGYpIDogc2VsZi5nZXRUcmFpbGluZyhwcmV2ZW50T3ZlcmxhcHMpLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICByZXR1cm4gdC5lbmRBbmltYXRpb24oKTtcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGlmICghaXNUb2dnbGUpIHtcbiAgICAgICAgICBpZiAoc2NydWJUd2VlbiAmJiAhX3JlZnJlc2hpbmcgJiYgIV9zdGFydHVwKSB7XG4gICAgICAgICAgICBzY3J1YlR3ZWVuLnZhcnMudG90YWxQcm9ncmVzcyA9IGNsaXBwZWQ7XG4gICAgICAgICAgICBzY3J1YlR3ZWVuLmludmFsaWRhdGUoKS5yZXN0YXJ0KCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChhbmltYXRpb24pIHtcbiAgICAgICAgICAgIGFuaW1hdGlvbi50b3RhbFByb2dyZXNzKGNsaXBwZWQsICEhX3JlZnJlc2hpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwaW4pIHtcbiAgICAgICAgICByZXNldCAmJiBwaW5TcGFjaW5nICYmIChzcGFjZXIuc3R5bGVbcGluU3BhY2luZyArIGRpcmVjdGlvbi5vczJdID0gc3BhY2luZ1N0YXJ0KTtcblxuICAgICAgICAgIGlmICghdXNlRml4ZWRQb3NpdGlvbikge1xuICAgICAgICAgICAgcGluU2V0dGVyKHBpblN0YXJ0ICsgcGluQ2hhbmdlICogY2xpcHBlZCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdGF0ZUNoYW5nZWQpIHtcbiAgICAgICAgICAgIGlzQXRNYXggPSAhcmVzZXQgJiYgY2xpcHBlZCA+IHByZXZQcm9ncmVzcyAmJiBlbmQgKyAxID4gc2Nyb2xsICYmIHNjcm9sbCArIDEgPj0gX21heFNjcm9sbChzY3JvbGxlciwgZGlyZWN0aW9uKTsgLy8gaWYgaXQncyBhdCB0aGUgVkVSWSBlbmQgb2YgdGhlIHBhZ2UsIGRvbid0IHN3aXRjaCBhd2F5IGZyb20gcG9zaXRpb246IGZpeGVkIGJlY2F1c2UgaXQncyBwb2ludGxlc3MgYW5kIGl0IGNvdWxkIGNhdXNlIGEgYnJpZWYgZmxhc2ggd2hlbiB0aGUgdXNlciBzY3JvbGxzIGJhY2sgdXAgKHdoZW4gaXQgZ2V0cyBwaW5uZWQgYWdhaW4pXG5cbiAgICAgICAgICAgIGlmIChwaW5SZXBhcmVudCkge1xuICAgICAgICAgICAgICBpZiAoIXJlc2V0ICYmIChpc0FjdGl2ZSB8fCBpc0F0TWF4KSkge1xuICAgICAgICAgICAgICAgIHZhciBib3VuZHMgPSBfZ2V0Qm91bmRzKHBpbiwgdHJ1ZSksXG4gICAgICAgICAgICAgICAgICAgIF9vZmZzZXQgPSBzY3JvbGwgLSBzdGFydDtcblxuICAgICAgICAgICAgICAgIF9yZXBhcmVudChwaW4sIF9ib2R5LCBib3VuZHMudG9wICsgKGRpcmVjdGlvbiA9PT0gX3ZlcnRpY2FsID8gX29mZnNldCA6IDApICsgX3B4LCBib3VuZHMubGVmdCArIChkaXJlY3Rpb24gPT09IF92ZXJ0aWNhbCA/IDAgOiBfb2Zmc2V0KSArIF9weCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3JlcGFyZW50KHBpbiwgc3BhY2VyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfc2V0U3RhdGUoaXNBY3RpdmUgfHwgaXNBdE1heCA/IHBpbkFjdGl2ZVN0YXRlIDogcGluU3RhdGUpO1xuXG4gICAgICAgICAgICBwaW5DaGFuZ2UgIT09IGNoYW5nZSAmJiBjbGlwcGVkIDwgMSAmJiBpc0FjdGl2ZSB8fCBwaW5TZXR0ZXIocGluU3RhcnQgKyAoY2xpcHBlZCA9PT0gMSAmJiAhaXNBdE1heCA/IHBpbkNoYW5nZSA6IDApKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzbmFwICYmICF0d2VlblRvLnR3ZWVuICYmICFfcmVmcmVzaGluZyAmJiAhX3N0YXJ0dXAgJiYgc25hcERlbGF5ZWRDYWxsLnJlc3RhcnQodHJ1ZSk7XG4gICAgICAgIHRvZ2dsZUNsYXNzICYmICh0b2dnbGVkIHx8IG9uY2UgJiYgY2xpcHBlZCAmJiAoY2xpcHBlZCA8IDEgfHwgIV9saW1pdENhbGxiYWNrcykpICYmIF90b0FycmF5KHRvZ2dsZUNsYXNzLnRhcmdldHMpLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgcmV0dXJuIGVsLmNsYXNzTGlzdFtpc0FjdGl2ZSB8fCBvbmNlID8gXCJhZGRcIiA6IFwicmVtb3ZlXCJdKHRvZ2dsZUNsYXNzLmNsYXNzTmFtZSk7XG4gICAgICAgIH0pOyAvLyBjbGFzc2VzIGNvdWxkIGFmZmVjdCBwb3NpdGlvbmluZywgc28gZG8gaXQgZXZlbiBpZiByZXNldCBvciByZWZyZXNoaW5nIGlzIHRydWUuXG5cbiAgICAgICAgb25VcGRhdGUgJiYgIWlzVG9nZ2xlICYmICFyZXNldCAmJiBvblVwZGF0ZShzZWxmKTtcblxuICAgICAgICBpZiAoc3RhdGVDaGFuZ2VkICYmICFfcmVmcmVzaGluZykge1xuICAgICAgICAgIGlmIChpc1RvZ2dsZSkge1xuICAgICAgICAgICAgaWYgKGlzVGFraW5nQWN0aW9uKSB7XG4gICAgICAgICAgICAgIGlmIChhY3Rpb24gPT09IFwiY29tcGxldGVcIikge1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5wYXVzZSgpLnRvdGFsUHJvZ3Jlc3MoMSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWN0aW9uID09PSBcInJlc2V0XCIpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb24ucmVzdGFydCh0cnVlKS5wYXVzZSgpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFjdGlvbiA9PT0gXCJyZXN0YXJ0XCIpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb24ucmVzdGFydCh0cnVlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25bYWN0aW9uXSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9uVXBkYXRlICYmIG9uVXBkYXRlKHNlbGYpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0b2dnbGVkIHx8ICFfbGltaXRDYWxsYmFja3MpIHtcbiAgICAgICAgICAgIC8vIG9uIHN0YXJ0dXAsIHRoZSBwYWdlIGNvdWxkIGJlIHNjcm9sbGVkIGFuZCB3ZSBkb24ndCB3YW50IHRvIGZpcmUgY2FsbGJhY2tzIHRoYXQgZGlkbid0IHRvZ2dsZS4gRm9yIGV4YW1wbGUgb25FbnRlciBzaG91bGRuJ3QgZmlyZSBpZiB0aGUgU2Nyb2xsVHJpZ2dlciBpc24ndCBhY3R1YWxseSBlbnRlcmVkLlxuICAgICAgICAgICAgb25Ub2dnbGUgJiYgdG9nZ2xlZCAmJiBfY2FsbGJhY2soc2VsZiwgb25Ub2dnbGUpO1xuICAgICAgICAgICAgY2FsbGJhY2tzW3RvZ2dsZVN0YXRlXSAmJiBfY2FsbGJhY2soc2VsZiwgY2FsbGJhY2tzW3RvZ2dsZVN0YXRlXSk7XG4gICAgICAgICAgICBvbmNlICYmIChjbGlwcGVkID09PSAxID8gc2VsZi5raWxsKGZhbHNlLCAxKSA6IGNhbGxiYWNrc1t0b2dnbGVTdGF0ZV0gPSAwKTsgLy8gYSBjYWxsYmFjayBzaG91bGRuJ3QgYmUgY2FsbGVkIGFnYWluIGlmIG9uY2UgaXMgdHJ1ZS5cblxuICAgICAgICAgICAgaWYgKCF0b2dnbGVkKSB7XG4gICAgICAgICAgICAgIC8vIGl0J3MgcG9zc2libGUgdG8gZ28gY29tcGxldGVseSBwYXN0LCBsaWtlIGZyb20gYmVmb3JlIHRoZSBzdGFydCB0byBhZnRlciB0aGUgZW5kIChvciB2aWNlLXZlcnNhKSBpbiB3aGljaCBjYXNlIEJPVEggY2FsbGJhY2tzIHNob3VsZCBiZSBmaXJlZCBpbiB0aGF0IG9yZGVyXG4gICAgICAgICAgICAgIHRvZ2dsZVN0YXRlID0gY2xpcHBlZCA9PT0gMSA/IDEgOiAzO1xuICAgICAgICAgICAgICBjYWxsYmFja3NbdG9nZ2xlU3RhdGVdICYmIF9jYWxsYmFjayhzZWxmLCBjYWxsYmFja3NbdG9nZ2xlU3RhdGVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZmFzdFNjcm9sbEVuZCAmJiAhaXNBY3RpdmUgJiYgTWF0aC5hYnMoc2VsZi5nZXRWZWxvY2l0eSgpKSA+IChfaXNOdW1iZXIoZmFzdFNjcm9sbEVuZCkgPyBmYXN0U2Nyb2xsRW5kIDogMjUwMCkpIHtcbiAgICAgICAgICAgIF9lbmRBbmltYXRpb24oc2VsZi5jYWxsYmFja0FuaW1hdGlvbik7XG5cbiAgICAgICAgICAgIHNjcnViVHdlZW4gPyBzY3J1YlR3ZWVuLnByb2dyZXNzKDEpIDogX2VuZEFuaW1hdGlvbihhbmltYXRpb24sICFjbGlwcGVkLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNUb2dnbGUgJiYgb25VcGRhdGUgJiYgIV9yZWZyZXNoaW5nKSB7XG4gICAgICAgICAgb25VcGRhdGUoc2VsZik7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gdXBkYXRlIGFic29sdXRlbHktcG9zaXRpb25lZCBtYXJrZXJzIChvbmx5IGlmIHRoZSBzY3JvbGxlciBpc24ndCB0aGUgdmlld3BvcnQpXG5cblxuICAgICAgaWYgKG1hcmtlckVuZFNldHRlcikge1xuICAgICAgICB2YXIgbiA9IGNvbnRhaW5lckFuaW1hdGlvbiA/IHNjcm9sbCAvIGNvbnRhaW5lckFuaW1hdGlvbi5kdXJhdGlvbigpICogKGNvbnRhaW5lckFuaW1hdGlvbi5fY2FTY3JvbGxEaXN0IHx8IDApIDogc2Nyb2xsO1xuICAgICAgICBtYXJrZXJTdGFydFNldHRlcihuICsgKG1hcmtlclN0YXJ0VHJpZ2dlci5faXNGbGlwcGVkID8gMSA6IDApKTtcbiAgICAgICAgbWFya2VyRW5kU2V0dGVyKG4pO1xuICAgICAgfVxuXG4gICAgICBjYU1hcmtlclNldHRlciAmJiBjYU1hcmtlclNldHRlcigtc2Nyb2xsIC8gY29udGFpbmVyQW5pbWF0aW9uLmR1cmF0aW9uKCkgKiAoY29udGFpbmVyQW5pbWF0aW9uLl9jYVNjcm9sbERpc3QgfHwgMCkpO1xuICAgIH07XG5cbiAgICBzZWxmLmVuYWJsZSA9IGZ1bmN0aW9uIChyZXNldCwgcmVmcmVzaCkge1xuICAgICAgaWYgKCFzZWxmLmVuYWJsZWQpIHtcbiAgICAgICAgc2VsZi5lbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICBfYWRkTGlzdGVuZXIoc2Nyb2xsZXIsIFwicmVzaXplXCIsIF9vblJlc2l6ZSk7XG5cbiAgICAgICAgX2FkZExpc3RlbmVyKHNjcm9sbGVyLCBcInNjcm9sbFwiLCBfb25TY3JvbGwpO1xuXG4gICAgICAgIG9uUmVmcmVzaEluaXQgJiYgX2FkZExpc3RlbmVyKFNjcm9sbFRyaWdnZXIsIFwicmVmcmVzaEluaXRcIiwgb25SZWZyZXNoSW5pdCk7XG5cbiAgICAgICAgaWYgKHJlc2V0ICE9PSBmYWxzZSkge1xuICAgICAgICAgIHNlbGYucHJvZ3Jlc3MgPSBwcmV2UHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgIHNjcm9sbDEgPSBzY3JvbGwyID0gbGFzdFNuYXAgPSBzY3JvbGxGdW5jKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZWZyZXNoICE9PSBmYWxzZSAmJiBzZWxmLnJlZnJlc2goKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc2VsZi5nZXRUd2VlbiA9IGZ1bmN0aW9uIChzbmFwKSB7XG4gICAgICByZXR1cm4gc25hcCAmJiB0d2VlblRvID8gdHdlZW5Uby50d2VlbiA6IHNjcnViVHdlZW47XG4gICAgfTtcblxuICAgIHNlbGYuc2V0UG9zaXRpb25zID0gZnVuY3Rpb24gKG5ld1N0YXJ0LCBuZXdFbmQpIHtcbiAgICAgIC8vIGRvZXNuJ3QgcGVyc2lzdCBhZnRlciByZWZyZXNoKCkhIEludGVuZGVkIHRvIGJlIGEgd2F5IHRvIG92ZXJyaWRlIHZhbHVlcyB0aGF0IHdlcmUgc2V0IGR1cmluZyByZWZyZXNoKCksIGxpa2UgeW91IGNvdWxkIHNldCBpdCBpbiBvblJlZnJlc2goKVxuICAgICAgaWYgKHBpbikge1xuICAgICAgICBwaW5TdGFydCArPSBuZXdTdGFydCAtIHN0YXJ0O1xuICAgICAgICBwaW5DaGFuZ2UgKz0gbmV3RW5kIC0gbmV3U3RhcnQgLSBjaGFuZ2U7XG4gICAgICB9XG5cbiAgICAgIHNlbGYuc3RhcnQgPSBzdGFydCA9IG5ld1N0YXJ0O1xuICAgICAgc2VsZi5lbmQgPSBlbmQgPSBuZXdFbmQ7XG4gICAgICBjaGFuZ2UgPSBuZXdFbmQgLSBuZXdTdGFydDtcbiAgICAgIHNlbGYudXBkYXRlKCk7XG4gICAgfTtcblxuICAgIHNlbGYuZGlzYWJsZSA9IGZ1bmN0aW9uIChyZXNldCwgYWxsb3dBbmltYXRpb24pIHtcbiAgICAgIGlmIChzZWxmLmVuYWJsZWQpIHtcbiAgICAgICAgcmVzZXQgIT09IGZhbHNlICYmIHNlbGYucmV2ZXJ0KCk7XG4gICAgICAgIHNlbGYuZW5hYmxlZCA9IHNlbGYuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgYWxsb3dBbmltYXRpb24gfHwgc2NydWJUd2VlbiAmJiBzY3J1YlR3ZWVuLnBhdXNlKCk7XG4gICAgICAgIHByZXZTY3JvbGwgPSAwO1xuICAgICAgICBwaW5DYWNoZSAmJiAocGluQ2FjaGUudW5jYWNoZSA9IDEpO1xuICAgICAgICBvblJlZnJlc2hJbml0ICYmIF9yZW1vdmVMaXN0ZW5lcihTY3JvbGxUcmlnZ2VyLCBcInJlZnJlc2hJbml0XCIsIG9uUmVmcmVzaEluaXQpO1xuXG4gICAgICAgIGlmIChzbmFwRGVsYXllZENhbGwpIHtcbiAgICAgICAgICBzbmFwRGVsYXllZENhbGwucGF1c2UoKTtcbiAgICAgICAgICB0d2VlblRvLnR3ZWVuICYmIHR3ZWVuVG8udHdlZW4ua2lsbCgpICYmICh0d2VlblRvLnR3ZWVuID0gMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVmlld3BvcnQpIHtcbiAgICAgICAgICB2YXIgaSA9IF90cmlnZ2Vycy5sZW5ndGg7XG5cbiAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBpZiAoX3RyaWdnZXJzW2ldLnNjcm9sbGVyID09PSBzY3JvbGxlciAmJiBfdHJpZ2dlcnNbaV0gIT09IHNlbGYpIHtcbiAgICAgICAgICAgICAgcmV0dXJuOyAvL2Rvbid0IHJlbW92ZSB0aGUgbGlzdGVuZXJzIGlmIHRoZXJlIGFyZSBzdGlsbCBvdGhlciB0cmlnZ2VycyByZWZlcmVuY2luZyBpdC5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfcmVtb3ZlTGlzdGVuZXIoc2Nyb2xsZXIsIFwicmVzaXplXCIsIF9vblJlc2l6ZSk7XG5cbiAgICAgICAgICBfcmVtb3ZlTGlzdGVuZXIoc2Nyb2xsZXIsIFwic2Nyb2xsXCIsIF9vblNjcm9sbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc2VsZi5raWxsID0gZnVuY3Rpb24gKHJldmVydCwgYWxsb3dBbmltYXRpb24pIHtcbiAgICAgIHNlbGYuZGlzYWJsZShyZXZlcnQsIGFsbG93QW5pbWF0aW9uKTtcbiAgICAgIHNjcnViVHdlZW4gJiYgc2NydWJUd2Vlbi5raWxsKCk7XG4gICAgICBpZCAmJiBkZWxldGUgX2lkc1tpZF07XG5cbiAgICAgIHZhciBpID0gX3RyaWdnZXJzLmluZGV4T2Yoc2VsZik7XG5cbiAgICAgIGkgPj0gMCAmJiBfdHJpZ2dlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgaSA9PT0gX2kgJiYgX2RpcmVjdGlvbiA+IDAgJiYgX2ktLTsgLy8gaWYgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHJlZnJlc2goKSBvciB1cGRhdGUoKSwgc3BsaWNpbmcgd291bGQgY2F1c2Ugc2tpcHMgaW4gdGhlIGluZGV4LCBzbyBhZGp1c3QuLi5cbiAgICAgIC8vIGlmIG5vIG90aGVyIFNjcm9sbFRyaWdnZXIgaW5zdGFuY2VzIG9mIHRoZSBzYW1lIHNjcm9sbGVyIGFyZSBmb3VuZCwgd2lwZSBvdXQgYW55IHJlY29yZGVkIHNjcm9sbCBwb3NpdGlvbi4gT3RoZXJ3aXNlLCBpbiBhIHNpbmdsZSBwYWdlIGFwcGxpY2F0aW9uLCBmb3IgZXhhbXBsZSwgaXQgY291bGQgbWFpbnRhaW4gc2Nyb2xsIHBvc2l0aW9uIHdoZW4gaXQgcmVhbGx5IHNob3VsZG4ndC5cblxuICAgICAgaSA9IDA7XG5cbiAgICAgIF90cmlnZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0LnNjcm9sbGVyID09PSBzZWxmLnNjcm9sbGVyICYmIChpID0gMSk7XG4gICAgICB9KTtcblxuICAgICAgaSB8fCAoc2VsZi5zY3JvbGwucmVjID0gMCk7XG5cbiAgICAgIGlmIChhbmltYXRpb24pIHtcbiAgICAgICAgYW5pbWF0aW9uLnNjcm9sbFRyaWdnZXIgPSBudWxsO1xuICAgICAgICByZXZlcnQgJiYgYW5pbWF0aW9uLnJlbmRlcigtMSk7XG4gICAgICAgIGFsbG93QW5pbWF0aW9uIHx8IGFuaW1hdGlvbi5raWxsKCk7XG4gICAgICB9XG5cbiAgICAgIG1hcmtlclN0YXJ0ICYmIFttYXJrZXJTdGFydCwgbWFya2VyRW5kLCBtYXJrZXJTdGFydFRyaWdnZXIsIG1hcmtlckVuZFRyaWdnZXJdLmZvckVhY2goZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgcmV0dXJuIG0ucGFyZW50Tm9kZSAmJiBtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobSk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHBpbikge1xuICAgICAgICBwaW5DYWNoZSAmJiAocGluQ2FjaGUudW5jYWNoZSA9IDEpO1xuICAgICAgICBpID0gMDtcblxuICAgICAgICBfdHJpZ2dlcnMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiB0LnBpbiA9PT0gcGluICYmIGkrKztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaSB8fCAocGluQ2FjaGUuc3BhY2VyID0gMCk7IC8vIGlmIHRoZXJlIGFyZW4ndCBhbnkgbW9yZSBTY3JvbGxUcmlnZ2VycyB3aXRoIHRoZSBzYW1lIHBpbiwgcmVtb3ZlIHRoZSBzcGFjZXIsIG90aGVyd2lzZSBpdCBjb3VsZCBiZSBjb250YW1pbmF0ZWQgd2l0aCBvbGQvc3RhbGUgdmFsdWVzIGlmIHRoZSB1c2VyIHJlLWNyZWF0ZXMgYSBTY3JvbGxUcmlnZ2VyIGZvciB0aGUgc2FtZSBlbGVtZW50LlxuICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxmLmVuYWJsZShmYWxzZSwgZmFsc2UpO1xuICAgICFhbmltYXRpb24gfHwgIWFuaW1hdGlvbi5hZGQgfHwgY2hhbmdlID8gc2VsZi5yZWZyZXNoKCkgOiBnc2FwLmRlbGF5ZWRDYWxsKDAuMDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBzdGFydCB8fCBlbmQgfHwgc2VsZi5yZWZyZXNoKCk7XG4gICAgfSkgJiYgKGNoYW5nZSA9IDAuMDEpICYmIChzdGFydCA9IGVuZCA9IDApOyAvLyBpZiB0aGUgYW5pbWF0aW9uIGlzIGEgdGltZWxpbmUsIGl0IG1heSBub3QgaGF2ZSBiZWVuIHBvcHVsYXRlZCB5ZXQsIHNvIGl0IHdvdWxkbid0IHJlbmRlciBhdCB0aGUgcHJvcGVyIHBsYWNlIG9uIHRoZSBmaXJzdCByZWZyZXNoKCksIHRodXMgd2Ugc2hvdWxkIHNjaGVkdWxlIG9uZSBmb3IgdGhlIG5leHQgdGljay4gSWYgXCJjaGFuZ2VcIiBpcyBkZWZpbmVkLCB3ZSBrbm93IGl0IG11c3QgYmUgcmUtZW5hYmxpbmcsIHRodXMgd2UgY2FuIHJlZnJlc2goKSByaWdodCBhd2F5LlxuICB9O1xuXG4gIFNjcm9sbFRyaWdnZXIucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3Rlcihjb3JlKSB7XG4gICAgaWYgKCFfY29yZUluaXR0ZWQpIHtcbiAgICAgIGdzYXAgPSBjb3JlIHx8IF9nZXRHU0FQKCk7XG5cbiAgICAgIGlmIChfd2luZG93RXhpc3RzKCkgJiYgd2luZG93LmRvY3VtZW50KSB7XG4gICAgICAgIF93aW4gPSB3aW5kb3c7XG4gICAgICAgIF9kb2MgPSBkb2N1bWVudDtcbiAgICAgICAgX2RvY0VsID0gX2RvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIF9ib2R5ID0gX2RvYy5ib2R5O1xuICAgICAgfVxuXG4gICAgICBpZiAoZ3NhcCkge1xuICAgICAgICBfdG9BcnJheSA9IGdzYXAudXRpbHMudG9BcnJheTtcbiAgICAgICAgX2NsYW1wID0gZ3NhcC51dGlscy5jbGFtcDtcbiAgICAgICAgX3N1cHByZXNzT3ZlcndyaXRlcyA9IGdzYXAuY29yZS5zdXBwcmVzc092ZXJ3cml0ZXMgfHwgX3Bhc3NUaHJvdWdoO1xuICAgICAgICBnc2FwLmNvcmUuZ2xvYmFscyhcIlNjcm9sbFRyaWdnZXJcIiwgU2Nyb2xsVHJpZ2dlcik7IC8vIG11c3QgcmVnaXN0ZXIgdGhlIGdsb2JhbCBtYW51YWxseSBiZWNhdXNlIGluIEludGVybmV0IEV4cGxvcmVyLCBmdW5jdGlvbnMgKGNsYXNzZXMpIGRvbid0IGhhdmUgYSBcIm5hbWVcIiBwcm9wZXJ0eS5cblxuICAgICAgICBpZiAoX2JvZHkpIHtcbiAgICAgICAgICBfYWRkTGlzdGVuZXIoX3dpbiwgXCJ3aGVlbFwiLCBfb25TY3JvbGwpO1xuXG4gICAgICAgICAgX3Jvb3QgPSBbX3dpbiwgX2RvYywgX2RvY0VsLCBfYm9keV07XG5cbiAgICAgICAgICBfYWRkTGlzdGVuZXIoX2RvYywgXCJzY3JvbGxcIiwgX29uU2Nyb2xsKTsgLy8gc29tZSBicm93c2VycyAobGlrZSBDaHJvbWUpLCB0aGUgd2luZG93IHN0b3BzIGRpc3BhdGNoaW5nIHNjcm9sbCBldmVudHMgb24gdGhlIHdpbmRvdyBpZiB5b3Ugc2Nyb2xsIHJlYWxseSBmYXN0LCBidXQgaXQncyBjb25zaXN0ZW50IG9uIHRoZSBkb2N1bWVudCFcblxuXG4gICAgICAgICAgdmFyIGJvZHlTdHlsZSA9IF9ib2R5LnN0eWxlLFxuICAgICAgICAgICAgICBib3JkZXIgPSBib2R5U3R5bGUuYm9yZGVyVG9wU3R5bGUsXG4gICAgICAgICAgICAgIGJvdW5kcztcbiAgICAgICAgICBib2R5U3R5bGUuYm9yZGVyVG9wU3R5bGUgPSBcInNvbGlkXCI7IC8vIHdvcmtzIGFyb3VuZCBhbiBpc3N1ZSB3aGVyZSBhIG1hcmdpbiBvZiBhIGNoaWxkIGVsZW1lbnQgY291bGQgdGhyb3cgb2ZmIHRoZSBib3VuZHMgb2YgdGhlIF9ib2R5LCBtYWtpbmcgaXQgc2VlbSBsaWtlIHRoZXJlJ3MgYSBtYXJnaW4gd2hlbiB0aGVyZSBhY3R1YWxseSBpc24ndC4gVGhlIGJvcmRlciBlbnN1cmVzIHRoYXQgdGhlIGJvdW5kcyBhcmUgYWNjdXJhdGUuXG5cbiAgICAgICAgICBib3VuZHMgPSBfZ2V0Qm91bmRzKF9ib2R5KTtcbiAgICAgICAgICBfdmVydGljYWwubSA9IE1hdGgucm91bmQoYm91bmRzLnRvcCArIF92ZXJ0aWNhbC5zYygpKSB8fCAwOyAvLyBhY2NvbW1vZGF0ZSB0aGUgb2Zmc2V0IG9mIHRoZSA8Ym9keT4gY2F1c2VkIGJ5IG1hcmdpbnMgYW5kL29yIHBhZGRpbmdcblxuICAgICAgICAgIF9ob3Jpem9udGFsLm0gPSBNYXRoLnJvdW5kKGJvdW5kcy5sZWZ0ICsgX2hvcml6b250YWwuc2MoKSkgfHwgMDtcbiAgICAgICAgICBib3JkZXIgPyBib2R5U3R5bGUuYm9yZGVyVG9wU3R5bGUgPSBib3JkZXIgOiBib2R5U3R5bGUucmVtb3ZlUHJvcGVydHkoXCJib3JkZXItdG9wLXN0eWxlXCIpO1xuICAgICAgICAgIF9zeW5jSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChfc3luYywgMjAwKTtcbiAgICAgICAgICBnc2FwLmRlbGF5ZWRDYWxsKDAuNSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdGFydHVwID0gMDtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIF9hZGRMaXN0ZW5lcihfZG9jLCBcInRvdWNoY2FuY2VsXCIsIF9wYXNzVGhyb3VnaCk7IC8vIHNvbWUgb2xkZXIgQW5kcm9pZCBkZXZpY2VzIGludGVybWl0dGVudGx5IHN0b3AgZGlzcGF0Y2hpbmcgXCJ0b3VjaG1vdmVcIiBldmVudHMgaWYgd2UgZG9uJ3QgbGlzdGVuIGZvciBcInRvdWNoY2FuY2VsXCIgb24gdGhlIGRvY3VtZW50LlxuXG5cbiAgICAgICAgICBfYWRkTGlzdGVuZXIoX2JvZHksIFwidG91Y2hzdGFydFwiLCBfcGFzc1Rocm91Z2gpOyAvL3dvcmtzIGFyb3VuZCBTYWZhcmkgYnVnOiBodHRwczovL2dyZWVuc29jay5jb20vZm9ydW1zL3RvcGljLzIxNDUwLWRyYWdnYWJsZS1pbi1pZnJhbWUtb24tbW9iaWxlLWlzLWJ1Z2d5L1xuXG5cbiAgICAgICAgICBfbXVsdGlMaXN0ZW5lcihfYWRkTGlzdGVuZXIsIF9kb2MsIFwicG9pbnRlcmRvd24sdG91Y2hzdGFydCxtb3VzZWRvd25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9wb2ludGVySXNEb3duID0gMTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIF9tdWx0aUxpc3RlbmVyKF9hZGRMaXN0ZW5lciwgX2RvYywgXCJwb2ludGVydXAsdG91Y2hlbmQsbW91c2V1cFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3BvaW50ZXJJc0Rvd24gPSAwO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgX3RyYW5zZm9ybVByb3AgPSBnc2FwLnV0aWxzLmNoZWNrUHJlZml4KFwidHJhbnNmb3JtXCIpO1xuXG4gICAgICAgICAgX3N0YXRlUHJvcHMucHVzaChfdHJhbnNmb3JtUHJvcCk7XG5cbiAgICAgICAgICBfY29yZUluaXR0ZWQgPSBfZ2V0VGltZSgpO1xuICAgICAgICAgIF9yZXNpemVEZWxheSA9IGdzYXAuZGVsYXllZENhbGwoMC4yLCBfcmVmcmVzaEFsbCkucGF1c2UoKTtcbiAgICAgICAgICBfYXV0b1JlZnJlc2ggPSBbX2RvYywgXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB3ID0gX3dpbi5pbm5lcldpZHRoLFxuICAgICAgICAgICAgICAgIGggPSBfd2luLmlubmVySGVpZ2h0O1xuXG4gICAgICAgICAgICBpZiAoX2RvYy5oaWRkZW4pIHtcbiAgICAgICAgICAgICAgX3ByZXZXaWR0aCA9IHc7XG4gICAgICAgICAgICAgIF9wcmV2SGVpZ2h0ID0gaDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX3ByZXZXaWR0aCAhPT0gdyB8fCBfcHJldkhlaWdodCAhPT0gaCkge1xuICAgICAgICAgICAgICBfb25SZXNpemUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBfZG9jLCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgX3JlZnJlc2hBbGwsIF93aW4sIFwibG9hZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX2xhc3RTY3JvbGxUaW1lIHx8IF9yZWZyZXNoQWxsKCk7XG4gICAgICAgICAgfSwgX3dpbiwgXCJyZXNpemVcIiwgX29uUmVzaXplXTtcblxuICAgICAgICAgIF9pdGVyYXRlQXV0b1JlZnJlc2goX2FkZExpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfY29yZUluaXR0ZWQ7XG4gIH07XG5cbiAgU2Nyb2xsVHJpZ2dlci5kZWZhdWx0cyA9IGZ1bmN0aW9uIGRlZmF1bHRzKGNvbmZpZykge1xuICAgIGlmIChjb25maWcpIHtcbiAgICAgIGZvciAodmFyIHAgaW4gY29uZmlnKSB7XG4gICAgICAgIF9kZWZhdWx0c1twXSA9IGNvbmZpZ1twXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gX2RlZmF1bHRzO1xuICB9O1xuXG4gIFNjcm9sbFRyaWdnZXIua2lsbCA9IGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgX2VuYWJsZWQgPSAwO1xuXG4gICAgX3RyaWdnZXJzLnNsaWNlKDApLmZvckVhY2goZnVuY3Rpb24gKHRyaWdnZXIpIHtcbiAgICAgIHJldHVybiB0cmlnZ2VyLmtpbGwoMSk7XG4gICAgfSk7XG4gIH07XG5cbiAgU2Nyb2xsVHJpZ2dlci5jb25maWcgPSBmdW5jdGlvbiBjb25maWcodmFycykge1xuICAgIFwibGltaXRDYWxsYmFja3NcIiBpbiB2YXJzICYmIChfbGltaXRDYWxsYmFja3MgPSAhIXZhcnMubGltaXRDYWxsYmFja3MpO1xuICAgIHZhciBtcyA9IHZhcnMuc3luY0ludGVydmFsO1xuICAgIG1zICYmIGNsZWFySW50ZXJ2YWwoX3N5bmNJbnRlcnZhbCkgfHwgKF9zeW5jSW50ZXJ2YWwgPSBtcykgJiYgc2V0SW50ZXJ2YWwoX3N5bmMsIG1zKTtcblxuICAgIGlmIChcImF1dG9SZWZyZXNoRXZlbnRzXCIgaW4gdmFycykge1xuICAgICAgX2l0ZXJhdGVBdXRvUmVmcmVzaChfcmVtb3ZlTGlzdGVuZXIpIHx8IF9pdGVyYXRlQXV0b1JlZnJlc2goX2FkZExpc3RlbmVyLCB2YXJzLmF1dG9SZWZyZXNoRXZlbnRzIHx8IFwibm9uZVwiKTtcbiAgICAgIF9pZ25vcmVSZXNpemUgPSAodmFycy5hdXRvUmVmcmVzaEV2ZW50cyArIFwiXCIpLmluZGV4T2YoXCJyZXNpemVcIikgPT09IC0xO1xuICAgIH1cbiAgfTtcblxuICBTY3JvbGxUcmlnZ2VyLnNjcm9sbGVyUHJveHkgPSBmdW5jdGlvbiBzY3JvbGxlclByb3h5KHRhcmdldCwgdmFycykge1xuICAgIHZhciB0ID0gX2dldFRhcmdldCh0YXJnZXQpLFxuICAgICAgICBpID0gX3Njcm9sbGVycy5pbmRleE9mKHQpLFxuICAgICAgICBpc1ZpZXdwb3J0ID0gX2lzVmlld3BvcnQodCk7XG5cbiAgICBpZiAofmkpIHtcbiAgICAgIF9zY3JvbGxlcnMuc3BsaWNlKGksIGlzVmlld3BvcnQgPyA2IDogMik7XG4gICAgfVxuXG4gICAgaWYgKHZhcnMpIHtcbiAgICAgIGlzVmlld3BvcnQgPyBfcHJveGllcy51bnNoaWZ0KF93aW4sIHZhcnMsIF9ib2R5LCB2YXJzLCBfZG9jRWwsIHZhcnMpIDogX3Byb3hpZXMudW5zaGlmdCh0LCB2YXJzKTtcbiAgICB9XG4gIH07XG5cbiAgU2Nyb2xsVHJpZ2dlci5tYXRjaE1lZGlhID0gZnVuY3Rpb24gbWF0Y2hNZWRpYSh2YXJzKSB7XG4gICAgLy8gX21lZGlhIGlzIHBvcHVsYXRlZCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyOiBtZWRpYVF1ZXJ5U3RyaW5nLCBvbk1hdGNoLCBvblVubWF0Y2gsIGlzTWF0Y2hlZC4gU28gaWYgdGhlcmUgYXJlIHR3byBtZWRpYSBxdWVyaWVzLCB0aGUgQXJyYXkgd291bGQgaGF2ZSBhIGxlbmd0aCBvZiA4XG4gICAgdmFyIG1xLCBwLCBpLCBmdW5jLCByZXN1bHQ7XG5cbiAgICBmb3IgKHAgaW4gdmFycykge1xuICAgICAgaSA9IF9tZWRpYS5pbmRleE9mKHApO1xuICAgICAgZnVuYyA9IHZhcnNbcF07XG4gICAgICBfY3JlYXRpbmdNZWRpYSA9IHA7XG5cbiAgICAgIGlmIChwID09PSBcImFsbFwiKSB7XG4gICAgICAgIGZ1bmMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1xID0gX3dpbi5tYXRjaE1lZGlhKHApO1xuXG4gICAgICAgIGlmIChtcSkge1xuICAgICAgICAgIG1xLm1hdGNoZXMgJiYgKHJlc3VsdCA9IGZ1bmMoKSk7XG5cbiAgICAgICAgICBpZiAofmkpIHtcbiAgICAgICAgICAgIF9tZWRpYVtpICsgMV0gPSBfY29tYmluZUZ1bmMoX21lZGlhW2kgKyAxXSwgZnVuYyk7XG4gICAgICAgICAgICBfbWVkaWFbaSArIDJdID0gX2NvbWJpbmVGdW5jKF9tZWRpYVtpICsgMl0sIHJlc3VsdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGkgPSBfbWVkaWEubGVuZ3RoO1xuXG4gICAgICAgICAgICBfbWVkaWEucHVzaChwLCBmdW5jLCByZXN1bHQpO1xuXG4gICAgICAgICAgICBtcS5hZGRMaXN0ZW5lciA/IG1xLmFkZExpc3RlbmVyKF9vbk1lZGlhQ2hhbmdlKSA6IG1xLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgX29uTWVkaWFDaGFuZ2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9tZWRpYVtpICsgM10gPSBtcS5tYXRjaGVzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIF9jcmVhdGluZ01lZGlhID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gX21lZGlhO1xuICB9O1xuXG4gIFNjcm9sbFRyaWdnZXIuY2xlYXJNYXRjaE1lZGlhID0gZnVuY3Rpb24gY2xlYXJNYXRjaE1lZGlhKHF1ZXJ5KSB7XG4gICAgcXVlcnkgfHwgKF9tZWRpYS5sZW5ndGggPSAwKTtcbiAgICBxdWVyeSA9IF9tZWRpYS5pbmRleE9mKHF1ZXJ5KTtcbiAgICBxdWVyeSA+PSAwICYmIF9tZWRpYS5zcGxpY2UocXVlcnksIDQpO1xuICB9O1xuXG4gIFNjcm9sbFRyaWdnZXIuaXNJblZpZXdwb3J0ID0gZnVuY3Rpb24gaXNJblZpZXdwb3J0KGVsZW1lbnQsIHJhdGlvLCBob3Jpem9udGFsKSB7XG4gICAgdmFyIGJvdW5kcyA9IChfaXNTdHJpbmcoZWxlbWVudCkgPyBfZ2V0VGFyZ2V0KGVsZW1lbnQpIDogZWxlbWVudCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIG9mZnNldCA9IGJvdW5kc1tob3Jpem9udGFsID8gX3dpZHRoIDogX2hlaWdodF0gKiByYXRpbyB8fCAwO1xuICAgIHJldHVybiBob3Jpem9udGFsID8gYm91bmRzLnJpZ2h0IC0gb2Zmc2V0ID4gMCAmJiBib3VuZHMubGVmdCArIG9mZnNldCA8IF93aW4uaW5uZXJXaWR0aCA6IGJvdW5kcy5ib3R0b20gLSBvZmZzZXQgPiAwICYmIGJvdW5kcy50b3AgKyBvZmZzZXQgPCBfd2luLmlubmVySGVpZ2h0O1xuICB9O1xuXG4gIFNjcm9sbFRyaWdnZXIucG9zaXRpb25JblZpZXdwb3J0ID0gZnVuY3Rpb24gcG9zaXRpb25JblZpZXdwb3J0KGVsZW1lbnQsIHJlZmVyZW5jZVBvaW50LCBob3Jpem9udGFsKSB7XG4gICAgX2lzU3RyaW5nKGVsZW1lbnQpICYmIChlbGVtZW50ID0gX2dldFRhcmdldChlbGVtZW50KSk7XG4gICAgdmFyIGJvdW5kcyA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIHNpemUgPSBib3VuZHNbaG9yaXpvbnRhbCA/IF93aWR0aCA6IF9oZWlnaHRdLFxuICAgICAgICBvZmZzZXQgPSByZWZlcmVuY2VQb2ludCA9PSBudWxsID8gc2l6ZSAvIDIgOiByZWZlcmVuY2VQb2ludCBpbiBfa2V5d29yZHMgPyBfa2V5d29yZHNbcmVmZXJlbmNlUG9pbnRdICogc2l6ZSA6IH5yZWZlcmVuY2VQb2ludC5pbmRleE9mKFwiJVwiKSA/IHBhcnNlRmxvYXQocmVmZXJlbmNlUG9pbnQpICogc2l6ZSAvIDEwMCA6IHBhcnNlRmxvYXQocmVmZXJlbmNlUG9pbnQpIHx8IDA7XG4gICAgcmV0dXJuIGhvcml6b250YWwgPyAoYm91bmRzLmxlZnQgKyBvZmZzZXQpIC8gX3dpbi5pbm5lcldpZHRoIDogKGJvdW5kcy50b3AgKyBvZmZzZXQpIC8gX3dpbi5pbm5lckhlaWdodDtcbiAgfTtcblxuICByZXR1cm4gU2Nyb2xsVHJpZ2dlcjtcbn0oKTtcblNjcm9sbFRyaWdnZXIudmVyc2lvbiA9IFwiMy45LjFcIjtcblxuU2Nyb2xsVHJpZ2dlci5zYXZlU3R5bGVzID0gZnVuY3Rpb24gKHRhcmdldHMpIHtcbiAgcmV0dXJuIHRhcmdldHMgPyBfdG9BcnJheSh0YXJnZXRzKS5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAvLyBzYXZlZCBzdHlsZXMgYXJlIHJlY29yZGVkIGluIGEgY29uc2VjdXRpdmUgYWx0ZXJuYXRpbmcgQXJyYXksIGxpa2UgW2VsZW1lbnQsIGNzc1RleHQsIHRyYW5zZm9ybSBhdHRyaWJ1dGUsIGNhY2hlLCBtYXRjaE1lZGlhLCAuLi5dXG4gICAgaWYgKHRhcmdldCAmJiB0YXJnZXQuc3R5bGUpIHtcbiAgICAgIHZhciBpID0gX3NhdmVkU3R5bGVzLmluZGV4T2YodGFyZ2V0KTtcblxuICAgICAgaSA+PSAwICYmIF9zYXZlZFN0eWxlcy5zcGxpY2UoaSwgNSk7XG5cbiAgICAgIF9zYXZlZFN0eWxlcy5wdXNoKHRhcmdldCwgdGFyZ2V0LnN0eWxlLmNzc1RleHQsIHRhcmdldC5nZXRCQm94ICYmIHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiksIGdzYXAuY29yZS5nZXRDYWNoZSh0YXJnZXQpLCBfY3JlYXRpbmdNZWRpYSk7XG4gICAgfVxuICB9KSA6IF9zYXZlZFN0eWxlcztcbn07XG5cblNjcm9sbFRyaWdnZXIucmV2ZXJ0ID0gZnVuY3Rpb24gKHNvZnQsIG1lZGlhKSB7XG4gIHJldHVybiBfcmV2ZXJ0QWxsKCFzb2Z0LCBtZWRpYSk7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLmNyZWF0ZSA9IGZ1bmN0aW9uICh2YXJzLCBhbmltYXRpb24pIHtcbiAgcmV0dXJuIG5ldyBTY3JvbGxUcmlnZ2VyKHZhcnMsIGFuaW1hdGlvbik7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLnJlZnJlc2ggPSBmdW5jdGlvbiAoc2FmZSkge1xuICByZXR1cm4gc2FmZSA/IF9vblJlc2l6ZSgpIDogKF9jb3JlSW5pdHRlZCB8fCBTY3JvbGxUcmlnZ2VyLnJlZ2lzdGVyKCkpICYmIF9yZWZyZXNoQWxsKHRydWUpO1xufTtcblxuU2Nyb2xsVHJpZ2dlci51cGRhdGUgPSBfdXBkYXRlQWxsO1xuU2Nyb2xsVHJpZ2dlci5jbGVhclNjcm9sbE1lbW9yeSA9IF9jbGVhclNjcm9sbE1lbW9yeTtcblxuU2Nyb2xsVHJpZ2dlci5tYXhTY3JvbGwgPSBmdW5jdGlvbiAoZWxlbWVudCwgaG9yaXpvbnRhbCkge1xuICByZXR1cm4gX21heFNjcm9sbChlbGVtZW50LCBob3Jpem9udGFsID8gX2hvcml6b250YWwgOiBfdmVydGljYWwpO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5nZXRTY3JvbGxGdW5jID0gZnVuY3Rpb24gKGVsZW1lbnQsIGhvcml6b250YWwpIHtcbiAgcmV0dXJuIF9nZXRTY3JvbGxGdW5jKF9nZXRUYXJnZXQoZWxlbWVudCksIGhvcml6b250YWwgPyBfaG9yaXpvbnRhbCA6IF92ZXJ0aWNhbCk7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLmdldEJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgcmV0dXJuIF9pZHNbaWRdO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5nZXRBbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBfdHJpZ2dlcnMuc2xpY2UoMCk7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLmlzU2Nyb2xsaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gISFfbGFzdFNjcm9sbFRpbWU7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLnNuYXBEaXJlY3Rpb25hbCA9IF9zbmFwRGlyZWN0aW9uYWw7XG5cblNjcm9sbFRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICh0eXBlLCBjYWxsYmFjaykge1xuICB2YXIgYSA9IF9saXN0ZW5lcnNbdHlwZV0gfHwgKF9saXN0ZW5lcnNbdHlwZV0gPSBbXSk7XG4gIH5hLmluZGV4T2YoY2FsbGJhY2spIHx8IGEucHVzaChjYWxsYmFjayk7XG59O1xuXG5TY3JvbGxUcmlnZ2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAodHlwZSwgY2FsbGJhY2spIHtcbiAgdmFyIGEgPSBfbGlzdGVuZXJzW3R5cGVdLFxuICAgICAgaSA9IGEgJiYgYS5pbmRleE9mKGNhbGxiYWNrKTtcbiAgaSA+PSAwICYmIGEuc3BsaWNlKGksIDEpO1xufTtcblxuU2Nyb2xsVHJpZ2dlci5iYXRjaCA9IGZ1bmN0aW9uICh0YXJnZXRzLCB2YXJzKSB7XG4gIHZhciByZXN1bHQgPSBbXSxcbiAgICAgIHZhcnNDb3B5ID0ge30sXG4gICAgICBpbnRlcnZhbCA9IHZhcnMuaW50ZXJ2YWwgfHwgMC4wMTYsXG4gICAgICBiYXRjaE1heCA9IHZhcnMuYmF0Y2hNYXggfHwgMWU5LFxuICAgICAgcHJveHlDYWxsYmFjayA9IGZ1bmN0aW9uIHByb3h5Q2FsbGJhY2sodHlwZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgZWxlbWVudHMgPSBbXSxcbiAgICAgICAgdHJpZ2dlcnMgPSBbXSxcbiAgICAgICAgZGVsYXkgPSBnc2FwLmRlbGF5ZWRDYWxsKGludGVydmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjayhlbGVtZW50cywgdHJpZ2dlcnMpO1xuICAgICAgZWxlbWVudHMgPSBbXTtcbiAgICAgIHRyaWdnZXJzID0gW107XG4gICAgfSkucGF1c2UoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHNlbGYpIHtcbiAgICAgIGVsZW1lbnRzLmxlbmd0aCB8fCBkZWxheS5yZXN0YXJ0KHRydWUpO1xuICAgICAgZWxlbWVudHMucHVzaChzZWxmLnRyaWdnZXIpO1xuICAgICAgdHJpZ2dlcnMucHVzaChzZWxmKTtcbiAgICAgIGJhdGNoTWF4IDw9IGVsZW1lbnRzLmxlbmd0aCAmJiBkZWxheS5wcm9ncmVzcygxKTtcbiAgICB9O1xuICB9LFxuICAgICAgcDtcblxuICBmb3IgKHAgaW4gdmFycykge1xuICAgIHZhcnNDb3B5W3BdID0gcC5zdWJzdHIoMCwgMikgPT09IFwib25cIiAmJiBfaXNGdW5jdGlvbih2YXJzW3BdKSAmJiBwICE9PSBcIm9uUmVmcmVzaEluaXRcIiA/IHByb3h5Q2FsbGJhY2socCwgdmFyc1twXSkgOiB2YXJzW3BdO1xuICB9XG5cbiAgaWYgKF9pc0Z1bmN0aW9uKGJhdGNoTWF4KSkge1xuICAgIGJhdGNoTWF4ID0gYmF0Y2hNYXgoKTtcblxuICAgIF9hZGRMaXN0ZW5lcihTY3JvbGxUcmlnZ2VyLCBcInJlZnJlc2hcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGJhdGNoTWF4ID0gdmFycy5iYXRjaE1heCgpO1xuICAgIH0pO1xuICB9XG5cbiAgX3RvQXJyYXkodGFyZ2V0cykuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdmFyIGNvbmZpZyA9IHt9O1xuXG4gICAgZm9yIChwIGluIHZhcnNDb3B5KSB7XG4gICAgICBjb25maWdbcF0gPSB2YXJzQ29weVtwXTtcbiAgICB9XG5cbiAgICBjb25maWcudHJpZ2dlciA9IHRhcmdldDtcbiAgICByZXN1bHQucHVzaChTY3JvbGxUcmlnZ2VyLmNyZWF0ZShjb25maWcpKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblNjcm9sbFRyaWdnZXIuc29ydCA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gIHJldHVybiBfdHJpZ2dlcnMuc29ydChmdW5jIHx8IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIChhLnZhcnMucmVmcmVzaFByaW9yaXR5IHx8IDApICogLTFlNiArIGEuc3RhcnQgLSAoYi5zdGFydCArIChiLnZhcnMucmVmcmVzaFByaW9yaXR5IHx8IDApICogLTFlNik7XG4gIH0pO1xufTtcblxuX2dldEdTQVAoKSAmJiBnc2FwLnJlZ2lzdGVyUGx1Z2luKFNjcm9sbFRyaWdnZXIpO1xuZXhwb3J0IHsgU2Nyb2xsVHJpZ2dlciBhcyBkZWZhdWx0IH07IiwiLyohXG4gKiBUZXh0UGx1Z2luIDMuOS4xXG4gKiBodHRwczovL2dyZWVuc29jay5jb21cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAwOC0yMDIxLCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuaW1wb3J0IHsgZW1vamlTYWZlU3BsaXQsIGdldFRleHQsIHNwbGl0SW5uZXJIVE1MIH0gZnJvbSBcIi4vdXRpbHMvc3RyaW5ncy5qc1wiO1xuXG52YXIgZ3NhcCxcbiAgICBfdGVtcERpdixcbiAgICBfZ2V0R1NBUCA9IGZ1bmN0aW9uIF9nZXRHU0FQKCkge1xuICByZXR1cm4gZ3NhcCB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIChnc2FwID0gd2luZG93LmdzYXApICYmIGdzYXAucmVnaXN0ZXJQbHVnaW4gJiYgZ3NhcDtcbn07XG5cbmV4cG9ydCB2YXIgVGV4dFBsdWdpbiA9IHtcbiAgdmVyc2lvbjogXCIzLjkuMVwiLFxuICBuYW1lOiBcInRleHRcIixcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCh0YXJnZXQsIHZhbHVlLCB0d2Vlbikge1xuICAgIHZhciBpID0gdGFyZ2V0Lm5vZGVOYW1lLnRvVXBwZXJDYXNlKCksXG4gICAgICAgIGRhdGEgPSB0aGlzLFxuICAgICAgICBfc2hvcnQsXG4gICAgICAgIHRleHQsXG4gICAgICAgIG9yaWdpbmFsLFxuICAgICAgICBqLFxuICAgICAgICBjb25kZW5zZWRUZXh0LFxuICAgICAgICBjb25kZW5zZWRPcmlnaW5hbCxcbiAgICAgICAgYWdncmVnYXRlLFxuICAgICAgICBzO1xuXG4gICAgZGF0YS5zdmcgPSB0YXJnZXQuZ2V0QkJveCAmJiAoaSA9PT0gXCJURVhUXCIgfHwgaSA9PT0gXCJUU1BBTlwiKTtcblxuICAgIGlmICghKFwiaW5uZXJIVE1MXCIgaW4gdGFyZ2V0KSAmJiAhZGF0YS5zdmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBkYXRhLnRhcmdldCA9IHRhcmdldDtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHZhbHVlID0ge1xuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCEoXCJ2YWx1ZVwiIGluIHZhbHVlKSkge1xuICAgICAgZGF0YS50ZXh0ID0gZGF0YS5vcmlnaW5hbCA9IFtcIlwiXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkYXRhLmRlbGltaXRlciA9IHZhbHVlLmRlbGltaXRlciB8fCBcIlwiO1xuICAgIG9yaWdpbmFsID0gc3BsaXRJbm5lckhUTUwodGFyZ2V0LCBkYXRhLmRlbGltaXRlciwgZmFsc2UsIHZhbHVlLnByZXNlcnZlU3BhY2VzKTtcblxuICAgIGlmICghX3RlbXBEaXYpIHtcbiAgICAgIF90ZW1wRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB9XG5cbiAgICBfdGVtcERpdi5pbm5lckhUTUwgPSB2YWx1ZS52YWx1ZTtcbiAgICB0ZXh0ID0gc3BsaXRJbm5lckhUTUwoX3RlbXBEaXYsIGRhdGEuZGVsaW1pdGVyKTtcbiAgICBkYXRhLmZyb20gPSB0d2Vlbi5fZnJvbTtcblxuICAgIGlmIChkYXRhLmZyb20pIHtcbiAgICAgIGkgPSBvcmlnaW5hbDtcbiAgICAgIG9yaWdpbmFsID0gdGV4dDtcbiAgICAgIHRleHQgPSBpO1xuICAgIH1cblxuICAgIGRhdGEuaGFzQ2xhc3MgPSAhISh2YWx1ZS5uZXdDbGFzcyB8fCB2YWx1ZS5vbGRDbGFzcyk7XG4gICAgZGF0YS5uZXdDbGFzcyA9IHZhbHVlLm5ld0NsYXNzO1xuICAgIGRhdGEub2xkQ2xhc3MgPSB2YWx1ZS5vbGRDbGFzcztcbiAgICBpID0gb3JpZ2luYWwubGVuZ3RoIC0gdGV4dC5sZW5ndGg7XG4gICAgX3Nob3J0ID0gaSA8IDAgPyBvcmlnaW5hbCA6IHRleHQ7XG4gICAgZGF0YS5maWxsQ2hhciA9IHZhbHVlLmZpbGxDaGFyIHx8ICh2YWx1ZS5wYWRTcGFjZSA/IFwiJm5ic3A7XCIgOiBcIlwiKTtcblxuICAgIGlmIChpIDwgMCkge1xuICAgICAgaSA9IC1pO1xuICAgIH1cblxuICAgIHdoaWxlICgtLWkgPiAtMSkge1xuICAgICAgX3Nob3J0LnB1c2goZGF0YS5maWxsQ2hhcik7XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlLnR5cGUgPT09IFwiZGlmZlwiKSB7XG4gICAgICBqID0gMDtcbiAgICAgIGNvbmRlbnNlZFRleHQgPSBbXTtcbiAgICAgIGNvbmRlbnNlZE9yaWdpbmFsID0gW107XG4gICAgICBhZ2dyZWdhdGUgPSBcIlwiO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBzID0gdGV4dFtpXTtcblxuICAgICAgICBpZiAocyA9PT0gb3JpZ2luYWxbaV0pIHtcbiAgICAgICAgICBhZ2dyZWdhdGUgKz0gcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25kZW5zZWRUZXh0W2pdID0gYWdncmVnYXRlICsgcztcbiAgICAgICAgICBjb25kZW5zZWRPcmlnaW5hbFtqKytdID0gYWdncmVnYXRlICsgb3JpZ2luYWxbaV07XG4gICAgICAgICAgYWdncmVnYXRlID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0ZXh0ID0gY29uZGVuc2VkVGV4dDtcbiAgICAgIG9yaWdpbmFsID0gY29uZGVuc2VkT3JpZ2luYWw7XG5cbiAgICAgIGlmIChhZ2dyZWdhdGUpIHtcbiAgICAgICAgdGV4dC5wdXNoKGFnZ3JlZ2F0ZSk7XG4gICAgICAgIG9yaWdpbmFsLnB1c2goYWdncmVnYXRlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmFsdWUuc3BlZWQpIHtcbiAgICAgIHR3ZWVuLmR1cmF0aW9uKE1hdGgubWluKDAuMDUgLyB2YWx1ZS5zcGVlZCAqIF9zaG9ydC5sZW5ndGgsIHZhbHVlLm1heER1cmF0aW9uIHx8IDk5OTkpKTtcbiAgICB9XG5cbiAgICB0aGlzLm9yaWdpbmFsID0gb3JpZ2luYWw7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcblxuICAgIHRoaXMuX3Byb3BzLnB1c2goXCJ0ZXh0XCIpO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihyYXRpbywgZGF0YSkge1xuICAgIGlmIChyYXRpbyA+IDEpIHtcbiAgICAgIHJhdGlvID0gMTtcbiAgICB9IGVsc2UgaWYgKHJhdGlvIDwgMCkge1xuICAgICAgcmF0aW8gPSAwO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmZyb20pIHtcbiAgICAgIHJhdGlvID0gMSAtIHJhdGlvO1xuICAgIH1cblxuICAgIHZhciB0ZXh0ID0gZGF0YS50ZXh0LFxuICAgICAgICBoYXNDbGFzcyA9IGRhdGEuaGFzQ2xhc3MsXG4gICAgICAgIG5ld0NsYXNzID0gZGF0YS5uZXdDbGFzcyxcbiAgICAgICAgb2xkQ2xhc3MgPSBkYXRhLm9sZENsYXNzLFxuICAgICAgICBkZWxpbWl0ZXIgPSBkYXRhLmRlbGltaXRlcixcbiAgICAgICAgdGFyZ2V0ID0gZGF0YS50YXJnZXQsXG4gICAgICAgIGZpbGxDaGFyID0gZGF0YS5maWxsQ2hhcixcbiAgICAgICAgb3JpZ2luYWwgPSBkYXRhLm9yaWdpbmFsLFxuICAgICAgICBsID0gdGV4dC5sZW5ndGgsXG4gICAgICAgIGkgPSByYXRpbyAqIGwgKyAwLjUgfCAwLFxuICAgICAgICBhcHBseU5ldyxcbiAgICAgICAgYXBwbHlPbGQsXG4gICAgICAgIHN0cjtcblxuICAgIGlmIChoYXNDbGFzcyAmJiByYXRpbykge1xuICAgICAgYXBwbHlOZXcgPSBuZXdDbGFzcyAmJiBpO1xuICAgICAgYXBwbHlPbGQgPSBvbGRDbGFzcyAmJiBpICE9PSBsO1xuICAgICAgc3RyID0gKGFwcGx5TmV3ID8gXCI8c3BhbiBjbGFzcz0nXCIgKyBuZXdDbGFzcyArIFwiJz5cIiA6IFwiXCIpICsgdGV4dC5zbGljZSgwLCBpKS5qb2luKGRlbGltaXRlcikgKyAoYXBwbHlOZXcgPyBcIjwvc3Bhbj5cIiA6IFwiXCIpICsgKGFwcGx5T2xkID8gXCI8c3BhbiBjbGFzcz0nXCIgKyBvbGRDbGFzcyArIFwiJz5cIiA6IFwiXCIpICsgZGVsaW1pdGVyICsgb3JpZ2luYWwuc2xpY2UoaSkuam9pbihkZWxpbWl0ZXIpICsgKGFwcGx5T2xkID8gXCI8L3NwYW4+XCIgOiBcIlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gdGV4dC5zbGljZSgwLCBpKS5qb2luKGRlbGltaXRlcikgKyBkZWxpbWl0ZXIgKyBvcmlnaW5hbC5zbGljZShpKS5qb2luKGRlbGltaXRlcik7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEuc3ZnKSB7XG4gICAgICAvL1NWRyB0ZXh0IGVsZW1lbnRzIGRvbid0IGhhdmUgYW4gXCJpbm5lckhUTUxcIiBpbiBNaWNyb3NvZnQgYnJvd3NlcnMuXG4gICAgICB0YXJnZXQudGV4dENvbnRlbnQgPSBzdHI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldC5pbm5lckhUTUwgPSBmaWxsQ2hhciA9PT0gXCImbmJzcDtcIiAmJiB+c3RyLmluZGV4T2YoXCIgIFwiKSA/IHN0ci5zcGxpdChcIiAgXCIpLmpvaW4oXCImbmJzcDsmbmJzcDtcIikgOiBzdHI7XG4gICAgfVxuICB9XG59O1xuVGV4dFBsdWdpbi5zcGxpdElubmVySFRNTCA9IHNwbGl0SW5uZXJIVE1MO1xuVGV4dFBsdWdpbi5lbW9qaVNhZmVTcGxpdCA9IGVtb2ppU2FmZVNwbGl0O1xuVGV4dFBsdWdpbi5nZXRUZXh0ID0gZ2V0VGV4dDtcbl9nZXRHU0FQKCkgJiYgZ3NhcC5yZWdpc3RlclBsdWdpbihUZXh0UGx1Z2luKTtcbmV4cG9ydCB7IFRleHRQbHVnaW4gYXMgZGVmYXVsdCB9OyIsImltcG9ydCBnc2FwIGZyb20gXCIuL2dzYXAtY29yZS5qc1wiO1xuaW1wb3J0IENTU1BsdWdpbiBmcm9tIFwiLi9DU1NQbHVnaW4uanNcIjtcbnZhciBnc2FwV2l0aENTUyA9IGdzYXAucmVnaXN0ZXJQbHVnaW4oQ1NTUGx1Z2luKSB8fCBnc2FwLCAvLyB0byBwcm90ZWN0IGZyb20gdHJlZSBzaGFraW5nXG5cdFR3ZWVuTWF4V2l0aENTUyA9IGdzYXBXaXRoQ1NTLmNvcmUuVHdlZW47XG5cbmV4cG9ydCB7IGdzYXBXaXRoQ1NTIGFzIGdzYXAsIGdzYXBXaXRoQ1NTIGFzIGRlZmF1bHQsIENTU1BsdWdpbiwgVHdlZW5NYXhXaXRoQ1NTIGFzIFR3ZWVuTWF4IH07XG5leHBvcnQgeyBUd2VlbkxpdGUsIFRpbWVsaW5lTWF4LCBUaW1lbGluZUxpdGUsIFBvd2VyMCwgUG93ZXIxLCBQb3dlcjIsIFBvd2VyMywgUG93ZXI0LCBMaW5lYXIsIFF1YWQsIEN1YmljLCBRdWFydCwgUXVpbnQsIFN0cm9uZywgRWxhc3RpYywgQmFjaywgU3RlcHBlZEVhc2UsIEJvdW5jZSwgU2luZSwgRXhwbywgQ2lyYywgd3JhcCwgd3JhcFlveW8sIGRpc3RyaWJ1dGUsIHJhbmRvbSwgc25hcCwgbm9ybWFsaXplLCBnZXRVbml0LCBjbGFtcCwgc3BsaXRDb2xvciwgdG9BcnJheSwgbWFwUmFuZ2UsIHBpcGUsIHVuaXRpemUsIGludGVycG9sYXRlLCBzaHVmZmxlLCBzZWxlY3RvciB9IGZyb20gXCIuL2dzYXAtY29yZS5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vQ3VzdG9tRWFzZS5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vQ1NTUnVsZVBsdWdpbi5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vRHJhZ2dhYmxlLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9FYXNlbFBsdWdpbi5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vRWFzZVBhY2suanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL0ZsaXAuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL01vdGlvblBhdGhQbHVnaW4uanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL1BpeGlQbHVnaW4uanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL1Njcm9sbFRvUGx1Z2luLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9TY3JvbGxUcmlnZ2VyLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9UZXh0UGx1Z2luLmpzXCI7IFxuXG4vL0JPTlVTIEVYUE9SVFNcbi8vZXhwb3J0ICogZnJvbSBcIi4vRHJhd1NWR1BsdWdpbi5qc1wiO1xuLy9leHBvcnQgKiBmcm9tIFwiLi9QaHlzaWNzMkRQbHVnaW4uanNcIjtcbi8vZXhwb3J0ICogZnJvbSBcIi4vUGh5c2ljc1Byb3BzUGx1Z2luLmpzXCI7XG4vL2V4cG9ydCAqIGZyb20gXCIuL1NjcmFtYmxlVGV4dFBsdWdpbi5qc1wiO1xuLy9leHBvcnQgKiBmcm9tIFwiLi9DdXN0b21Cb3VuY2UuanNcIjtcbi8vZXhwb3J0ICogZnJvbSBcIi4vQ3VzdG9tV2lnZ2xlLmpzXCI7XG4vL2V4cG9ydCAqIGZyb20gXCIuL0dTRGV2VG9vbHMuanNcIjtcbi8vZXhwb3J0ICogZnJvbSBcIi4vSW5lcnRpYVBsdWdpbi5qc1wiO1xuLy9leHBvcnQgKiBmcm9tIFwiLi9Nb3JwaFNWR1BsdWdpbi5qc1wiO1xuLy9leHBvcnQgKiBmcm9tIFwiLi9Nb3Rpb25QYXRoSGVscGVyLmpzXCI7XG4vL2V4cG9ydCAqIGZyb20gXCIuL1NwbGl0VGV4dC5qc1wiOyIsImZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyohXG4gKiBHU0FQIDMuOS4xXG4gKiBodHRwczovL2dyZWVuc29jay5jb21cbiAqXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAwOC0yMDIxLCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xudmFyIF9jb25maWcgPSB7XG4gIGF1dG9TbGVlcDogMTIwLFxuICBmb3JjZTNEOiBcImF1dG9cIixcbiAgbnVsbFRhcmdldFdhcm46IDEsXG4gIHVuaXRzOiB7XG4gICAgbGluZUhlaWdodDogXCJcIlxuICB9XG59LFxuICAgIF9kZWZhdWx0cyA9IHtcbiAgZHVyYXRpb246IC41LFxuICBvdmVyd3JpdGU6IGZhbHNlLFxuICBkZWxheTogMFxufSxcbiAgICBfc3VwcHJlc3NPdmVyd3JpdGVzLFxuICAgIF9iaWdOdW0gPSAxZTgsXG4gICAgX3RpbnlOdW0gPSAxIC8gX2JpZ051bSxcbiAgICBfMlBJID0gTWF0aC5QSSAqIDIsXG4gICAgX0hBTEZfUEkgPSBfMlBJIC8gNCxcbiAgICBfZ3NJRCA9IDAsXG4gICAgX3NxcnQgPSBNYXRoLnNxcnQsXG4gICAgX2NvcyA9IE1hdGguY29zLFxuICAgIF9zaW4gPSBNYXRoLnNpbixcbiAgICBfaXNTdHJpbmcgPSBmdW5jdGlvbiBfaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIjtcbn0sXG4gICAgX2lzRnVuY3Rpb24gPSBmdW5jdGlvbiBfaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCI7XG59LFxuICAgIF9pc051bWJlciA9IGZ1bmN0aW9uIF9pc051bWJlcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiO1xufSxcbiAgICBfaXNVbmRlZmluZWQgPSBmdW5jdGlvbiBfaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIjtcbn0sXG4gICAgX2lzT2JqZWN0ID0gZnVuY3Rpb24gX2lzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCI7XG59LFxuICAgIF9pc05vdEZhbHNlID0gZnVuY3Rpb24gX2lzTm90RmFsc2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSBmYWxzZTtcbn0sXG4gICAgX3dpbmRvd0V4aXN0cyA9IGZ1bmN0aW9uIF93aW5kb3dFeGlzdHMoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xufSxcbiAgICBfaXNGdW5jT3JTdHJpbmcgPSBmdW5jdGlvbiBfaXNGdW5jT3JTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIF9pc0Z1bmN0aW9uKHZhbHVlKSB8fCBfaXNTdHJpbmcodmFsdWUpO1xufSxcbiAgICBfaXNUeXBlZEFycmF5ID0gdHlwZW9mIEFycmF5QnVmZmVyID09PSBcImZ1bmN0aW9uXCIgJiYgQXJyYXlCdWZmZXIuaXNWaWV3IHx8IGZ1bmN0aW9uICgpIHt9LFxuICAgIC8vIG5vdGU6IElFMTAgaGFzIEFycmF5QnVmZmVyLCBidXQgTk9UIEFycmF5QnVmZmVyLmlzVmlldygpLlxuX2lzQXJyYXkgPSBBcnJheS5pc0FycmF5LFxuICAgIF9zdHJpY3ROdW1FeHAgPSAvKD86LT9cXC4/XFxkfFxcLikrL2dpLFxuICAgIC8vb25seSBudW1iZXJzIChpbmNsdWRpbmcgbmVnYXRpdmVzIGFuZCBkZWNpbWFscykgYnV0IE5PVCByZWxhdGl2ZSB2YWx1ZXMuXG5fbnVtRXhwID0gL1stKz0uXSpcXGQrWy5lXFwtK10qXFxkKltlXFwtK10qXFxkKi9nLFxuICAgIC8vZmluZHMgYW55IG51bWJlcnMsIGluY2x1ZGluZyBvbmVzIHRoYXQgc3RhcnQgd2l0aCArPSBvciAtPSwgbmVnYXRpdmUgbnVtYmVycywgYW5kIG9uZXMgaW4gc2NpZW50aWZpYyBub3RhdGlvbiBsaWtlIDFlLTguXG5fbnVtV2l0aFVuaXRFeHAgPSAvWy0rPS5dKlxcZCtbLmUtXSpcXGQqW2EteiVdKi9nLFxuICAgIF9jb21wbGV4U3RyaW5nTnVtRXhwID0gL1stKz0uXSpcXGQrXFwuP1xcZCooPzplLXxlXFwrKT9cXGQqL2dpLFxuICAgIC8vZHVwbGljYXRlIHNvIHRoYXQgd2hpbGUgd2UncmUgbG9vcGluZyB0aHJvdWdoIG1hdGNoZXMgZnJvbSBleGVjKCksIGl0IGRvZXNuJ3QgY29udGFtaW5hdGUgdGhlIGxhc3RJbmRleCBvZiBfbnVtRXhwIHdoaWNoIHdlIHVzZSB0byBzZWFyY2ggZm9yIGNvbG9ycyB0b28uXG5fcmVsRXhwID0gL1srLV09LT9bLlxcZF0rLyxcbiAgICBfZGVsaW1pdGVkVmFsdWVFeHAgPSAvW14sJ1wiXFxbXFxdXFxzXSsvZ2ksXG4gICAgLy8gcHJldmlvdXNseSAvWyNcXC0rLl0qXFxiW2EtelxcZFxcLT0rJS5dKy9naSBidXQgZGlkbid0IGNhdGNoIHNwZWNpYWwgY2hhcmFjdGVycy5cbl91bml0RXhwID0gL1tcXGQuK1xcLT1dKyg/OmVbLStdXFxkKikqL2ksXG4gICAgX2dsb2JhbFRpbWVsaW5lLFxuICAgIF93aW4sXG4gICAgX2NvcmVJbml0dGVkLFxuICAgIF9kb2MsXG4gICAgX2dsb2JhbHMgPSB7fSxcbiAgICBfaW5zdGFsbFNjb3BlID0ge30sXG4gICAgX2NvcmVSZWFkeSxcbiAgICBfaW5zdGFsbCA9IGZ1bmN0aW9uIF9pbnN0YWxsKHNjb3BlKSB7XG4gIHJldHVybiAoX2luc3RhbGxTY29wZSA9IF9tZXJnZShzY29wZSwgX2dsb2JhbHMpKSAmJiBnc2FwO1xufSxcbiAgICBfbWlzc2luZ1BsdWdpbiA9IGZ1bmN0aW9uIF9taXNzaW5nUGx1Z2luKHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gY29uc29sZS53YXJuKFwiSW52YWxpZCBwcm9wZXJ0eVwiLCBwcm9wZXJ0eSwgXCJzZXQgdG9cIiwgdmFsdWUsIFwiTWlzc2luZyBwbHVnaW4/IGdzYXAucmVnaXN0ZXJQbHVnaW4oKVwiKTtcbn0sXG4gICAgX3dhcm4gPSBmdW5jdGlvbiBfd2FybihtZXNzYWdlLCBzdXBwcmVzcykge1xuICByZXR1cm4gIXN1cHByZXNzICYmIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbn0sXG4gICAgX2FkZEdsb2JhbCA9IGZ1bmN0aW9uIF9hZGRHbG9iYWwobmFtZSwgb2JqKSB7XG4gIHJldHVybiBuYW1lICYmIChfZ2xvYmFsc1tuYW1lXSA9IG9iaikgJiYgX2luc3RhbGxTY29wZSAmJiAoX2luc3RhbGxTY29wZVtuYW1lXSA9IG9iaikgfHwgX2dsb2JhbHM7XG59LFxuICAgIF9lbXB0eUZ1bmMgPSBmdW5jdGlvbiBfZW1wdHlGdW5jKCkge1xuICByZXR1cm4gMDtcbn0sXG4gICAgX3Jlc2VydmVkUHJvcHMgPSB7fSxcbiAgICBfbGF6eVR3ZWVucyA9IFtdLFxuICAgIF9sYXp5TG9va3VwID0ge30sXG4gICAgX2xhc3RSZW5kZXJlZEZyYW1lLFxuICAgIF9wbHVnaW5zID0ge30sXG4gICAgX2VmZmVjdHMgPSB7fSxcbiAgICBfbmV4dEdDRnJhbWUgPSAzMCxcbiAgICBfaGFybmVzc1BsdWdpbnMgPSBbXSxcbiAgICBfY2FsbGJhY2tOYW1lcyA9IFwiXCIsXG4gICAgX2hhcm5lc3MgPSBmdW5jdGlvbiBfaGFybmVzcyh0YXJnZXRzKSB7XG4gIHZhciB0YXJnZXQgPSB0YXJnZXRzWzBdLFxuICAgICAgaGFybmVzc1BsdWdpbixcbiAgICAgIGk7XG4gIF9pc09iamVjdCh0YXJnZXQpIHx8IF9pc0Z1bmN0aW9uKHRhcmdldCkgfHwgKHRhcmdldHMgPSBbdGFyZ2V0c10pO1xuXG4gIGlmICghKGhhcm5lc3NQbHVnaW4gPSAodGFyZ2V0Ll9nc2FwIHx8IHt9KS5oYXJuZXNzKSkge1xuICAgIC8vIGZpbmQgdGhlIGZpcnN0IHRhcmdldCB3aXRoIGEgaGFybmVzcy4gV2UgYXNzdW1lIHRhcmdldHMgcGFzc2VkIGludG8gYW4gYW5pbWF0aW9uIHdpbGwgYmUgb2Ygc2ltaWxhciB0eXBlLCBtZWFuaW5nIHRoZSBzYW1lIGtpbmQgb2YgaGFybmVzcyBjYW4gYmUgdXNlZCBmb3IgdGhlbSBhbGwgKHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbilcbiAgICBpID0gX2hhcm5lc3NQbHVnaW5zLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0gJiYgIV9oYXJuZXNzUGx1Z2luc1tpXS50YXJnZXRUZXN0KHRhcmdldCkpIHt9XG5cbiAgICBoYXJuZXNzUGx1Z2luID0gX2hhcm5lc3NQbHVnaW5zW2ldO1xuICB9XG5cbiAgaSA9IHRhcmdldHMubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICB0YXJnZXRzW2ldICYmICh0YXJnZXRzW2ldLl9nc2FwIHx8ICh0YXJnZXRzW2ldLl9nc2FwID0gbmV3IEdTQ2FjaGUodGFyZ2V0c1tpXSwgaGFybmVzc1BsdWdpbikpKSB8fCB0YXJnZXRzLnNwbGljZShpLCAxKTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXRzO1xufSxcbiAgICBfZ2V0Q2FjaGUgPSBmdW5jdGlvbiBfZ2V0Q2FjaGUodGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXQuX2dzYXAgfHwgX2hhcm5lc3ModG9BcnJheSh0YXJnZXQpKVswXS5fZ3NhcDtcbn0sXG4gICAgX2dldFByb3BlcnR5ID0gZnVuY3Rpb24gX2dldFByb3BlcnR5KHRhcmdldCwgcHJvcGVydHksIHYpIHtcbiAgcmV0dXJuICh2ID0gdGFyZ2V0W3Byb3BlcnR5XSkgJiYgX2lzRnVuY3Rpb24odikgPyB0YXJnZXRbcHJvcGVydHldKCkgOiBfaXNVbmRlZmluZWQodikgJiYgdGFyZ2V0LmdldEF0dHJpYnV0ZSAmJiB0YXJnZXQuZ2V0QXR0cmlidXRlKHByb3BlcnR5KSB8fCB2O1xufSxcbiAgICBfZm9yRWFjaE5hbWUgPSBmdW5jdGlvbiBfZm9yRWFjaE5hbWUobmFtZXMsIGZ1bmMpIHtcbiAgcmV0dXJuIChuYW1lcyA9IG5hbWVzLnNwbGl0KFwiLFwiKSkuZm9yRWFjaChmdW5jKSB8fCBuYW1lcztcbn0sXG4gICAgLy9zcGxpdCBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIG5hbWVzIGludG8gYW4gYXJyYXksIHRoZW4gcnVuIGEgZm9yRWFjaCgpIGZ1bmN0aW9uIGFuZCByZXR1cm4gdGhlIHNwbGl0IGFycmF5ICh0aGlzIGlzIGp1c3QgYSB3YXkgdG8gY29uc29saWRhdGUvc2hvcnRlbiBzb21lIGNvZGUpLlxuX3JvdW5kID0gZnVuY3Rpb24gX3JvdW5kKHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogMTAwMDAwKSAvIDEwMDAwMCB8fCAwO1xufSxcbiAgICBfcm91bmRQcmVjaXNlID0gZnVuY3Rpb24gX3JvdW5kUHJlY2lzZSh2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIDEwMDAwMDAwKSAvIDEwMDAwMDAwIHx8IDA7XG59LFxuICAgIC8vIGluY3JlYXNlZCBwcmVjaXNpb24gbW9zdGx5IGZvciB0aW1pbmcgdmFsdWVzLlxuX2FycmF5Q29udGFpbnNBbnkgPSBmdW5jdGlvbiBfYXJyYXlDb250YWluc0FueSh0b1NlYXJjaCwgdG9GaW5kKSB7XG4gIC8vc2VhcmNoZXMgb25lIGFycmF5IHRvIGZpbmQgbWF0Y2hlcyBmb3IgYW55IG9mIHRoZSBpdGVtcyBpbiB0aGUgdG9GaW5kIGFycmF5LiBBcyBzb29uIGFzIG9uZSBpcyBmb3VuZCwgaXQgcmV0dXJucyB0cnVlLiBJdCBkb2VzIE5PVCByZXR1cm4gYWxsIHRoZSBtYXRjaGVzOyBpdCdzIHNpbXBseSBhIGJvb2xlYW4gc2VhcmNoLlxuICB2YXIgbCA9IHRvRmluZC5sZW5ndGgsXG4gICAgICBpID0gMDtcblxuICBmb3IgKDsgdG9TZWFyY2guaW5kZXhPZih0b0ZpbmRbaV0pIDwgMCAmJiArK2kgPCBsOykge31cblxuICByZXR1cm4gaSA8IGw7XG59LFxuICAgIF9sYXp5UmVuZGVyID0gZnVuY3Rpb24gX2xhenlSZW5kZXIoKSB7XG4gIHZhciBsID0gX2xhenlUd2VlbnMubGVuZ3RoLFxuICAgICAgYSA9IF9sYXp5VHdlZW5zLnNsaWNlKDApLFxuICAgICAgaSxcbiAgICAgIHR3ZWVuO1xuXG4gIF9sYXp5TG9va3VwID0ge307XG4gIF9sYXp5VHdlZW5zLmxlbmd0aCA9IDA7XG5cbiAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIHR3ZWVuID0gYVtpXTtcbiAgICB0d2VlbiAmJiB0d2Vlbi5fbGF6eSAmJiAodHdlZW4ucmVuZGVyKHR3ZWVuLl9sYXp5WzBdLCB0d2Vlbi5fbGF6eVsxXSwgdHJ1ZSkuX2xhenkgPSAwKTtcbiAgfVxufSxcbiAgICBfbGF6eVNhZmVSZW5kZXIgPSBmdW5jdGlvbiBfbGF6eVNhZmVSZW5kZXIoYW5pbWF0aW9uLCB0aW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcbiAgX2xhenlUd2VlbnMubGVuZ3RoICYmIF9sYXp5UmVuZGVyKCk7XG4gIGFuaW1hdGlvbi5yZW5kZXIodGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgX2xhenlUd2VlbnMubGVuZ3RoICYmIF9sYXp5UmVuZGVyKCk7IC8vaW4gY2FzZSByZW5kZXJpbmcgY2F1c2VkIGFueSB0d2VlbnMgdG8gbGF6eS1pbml0LCB3ZSBzaG91bGQgcmVuZGVyIHRoZW0gYmVjYXVzZSB0eXBpY2FsbHkgd2hlbiBzb21lb25lIGNhbGxzIHNlZWsoKSBvciB0aW1lKCkgb3IgcHJvZ3Jlc3MoKSwgdGhleSBleHBlY3QgYW4gaW1tZWRpYXRlIHJlbmRlci5cbn0sXG4gICAgX251bWVyaWNJZlBvc3NpYmxlID0gZnVuY3Rpb24gX251bWVyaWNJZlBvc3NpYmxlKHZhbHVlKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gIHJldHVybiAobiB8fCBuID09PSAwKSAmJiAodmFsdWUgKyBcIlwiKS5tYXRjaChfZGVsaW1pdGVkVmFsdWVFeHApLmxlbmd0aCA8IDIgPyBuIDogX2lzU3RyaW5nKHZhbHVlKSA/IHZhbHVlLnRyaW0oKSA6IHZhbHVlO1xufSxcbiAgICBfcGFzc1Rocm91Z2ggPSBmdW5jdGlvbiBfcGFzc1Rocm91Z2gocCkge1xuICByZXR1cm4gcDtcbn0sXG4gICAgX3NldERlZmF1bHRzID0gZnVuY3Rpb24gX3NldERlZmF1bHRzKG9iaiwgZGVmYXVsdHMpIHtcbiAgZm9yICh2YXIgcCBpbiBkZWZhdWx0cykge1xuICAgIHAgaW4gb2JqIHx8IChvYmpbcF0gPSBkZWZhdWx0c1twXSk7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufSxcbiAgICBfc2V0S2V5ZnJhbWVEZWZhdWx0cyA9IGZ1bmN0aW9uIF9zZXRLZXlmcmFtZURlZmF1bHRzKGV4Y2x1ZGVEdXJhdGlvbikge1xuICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgZGVmYXVsdHMpIHtcbiAgICBmb3IgKHZhciBwIGluIGRlZmF1bHRzKSB7XG4gICAgICBwIGluIG9iaiB8fCBwID09PSBcImR1cmF0aW9uXCIgJiYgZXhjbHVkZUR1cmF0aW9uIHx8IHAgPT09IFwiZWFzZVwiIHx8IChvYmpbcF0gPSBkZWZhdWx0c1twXSk7XG4gICAgfVxuICB9O1xufSxcbiAgICBfbWVyZ2UgPSBmdW5jdGlvbiBfbWVyZ2UoYmFzZSwgdG9NZXJnZSkge1xuICBmb3IgKHZhciBwIGluIHRvTWVyZ2UpIHtcbiAgICBiYXNlW3BdID0gdG9NZXJnZVtwXTtcbiAgfVxuXG4gIHJldHVybiBiYXNlO1xufSxcbiAgICBfbWVyZ2VEZWVwID0gZnVuY3Rpb24gX21lcmdlRGVlcChiYXNlLCB0b01lcmdlKSB7XG4gIGZvciAodmFyIHAgaW4gdG9NZXJnZSkge1xuICAgIHAgIT09IFwiX19wcm90b19fXCIgJiYgcCAhPT0gXCJjb25zdHJ1Y3RvclwiICYmIHAgIT09IFwicHJvdG90eXBlXCIgJiYgKGJhc2VbcF0gPSBfaXNPYmplY3QodG9NZXJnZVtwXSkgPyBfbWVyZ2VEZWVwKGJhc2VbcF0gfHwgKGJhc2VbcF0gPSB7fSksIHRvTWVyZ2VbcF0pIDogdG9NZXJnZVtwXSk7XG4gIH1cblxuICByZXR1cm4gYmFzZTtcbn0sXG4gICAgX2NvcHlFeGNsdWRpbmcgPSBmdW5jdGlvbiBfY29weUV4Y2x1ZGluZyhvYmosIGV4Y2x1ZGluZykge1xuICB2YXIgY29weSA9IHt9LFxuICAgICAgcDtcblxuICBmb3IgKHAgaW4gb2JqKSB7XG4gICAgcCBpbiBleGNsdWRpbmcgfHwgKGNvcHlbcF0gPSBvYmpbcF0pO1xuICB9XG5cbiAgcmV0dXJuIGNvcHk7XG59LFxuICAgIF9pbmhlcml0RGVmYXVsdHMgPSBmdW5jdGlvbiBfaW5oZXJpdERlZmF1bHRzKHZhcnMpIHtcbiAgdmFyIHBhcmVudCA9IHZhcnMucGFyZW50IHx8IF9nbG9iYWxUaW1lbGluZSxcbiAgICAgIGZ1bmMgPSB2YXJzLmtleWZyYW1lcyA/IF9zZXRLZXlmcmFtZURlZmF1bHRzKF9pc0FycmF5KHZhcnMua2V5ZnJhbWVzKSkgOiBfc2V0RGVmYXVsdHM7XG5cbiAgaWYgKF9pc05vdEZhbHNlKHZhcnMuaW5oZXJpdCkpIHtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBmdW5jKHZhcnMsIHBhcmVudC52YXJzLmRlZmF1bHRzKTtcbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQgfHwgcGFyZW50Ll9kcDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFycztcbn0sXG4gICAgX2FycmF5c01hdGNoID0gZnVuY3Rpb24gX2FycmF5c01hdGNoKGExLCBhMikge1xuICB2YXIgaSA9IGExLmxlbmd0aCxcbiAgICAgIG1hdGNoID0gaSA9PT0gYTIubGVuZ3RoO1xuXG4gIHdoaWxlIChtYXRjaCAmJiBpLS0gJiYgYTFbaV0gPT09IGEyW2ldKSB7fVxuXG4gIHJldHVybiBpIDwgMDtcbn0sXG4gICAgX2FkZExpbmtlZExpc3RJdGVtID0gZnVuY3Rpb24gX2FkZExpbmtlZExpc3RJdGVtKHBhcmVudCwgY2hpbGQsIGZpcnN0UHJvcCwgbGFzdFByb3AsIHNvcnRCeSkge1xuICBpZiAoZmlyc3RQcm9wID09PSB2b2lkIDApIHtcbiAgICBmaXJzdFByb3AgPSBcIl9maXJzdFwiO1xuICB9XG5cbiAgaWYgKGxhc3RQcm9wID09PSB2b2lkIDApIHtcbiAgICBsYXN0UHJvcCA9IFwiX2xhc3RcIjtcbiAgfVxuXG4gIHZhciBwcmV2ID0gcGFyZW50W2xhc3RQcm9wXSxcbiAgICAgIHQ7XG5cbiAgaWYgKHNvcnRCeSkge1xuICAgIHQgPSBjaGlsZFtzb3J0QnldO1xuXG4gICAgd2hpbGUgKHByZXYgJiYgcHJldltzb3J0QnldID4gdCkge1xuICAgICAgcHJldiA9IHByZXYuX3ByZXY7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByZXYpIHtcbiAgICBjaGlsZC5fbmV4dCA9IHByZXYuX25leHQ7XG4gICAgcHJldi5fbmV4dCA9IGNoaWxkO1xuICB9IGVsc2Uge1xuICAgIGNoaWxkLl9uZXh0ID0gcGFyZW50W2ZpcnN0UHJvcF07XG4gICAgcGFyZW50W2ZpcnN0UHJvcF0gPSBjaGlsZDtcbiAgfVxuXG4gIGlmIChjaGlsZC5fbmV4dCkge1xuICAgIGNoaWxkLl9uZXh0Ll9wcmV2ID0gY2hpbGQ7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50W2xhc3RQcm9wXSA9IGNoaWxkO1xuICB9XG5cbiAgY2hpbGQuX3ByZXYgPSBwcmV2O1xuICBjaGlsZC5wYXJlbnQgPSBjaGlsZC5fZHAgPSBwYXJlbnQ7XG4gIHJldHVybiBjaGlsZDtcbn0sXG4gICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtID0gZnVuY3Rpb24gX3JlbW92ZUxpbmtlZExpc3RJdGVtKHBhcmVudCwgY2hpbGQsIGZpcnN0UHJvcCwgbGFzdFByb3ApIHtcbiAgaWYgKGZpcnN0UHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgZmlyc3RQcm9wID0gXCJfZmlyc3RcIjtcbiAgfVxuXG4gIGlmIChsYXN0UHJvcCA9PT0gdm9pZCAwKSB7XG4gICAgbGFzdFByb3AgPSBcIl9sYXN0XCI7XG4gIH1cblxuICB2YXIgcHJldiA9IGNoaWxkLl9wcmV2LFxuICAgICAgbmV4dCA9IGNoaWxkLl9uZXh0O1xuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5fbmV4dCA9IG5leHQ7XG4gIH0gZWxzZSBpZiAocGFyZW50W2ZpcnN0UHJvcF0gPT09IGNoaWxkKSB7XG4gICAgcGFyZW50W2ZpcnN0UHJvcF0gPSBuZXh0O1xuICB9XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0Ll9wcmV2ID0gcHJldjtcbiAgfSBlbHNlIGlmIChwYXJlbnRbbGFzdFByb3BdID09PSBjaGlsZCkge1xuICAgIHBhcmVudFtsYXN0UHJvcF0gPSBwcmV2O1xuICB9XG5cbiAgY2hpbGQuX25leHQgPSBjaGlsZC5fcHJldiA9IGNoaWxkLnBhcmVudCA9IG51bGw7IC8vIGRvbid0IGRlbGV0ZSB0aGUgX2RwIGp1c3Qgc28gd2UgY2FuIHJldmVydCBpZiBuZWNlc3NhcnkuIEJ1dCBwYXJlbnQgc2hvdWxkIGJlIG51bGwgdG8gaW5kaWNhdGUgdGhlIGl0ZW0gaXNuJ3QgaW4gYSBsaW5rZWQgbGlzdC5cbn0sXG4gICAgX3JlbW92ZUZyb21QYXJlbnQgPSBmdW5jdGlvbiBfcmVtb3ZlRnJvbVBhcmVudChjaGlsZCwgb25seUlmUGFyZW50SGFzQXV0b1JlbW92ZSkge1xuICBjaGlsZC5wYXJlbnQgJiYgKCFvbmx5SWZQYXJlbnRIYXNBdXRvUmVtb3ZlIHx8IGNoaWxkLnBhcmVudC5hdXRvUmVtb3ZlQ2hpbGRyZW4pICYmIGNoaWxkLnBhcmVudC5yZW1vdmUoY2hpbGQpO1xuICBjaGlsZC5fYWN0ID0gMDtcbn0sXG4gICAgX3VuY2FjaGUgPSBmdW5jdGlvbiBfdW5jYWNoZShhbmltYXRpb24sIGNoaWxkKSB7XG4gIGlmIChhbmltYXRpb24gJiYgKCFjaGlsZCB8fCBjaGlsZC5fZW5kID4gYW5pbWF0aW9uLl9kdXIgfHwgY2hpbGQuX3N0YXJ0IDwgMCkpIHtcbiAgICAvLyBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246IGlmIGEgY2hpbGQgYW5pbWF0aW9uIGlzIHBhc3NlZCBpbiB3ZSBzaG91bGQgb25seSB1bmNhY2hlIGlmIHRoYXQgY2hpbGQgRVhURU5EUyB0aGUgYW5pbWF0aW9uIChpdHMgZW5kIHRpbWUgaXMgYmV5b25kIHRoZSBlbmQpXG4gICAgdmFyIGEgPSBhbmltYXRpb247XG5cbiAgICB3aGlsZSAoYSkge1xuICAgICAgYS5fZGlydHkgPSAxO1xuICAgICAgYSA9IGEucGFyZW50O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhbmltYXRpb247XG59LFxuICAgIF9yZWNhY2hlQW5jZXN0b3JzID0gZnVuY3Rpb24gX3JlY2FjaGVBbmNlc3RvcnMoYW5pbWF0aW9uKSB7XG4gIHZhciBwYXJlbnQgPSBhbmltYXRpb24ucGFyZW50O1xuXG4gIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LnBhcmVudCkge1xuICAgIC8vc29tZXRpbWVzIHdlIG11c3QgZm9yY2UgYSByZS1zb3J0IG9mIGFsbCBjaGlsZHJlbiBhbmQgdXBkYXRlIHRoZSBkdXJhdGlvbi90b3RhbER1cmF0aW9uIG9mIGFsbCBhbmNlc3RvciB0aW1lbGluZXMgaW1tZWRpYXRlbHkgaW4gY2FzZSwgZm9yIGV4YW1wbGUsIGluIHRoZSBtaWRkbGUgb2YgYSByZW5kZXIgbG9vcCwgb25lIHR3ZWVuIGFsdGVycyBhbm90aGVyIHR3ZWVuJ3MgdGltZVNjYWxlIHdoaWNoIHNob3ZlcyBpdHMgc3RhcnRUaW1lIGJlZm9yZSAwLCBmb3JjaW5nIHRoZSBwYXJlbnQgdGltZWxpbmUgdG8gc2hpZnQgYXJvdW5kIGFuZCBzaGlmdENoaWxkcmVuKCkgd2hpY2ggY291bGQgYWZmZWN0IHRoYXQgbmV4dCB0d2VlbidzIHJlbmRlciAoc3RhcnRUaW1lKS4gRG9lc24ndCBtYXR0ZXIgZm9yIHRoZSByb290IHRpbWVsaW5lIHRob3VnaC5cbiAgICBwYXJlbnQuX2RpcnR5ID0gMTtcbiAgICBwYXJlbnQudG90YWxEdXJhdGlvbigpO1xuICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XG4gIH1cblxuICByZXR1cm4gYW5pbWF0aW9uO1xufSxcbiAgICBfaGFzTm9QYXVzZWRBbmNlc3RvcnMgPSBmdW5jdGlvbiBfaGFzTm9QYXVzZWRBbmNlc3RvcnMoYW5pbWF0aW9uKSB7XG4gIHJldHVybiAhYW5pbWF0aW9uIHx8IGFuaW1hdGlvbi5fdHMgJiYgX2hhc05vUGF1c2VkQW5jZXN0b3JzKGFuaW1hdGlvbi5wYXJlbnQpO1xufSxcbiAgICBfZWxhcHNlZEN5Y2xlRHVyYXRpb24gPSBmdW5jdGlvbiBfZWxhcHNlZEN5Y2xlRHVyYXRpb24oYW5pbWF0aW9uKSB7XG4gIHJldHVybiBhbmltYXRpb24uX3JlcGVhdCA/IF9hbmltYXRpb25DeWNsZShhbmltYXRpb24uX3RUaW1lLCBhbmltYXRpb24gPSBhbmltYXRpb24uZHVyYXRpb24oKSArIGFuaW1hdGlvbi5fckRlbGF5KSAqIGFuaW1hdGlvbiA6IDA7XG59LFxuICAgIC8vIGZlZWQgaW4gdGhlIHRvdGFsVGltZSBhbmQgY3ljbGVEdXJhdGlvbiBhbmQgaXQnbGwgcmV0dXJuIHRoZSBjeWNsZSAoaXRlcmF0aW9uIG1pbnVzIDEpIGFuZCBpZiB0aGUgcGxheWhlYWQgaXMgZXhhY3RseSBhdCB0aGUgdmVyeSBFTkQsIGl0IHdpbGwgTk9UIGJ1bXAgdXAgdG8gdGhlIG5leHQgY3ljbGUuXG5fYW5pbWF0aW9uQ3ljbGUgPSBmdW5jdGlvbiBfYW5pbWF0aW9uQ3ljbGUodFRpbWUsIGN5Y2xlRHVyYXRpb24pIHtcbiAgdmFyIHdob2xlID0gTWF0aC5mbG9vcih0VGltZSAvPSBjeWNsZUR1cmF0aW9uKTtcbiAgcmV0dXJuIHRUaW1lICYmIHdob2xlID09PSB0VGltZSA/IHdob2xlIC0gMSA6IHdob2xlO1xufSxcbiAgICBfcGFyZW50VG9DaGlsZFRvdGFsVGltZSA9IGZ1bmN0aW9uIF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHBhcmVudFRpbWUsIGNoaWxkKSB7XG4gIHJldHVybiAocGFyZW50VGltZSAtIGNoaWxkLl9zdGFydCkgKiBjaGlsZC5fdHMgKyAoY2hpbGQuX3RzID49IDAgPyAwIDogY2hpbGQuX2RpcnR5ID8gY2hpbGQudG90YWxEdXJhdGlvbigpIDogY2hpbGQuX3REdXIpO1xufSxcbiAgICBfc2V0RW5kID0gZnVuY3Rpb24gX3NldEVuZChhbmltYXRpb24pIHtcbiAgcmV0dXJuIGFuaW1hdGlvbi5fZW5kID0gX3JvdW5kUHJlY2lzZShhbmltYXRpb24uX3N0YXJ0ICsgKGFuaW1hdGlvbi5fdER1ciAvIE1hdGguYWJzKGFuaW1hdGlvbi5fdHMgfHwgYW5pbWF0aW9uLl9ydHMgfHwgX3RpbnlOdW0pIHx8IDApKTtcbn0sXG4gICAgX2FsaWduUGxheWhlYWQgPSBmdW5jdGlvbiBfYWxpZ25QbGF5aGVhZChhbmltYXRpb24sIHRvdGFsVGltZSkge1xuICAvLyBhZGp1c3RzIHRoZSBhbmltYXRpb24ncyBfc3RhcnQgYW5kIF9lbmQgYWNjb3JkaW5nIHRvIHRoZSBwcm92aWRlZCB0b3RhbFRpbWUgKG9ubHkgaWYgdGhlIHBhcmVudCdzIHNtb290aENoaWxkVGltaW5nIGlzIHRydWUgYW5kIHRoZSBhbmltYXRpb24gaXNuJ3QgcGF1c2VkKS4gSXQgZG9lc24ndCBkbyBhbnkgcmVuZGVyaW5nIG9yIGZvcmNpbmcgdGhpbmdzIGJhY2sgaW50byBwYXJlbnQgdGltZWxpbmVzLCBldGMuIC0gdGhhdCdzIHdoYXQgdG90YWxUaW1lKCkgaXMgZm9yLlxuICB2YXIgcGFyZW50ID0gYW5pbWF0aW9uLl9kcDtcblxuICBpZiAocGFyZW50ICYmIHBhcmVudC5zbW9vdGhDaGlsZFRpbWluZyAmJiBhbmltYXRpb24uX3RzKSB7XG4gICAgYW5pbWF0aW9uLl9zdGFydCA9IF9yb3VuZFByZWNpc2UocGFyZW50Ll90aW1lIC0gKGFuaW1hdGlvbi5fdHMgPiAwID8gdG90YWxUaW1lIC8gYW5pbWF0aW9uLl90cyA6ICgoYW5pbWF0aW9uLl9kaXJ0eSA/IGFuaW1hdGlvbi50b3RhbER1cmF0aW9uKCkgOiBhbmltYXRpb24uX3REdXIpIC0gdG90YWxUaW1lKSAvIC1hbmltYXRpb24uX3RzKSk7XG5cbiAgICBfc2V0RW5kKGFuaW1hdGlvbik7XG5cbiAgICBwYXJlbnQuX2RpcnR5IHx8IF91bmNhY2hlKHBhcmVudCwgYW5pbWF0aW9uKTsgLy9mb3IgcGVyZm9ybWFuY2UgaW1wcm92ZW1lbnQuIElmIHRoZSBwYXJlbnQncyBjYWNoZSBpcyBhbHJlYWR5IGRpcnR5LCBpdCBhbHJlYWR5IHRvb2sgY2FyZSBvZiBtYXJraW5nIHRoZSBhbmNlc3RvcnMgYXMgZGlydHkgdG9vLCBzbyBza2lwIHRoZSBmdW5jdGlvbiBjYWxsIGhlcmUuXG4gIH1cblxuICByZXR1cm4gYW5pbWF0aW9uO1xufSxcblxuLypcbl90b3RhbFRpbWVUb1RpbWUgPSAoY2xhbXBlZFRvdGFsVGltZSwgZHVyYXRpb24sIHJlcGVhdCwgcmVwZWF0RGVsYXksIHlveW8pID0+IHtcblx0bGV0IGN5Y2xlRHVyYXRpb24gPSBkdXJhdGlvbiArIHJlcGVhdERlbGF5LFxuXHRcdHRpbWUgPSBfcm91bmQoY2xhbXBlZFRvdGFsVGltZSAlIGN5Y2xlRHVyYXRpb24pO1xuXHRpZiAodGltZSA+IGR1cmF0aW9uKSB7XG5cdFx0dGltZSA9IGR1cmF0aW9uO1xuXHR9XG5cdHJldHVybiAoeW95byAmJiAofn4oY2xhbXBlZFRvdGFsVGltZSAvIGN5Y2xlRHVyYXRpb24pICYgMSkpID8gZHVyYXRpb24gLSB0aW1lIDogdGltZTtcbn0sXG4qL1xuX3Bvc3RBZGRDaGVja3MgPSBmdW5jdGlvbiBfcG9zdEFkZENoZWNrcyh0aW1lbGluZSwgY2hpbGQpIHtcbiAgdmFyIHQ7XG5cbiAgaWYgKGNoaWxkLl90aW1lIHx8IGNoaWxkLl9pbml0dGVkICYmICFjaGlsZC5fZHVyKSB7XG4gICAgLy9pbiBjYXNlLCBmb3IgZXhhbXBsZSwgdGhlIF9zdGFydCBpcyBtb3ZlZCBvbiBhIHR3ZWVuIHRoYXQgaGFzIGFscmVhZHkgcmVuZGVyZWQuIEltYWdpbmUgaXQncyBhdCBpdHMgZW5kIHN0YXRlLCB0aGVuIHRoZSBzdGFydFRpbWUgaXMgbW92ZWQgV0FZIGxhdGVyIChhZnRlciB0aGUgZW5kIG9mIHRoaXMgdGltZWxpbmUpLCBpdCBzaG91bGQgcmVuZGVyIGF0IGl0cyBiZWdpbm5pbmcuXG4gICAgdCA9IF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHRpbWVsaW5lLnJhd1RpbWUoKSwgY2hpbGQpO1xuXG4gICAgaWYgKCFjaGlsZC5fZHVyIHx8IF9jbGFtcCgwLCBjaGlsZC50b3RhbER1cmF0aW9uKCksIHQpIC0gY2hpbGQuX3RUaW1lID4gX3RpbnlOdW0pIHtcbiAgICAgIGNoaWxkLnJlbmRlcih0LCB0cnVlKTtcbiAgICB9XG4gIH0gLy9pZiB0aGUgdGltZWxpbmUgaGFzIGFscmVhZHkgZW5kZWQgYnV0IHRoZSBpbnNlcnRlZCB0d2Vlbi90aW1lbGluZSBleHRlbmRzIHRoZSBkdXJhdGlvbiwgd2Ugc2hvdWxkIGVuYWJsZSB0aGlzIHRpbWVsaW5lIGFnYWluIHNvIHRoYXQgaXQgcmVuZGVycyBwcm9wZXJseS4gV2Ugc2hvdWxkIGFsc28gYWxpZ24gdGhlIHBsYXloZWFkIHdpdGggdGhlIHBhcmVudCB0aW1lbGluZSdzIHdoZW4gYXBwcm9wcmlhdGUuXG5cblxuICBpZiAoX3VuY2FjaGUodGltZWxpbmUsIGNoaWxkKS5fZHAgJiYgdGltZWxpbmUuX2luaXR0ZWQgJiYgdGltZWxpbmUuX3RpbWUgPj0gdGltZWxpbmUuX2R1ciAmJiB0aW1lbGluZS5fdHMpIHtcbiAgICAvL2luIGNhc2UgYW55IG9mIHRoZSBhbmNlc3RvcnMgaGFkIGNvbXBsZXRlZCBidXQgc2hvdWxkIG5vdyBiZSBlbmFibGVkLi4uXG4gICAgaWYgKHRpbWVsaW5lLl9kdXIgPCB0aW1lbGluZS5kdXJhdGlvbigpKSB7XG4gICAgICB0ID0gdGltZWxpbmU7XG5cbiAgICAgIHdoaWxlICh0Ll9kcCkge1xuICAgICAgICB0LnJhd1RpbWUoKSA+PSAwICYmIHQudG90YWxUaW1lKHQuX3RUaW1lKTsgLy9tb3ZlcyB0aGUgdGltZWxpbmUgKHNoaWZ0cyBpdHMgc3RhcnRUaW1lKSBpZiBuZWNlc3NhcnksIGFuZCBhbHNvIGVuYWJsZXMgaXQuIElmIGl0J3MgY3VycmVudGx5IHplcm8sIHRob3VnaCwgaXQgbWF5IG5vdCBiZSBzY2hlZHVsZWQgdG8gcmVuZGVyIHVudGlsIGxhdGVyIHNvIHRoZXJlJ3Mgbm8gbmVlZCB0byBmb3JjZSBpdCB0byBhbGlnbiB3aXRoIHRoZSBjdXJyZW50IHBsYXloZWFkIHBvc2l0aW9uLiBPbmx5IG1vdmUgdG8gY2F0Y2ggdXAgd2l0aCB0aGUgcGxheWhlYWQuXG5cbiAgICAgICAgdCA9IHQuX2RwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRpbWVsaW5lLl96VGltZSA9IC1fdGlueU51bTsgLy8gaGVscHMgZW5zdXJlIHRoYXQgdGhlIG5leHQgcmVuZGVyKCkgd2lsbCBiZSBmb3JjZWQgKGNyb3NzaW5nU3RhcnQgPSB0cnVlIGluIHJlbmRlcigpKSwgZXZlbiBpZiB0aGUgZHVyYXRpb24gaGFzbid0IGNoYW5nZWQgKHdlJ3JlIGFkZGluZyBhIGNoaWxkIHdoaWNoIHdvdWxkIG5lZWQgdG8gZ2V0IHJlbmRlcmVkKS4gRGVmaW5pdGVseSBhbiBlZGdlIGNhc2UuIE5vdGU6IHdlIE1VU1QgZG8gdGhpcyBBRlRFUiB0aGUgbG9vcCBhYm92ZSB3aGVyZSB0aGUgdG90YWxUaW1lKCkgbWlnaHQgdHJpZ2dlciBhIHJlbmRlcigpIGJlY2F1c2UgdGhpcyBfYWRkVG9UaW1lbGluZSgpIG1ldGhvZCBnZXRzIGNhbGxlZCBmcm9tIHRoZSBBbmltYXRpb24gY29uc3RydWN0b3IsIEJFRk9SRSB0d2VlbnMgZXZlbiByZWNvcmQgdGhlaXIgdGFyZ2V0cywgZXRjLiBzbyB3ZSB3b3VsZG4ndCB3YW50IHRoaW5ncyB0byBnZXQgdHJpZ2dlcmVkIGluIHRoZSB3cm9uZyBvcmRlci5cbiAgfVxufSxcbiAgICBfYWRkVG9UaW1lbGluZSA9IGZ1bmN0aW9uIF9hZGRUb1RpbWVsaW5lKHRpbWVsaW5lLCBjaGlsZCwgcG9zaXRpb24sIHNraXBDaGVja3MpIHtcbiAgY2hpbGQucGFyZW50ICYmIF9yZW1vdmVGcm9tUGFyZW50KGNoaWxkKTtcbiAgY2hpbGQuX3N0YXJ0ID0gX3JvdW5kUHJlY2lzZSgoX2lzTnVtYmVyKHBvc2l0aW9uKSA/IHBvc2l0aW9uIDogcG9zaXRpb24gfHwgdGltZWxpbmUgIT09IF9nbG9iYWxUaW1lbGluZSA/IF9wYXJzZVBvc2l0aW9uKHRpbWVsaW5lLCBwb3NpdGlvbiwgY2hpbGQpIDogdGltZWxpbmUuX3RpbWUpICsgY2hpbGQuX2RlbGF5KTtcbiAgY2hpbGQuX2VuZCA9IF9yb3VuZFByZWNpc2UoY2hpbGQuX3N0YXJ0ICsgKGNoaWxkLnRvdGFsRHVyYXRpb24oKSAvIE1hdGguYWJzKGNoaWxkLnRpbWVTY2FsZSgpKSB8fCAwKSk7XG5cbiAgX2FkZExpbmtlZExpc3RJdGVtKHRpbWVsaW5lLCBjaGlsZCwgXCJfZmlyc3RcIiwgXCJfbGFzdFwiLCB0aW1lbGluZS5fc29ydCA/IFwiX3N0YXJ0XCIgOiAwKTtcblxuICBfaXNGcm9tT3JGcm9tU3RhcnQoY2hpbGQpIHx8ICh0aW1lbGluZS5fcmVjZW50ID0gY2hpbGQpO1xuICBza2lwQ2hlY2tzIHx8IF9wb3N0QWRkQ2hlY2tzKHRpbWVsaW5lLCBjaGlsZCk7XG4gIHJldHVybiB0aW1lbGluZTtcbn0sXG4gICAgX3Njcm9sbFRyaWdnZXIgPSBmdW5jdGlvbiBfc2Nyb2xsVHJpZ2dlcihhbmltYXRpb24sIHRyaWdnZXIpIHtcbiAgcmV0dXJuIChfZ2xvYmFscy5TY3JvbGxUcmlnZ2VyIHx8IF9taXNzaW5nUGx1Z2luKFwic2Nyb2xsVHJpZ2dlclwiLCB0cmlnZ2VyKSkgJiYgX2dsb2JhbHMuU2Nyb2xsVHJpZ2dlci5jcmVhdGUodHJpZ2dlciwgYW5pbWF0aW9uKTtcbn0sXG4gICAgX2F0dGVtcHRJbml0VHdlZW4gPSBmdW5jdGlvbiBfYXR0ZW1wdEluaXRUd2Vlbih0d2VlbiwgdG90YWxUaW1lLCBmb3JjZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgX2luaXRUd2Vlbih0d2VlbiwgdG90YWxUaW1lKTtcblxuICBpZiAoIXR3ZWVuLl9pbml0dGVkKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICBpZiAoIWZvcmNlICYmIHR3ZWVuLl9wdCAmJiAodHdlZW4uX2R1ciAmJiB0d2Vlbi52YXJzLmxhenkgIT09IGZhbHNlIHx8ICF0d2Vlbi5fZHVyICYmIHR3ZWVuLnZhcnMubGF6eSkgJiYgX2xhc3RSZW5kZXJlZEZyYW1lICE9PSBfdGlja2VyLmZyYW1lKSB7XG4gICAgX2xhenlUd2VlbnMucHVzaCh0d2Vlbik7XG5cbiAgICB0d2Vlbi5fbGF6eSA9IFt0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzXTtcbiAgICByZXR1cm4gMTtcbiAgfVxufSxcbiAgICBfcGFyZW50UGxheWhlYWRJc0JlZm9yZVN0YXJ0ID0gZnVuY3Rpb24gX3BhcmVudFBsYXloZWFkSXNCZWZvcmVTdGFydChfcmVmKSB7XG4gIHZhciBwYXJlbnQgPSBfcmVmLnBhcmVudDtcbiAgcmV0dXJuIHBhcmVudCAmJiBwYXJlbnQuX3RzICYmIHBhcmVudC5faW5pdHRlZCAmJiAhcGFyZW50Ll9sb2NrICYmIChwYXJlbnQucmF3VGltZSgpIDwgMCB8fCBfcGFyZW50UGxheWhlYWRJc0JlZm9yZVN0YXJ0KHBhcmVudCkpO1xufSxcbiAgICAvLyBjaGVjayBwYXJlbnQncyBfbG9jayBiZWNhdXNlIHdoZW4gYSB0aW1lbGluZSByZXBlYXRzL3lveW9zIGFuZCBkb2VzIGl0cyBhcnRpZmljaWFsIHdyYXBwaW5nLCB3ZSBzaG91bGRuJ3QgZm9yY2UgdGhlIHJhdGlvIGJhY2sgdG8gMFxuX2lzRnJvbU9yRnJvbVN0YXJ0ID0gZnVuY3Rpb24gX2lzRnJvbU9yRnJvbVN0YXJ0KF9yZWYyKSB7XG4gIHZhciBkYXRhID0gX3JlZjIuZGF0YTtcbiAgcmV0dXJuIGRhdGEgPT09IFwiaXNGcm9tU3RhcnRcIiB8fCBkYXRhID09PSBcImlzU3RhcnRcIjtcbn0sXG4gICAgX3JlbmRlclplcm9EdXJhdGlvblR3ZWVuID0gZnVuY3Rpb24gX3JlbmRlclplcm9EdXJhdGlvblR3ZWVuKHR3ZWVuLCB0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkge1xuICB2YXIgcHJldlJhdGlvID0gdHdlZW4ucmF0aW8sXG4gICAgICByYXRpbyA9IHRvdGFsVGltZSA8IDAgfHwgIXRvdGFsVGltZSAmJiAoIXR3ZWVuLl9zdGFydCAmJiBfcGFyZW50UGxheWhlYWRJc0JlZm9yZVN0YXJ0KHR3ZWVuKSAmJiAhKCF0d2Vlbi5faW5pdHRlZCAmJiBfaXNGcm9tT3JGcm9tU3RhcnQodHdlZW4pKSB8fCAodHdlZW4uX3RzIDwgMCB8fCB0d2Vlbi5fZHAuX3RzIDwgMCkgJiYgIV9pc0Zyb21PckZyb21TdGFydCh0d2VlbikpID8gMCA6IDEsXG4gICAgICAvLyBpZiB0aGUgdHdlZW4gb3IgaXRzIHBhcmVudCBpcyByZXZlcnNlZCBhbmQgdGhlIHRvdGFsVGltZSBpcyAwLCB3ZSBzaG91bGQgZ28gdG8gYSByYXRpbyBvZiAwLiBFZGdlIGNhc2U6IGlmIGEgZnJvbSgpIG9yIGZyb21UbygpIHN0YWdnZXIgdHdlZW4gaXMgcGxhY2VkIGxhdGVyIGluIGEgdGltZWxpbmUsIHRoZSBcInN0YXJ0QXRcIiB6ZXJvLWR1cmF0aW9uIHR3ZWVuIGNvdWxkIGluaXRpYWxseSByZW5kZXIgYXQgYSB0aW1lIHdoZW4gdGhlIHBhcmVudCB0aW1lbGluZSdzIHBsYXloZWFkIGlzIHRlY2huaWNhbGx5IEJFRk9SRSB3aGVyZSB0aGlzIHR3ZWVuIGlzLCBzbyBtYWtlIHN1cmUgdGhhdCBhbnkgXCJmcm9tXCIgYW5kIFwiZnJvbVRvXCIgc3RhcnRBdCB0d2VlbnMgYXJlIHJlbmRlcmVkIHRoZSBmaXJzdCB0aW1lIGF0IGEgcmF0aW8gb2YgMS5cbiAgcmVwZWF0RGVsYXkgPSB0d2Vlbi5fckRlbGF5LFxuICAgICAgdFRpbWUgPSAwLFxuICAgICAgcHQsXG4gICAgICBpdGVyYXRpb24sXG4gICAgICBwcmV2SXRlcmF0aW9uO1xuXG4gIGlmIChyZXBlYXREZWxheSAmJiB0d2Vlbi5fcmVwZWF0KSB7XG4gICAgLy8gaW4gY2FzZSB0aGVyZSdzIGEgemVyby1kdXJhdGlvbiB0d2VlbiB0aGF0IGhhcyBhIHJlcGVhdCB3aXRoIGEgcmVwZWF0RGVsYXlcbiAgICB0VGltZSA9IF9jbGFtcCgwLCB0d2Vlbi5fdER1ciwgdG90YWxUaW1lKTtcbiAgICBpdGVyYXRpb24gPSBfYW5pbWF0aW9uQ3ljbGUodFRpbWUsIHJlcGVhdERlbGF5KTtcbiAgICB0d2Vlbi5feW95byAmJiBpdGVyYXRpb24gJiAxICYmIChyYXRpbyA9IDEgLSByYXRpbyk7XG5cbiAgICBpZiAoaXRlcmF0aW9uICE9PSBfYW5pbWF0aW9uQ3ljbGUodHdlZW4uX3RUaW1lLCByZXBlYXREZWxheSkpIHtcbiAgICAgIC8vIGlmIGl0ZXJhdGlvbiBjaGFuZ2VkXG4gICAgICBwcmV2UmF0aW8gPSAxIC0gcmF0aW87XG4gICAgICB0d2Vlbi52YXJzLnJlcGVhdFJlZnJlc2ggJiYgdHdlZW4uX2luaXR0ZWQgJiYgdHdlZW4uaW52YWxpZGF0ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyYXRpbyAhPT0gcHJldlJhdGlvIHx8IGZvcmNlIHx8IHR3ZWVuLl96VGltZSA9PT0gX3RpbnlOdW0gfHwgIXRvdGFsVGltZSAmJiB0d2Vlbi5felRpbWUpIHtcbiAgICBpZiAoIXR3ZWVuLl9pbml0dGVkICYmIF9hdHRlbXB0SW5pdFR3ZWVuKHR3ZWVuLCB0b3RhbFRpbWUsIGZvcmNlLCBzdXBwcmVzc0V2ZW50cykpIHtcbiAgICAgIC8vIGlmIHdlIHJlbmRlciB0aGUgdmVyeSBiZWdpbm5pbmcgKHRpbWUgPT0gMCkgb2YgYSBmcm9tVG8oKSwgd2UgbXVzdCBmb3JjZSB0aGUgcmVuZGVyIChub3JtYWwgdHdlZW5zIHdvdWxkbid0IG5lZWQgdG8gcmVuZGVyIGF0IGEgdGltZSBvZiAwIHdoZW4gdGhlIHByZXZUaW1lIHdhcyBhbHNvIDApLiBUaGlzIGlzIGFsc28gbWFuZGF0b3J5IHRvIG1ha2Ugc3VyZSBvdmVyd3JpdGluZyBraWNrcyBpbiBpbW1lZGlhdGVseS5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwcmV2SXRlcmF0aW9uID0gdHdlZW4uX3pUaW1lO1xuICAgIHR3ZWVuLl96VGltZSA9IHRvdGFsVGltZSB8fCAoc3VwcHJlc3NFdmVudHMgPyBfdGlueU51bSA6IDApOyAvLyB3aGVuIHRoZSBwbGF5aGVhZCBhcnJpdmVzIGF0IEVYQUNUTFkgdGltZSAwIChyaWdodCBvbiB0b3ApIG9mIGEgemVyby1kdXJhdGlvbiB0d2Vlbiwgd2UgbmVlZCB0byBkaXNjZXJuIGlmIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBzbyB0aGF0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIGFnYWluIChuZXh0IHRpbWUpLCBpdCdsbCB0cmlnZ2VyIHRoZSBjYWxsYmFjay4gSWYgZXZlbnRzIGFyZSBOT1Qgc3VwcHJlc3NlZCwgb2J2aW91c2x5IHRoZSBjYWxsYmFjayB3b3VsZCBiZSB0cmlnZ2VyZWQgaW4gdGhpcyByZW5kZXIuIEJhc2ljYWxseSwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlIGVpdGhlciB3aGVuIHRoZSBwbGF5aGVhZCBBUlJJVkVTIG9yIExFQVZFUyB0aGlzIGV4YWN0IHNwb3QsIG5vdCBib3RoLiBJbWFnaW5lIGRvaW5nIGEgdGltZWxpbmUuc2VlaygwKSBhbmQgdGhlcmUncyBhIGNhbGxiYWNrIHRoYXQgc2l0cyBhdCAwLiBTaW5jZSBldmVudHMgYXJlIHN1cHByZXNzZWQgb24gdGhhdCBzZWVrKCkgYnkgZGVmYXVsdCwgbm90aGluZyB3aWxsIGZpcmUsIGJ1dCB3aGVuIHRoZSBwbGF5aGVhZCBtb3ZlcyBvZmYgb2YgdGhhdCBwb3NpdGlvbiwgdGhlIGNhbGxiYWNrIHNob3VsZCBmaXJlLiBUaGlzIGJlaGF2aW9yIGlzIHdoYXQgcGVvcGxlIGludHVpdGl2ZWx5IGV4cGVjdC5cblxuICAgIHN1cHByZXNzRXZlbnRzIHx8IChzdXBwcmVzc0V2ZW50cyA9IHRvdGFsVGltZSAmJiAhcHJldkl0ZXJhdGlvbik7IC8vIGlmIGl0IHdhcyByZW5kZXJlZCBwcmV2aW91c2x5IGF0IGV4YWN0bHkgMCAoX3pUaW1lKSBhbmQgbm93IHRoZSBwbGF5aGVhZCBpcyBtb3ZpbmcgYXdheSwgRE9OJ1QgZmlyZSBjYWxsYmFja3Mgb3RoZXJ3aXNlIHRoZXknbGwgc2VlbSBsaWtlIGR1cGxpY2F0ZXMuXG5cbiAgICB0d2Vlbi5yYXRpbyA9IHJhdGlvO1xuICAgIHR3ZWVuLl9mcm9tICYmIChyYXRpbyA9IDEgLSByYXRpbyk7XG4gICAgdHdlZW4uX3RpbWUgPSAwO1xuICAgIHR3ZWVuLl90VGltZSA9IHRUaW1lO1xuICAgIHB0ID0gdHdlZW4uX3B0O1xuXG4gICAgd2hpbGUgKHB0KSB7XG4gICAgICBwdC5yKHJhdGlvLCBwdC5kKTtcbiAgICAgIHB0ID0gcHQuX25leHQ7XG4gICAgfVxuXG4gICAgdHdlZW4uX3N0YXJ0QXQgJiYgdG90YWxUaW1lIDwgMCAmJiB0d2Vlbi5fc3RhcnRBdC5yZW5kZXIodG90YWxUaW1lLCB0cnVlLCB0cnVlKTtcbiAgICB0d2Vlbi5fb25VcGRhdGUgJiYgIXN1cHByZXNzRXZlbnRzICYmIF9jYWxsYmFjayh0d2VlbiwgXCJvblVwZGF0ZVwiKTtcbiAgICB0VGltZSAmJiB0d2Vlbi5fcmVwZWF0ICYmICFzdXBwcmVzc0V2ZW50cyAmJiB0d2Vlbi5wYXJlbnQgJiYgX2NhbGxiYWNrKHR3ZWVuLCBcIm9uUmVwZWF0XCIpO1xuXG4gICAgaWYgKCh0b3RhbFRpbWUgPj0gdHdlZW4uX3REdXIgfHwgdG90YWxUaW1lIDwgMCkgJiYgdHdlZW4ucmF0aW8gPT09IHJhdGlvKSB7XG4gICAgICByYXRpbyAmJiBfcmVtb3ZlRnJvbVBhcmVudCh0d2VlbiwgMSk7XG5cbiAgICAgIGlmICghc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgICAgX2NhbGxiYWNrKHR3ZWVuLCByYXRpbyA/IFwib25Db21wbGV0ZVwiIDogXCJvblJldmVyc2VDb21wbGV0ZVwiLCB0cnVlKTtcblxuICAgICAgICB0d2Vlbi5fcHJvbSAmJiB0d2Vlbi5fcHJvbSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICghdHdlZW4uX3pUaW1lKSB7XG4gICAgdHdlZW4uX3pUaW1lID0gdG90YWxUaW1lO1xuICB9XG59LFxuICAgIF9maW5kTmV4dFBhdXNlVHdlZW4gPSBmdW5jdGlvbiBfZmluZE5leHRQYXVzZVR3ZWVuKGFuaW1hdGlvbiwgcHJldlRpbWUsIHRpbWUpIHtcbiAgdmFyIGNoaWxkO1xuXG4gIGlmICh0aW1lID4gcHJldlRpbWUpIHtcbiAgICBjaGlsZCA9IGFuaW1hdGlvbi5fZmlyc3Q7XG5cbiAgICB3aGlsZSAoY2hpbGQgJiYgY2hpbGQuX3N0YXJ0IDw9IHRpbWUpIHtcbiAgICAgIGlmIChjaGlsZC5kYXRhID09PSBcImlzUGF1c2VcIiAmJiBjaGlsZC5fc3RhcnQgPiBwcmV2VGltZSkge1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuX25leHQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNoaWxkID0gYW5pbWF0aW9uLl9sYXN0O1xuXG4gICAgd2hpbGUgKGNoaWxkICYmIGNoaWxkLl9zdGFydCA+PSB0aW1lKSB7XG4gICAgICBpZiAoY2hpbGQuZGF0YSA9PT0gXCJpc1BhdXNlXCIgJiYgY2hpbGQuX3N0YXJ0IDwgcHJldlRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLl9wcmV2O1xuICAgIH1cbiAgfVxufSxcbiAgICBfc2V0RHVyYXRpb24gPSBmdW5jdGlvbiBfc2V0RHVyYXRpb24oYW5pbWF0aW9uLCBkdXJhdGlvbiwgc2tpcFVuY2FjaGUsIGxlYXZlUGxheWhlYWQpIHtcbiAgdmFyIHJlcGVhdCA9IGFuaW1hdGlvbi5fcmVwZWF0LFxuICAgICAgZHVyID0gX3JvdW5kUHJlY2lzZShkdXJhdGlvbikgfHwgMCxcbiAgICAgIHRvdGFsUHJvZ3Jlc3MgPSBhbmltYXRpb24uX3RUaW1lIC8gYW5pbWF0aW9uLl90RHVyO1xuICB0b3RhbFByb2dyZXNzICYmICFsZWF2ZVBsYXloZWFkICYmIChhbmltYXRpb24uX3RpbWUgKj0gZHVyIC8gYW5pbWF0aW9uLl9kdXIpO1xuICBhbmltYXRpb24uX2R1ciA9IGR1cjtcbiAgYW5pbWF0aW9uLl90RHVyID0gIXJlcGVhdCA/IGR1ciA6IHJlcGVhdCA8IDAgPyAxZTEwIDogX3JvdW5kUHJlY2lzZShkdXIgKiAocmVwZWF0ICsgMSkgKyBhbmltYXRpb24uX3JEZWxheSAqIHJlcGVhdCk7XG4gIHRvdGFsUHJvZ3Jlc3MgPiAwICYmICFsZWF2ZVBsYXloZWFkID8gX2FsaWduUGxheWhlYWQoYW5pbWF0aW9uLCBhbmltYXRpb24uX3RUaW1lID0gYW5pbWF0aW9uLl90RHVyICogdG90YWxQcm9ncmVzcykgOiBhbmltYXRpb24ucGFyZW50ICYmIF9zZXRFbmQoYW5pbWF0aW9uKTtcbiAgc2tpcFVuY2FjaGUgfHwgX3VuY2FjaGUoYW5pbWF0aW9uLnBhcmVudCwgYW5pbWF0aW9uKTtcbiAgcmV0dXJuIGFuaW1hdGlvbjtcbn0sXG4gICAgX29uVXBkYXRlVG90YWxEdXJhdGlvbiA9IGZ1bmN0aW9uIF9vblVwZGF0ZVRvdGFsRHVyYXRpb24oYW5pbWF0aW9uKSB7XG4gIHJldHVybiBhbmltYXRpb24gaW5zdGFuY2VvZiBUaW1lbGluZSA/IF91bmNhY2hlKGFuaW1hdGlvbikgOiBfc2V0RHVyYXRpb24oYW5pbWF0aW9uLCBhbmltYXRpb24uX2R1cik7XG59LFxuICAgIF96ZXJvUG9zaXRpb24gPSB7XG4gIF9zdGFydDogMCxcbiAgZW5kVGltZTogX2VtcHR5RnVuYyxcbiAgdG90YWxEdXJhdGlvbjogX2VtcHR5RnVuY1xufSxcbiAgICBfcGFyc2VQb3NpdGlvbiA9IGZ1bmN0aW9uIF9wYXJzZVBvc2l0aW9uKGFuaW1hdGlvbiwgcG9zaXRpb24sIHBlcmNlbnRBbmltYXRpb24pIHtcbiAgdmFyIGxhYmVscyA9IGFuaW1hdGlvbi5sYWJlbHMsXG4gICAgICByZWNlbnQgPSBhbmltYXRpb24uX3JlY2VudCB8fCBfemVyb1Bvc2l0aW9uLFxuICAgICAgY2xpcHBlZER1cmF0aW9uID0gYW5pbWF0aW9uLmR1cmF0aW9uKCkgPj0gX2JpZ051bSA/IHJlY2VudC5lbmRUaW1lKGZhbHNlKSA6IGFuaW1hdGlvbi5fZHVyLFxuICAgICAgLy9pbiBjYXNlIHRoZXJlJ3MgYSBjaGlsZCB0aGF0IGluZmluaXRlbHkgcmVwZWF0cywgdXNlcnMgYWxtb3N0IG5ldmVyIGludGVuZCBmb3IgdGhlIGluc2VydGlvbiBwb2ludCBvZiBhIG5ldyBjaGlsZCB0byBiZSBiYXNlZCBvbiBhIFNVUEVSIGxvbmcgdmFsdWUgbGlrZSB0aGF0IHNvIHdlIGNsaXAgaXQgYW5kIGFzc3VtZSB0aGUgbW9zdCByZWNlbnRseS1hZGRlZCBjaGlsZCdzIGVuZFRpbWUgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAgaSxcbiAgICAgIG9mZnNldCxcbiAgICAgIGlzUGVyY2VudDtcblxuICBpZiAoX2lzU3RyaW5nKHBvc2l0aW9uKSAmJiAoaXNOYU4ocG9zaXRpb24pIHx8IHBvc2l0aW9uIGluIGxhYmVscykpIHtcbiAgICAvL2lmIHRoZSBzdHJpbmcgaXMgYSBudW1iZXIgbGlrZSBcIjFcIiwgY2hlY2sgdG8gc2VlIGlmIHRoZXJlJ3MgYSBsYWJlbCB3aXRoIHRoYXQgbmFtZSwgb3RoZXJ3aXNlIGludGVycHJldCBpdCBhcyBhIG51bWJlciAoYWJzb2x1dGUgdmFsdWUpLlxuICAgIG9mZnNldCA9IHBvc2l0aW9uLmNoYXJBdCgwKTtcbiAgICBpc1BlcmNlbnQgPSBwb3NpdGlvbi5zdWJzdHIoLTEpID09PSBcIiVcIjtcbiAgICBpID0gcG9zaXRpb24uaW5kZXhPZihcIj1cIik7XG5cbiAgICBpZiAob2Zmc2V0ID09PSBcIjxcIiB8fCBvZmZzZXQgPT09IFwiPlwiKSB7XG4gICAgICBpID49IDAgJiYgKHBvc2l0aW9uID0gcG9zaXRpb24ucmVwbGFjZSgvPS8sIFwiXCIpKTtcbiAgICAgIHJldHVybiAob2Zmc2V0ID09PSBcIjxcIiA/IHJlY2VudC5fc3RhcnQgOiByZWNlbnQuZW5kVGltZShyZWNlbnQuX3JlcGVhdCA+PSAwKSkgKyAocGFyc2VGbG9hdChwb3NpdGlvbi5zdWJzdHIoMSkpIHx8IDApICogKGlzUGVyY2VudCA/IChpIDwgMCA/IHJlY2VudCA6IHBlcmNlbnRBbmltYXRpb24pLnRvdGFsRHVyYXRpb24oKSAvIDEwMCA6IDEpO1xuICAgIH1cblxuICAgIGlmIChpIDwgMCkge1xuICAgICAgcG9zaXRpb24gaW4gbGFiZWxzIHx8IChsYWJlbHNbcG9zaXRpb25dID0gY2xpcHBlZER1cmF0aW9uKTtcbiAgICAgIHJldHVybiBsYWJlbHNbcG9zaXRpb25dO1xuICAgIH1cblxuICAgIG9mZnNldCA9IHBhcnNlRmxvYXQocG9zaXRpb24uY2hhckF0KGkgLSAxKSArIHBvc2l0aW9uLnN1YnN0cihpICsgMSkpO1xuXG4gICAgaWYgKGlzUGVyY2VudCAmJiBwZXJjZW50QW5pbWF0aW9uKSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgLyAxMDAgKiAoX2lzQXJyYXkocGVyY2VudEFuaW1hdGlvbikgPyBwZXJjZW50QW5pbWF0aW9uWzBdIDogcGVyY2VudEFuaW1hdGlvbikudG90YWxEdXJhdGlvbigpO1xuICAgIH1cblxuICAgIHJldHVybiBpID4gMSA/IF9wYXJzZVBvc2l0aW9uKGFuaW1hdGlvbiwgcG9zaXRpb24uc3Vic3RyKDAsIGkgLSAxKSwgcGVyY2VudEFuaW1hdGlvbikgKyBvZmZzZXQgOiBjbGlwcGVkRHVyYXRpb24gKyBvZmZzZXQ7XG4gIH1cblxuICByZXR1cm4gcG9zaXRpb24gPT0gbnVsbCA/IGNsaXBwZWREdXJhdGlvbiA6ICtwb3NpdGlvbjtcbn0sXG4gICAgX2NyZWF0ZVR3ZWVuVHlwZSA9IGZ1bmN0aW9uIF9jcmVhdGVUd2VlblR5cGUodHlwZSwgcGFyYW1zLCB0aW1lbGluZSkge1xuICB2YXIgaXNMZWdhY3kgPSBfaXNOdW1iZXIocGFyYW1zWzFdKSxcbiAgICAgIHZhcnNJbmRleCA9IChpc0xlZ2FjeSA/IDIgOiAxKSArICh0eXBlIDwgMiA/IDAgOiAxKSxcbiAgICAgIHZhcnMgPSBwYXJhbXNbdmFyc0luZGV4XSxcbiAgICAgIGlyVmFycyxcbiAgICAgIHBhcmVudDtcblxuICBpc0xlZ2FjeSAmJiAodmFycy5kdXJhdGlvbiA9IHBhcmFtc1sxXSk7XG4gIHZhcnMucGFyZW50ID0gdGltZWxpbmU7XG5cbiAgaWYgKHR5cGUpIHtcbiAgICBpclZhcnMgPSB2YXJzO1xuICAgIHBhcmVudCA9IHRpbWVsaW5lO1xuXG4gICAgd2hpbGUgKHBhcmVudCAmJiAhKFwiaW1tZWRpYXRlUmVuZGVyXCIgaW4gaXJWYXJzKSkge1xuICAgICAgLy8gaW5oZXJpdGFuY2UgaGFzbid0IGhhcHBlbmVkIHlldCwgYnV0IHNvbWVvbmUgbWF5IGhhdmUgc2V0IGEgZGVmYXVsdCBpbiBhbiBhbmNlc3RvciB0aW1lbGluZS4gV2UgY291bGQgZG8gdmFycy5pbW1lZGlhdGVSZW5kZXIgPSBfaXNOb3RGYWxzZShfaW5oZXJpdERlZmF1bHRzKHZhcnMpLmltbWVkaWF0ZVJlbmRlcikgYnV0IHRoYXQnZCBleGFjdCBhIHNsaWdodCBwZXJmb3JtYW5jZSBwZW5hbHR5IGJlY2F1c2UgX2luaGVyaXREZWZhdWx0cygpIGFsc28gcnVucyBpbiB0aGUgVHdlZW4gY29uc3RydWN0b3IuIFdlJ3JlIHBheWluZyBhIHNtYWxsIGtiIHByaWNlIGhlcmUgdG8gZ2FpbiBzcGVlZC5cbiAgICAgIGlyVmFycyA9IHBhcmVudC52YXJzLmRlZmF1bHRzIHx8IHt9O1xuICAgICAgcGFyZW50ID0gX2lzTm90RmFsc2UocGFyZW50LnZhcnMuaW5oZXJpdCkgJiYgcGFyZW50LnBhcmVudDtcbiAgICB9XG5cbiAgICB2YXJzLmltbWVkaWF0ZVJlbmRlciA9IF9pc05vdEZhbHNlKGlyVmFycy5pbW1lZGlhdGVSZW5kZXIpO1xuICAgIHR5cGUgPCAyID8gdmFycy5ydW5CYWNrd2FyZHMgPSAxIDogdmFycy5zdGFydEF0ID0gcGFyYW1zW3ZhcnNJbmRleCAtIDFdOyAvLyBcImZyb21cIiB2YXJzXG4gIH1cblxuICByZXR1cm4gbmV3IFR3ZWVuKHBhcmFtc1swXSwgdmFycywgcGFyYW1zW3ZhcnNJbmRleCArIDFdKTtcbn0sXG4gICAgX2NvbmRpdGlvbmFsUmV0dXJuID0gZnVuY3Rpb24gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jKSB7XG4gIHJldHVybiB2YWx1ZSB8fCB2YWx1ZSA9PT0gMCA/IGZ1bmModmFsdWUpIDogZnVuYztcbn0sXG4gICAgX2NsYW1wID0gZnVuY3Rpb24gX2NsYW1wKG1pbiwgbWF4LCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPCBtaW4gPyBtaW4gOiB2YWx1ZSA+IG1heCA/IG1heCA6IHZhbHVlO1xufSxcbiAgICBnZXRVbml0ID0gZnVuY3Rpb24gZ2V0VW5pdCh2YWx1ZSwgdikge1xuICByZXR1cm4gIV9pc1N0cmluZyh2YWx1ZSkgfHwgISh2ID0gX3VuaXRFeHAuZXhlYyh2YWx1ZSkpID8gXCJcIiA6IHZhbHVlLnN1YnN0cih2LmluZGV4ICsgdlswXS5sZW5ndGgpO1xufSxcbiAgICAvLyBub3RlOiBwcm90ZWN0IGFnYWluc3QgcGFkZGVkIG51bWJlcnMgYXMgc3RyaW5ncywgbGlrZSBcIjEwMC4xMDBcIi4gVGhhdCBzaG91bGRuJ3QgcmV0dXJuIFwiMDBcIiBhcyB0aGUgdW5pdC4gSWYgaXQncyBudW1lcmljLCByZXR1cm4gbm8gdW5pdC5cbmNsYW1wID0gZnVuY3Rpb24gY2xhbXAobWluLCBtYXgsIHZhbHVlKSB7XG4gIHJldHVybiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIF9jbGFtcChtaW4sIG1heCwgdik7XG4gIH0pO1xufSxcbiAgICBfc2xpY2UgPSBbXS5zbGljZSxcbiAgICBfaXNBcnJheUxpa2UgPSBmdW5jdGlvbiBfaXNBcnJheUxpa2UodmFsdWUsIG5vbkVtcHR5KSB7XG4gIHJldHVybiB2YWx1ZSAmJiBfaXNPYmplY3QodmFsdWUpICYmIFwibGVuZ3RoXCIgaW4gdmFsdWUgJiYgKCFub25FbXB0eSAmJiAhdmFsdWUubGVuZ3RoIHx8IHZhbHVlLmxlbmd0aCAtIDEgaW4gdmFsdWUgJiYgX2lzT2JqZWN0KHZhbHVlWzBdKSkgJiYgIXZhbHVlLm5vZGVUeXBlICYmIHZhbHVlICE9PSBfd2luO1xufSxcbiAgICBfZmxhdHRlbiA9IGZ1bmN0aW9uIF9mbGF0dGVuKGFyLCBsZWF2ZVN0cmluZ3MsIGFjY3VtdWxhdG9yKSB7XG4gIGlmIChhY2N1bXVsYXRvciA9PT0gdm9pZCAwKSB7XG4gICAgYWNjdW11bGF0b3IgPSBbXTtcbiAgfVxuXG4gIHJldHVybiBhci5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciBfYWNjdW11bGF0b3I7XG5cbiAgICByZXR1cm4gX2lzU3RyaW5nKHZhbHVlKSAmJiAhbGVhdmVTdHJpbmdzIHx8IF9pc0FycmF5TGlrZSh2YWx1ZSwgMSkgPyAoX2FjY3VtdWxhdG9yID0gYWNjdW11bGF0b3IpLnB1c2guYXBwbHkoX2FjY3VtdWxhdG9yLCB0b0FycmF5KHZhbHVlKSkgOiBhY2N1bXVsYXRvci5wdXNoKHZhbHVlKTtcbiAgfSkgfHwgYWNjdW11bGF0b3I7XG59LFxuICAgIC8vdGFrZXMgYW55IHZhbHVlIGFuZCByZXR1cm5zIGFuIGFycmF5LiBJZiBpdCdzIGEgc3RyaW5nIChhbmQgbGVhdmVTdHJpbmdzIGlzbid0IHRydWUpLCBpdCdsbCB1c2UgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgpIGFuZCBjb252ZXJ0IHRoYXQgdG8gYW4gYXJyYXkuIEl0J2xsIGFsc28gYWNjZXB0IGl0ZXJhYmxlcyBsaWtlIGpRdWVyeSBvYmplY3RzLlxudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkodmFsdWUsIHNjb3BlLCBsZWF2ZVN0cmluZ3MpIHtcbiAgcmV0dXJuIF9pc1N0cmluZyh2YWx1ZSkgJiYgIWxlYXZlU3RyaW5ncyAmJiAoX2NvcmVJbml0dGVkIHx8ICFfd2FrZSgpKSA/IF9zbGljZS5jYWxsKChzY29wZSB8fCBfZG9jKS5xdWVyeVNlbGVjdG9yQWxsKHZhbHVlKSwgMCkgOiBfaXNBcnJheSh2YWx1ZSkgPyBfZmxhdHRlbih2YWx1ZSwgbGVhdmVTdHJpbmdzKSA6IF9pc0FycmF5TGlrZSh2YWx1ZSkgPyBfc2xpY2UuY2FsbCh2YWx1ZSwgMCkgOiB2YWx1ZSA/IFt2YWx1ZV0gOiBbXTtcbn0sXG4gICAgc2VsZWN0b3IgPSBmdW5jdGlvbiBzZWxlY3Rvcih2YWx1ZSkge1xuICB2YWx1ZSA9IHRvQXJyYXkodmFsdWUpWzBdIHx8IF93YXJuKFwiSW52YWxpZCBzY29wZVwiKSB8fCB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgdmFyIGVsID0gdmFsdWUuY3VycmVudCB8fCB2YWx1ZS5uYXRpdmVFbGVtZW50IHx8IHZhbHVlO1xuICAgIHJldHVybiB0b0FycmF5KHYsIGVsLnF1ZXJ5U2VsZWN0b3JBbGwgPyBlbCA6IGVsID09PSB2YWx1ZSA/IF93YXJuKFwiSW52YWxpZCBzY29wZVwiKSB8fCBfZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgOiB2YWx1ZSk7XG4gIH07XG59LFxuICAgIHNodWZmbGUgPSBmdW5jdGlvbiBzaHVmZmxlKGEpIHtcbiAgcmV0dXJuIGEuc29ydChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIC41IC0gTWF0aC5yYW5kb20oKTtcbiAgfSk7XG59LFxuICAgIC8vIGFsdGVybmF0aXZlIHRoYXQncyBhIGJpdCBmYXN0ZXIgYW5kIG1vcmUgcmVsaWFibHkgZGl2ZXJzZSBidXQgYmlnZ2VyOiAgIGZvciAobGV0IGosIHYsIGkgPSBhLmxlbmd0aDsgaTsgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGkpLCB2ID0gYVstLWldLCBhW2ldID0gYVtqXSwgYVtqXSA9IHYpOyByZXR1cm4gYTtcbi8vZm9yIGRpc3RyaWJ1dGluZyB2YWx1ZXMgYWNyb3NzIGFuIGFycmF5LiBDYW4gYWNjZXB0IGEgbnVtYmVyLCBhIGZ1bmN0aW9uIG9yIChtb3N0IGNvbW1vbmx5KSBhIGZ1bmN0aW9uIHdoaWNoIGNhbiBjb250YWluIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczoge2Jhc2UsIGFtb3VudCwgZnJvbSwgZWFzZSwgZ3JpZCwgYXhpcywgbGVuZ3RoLCBlYWNofS4gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgZXhwZWN0cyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6IGluZGV4LCB0YXJnZXQsIGFycmF5LiBSZWNvZ25pemVzIHRoZSBmb2xsb3dpbmdcbmRpc3RyaWJ1dGUgPSBmdW5jdGlvbiBkaXN0cmlidXRlKHYpIHtcbiAgaWYgKF9pc0Z1bmN0aW9uKHYpKSB7XG4gICAgcmV0dXJuIHY7XG4gIH1cblxuICB2YXIgdmFycyA9IF9pc09iamVjdCh2KSA/IHYgOiB7XG4gICAgZWFjaDogdlxuICB9LFxuICAgICAgLy9uOjEgaXMganVzdCB0byBpbmRpY2F0ZSB2IHdhcyBhIG51bWJlcjsgd2UgbGV2ZXJhZ2UgdGhhdCBsYXRlciB0byBzZXQgdiBhY2NvcmRpbmcgdG8gdGhlIGxlbmd0aCB3ZSBnZXQuIElmIGEgbnVtYmVyIGlzIHBhc3NlZCBpbiwgd2UgdHJlYXQgaXQgbGlrZSB0aGUgb2xkIHN0YWdnZXIgdmFsdWUgd2hlcmUgMC4xLCBmb3IgZXhhbXBsZSwgd291bGQgbWVhbiB0aGF0IHRoaW5ncyB3b3VsZCBiZSBkaXN0cmlidXRlZCB3aXRoIDAuMSBiZXR3ZWVuIGVhY2ggZWxlbWVudCBpbiB0aGUgYXJyYXkgcmF0aGVyIHRoYW4gYSB0b3RhbCBcImFtb3VudFwiIHRoYXQncyBjaHVua2VkIG91dCBhbW9uZyB0aGVtIGFsbC5cbiAgZWFzZSA9IF9wYXJzZUVhc2UodmFycy5lYXNlKSxcbiAgICAgIGZyb20gPSB2YXJzLmZyb20gfHwgMCxcbiAgICAgIGJhc2UgPSBwYXJzZUZsb2F0KHZhcnMuYmFzZSkgfHwgMCxcbiAgICAgIGNhY2hlID0ge30sXG4gICAgICBpc0RlY2ltYWwgPSBmcm9tID4gMCAmJiBmcm9tIDwgMSxcbiAgICAgIHJhdGlvcyA9IGlzTmFOKGZyb20pIHx8IGlzRGVjaW1hbCxcbiAgICAgIGF4aXMgPSB2YXJzLmF4aXMsXG4gICAgICByYXRpb1ggPSBmcm9tLFxuICAgICAgcmF0aW9ZID0gZnJvbTtcblxuICBpZiAoX2lzU3RyaW5nKGZyb20pKSB7XG4gICAgcmF0aW9YID0gcmF0aW9ZID0ge1xuICAgICAgY2VudGVyOiAuNSxcbiAgICAgIGVkZ2VzOiAuNSxcbiAgICAgIGVuZDogMVxuICAgIH1bZnJvbV0gfHwgMDtcbiAgfSBlbHNlIGlmICghaXNEZWNpbWFsICYmIHJhdGlvcykge1xuICAgIHJhdGlvWCA9IGZyb21bMF07XG4gICAgcmF0aW9ZID0gZnJvbVsxXTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoaSwgdGFyZ2V0LCBhKSB7XG4gICAgdmFyIGwgPSAoYSB8fCB2YXJzKS5sZW5ndGgsXG4gICAgICAgIGRpc3RhbmNlcyA9IGNhY2hlW2xdLFxuICAgICAgICBvcmlnaW5YLFxuICAgICAgICBvcmlnaW5ZLFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBkLFxuICAgICAgICBqLFxuICAgICAgICBtYXgsXG4gICAgICAgIG1pbixcbiAgICAgICAgd3JhcEF0O1xuXG4gICAgaWYgKCFkaXN0YW5jZXMpIHtcbiAgICAgIHdyYXBBdCA9IHZhcnMuZ3JpZCA9PT0gXCJhdXRvXCIgPyAwIDogKHZhcnMuZ3JpZCB8fCBbMSwgX2JpZ051bV0pWzFdO1xuXG4gICAgICBpZiAoIXdyYXBBdCkge1xuICAgICAgICBtYXggPSAtX2JpZ051bTtcblxuICAgICAgICB3aGlsZSAobWF4IDwgKG1heCA9IGFbd3JhcEF0KytdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQpICYmIHdyYXBBdCA8IGwpIHt9XG5cbiAgICAgICAgd3JhcEF0LS07XG4gICAgICB9XG5cbiAgICAgIGRpc3RhbmNlcyA9IGNhY2hlW2xdID0gW107XG4gICAgICBvcmlnaW5YID0gcmF0aW9zID8gTWF0aC5taW4od3JhcEF0LCBsKSAqIHJhdGlvWCAtIC41IDogZnJvbSAlIHdyYXBBdDtcbiAgICAgIG9yaWdpblkgPSB3cmFwQXQgPT09IF9iaWdOdW0gPyAwIDogcmF0aW9zID8gbCAqIHJhdGlvWSAvIHdyYXBBdCAtIC41IDogZnJvbSAvIHdyYXBBdCB8IDA7XG4gICAgICBtYXggPSAwO1xuICAgICAgbWluID0gX2JpZ051bTtcblxuICAgICAgZm9yIChqID0gMDsgaiA8IGw7IGorKykge1xuICAgICAgICB4ID0gaiAlIHdyYXBBdCAtIG9yaWdpblg7XG4gICAgICAgIHkgPSBvcmlnaW5ZIC0gKGogLyB3cmFwQXQgfCAwKTtcbiAgICAgICAgZGlzdGFuY2VzW2pdID0gZCA9ICFheGlzID8gX3NxcnQoeCAqIHggKyB5ICogeSkgOiBNYXRoLmFicyhheGlzID09PSBcInlcIiA/IHkgOiB4KTtcbiAgICAgICAgZCA+IG1heCAmJiAobWF4ID0gZCk7XG4gICAgICAgIGQgPCBtaW4gJiYgKG1pbiA9IGQpO1xuICAgICAgfVxuXG4gICAgICBmcm9tID09PSBcInJhbmRvbVwiICYmIHNodWZmbGUoZGlzdGFuY2VzKTtcbiAgICAgIGRpc3RhbmNlcy5tYXggPSBtYXggLSBtaW47XG4gICAgICBkaXN0YW5jZXMubWluID0gbWluO1xuICAgICAgZGlzdGFuY2VzLnYgPSBsID0gKHBhcnNlRmxvYXQodmFycy5hbW91bnQpIHx8IHBhcnNlRmxvYXQodmFycy5lYWNoKSAqICh3cmFwQXQgPiBsID8gbCAtIDEgOiAhYXhpcyA/IE1hdGgubWF4KHdyYXBBdCwgbCAvIHdyYXBBdCkgOiBheGlzID09PSBcInlcIiA/IGwgLyB3cmFwQXQgOiB3cmFwQXQpIHx8IDApICogKGZyb20gPT09IFwiZWRnZXNcIiA/IC0xIDogMSk7XG4gICAgICBkaXN0YW5jZXMuYiA9IGwgPCAwID8gYmFzZSAtIGwgOiBiYXNlO1xuICAgICAgZGlzdGFuY2VzLnUgPSBnZXRVbml0KHZhcnMuYW1vdW50IHx8IHZhcnMuZWFjaCkgfHwgMDsgLy91bml0XG5cbiAgICAgIGVhc2UgPSBlYXNlICYmIGwgPCAwID8gX2ludmVydEVhc2UoZWFzZSkgOiBlYXNlO1xuICAgIH1cblxuICAgIGwgPSAoZGlzdGFuY2VzW2ldIC0gZGlzdGFuY2VzLm1pbikgLyBkaXN0YW5jZXMubWF4IHx8IDA7XG4gICAgcmV0dXJuIF9yb3VuZFByZWNpc2UoZGlzdGFuY2VzLmIgKyAoZWFzZSA/IGVhc2UobCkgOiBsKSAqIGRpc3RhbmNlcy52KSArIGRpc3RhbmNlcy51OyAvL3JvdW5kIGluIG9yZGVyIHRvIHdvcmsgYXJvdW5kIGZsb2F0aW5nIHBvaW50IGVycm9yc1xuICB9O1xufSxcbiAgICBfcm91bmRNb2RpZmllciA9IGZ1bmN0aW9uIF9yb3VuZE1vZGlmaWVyKHYpIHtcbiAgLy9wYXNzIGluIDAuMSBnZXQgYSBmdW5jdGlvbiB0aGF0J2xsIHJvdW5kIHRvIHRoZSBuZWFyZXN0IHRlbnRoLCBvciA1IHRvIHJvdW5kIHRvIHRoZSBjbG9zZXN0IDUsIG9yIDAuMDAxIHRvIHRoZSBjbG9zZXN0IDEwMDB0aCwgZXRjLlxuICB2YXIgcCA9IE1hdGgucG93KDEwLCAoKHYgKyBcIlwiKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoKTsgLy90byBhdm9pZCBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyAobGlrZSAyNCAqIDAuMSA9PSAyLjQwMDAwMDAwMDAwMDAwMDQpLCB3ZSBjaG9wIG9mZiBhdCBhIHNwZWNpZmljIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyAobXVjaCBmYXN0ZXIgdGhhbiB0b0ZpeGVkKCkpXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChyYXcpIHtcbiAgICB2YXIgbiA9IE1hdGgucm91bmQocGFyc2VGbG9hdChyYXcpIC8gdikgKiB2ICogcDtcbiAgICByZXR1cm4gKG4gLSBuICUgMSkgLyBwICsgKF9pc051bWJlcihyYXcpID8gMCA6IGdldFVuaXQocmF3KSk7IC8vIG4gLSBuICUgMSByZXBsYWNlcyBNYXRoLmZsb29yKCkgaW4gb3JkZXIgdG8gaGFuZGxlIG5lZ2F0aXZlIHZhbHVlcyBwcm9wZXJseS4gRm9yIGV4YW1wbGUsIE1hdGguZmxvb3IoLTE1MC4wMDAwMDAwMDAwMDAwMykgaXMgMTUxIVxuICB9O1xufSxcbiAgICBzbmFwID0gZnVuY3Rpb24gc25hcChzbmFwVG8sIHZhbHVlKSB7XG4gIHZhciBpc0FycmF5ID0gX2lzQXJyYXkoc25hcFRvKSxcbiAgICAgIHJhZGl1cyxcbiAgICAgIGlzMkQ7XG5cbiAgaWYgKCFpc0FycmF5ICYmIF9pc09iamVjdChzbmFwVG8pKSB7XG4gICAgcmFkaXVzID0gaXNBcnJheSA9IHNuYXBUby5yYWRpdXMgfHwgX2JpZ051bTtcblxuICAgIGlmIChzbmFwVG8udmFsdWVzKSB7XG4gICAgICBzbmFwVG8gPSB0b0FycmF5KHNuYXBUby52YWx1ZXMpO1xuXG4gICAgICBpZiAoaXMyRCA9ICFfaXNOdW1iZXIoc25hcFRvWzBdKSkge1xuICAgICAgICByYWRpdXMgKj0gcmFkaXVzOyAvL3BlcmZvcm1hbmNlIG9wdGltaXphdGlvbiBzbyB3ZSBkb24ndCBoYXZlIHRvIE1hdGguc3FydCgpIGluIHRoZSBsb29wLlxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzbmFwVG8gPSBfcm91bmRNb2RpZmllcihzbmFwVG8uaW5jcmVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCAhaXNBcnJheSA/IF9yb3VuZE1vZGlmaWVyKHNuYXBUbykgOiBfaXNGdW5jdGlvbihzbmFwVG8pID8gZnVuY3Rpb24gKHJhdykge1xuICAgIGlzMkQgPSBzbmFwVG8ocmF3KTtcbiAgICByZXR1cm4gTWF0aC5hYnMoaXMyRCAtIHJhdykgPD0gcmFkaXVzID8gaXMyRCA6IHJhdztcbiAgfSA6IGZ1bmN0aW9uIChyYXcpIHtcbiAgICB2YXIgeCA9IHBhcnNlRmxvYXQoaXMyRCA/IHJhdy54IDogcmF3KSxcbiAgICAgICAgeSA9IHBhcnNlRmxvYXQoaXMyRCA/IHJhdy55IDogMCksXG4gICAgICAgIG1pbiA9IF9iaWdOdW0sXG4gICAgICAgIGNsb3Nlc3QgPSAwLFxuICAgICAgICBpID0gc25hcFRvLmxlbmd0aCxcbiAgICAgICAgZHgsXG4gICAgICAgIGR5O1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgaWYgKGlzMkQpIHtcbiAgICAgICAgZHggPSBzbmFwVG9baV0ueCAtIHg7XG4gICAgICAgIGR5ID0gc25hcFRvW2ldLnkgLSB5O1xuICAgICAgICBkeCA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHggPSBNYXRoLmFicyhzbmFwVG9baV0gLSB4KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGR4IDwgbWluKSB7XG4gICAgICAgIG1pbiA9IGR4O1xuICAgICAgICBjbG9zZXN0ID0gaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjbG9zZXN0ID0gIXJhZGl1cyB8fCBtaW4gPD0gcmFkaXVzID8gc25hcFRvW2Nsb3Nlc3RdIDogcmF3O1xuICAgIHJldHVybiBpczJEIHx8IGNsb3Nlc3QgPT09IHJhdyB8fCBfaXNOdW1iZXIocmF3KSA/IGNsb3Nlc3QgOiBjbG9zZXN0ICsgZ2V0VW5pdChyYXcpO1xuICB9KTtcbn0sXG4gICAgcmFuZG9tID0gZnVuY3Rpb24gcmFuZG9tKG1pbiwgbWF4LCByb3VuZGluZ0luY3JlbWVudCwgcmV0dXJuRnVuY3Rpb24pIHtcbiAgcmV0dXJuIF9jb25kaXRpb25hbFJldHVybihfaXNBcnJheShtaW4pID8gIW1heCA6IHJvdW5kaW5nSW5jcmVtZW50ID09PSB0cnVlID8gISEocm91bmRpbmdJbmNyZW1lbnQgPSAwKSA6ICFyZXR1cm5GdW5jdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaXNBcnJheShtaW4pID8gbWluW35+KE1hdGgucmFuZG9tKCkgKiBtaW4ubGVuZ3RoKV0gOiAocm91bmRpbmdJbmNyZW1lbnQgPSByb3VuZGluZ0luY3JlbWVudCB8fCAxZS01KSAmJiAocmV0dXJuRnVuY3Rpb24gPSByb3VuZGluZ0luY3JlbWVudCA8IDEgPyBNYXRoLnBvdygxMCwgKHJvdW5kaW5nSW5jcmVtZW50ICsgXCJcIikubGVuZ3RoIC0gMikgOiAxKSAmJiBNYXRoLmZsb29yKE1hdGgucm91bmQoKG1pbiAtIHJvdW5kaW5nSW5jcmVtZW50IC8gMiArIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgcm91bmRpbmdJbmNyZW1lbnQgKiAuOTkpKSAvIHJvdW5kaW5nSW5jcmVtZW50KSAqIHJvdW5kaW5nSW5jcmVtZW50ICogcmV0dXJuRnVuY3Rpb24pIC8gcmV0dXJuRnVuY3Rpb247XG4gIH0pO1xufSxcbiAgICBwaXBlID0gZnVuY3Rpb24gcGlwZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGZ1bmN0aW9ucyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBmdW5jdGlvbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9ucy5yZWR1Y2UoZnVuY3Rpb24gKHYsIGYpIHtcbiAgICAgIHJldHVybiBmKHYpO1xuICAgIH0sIHZhbHVlKTtcbiAgfTtcbn0sXG4gICAgdW5pdGl6ZSA9IGZ1bmN0aW9uIHVuaXRpemUoZnVuYywgdW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmMocGFyc2VGbG9hdCh2YWx1ZSkpICsgKHVuaXQgfHwgZ2V0VW5pdCh2YWx1ZSkpO1xuICB9O1xufSxcbiAgICBub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUobWluLCBtYXgsIHZhbHVlKSB7XG4gIHJldHVybiBtYXBSYW5nZShtaW4sIG1heCwgMCwgMSwgdmFsdWUpO1xufSxcbiAgICBfd3JhcEFycmF5ID0gZnVuY3Rpb24gX3dyYXBBcnJheShhLCB3cmFwcGVyLCB2YWx1ZSkge1xuICByZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICByZXR1cm4gYVt+fndyYXBwZXIoaW5kZXgpXTtcbiAgfSk7XG59LFxuICAgIHdyYXAgPSBmdW5jdGlvbiB3cmFwKG1pbiwgbWF4LCB2YWx1ZSkge1xuICAvLyBOT1RFOiB3cmFwKCkgQ0FOTk9UIGJlIGFuIGFycm93IGZ1bmN0aW9uISBBIHZlcnkgb2RkIGNvbXBpbGluZyBidWcgY2F1c2VzIHByb2JsZW1zICh1bnJlbGF0ZWQgdG8gR1NBUCkuXG4gIHZhciByYW5nZSA9IG1heCAtIG1pbjtcbiAgcmV0dXJuIF9pc0FycmF5KG1pbikgPyBfd3JhcEFycmF5KG1pbiwgd3JhcCgwLCBtaW4ubGVuZ3RoKSwgbWF4KSA6IF9jb25kaXRpb25hbFJldHVybih2YWx1ZSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIChyYW5nZSArICh2YWx1ZSAtIG1pbikgJSByYW5nZSkgJSByYW5nZSArIG1pbjtcbiAgfSk7XG59LFxuICAgIHdyYXBZb3lvID0gZnVuY3Rpb24gd3JhcFlveW8obWluLCBtYXgsIHZhbHVlKSB7XG4gIHZhciByYW5nZSA9IG1heCAtIG1pbixcbiAgICAgIHRvdGFsID0gcmFuZ2UgKiAyO1xuICByZXR1cm4gX2lzQXJyYXkobWluKSA/IF93cmFwQXJyYXkobWluLCB3cmFwWW95bygwLCBtaW4ubGVuZ3RoIC0gMSksIG1heCkgOiBfY29uZGl0aW9uYWxSZXR1cm4odmFsdWUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhbHVlID0gKHRvdGFsICsgKHZhbHVlIC0gbWluKSAlIHRvdGFsKSAlIHRvdGFsIHx8IDA7XG4gICAgcmV0dXJuIG1pbiArICh2YWx1ZSA+IHJhbmdlID8gdG90YWwgLSB2YWx1ZSA6IHZhbHVlKTtcbiAgfSk7XG59LFxuICAgIF9yZXBsYWNlUmFuZG9tID0gZnVuY3Rpb24gX3JlcGxhY2VSYW5kb20odmFsdWUpIHtcbiAgLy9yZXBsYWNlcyBhbGwgb2NjdXJyZW5jZXMgb2YgcmFuZG9tKC4uLikgaW4gYSBzdHJpbmcgd2l0aCB0aGUgY2FsY3VsYXRlZCByYW5kb20gdmFsdWUuIGNhbiBiZSBhIHJhbmdlIGxpa2UgcmFuZG9tKC0xMDAsIDEwMCwgNSkgb3IgYW4gYXJyYXkgbGlrZSByYW5kb20oWzAsIDEwMCwgNTAwXSlcbiAgdmFyIHByZXYgPSAwLFxuICAgICAgcyA9IFwiXCIsXG4gICAgICBpLFxuICAgICAgbnVtcyxcbiAgICAgIGVuZCxcbiAgICAgIGlzQXJyYXk7XG5cbiAgd2hpbGUgKH4oaSA9IHZhbHVlLmluZGV4T2YoXCJyYW5kb20oXCIsIHByZXYpKSkge1xuICAgIGVuZCA9IHZhbHVlLmluZGV4T2YoXCIpXCIsIGkpO1xuICAgIGlzQXJyYXkgPSB2YWx1ZS5jaGFyQXQoaSArIDcpID09PSBcIltcIjtcbiAgICBudW1zID0gdmFsdWUuc3Vic3RyKGkgKyA3LCBlbmQgLSBpIC0gNykubWF0Y2goaXNBcnJheSA/IF9kZWxpbWl0ZWRWYWx1ZUV4cCA6IF9zdHJpY3ROdW1FeHApO1xuICAgIHMgKz0gdmFsdWUuc3Vic3RyKHByZXYsIGkgLSBwcmV2KSArIHJhbmRvbShpc0FycmF5ID8gbnVtcyA6ICtudW1zWzBdLCBpc0FycmF5ID8gMCA6ICtudW1zWzFdLCArbnVtc1syXSB8fCAxZS01KTtcbiAgICBwcmV2ID0gZW5kICsgMTtcbiAgfVxuXG4gIHJldHVybiBzICsgdmFsdWUuc3Vic3RyKHByZXYsIHZhbHVlLmxlbmd0aCAtIHByZXYpO1xufSxcbiAgICBtYXBSYW5nZSA9IGZ1bmN0aW9uIG1hcFJhbmdlKGluTWluLCBpbk1heCwgb3V0TWluLCBvdXRNYXgsIHZhbHVlKSB7XG4gIHZhciBpblJhbmdlID0gaW5NYXggLSBpbk1pbixcbiAgICAgIG91dFJhbmdlID0gb3V0TWF4IC0gb3V0TWluO1xuICByZXR1cm4gX2NvbmRpdGlvbmFsUmV0dXJuKHZhbHVlLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gb3V0TWluICsgKCh2YWx1ZSAtIGluTWluKSAvIGluUmFuZ2UgKiBvdXRSYW5nZSB8fCAwKTtcbiAgfSk7XG59LFxuICAgIGludGVycG9sYXRlID0gZnVuY3Rpb24gaW50ZXJwb2xhdGUoc3RhcnQsIGVuZCwgcHJvZ3Jlc3MsIG11dGF0ZSkge1xuICB2YXIgZnVuYyA9IGlzTmFOKHN0YXJ0ICsgZW5kKSA/IDAgOiBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiAoMSAtIHApICogc3RhcnQgKyBwICogZW5kO1xuICB9O1xuXG4gIGlmICghZnVuYykge1xuICAgIHZhciBpc1N0cmluZyA9IF9pc1N0cmluZyhzdGFydCksXG4gICAgICAgIG1hc3RlciA9IHt9LFxuICAgICAgICBwLFxuICAgICAgICBpLFxuICAgICAgICBpbnRlcnBvbGF0b3JzLFxuICAgICAgICBsLFxuICAgICAgICBpbDtcblxuICAgIHByb2dyZXNzID09PSB0cnVlICYmIChtdXRhdGUgPSAxKSAmJiAocHJvZ3Jlc3MgPSBudWxsKTtcblxuICAgIGlmIChpc1N0cmluZykge1xuICAgICAgc3RhcnQgPSB7XG4gICAgICAgIHA6IHN0YXJ0XG4gICAgICB9O1xuICAgICAgZW5kID0ge1xuICAgICAgICBwOiBlbmRcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChfaXNBcnJheShzdGFydCkgJiYgIV9pc0FycmF5KGVuZCkpIHtcbiAgICAgIGludGVycG9sYXRvcnMgPSBbXTtcbiAgICAgIGwgPSBzdGFydC5sZW5ndGg7XG4gICAgICBpbCA9IGwgLSAyO1xuXG4gICAgICBmb3IgKGkgPSAxOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGludGVycG9sYXRvcnMucHVzaChpbnRlcnBvbGF0ZShzdGFydFtpIC0gMV0sIHN0YXJ0W2ldKSk7IC8vYnVpbGQgdGhlIGludGVycG9sYXRvcnMgdXAgZnJvbnQgYXMgYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gc28gdGhhdCB3aGVuIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgbWFueSB0aW1lcywgaXQgY2FuIGp1c3QgcmV1c2UgdGhlbS5cbiAgICAgIH1cblxuICAgICAgbC0tO1xuXG4gICAgICBmdW5jID0gZnVuY3Rpb24gZnVuYyhwKSB7XG4gICAgICAgIHAgKj0gbDtcbiAgICAgICAgdmFyIGkgPSBNYXRoLm1pbihpbCwgfn5wKTtcbiAgICAgICAgcmV0dXJuIGludGVycG9sYXRvcnNbaV0ocCAtIGkpO1xuICAgICAgfTtcblxuICAgICAgcHJvZ3Jlc3MgPSBlbmQ7XG4gICAgfSBlbHNlIGlmICghbXV0YXRlKSB7XG4gICAgICBzdGFydCA9IF9tZXJnZShfaXNBcnJheShzdGFydCkgPyBbXSA6IHt9LCBzdGFydCk7XG4gICAgfVxuXG4gICAgaWYgKCFpbnRlcnBvbGF0b3JzKSB7XG4gICAgICBmb3IgKHAgaW4gZW5kKSB7XG4gICAgICAgIF9hZGRQcm9wVHdlZW4uY2FsbChtYXN0ZXIsIHN0YXJ0LCBwLCBcImdldFwiLCBlbmRbcF0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jID0gZnVuY3Rpb24gZnVuYyhwKSB7XG4gICAgICAgIHJldHVybiBfcmVuZGVyUHJvcFR3ZWVucyhwLCBtYXN0ZXIpIHx8IChpc1N0cmluZyA/IHN0YXJ0LnAgOiBzdGFydCk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfY29uZGl0aW9uYWxSZXR1cm4ocHJvZ3Jlc3MsIGZ1bmMpO1xufSxcbiAgICBfZ2V0TGFiZWxJbkRpcmVjdGlvbiA9IGZ1bmN0aW9uIF9nZXRMYWJlbEluRGlyZWN0aW9uKHRpbWVsaW5lLCBmcm9tVGltZSwgYmFja3dhcmQpIHtcbiAgLy91c2VkIGZvciBuZXh0TGFiZWwoKSBhbmQgcHJldmlvdXNMYWJlbCgpXG4gIHZhciBsYWJlbHMgPSB0aW1lbGluZS5sYWJlbHMsXG4gICAgICBtaW4gPSBfYmlnTnVtLFxuICAgICAgcCxcbiAgICAgIGRpc3RhbmNlLFxuICAgICAgbGFiZWw7XG5cbiAgZm9yIChwIGluIGxhYmVscykge1xuICAgIGRpc3RhbmNlID0gbGFiZWxzW3BdIC0gZnJvbVRpbWU7XG5cbiAgICBpZiAoZGlzdGFuY2UgPCAwID09PSAhIWJhY2t3YXJkICYmIGRpc3RhbmNlICYmIG1pbiA+IChkaXN0YW5jZSA9IE1hdGguYWJzKGRpc3RhbmNlKSkpIHtcbiAgICAgIGxhYmVsID0gcDtcbiAgICAgIG1pbiA9IGRpc3RhbmNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsYWJlbDtcbn0sXG4gICAgX2NhbGxiYWNrID0gZnVuY3Rpb24gX2NhbGxiYWNrKGFuaW1hdGlvbiwgdHlwZSwgZXhlY3V0ZUxhenlGaXJzdCkge1xuICB2YXIgdiA9IGFuaW1hdGlvbi52YXJzLFxuICAgICAgY2FsbGJhY2sgPSB2W3R5cGVdLFxuICAgICAgcGFyYW1zLFxuICAgICAgc2NvcGU7XG5cbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHBhcmFtcyA9IHZbdHlwZSArIFwiUGFyYW1zXCJdO1xuICBzY29wZSA9IHYuY2FsbGJhY2tTY29wZSB8fCBhbmltYXRpb247XG4gIGV4ZWN1dGVMYXp5Rmlyc3QgJiYgX2xhenlUd2VlbnMubGVuZ3RoICYmIF9sYXp5UmVuZGVyKCk7IC8vaW4gY2FzZSByZW5kZXJpbmcgY2F1c2VkIGFueSB0d2VlbnMgdG8gbGF6eS1pbml0LCB3ZSBzaG91bGQgcmVuZGVyIHRoZW0gYmVjYXVzZSB0eXBpY2FsbHkgd2hlbiBhIHRpbWVsaW5lIGZpbmlzaGVzLCB1c2VycyBleHBlY3QgdGhpbmdzIHRvIGhhdmUgcmVuZGVyZWQgZnVsbHkuIEltYWdpbmUgYW4gb25VcGRhdGUgb24gYSB0aW1lbGluZSB0aGF0IHJlcG9ydHMvY2hlY2tzIHR3ZWVuZWQgdmFsdWVzLlxuXG4gIHJldHVybiBwYXJhbXMgPyBjYWxsYmFjay5hcHBseShzY29wZSwgcGFyYW1zKSA6IGNhbGxiYWNrLmNhbGwoc2NvcGUpO1xufSxcbiAgICBfaW50ZXJydXB0ID0gZnVuY3Rpb24gX2ludGVycnVwdChhbmltYXRpb24pIHtcbiAgX3JlbW92ZUZyb21QYXJlbnQoYW5pbWF0aW9uKTtcblxuICBhbmltYXRpb24uc2Nyb2xsVHJpZ2dlciAmJiBhbmltYXRpb24uc2Nyb2xsVHJpZ2dlci5raWxsKGZhbHNlKTtcbiAgYW5pbWF0aW9uLnByb2dyZXNzKCkgPCAxICYmIF9jYWxsYmFjayhhbmltYXRpb24sIFwib25JbnRlcnJ1cHRcIik7XG4gIHJldHVybiBhbmltYXRpb247XG59LFxuICAgIF9xdWlja1R3ZWVuLFxuICAgIF9jcmVhdGVQbHVnaW4gPSBmdW5jdGlvbiBfY3JlYXRlUGx1Z2luKGNvbmZpZykge1xuICBjb25maWcgPSAhY29uZmlnLm5hbWUgJiYgY29uZmlnW1wiZGVmYXVsdFwiXSB8fCBjb25maWc7IC8vVU1EIHBhY2thZ2luZyB3cmFwcyB0aGluZ3Mgb2RkbHksIHNvIGZvciBleGFtcGxlIE1vdGlvblBhdGhIZWxwZXIgYmVjb21lcyB7TW90aW9uUGF0aEhlbHBlcjpNb3Rpb25QYXRoSGVscGVyLCBkZWZhdWx0Ok1vdGlvblBhdGhIZWxwZXJ9LlxuXG4gIHZhciBuYW1lID0gY29uZmlnLm5hbWUsXG4gICAgICBpc0Z1bmMgPSBfaXNGdW5jdGlvbihjb25maWcpLFxuICAgICAgUGx1Z2luID0gbmFtZSAmJiAhaXNGdW5jICYmIGNvbmZpZy5pbml0ID8gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3Byb3BzID0gW107XG4gIH0gOiBjb25maWcsXG4gICAgICAvL2luIGNhc2Ugc29tZW9uZSBwYXNzZXMgaW4gYW4gb2JqZWN0IHRoYXQncyBub3QgYSBwbHVnaW4sIGxpa2UgQ3VzdG9tRWFzZVxuICBpbnN0YW5jZURlZmF1bHRzID0ge1xuICAgIGluaXQ6IF9lbXB0eUZ1bmMsXG4gICAgcmVuZGVyOiBfcmVuZGVyUHJvcFR3ZWVucyxcbiAgICBhZGQ6IF9hZGRQcm9wVHdlZW4sXG4gICAga2lsbDogX2tpbGxQcm9wVHdlZW5zT2YsXG4gICAgbW9kaWZpZXI6IF9hZGRQbHVnaW5Nb2RpZmllcixcbiAgICByYXdWYXJzOiAwXG4gIH0sXG4gICAgICBzdGF0aWNzID0ge1xuICAgIHRhcmdldFRlc3Q6IDAsXG4gICAgZ2V0OiAwLFxuICAgIGdldFNldHRlcjogX2dldFNldHRlcixcbiAgICBhbGlhc2VzOiB7fSxcbiAgICByZWdpc3RlcjogMFxuICB9O1xuXG4gIF93YWtlKCk7XG5cbiAgaWYgKGNvbmZpZyAhPT0gUGx1Z2luKSB7XG4gICAgaWYgKF9wbHVnaW5zW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX3NldERlZmF1bHRzKFBsdWdpbiwgX3NldERlZmF1bHRzKF9jb3B5RXhjbHVkaW5nKGNvbmZpZywgaW5zdGFuY2VEZWZhdWx0cyksIHN0YXRpY3MpKTsgLy9zdGF0aWMgbWV0aG9kc1xuXG5cbiAgICBfbWVyZ2UoUGx1Z2luLnByb3RvdHlwZSwgX21lcmdlKGluc3RhbmNlRGVmYXVsdHMsIF9jb3B5RXhjbHVkaW5nKGNvbmZpZywgc3RhdGljcykpKTsgLy9pbnN0YW5jZSBtZXRob2RzXG5cblxuICAgIF9wbHVnaW5zW1BsdWdpbi5wcm9wID0gbmFtZV0gPSBQbHVnaW47XG5cbiAgICBpZiAoY29uZmlnLnRhcmdldFRlc3QpIHtcbiAgICAgIF9oYXJuZXNzUGx1Z2lucy5wdXNoKFBsdWdpbik7XG5cbiAgICAgIF9yZXNlcnZlZFByb3BzW25hbWVdID0gMTtcbiAgICB9XG5cbiAgICBuYW1lID0gKG5hbWUgPT09IFwiY3NzXCIgPyBcIkNTU1wiIDogbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyKDEpKSArIFwiUGx1Z2luXCI7IC8vZm9yIHRoZSBnbG9iYWwgbmFtZS4gXCJtb3Rpb25QYXRoXCIgc2hvdWxkIGJlY29tZSBNb3Rpb25QYXRoUGx1Z2luXG4gIH1cblxuICBfYWRkR2xvYmFsKG5hbWUsIFBsdWdpbik7XG5cbiAgY29uZmlnLnJlZ2lzdGVyICYmIGNvbmZpZy5yZWdpc3Rlcihnc2FwLCBQbHVnaW4sIFByb3BUd2Vlbik7XG59LFxuXG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENPTE9SU1xuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXzI1NSA9IDI1NSxcbiAgICBfY29sb3JMb29rdXAgPSB7XG4gIGFxdWE6IFswLCBfMjU1LCBfMjU1XSxcbiAgbGltZTogWzAsIF8yNTUsIDBdLFxuICBzaWx2ZXI6IFsxOTIsIDE5MiwgMTkyXSxcbiAgYmxhY2s6IFswLCAwLCAwXSxcbiAgbWFyb29uOiBbMTI4LCAwLCAwXSxcbiAgdGVhbDogWzAsIDEyOCwgMTI4XSxcbiAgYmx1ZTogWzAsIDAsIF8yNTVdLFxuICBuYXZ5OiBbMCwgMCwgMTI4XSxcbiAgd2hpdGU6IFtfMjU1LCBfMjU1LCBfMjU1XSxcbiAgb2xpdmU6IFsxMjgsIDEyOCwgMF0sXG4gIHllbGxvdzogW18yNTUsIF8yNTUsIDBdLFxuICBvcmFuZ2U6IFtfMjU1LCAxNjUsIDBdLFxuICBncmF5OiBbMTI4LCAxMjgsIDEyOF0sXG4gIHB1cnBsZTogWzEyOCwgMCwgMTI4XSxcbiAgZ3JlZW46IFswLCAxMjgsIDBdLFxuICByZWQ6IFtfMjU1LCAwLCAwXSxcbiAgcGluazogW18yNTUsIDE5MiwgMjAzXSxcbiAgY3lhbjogWzAsIF8yNTUsIF8yNTVdLFxuICB0cmFuc3BhcmVudDogW18yNTUsIF8yNTUsIF8yNTUsIDBdXG59LFxuICAgIC8vIHBvc3NpYmxlIGZ1dHVyZSBpZGVhIHRvIHJlcGxhY2UgdGhlIGhhcmQtY29kZWQgY29sb3IgbmFtZSB2YWx1ZXMgLSBwdXQgdGhpcyBpbiB0aGUgdGlja2VyLndha2UoKSB3aGVyZSB3ZSBzZXQgdGhlIF9kb2M6XG4vLyBsZXQgY3R4ID0gX2RvYy5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLmdldENvbnRleHQoXCIyZFwiKTtcbi8vIF9mb3JFYWNoTmFtZShcImFxdWEsbGltZSxzaWx2ZXIsYmxhY2ssbWFyb29uLHRlYWwsYmx1ZSxuYXZ5LHdoaXRlLG9saXZlLHllbGxvdyxvcmFuZ2UsZ3JheSxwdXJwbGUsZ3JlZW4scmVkLHBpbmssY3lhblwiLCBjb2xvciA9PiB7Y3R4LmZpbGxTdHlsZSA9IGNvbG9yOyBfY29sb3JMb29rdXBbY29sb3JdID0gc3BsaXRDb2xvcihjdHguZmlsbFN0eWxlKX0pO1xuX2h1ZSA9IGZ1bmN0aW9uIF9odWUoaCwgbTEsIG0yKSB7XG4gIGggKz0gaCA8IDAgPyAxIDogaCA+IDEgPyAtMSA6IDA7XG4gIHJldHVybiAoaCAqIDYgPCAxID8gbTEgKyAobTIgLSBtMSkgKiBoICogNiA6IGggPCAuNSA/IG0yIDogaCAqIDMgPCAyID8gbTEgKyAobTIgLSBtMSkgKiAoMiAvIDMgLSBoKSAqIDYgOiBtMSkgKiBfMjU1ICsgLjUgfCAwO1xufSxcbiAgICBzcGxpdENvbG9yID0gZnVuY3Rpb24gc3BsaXRDb2xvcih2LCB0b0hTTCwgZm9yY2VBbHBoYSkge1xuICB2YXIgYSA9ICF2ID8gX2NvbG9yTG9va3VwLmJsYWNrIDogX2lzTnVtYmVyKHYpID8gW3YgPj4gMTYsIHYgPj4gOCAmIF8yNTUsIHYgJiBfMjU1XSA6IDAsXG4gICAgICByLFxuICAgICAgZyxcbiAgICAgIGIsXG4gICAgICBoLFxuICAgICAgcyxcbiAgICAgIGwsXG4gICAgICBtYXgsXG4gICAgICBtaW4sXG4gICAgICBkLFxuICAgICAgd2FzSFNMO1xuXG4gIGlmICghYSkge1xuICAgIGlmICh2LnN1YnN0cigtMSkgPT09IFwiLFwiKSB7XG4gICAgICAvL3NvbWV0aW1lcyBhIHRyYWlsaW5nIGNvbW1hIGlzIGluY2x1ZGVkIGFuZCB3ZSBzaG91bGQgY2hvcCBpdCBvZmYgKHR5cGljYWxseSBmcm9tIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgdmFsdWVzIGxpa2UgYSB0ZXh0U2hhZG93OlwiMnB4IDJweCAycHggYmx1ZSwgNXB4IDVweCA1cHggcmdiKDI1NSwwLDApXCIgLSBpbiB0aGlzIGV4YW1wbGUgXCJibHVlLFwiIGhhcyBhIHRyYWlsaW5nIGNvbW1hLiBXZSBjb3VsZCBzdHJpcCBpdCBvdXQgaW5zaWRlIHBhcnNlQ29tcGxleCgpIGJ1dCB3ZSdkIG5lZWQgdG8gZG8gaXQgdG8gdGhlIGJlZ2lubmluZyBhbmQgZW5kaW5nIHZhbHVlcyBwbHVzIGl0IHdvdWxkbid0IHByb3ZpZGUgcHJvdGVjdGlvbiBmcm9tIG90aGVyIHBvdGVudGlhbCBzY2VuYXJpb3MgbGlrZSBpZiB0aGUgdXNlciBwYXNzZXMgaW4gYSBzaW1pbGFyIHZhbHVlLlxuICAgICAgdiA9IHYuc3Vic3RyKDAsIHYubGVuZ3RoIC0gMSk7XG4gICAgfVxuXG4gICAgaWYgKF9jb2xvckxvb2t1cFt2XSkge1xuICAgICAgYSA9IF9jb2xvckxvb2t1cFt2XTtcbiAgICB9IGVsc2UgaWYgKHYuY2hhckF0KDApID09PSBcIiNcIikge1xuICAgICAgaWYgKHYubGVuZ3RoIDwgNikge1xuICAgICAgICAvL2ZvciBzaG9ydGhhbmQgbGlrZSAjOUYwIG9yICM5RjBGIChjb3VsZCBoYXZlIGFscGhhKVxuICAgICAgICByID0gdi5jaGFyQXQoMSk7XG4gICAgICAgIGcgPSB2LmNoYXJBdCgyKTtcbiAgICAgICAgYiA9IHYuY2hhckF0KDMpO1xuICAgICAgICB2ID0gXCIjXCIgKyByICsgciArIGcgKyBnICsgYiArIGIgKyAodi5sZW5ndGggPT09IDUgPyB2LmNoYXJBdCg0KSArIHYuY2hhckF0KDQpIDogXCJcIik7XG4gICAgICB9XG5cbiAgICAgIGlmICh2Lmxlbmd0aCA9PT0gOSkge1xuICAgICAgICAvLyBoZXggd2l0aCBhbHBoYSwgbGlrZSAjZmQ1ZTUzZmZcbiAgICAgICAgYSA9IHBhcnNlSW50KHYuc3Vic3RyKDEsIDYpLCAxNik7XG4gICAgICAgIHJldHVybiBbYSA+PiAxNiwgYSA+PiA4ICYgXzI1NSwgYSAmIF8yNTUsIHBhcnNlSW50KHYuc3Vic3RyKDcpLCAxNikgLyAyNTVdO1xuICAgICAgfVxuXG4gICAgICB2ID0gcGFyc2VJbnQodi5zdWJzdHIoMSksIDE2KTtcbiAgICAgIGEgPSBbdiA+PiAxNiwgdiA+PiA4ICYgXzI1NSwgdiAmIF8yNTVdO1xuICAgIH0gZWxzZSBpZiAodi5zdWJzdHIoMCwgMykgPT09IFwiaHNsXCIpIHtcbiAgICAgIGEgPSB3YXNIU0wgPSB2Lm1hdGNoKF9zdHJpY3ROdW1FeHApO1xuXG4gICAgICBpZiAoIXRvSFNMKSB7XG4gICAgICAgIGggPSArYVswXSAlIDM2MCAvIDM2MDtcbiAgICAgICAgcyA9ICthWzFdIC8gMTAwO1xuICAgICAgICBsID0gK2FbMl0gLyAxMDA7XG4gICAgICAgIGcgPSBsIDw9IC41ID8gbCAqIChzICsgMSkgOiBsICsgcyAtIGwgKiBzO1xuICAgICAgICByID0gbCAqIDIgLSBnO1xuICAgICAgICBhLmxlbmd0aCA+IDMgJiYgKGFbM10gKj0gMSk7IC8vY2FzdCBhcyBudW1iZXJcblxuICAgICAgICBhWzBdID0gX2h1ZShoICsgMSAvIDMsIHIsIGcpO1xuICAgICAgICBhWzFdID0gX2h1ZShoLCByLCBnKTtcbiAgICAgICAgYVsyXSA9IF9odWUoaCAtIDEgLyAzLCByLCBnKTtcbiAgICAgIH0gZWxzZSBpZiAofnYuaW5kZXhPZihcIj1cIikpIHtcbiAgICAgICAgLy9pZiByZWxhdGl2ZSB2YWx1ZXMgYXJlIGZvdW5kLCBqdXN0IHJldHVybiB0aGUgcmF3IHN0cmluZ3Mgd2l0aCB0aGUgcmVsYXRpdmUgcHJlZml4ZXMgaW4gcGxhY2UuXG4gICAgICAgIGEgPSB2Lm1hdGNoKF9udW1FeHApO1xuICAgICAgICBmb3JjZUFscGhhICYmIGEubGVuZ3RoIDwgNCAmJiAoYVszXSA9IDEpO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IHYubWF0Y2goX3N0cmljdE51bUV4cCkgfHwgX2NvbG9yTG9va3VwLnRyYW5zcGFyZW50O1xuICAgIH1cblxuICAgIGEgPSBhLm1hcChOdW1iZXIpO1xuICB9XG5cbiAgaWYgKHRvSFNMICYmICF3YXNIU0wpIHtcbiAgICByID0gYVswXSAvIF8yNTU7XG4gICAgZyA9IGFbMV0gLyBfMjU1O1xuICAgIGIgPSBhWzJdIC8gXzI1NTtcbiAgICBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgICBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICBsID0gKG1heCArIG1pbikgLyAyO1xuXG4gICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICBoID0gcyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGQgPSBtYXggLSBtaW47XG4gICAgICBzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XG4gICAgICBoID0gbWF4ID09PSByID8gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCkgOiBtYXggPT09IGcgPyAoYiAtIHIpIC8gZCArIDIgOiAociAtIGcpIC8gZCArIDQ7XG4gICAgICBoICo9IDYwO1xuICAgIH1cblxuICAgIGFbMF0gPSB+fihoICsgLjUpO1xuICAgIGFbMV0gPSB+fihzICogMTAwICsgLjUpO1xuICAgIGFbMl0gPSB+fihsICogMTAwICsgLjUpO1xuICB9XG5cbiAgZm9yY2VBbHBoYSAmJiBhLmxlbmd0aCA8IDQgJiYgKGFbM10gPSAxKTtcbiAgcmV0dXJuIGE7XG59LFxuICAgIF9jb2xvck9yZGVyRGF0YSA9IGZ1bmN0aW9uIF9jb2xvck9yZGVyRGF0YSh2KSB7XG4gIC8vIHN0cmlwcyBvdXQgdGhlIGNvbG9ycyBmcm9tIHRoZSBzdHJpbmcsIGZpbmRzIGFsbCB0aGUgbnVtZXJpYyBzbG90cyAod2l0aCB1bml0cykgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhvc2UuIFRoZSBBcnJheSBhbHNvIGhhcyBhIFwiY1wiIHByb3BlcnR5IHdoaWNoIGlzIGFuIEFycmF5IG9mIHRoZSBpbmRleCB2YWx1ZXMgd2hlcmUgdGhlIGNvbG9ycyBiZWxvbmcuIFRoaXMgaXMgdG8gaGVscCB3b3JrIGFyb3VuZCBpc3N1ZXMgd2hlcmUgdGhlcmUncyBhIG1pcy1tYXRjaGVkIG9yZGVyIG9mIGNvbG9yL251bWVyaWMgZGF0YSBsaWtlIGRyb3Atc2hhZG93KCNmMDAgMHB4IDFweCAycHgpIGFuZCBkcm9wLXNoYWRvdygweCAxcHggMnB4ICNmMDApLiBUaGlzIGlzIGJhc2ljYWxseSBhIGhlbHBlciBmdW5jdGlvbiB1c2VkIGluIF9mb3JtYXRDb2xvcnMoKVxuICB2YXIgdmFsdWVzID0gW10sXG4gICAgICBjID0gW10sXG4gICAgICBpID0gLTE7XG4gIHYuc3BsaXQoX2NvbG9yRXhwKS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgdmFyIGEgPSB2Lm1hdGNoKF9udW1XaXRoVW5pdEV4cCkgfHwgW107XG4gICAgdmFsdWVzLnB1c2guYXBwbHkodmFsdWVzLCBhKTtcbiAgICBjLnB1c2goaSArPSBhLmxlbmd0aCArIDEpO1xuICB9KTtcbiAgdmFsdWVzLmMgPSBjO1xuICByZXR1cm4gdmFsdWVzO1xufSxcbiAgICBfZm9ybWF0Q29sb3JzID0gZnVuY3Rpb24gX2Zvcm1hdENvbG9ycyhzLCB0b0hTTCwgb3JkZXJNYXRjaERhdGEpIHtcbiAgdmFyIHJlc3VsdCA9IFwiXCIsXG4gICAgICBjb2xvcnMgPSAocyArIHJlc3VsdCkubWF0Y2goX2NvbG9yRXhwKSxcbiAgICAgIHR5cGUgPSB0b0hTTCA/IFwiaHNsYShcIiA6IFwicmdiYShcIixcbiAgICAgIGkgPSAwLFxuICAgICAgYyxcbiAgICAgIHNoZWxsLFxuICAgICAgZCxcbiAgICAgIGw7XG5cbiAgaWYgKCFjb2xvcnMpIHtcbiAgICByZXR1cm4gcztcbiAgfVxuXG4gIGNvbG9ycyA9IGNvbG9ycy5tYXAoZnVuY3Rpb24gKGNvbG9yKSB7XG4gICAgcmV0dXJuIChjb2xvciA9IHNwbGl0Q29sb3IoY29sb3IsIHRvSFNMLCAxKSkgJiYgdHlwZSArICh0b0hTTCA/IGNvbG9yWzBdICsgXCIsXCIgKyBjb2xvclsxXSArIFwiJSxcIiArIGNvbG9yWzJdICsgXCIlLFwiICsgY29sb3JbM10gOiBjb2xvci5qb2luKFwiLFwiKSkgKyBcIilcIjtcbiAgfSk7XG5cbiAgaWYgKG9yZGVyTWF0Y2hEYXRhKSB7XG4gICAgZCA9IF9jb2xvck9yZGVyRGF0YShzKTtcbiAgICBjID0gb3JkZXJNYXRjaERhdGEuYztcblxuICAgIGlmIChjLmpvaW4ocmVzdWx0KSAhPT0gZC5jLmpvaW4ocmVzdWx0KSkge1xuICAgICAgc2hlbGwgPSBzLnJlcGxhY2UoX2NvbG9yRXhwLCBcIjFcIikuc3BsaXQoX251bVdpdGhVbml0RXhwKTtcbiAgICAgIGwgPSBzaGVsbC5sZW5ndGggLSAxO1xuXG4gICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICByZXN1bHQgKz0gc2hlbGxbaV0gKyAofmMuaW5kZXhPZihpKSA/IGNvbG9ycy5zaGlmdCgpIHx8IHR5cGUgKyBcIjAsMCwwLDApXCIgOiAoZC5sZW5ndGggPyBkIDogY29sb3JzLmxlbmd0aCA/IGNvbG9ycyA6IG9yZGVyTWF0Y2hEYXRhKS5zaGlmdCgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIXNoZWxsKSB7XG4gICAgc2hlbGwgPSBzLnNwbGl0KF9jb2xvckV4cCk7XG4gICAgbCA9IHNoZWxsLmxlbmd0aCAtIDE7XG5cbiAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgcmVzdWx0ICs9IHNoZWxsW2ldICsgY29sb3JzW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQgKyBzaGVsbFtsXTtcbn0sXG4gICAgX2NvbG9yRXhwID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcyA9IFwiKD86XFxcXGIoPzooPzpyZ2J8cmdiYXxoc2x8aHNsYSlcXFxcKC4rP1xcXFwpKXxcXFxcQiMoPzpbMC05YS1mXXszLDR9KXsxLDJ9XFxcXGJcIixcbiAgICAgIC8vd2UnbGwgZHluYW1pY2FsbHkgYnVpbGQgdGhpcyBSZWd1bGFyIEV4cHJlc3Npb24gdG8gY29uc2VydmUgZmlsZSBzaXplLiBBZnRlciBidWlsZGluZyBpdCwgaXQgd2lsbCBiZSBhYmxlIHRvIGZpbmQgcmdiKCksIHJnYmEoKSwgIyAoaGV4YWRlY2ltYWwpLCBhbmQgbmFtZWQgY29sb3IgdmFsdWVzIGxpa2UgcmVkLCBibHVlLCBwdXJwbGUsIGV0Yy4sXG4gIHA7XG5cbiAgZm9yIChwIGluIF9jb2xvckxvb2t1cCkge1xuICAgIHMgKz0gXCJ8XCIgKyBwICsgXCJcXFxcYlwiO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBSZWdFeHAocyArIFwiKVwiLCBcImdpXCIpO1xufSgpLFxuICAgIF9oc2xFeHAgPSAvaHNsW2FdP1xcKC8sXG4gICAgX2NvbG9yU3RyaW5nRmlsdGVyID0gZnVuY3Rpb24gX2NvbG9yU3RyaW5nRmlsdGVyKGEpIHtcbiAgdmFyIGNvbWJpbmVkID0gYS5qb2luKFwiIFwiKSxcbiAgICAgIHRvSFNMO1xuICBfY29sb3JFeHAubGFzdEluZGV4ID0gMDtcblxuICBpZiAoX2NvbG9yRXhwLnRlc3QoY29tYmluZWQpKSB7XG4gICAgdG9IU0wgPSBfaHNsRXhwLnRlc3QoY29tYmluZWQpO1xuICAgIGFbMV0gPSBfZm9ybWF0Q29sb3JzKGFbMV0sIHRvSFNMKTtcbiAgICBhWzBdID0gX2Zvcm1hdENvbG9ycyhhWzBdLCB0b0hTTCwgX2NvbG9yT3JkZXJEYXRhKGFbMV0pKTsgLy8gbWFrZSBzdXJlIHRoZSBvcmRlciBvZiBudW1iZXJzL2NvbG9ycyBtYXRjaCB3aXRoIHRoZSBFTkQgdmFsdWUuXG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufSxcblxuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBUSUNLRVJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cbl90aWNrZXJBY3RpdmUsXG4gICAgX3RpY2tlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF9nZXRUaW1lID0gRGF0ZS5ub3csXG4gICAgICBfbGFnVGhyZXNob2xkID0gNTAwLFxuICAgICAgX2FkanVzdGVkTGFnID0gMzMsXG4gICAgICBfc3RhcnRUaW1lID0gX2dldFRpbWUoKSxcbiAgICAgIF9sYXN0VXBkYXRlID0gX3N0YXJ0VGltZSxcbiAgICAgIF9nYXAgPSAxMDAwIC8gMjQwLFxuICAgICAgX25leHRUaW1lID0gX2dhcCxcbiAgICAgIF9saXN0ZW5lcnMgPSBbXSxcbiAgICAgIF9pZCxcbiAgICAgIF9yZXEsXG4gICAgICBfcmFmLFxuICAgICAgX3NlbGYsXG4gICAgICBfZGVsdGEsXG4gICAgICBfaSxcbiAgICAgIF90aWNrID0gZnVuY3Rpb24gX3RpY2sodikge1xuICAgIHZhciBlbGFwc2VkID0gX2dldFRpbWUoKSAtIF9sYXN0VXBkYXRlLFxuICAgICAgICBtYW51YWwgPSB2ID09PSB0cnVlLFxuICAgICAgICBvdmVybGFwLFxuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAgdGltZSxcbiAgICAgICAgZnJhbWU7XG5cbiAgICBlbGFwc2VkID4gX2xhZ1RocmVzaG9sZCAmJiAoX3N0YXJ0VGltZSArPSBlbGFwc2VkIC0gX2FkanVzdGVkTGFnKTtcbiAgICBfbGFzdFVwZGF0ZSArPSBlbGFwc2VkO1xuICAgIHRpbWUgPSBfbGFzdFVwZGF0ZSAtIF9zdGFydFRpbWU7XG4gICAgb3ZlcmxhcCA9IHRpbWUgLSBfbmV4dFRpbWU7XG5cbiAgICBpZiAob3ZlcmxhcCA+IDAgfHwgbWFudWFsKSB7XG4gICAgICBmcmFtZSA9ICsrX3NlbGYuZnJhbWU7XG4gICAgICBfZGVsdGEgPSB0aW1lIC0gX3NlbGYudGltZSAqIDEwMDA7XG4gICAgICBfc2VsZi50aW1lID0gdGltZSA9IHRpbWUgLyAxMDAwO1xuICAgICAgX25leHRUaW1lICs9IG92ZXJsYXAgKyAob3ZlcmxhcCA+PSBfZ2FwID8gNCA6IF9nYXAgLSBvdmVybGFwKTtcbiAgICAgIGRpc3BhdGNoID0gMTtcbiAgICB9XG5cbiAgICBtYW51YWwgfHwgKF9pZCA9IF9yZXEoX3RpY2spKTsgLy9tYWtlIHN1cmUgdGhlIHJlcXVlc3QgaXMgbWFkZSBiZWZvcmUgd2UgZGlzcGF0Y2ggdGhlIFwidGlja1wiIGV2ZW50IHNvIHRoYXQgdGltaW5nIGlzIG1haW50YWluZWQuIE90aGVyd2lzZSwgaWYgcHJvY2Vzc2luZyB0aGUgXCJ0aWNrXCIgcmVxdWlyZXMgYSBidW5jaCBvZiB0aW1lIChsaWtlIDE1bXMpIGFuZCB3ZSdyZSB1c2luZyBhIHNldFRpbWVvdXQoKSB0aGF0J3MgYmFzZWQgb24gMTYuN21zLCBpdCdkIHRlY2huaWNhbGx5IHRha2UgMzEuN21zIGJldHdlZW4gZnJhbWVzIG90aGVyd2lzZS5cblxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgZm9yIChfaSA9IDA7IF9pIDwgX2xpc3RlbmVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgLy8gdXNlIF9pIGFuZCBjaGVjayBfbGlzdGVuZXJzLmxlbmd0aCBpbnN0ZWFkIG9mIGEgdmFyaWFibGUgYmVjYXVzZSBhIGxpc3RlbmVyIGNvdWxkIGdldCByZW1vdmVkIGR1cmluZyB0aGUgbG9vcCwgYW5kIGlmIHRoYXQgaGFwcGVucyB0byBhbiBlbGVtZW50IGxlc3MgdGhhbiB0aGUgY3VycmVudCBpbmRleCwgaXQnZCB0aHJvdyB0aGluZ3Mgb2ZmIGluIHRoZSBsb29wLlxuICAgICAgICBfbGlzdGVuZXJzW19pXSh0aW1lLCBfZGVsdGEsIGZyYW1lLCB2KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3NlbGYgPSB7XG4gICAgdGltZTogMCxcbiAgICBmcmFtZTogMCxcbiAgICB0aWNrOiBmdW5jdGlvbiB0aWNrKCkge1xuICAgICAgX3RpY2sodHJ1ZSk7XG4gICAgfSxcbiAgICBkZWx0YVJhdGlvOiBmdW5jdGlvbiBkZWx0YVJhdGlvKGZwcykge1xuICAgICAgcmV0dXJuIF9kZWx0YSAvICgxMDAwIC8gKGZwcyB8fCA2MCkpO1xuICAgIH0sXG4gICAgd2FrZTogZnVuY3Rpb24gd2FrZSgpIHtcbiAgICAgIGlmIChfY29yZVJlYWR5KSB7XG4gICAgICAgIGlmICghX2NvcmVJbml0dGVkICYmIF93aW5kb3dFeGlzdHMoKSkge1xuICAgICAgICAgIF93aW4gPSBfY29yZUluaXR0ZWQgPSB3aW5kb3c7XG4gICAgICAgICAgX2RvYyA9IF93aW4uZG9jdW1lbnQgfHwge307XG4gICAgICAgICAgX2dsb2JhbHMuZ3NhcCA9IGdzYXA7XG4gICAgICAgICAgKF93aW4uZ3NhcFZlcnNpb25zIHx8IChfd2luLmdzYXBWZXJzaW9ucyA9IFtdKSkucHVzaChnc2FwLnZlcnNpb24pO1xuXG4gICAgICAgICAgX2luc3RhbGwoX2luc3RhbGxTY29wZSB8fCBfd2luLkdyZWVuU29ja0dsb2JhbHMgfHwgIV93aW4uZ3NhcCAmJiBfd2luIHx8IHt9KTtcblxuICAgICAgICAgIF9yYWYgPSBfd2luLnJlcXVlc3RBbmltYXRpb25GcmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9pZCAmJiBfc2VsZi5zbGVlcCgpO1xuXG4gICAgICAgIF9yZXEgPSBfcmFmIHx8IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZiwgX25leHRUaW1lIC0gX3NlbGYudGltZSAqIDEwMDAgKyAxIHwgMCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgX3RpY2tlckFjdGl2ZSA9IDE7XG5cbiAgICAgICAgX3RpY2soMik7XG4gICAgICB9XG4gICAgfSxcbiAgICBzbGVlcDogZnVuY3Rpb24gc2xlZXAoKSB7XG4gICAgICAoX3JhZiA/IF93aW4uY2FuY2VsQW5pbWF0aW9uRnJhbWUgOiBjbGVhclRpbWVvdXQpKF9pZCk7XG4gICAgICBfdGlja2VyQWN0aXZlID0gMDtcbiAgICAgIF9yZXEgPSBfZW1wdHlGdW5jO1xuICAgIH0sXG4gICAgbGFnU21vb3RoaW5nOiBmdW5jdGlvbiBsYWdTbW9vdGhpbmcodGhyZXNob2xkLCBhZGp1c3RlZExhZykge1xuICAgICAgX2xhZ1RocmVzaG9sZCA9IHRocmVzaG9sZCB8fCAxIC8gX3RpbnlOdW07IC8vemVybyBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYmFzaWNhbGx5IHVubGltaXRlZFxuXG4gICAgICBfYWRqdXN0ZWRMYWcgPSBNYXRoLm1pbihhZGp1c3RlZExhZywgX2xhZ1RocmVzaG9sZCwgMCk7XG4gICAgfSxcbiAgICBmcHM6IGZ1bmN0aW9uIGZwcyhfZnBzKSB7XG4gICAgICBfZ2FwID0gMTAwMCAvIChfZnBzIHx8IDI0MCk7XG4gICAgICBfbmV4dFRpbWUgPSBfc2VsZi50aW1lICogMTAwMCArIF9nYXA7XG4gICAgfSxcbiAgICBhZGQ6IGZ1bmN0aW9uIGFkZChjYWxsYmFjaykge1xuICAgICAgX2xpc3RlbmVycy5pbmRleE9mKGNhbGxiYWNrKSA8IDAgJiYgX2xpc3RlbmVycy5wdXNoKGNhbGxiYWNrKTtcblxuICAgICAgX3dha2UoKTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGNhbGxiYWNrLCBpKSB7XG4gICAgICB+KGkgPSBfbGlzdGVuZXJzLmluZGV4T2YoY2FsbGJhY2spKSAmJiBfbGlzdGVuZXJzLnNwbGljZShpLCAxKSAmJiBfaSA+PSBpICYmIF9pLS07XG4gICAgfSxcbiAgICBfbGlzdGVuZXJzOiBfbGlzdGVuZXJzXG4gIH07XG4gIHJldHVybiBfc2VsZjtcbn0oKSxcbiAgICBfd2FrZSA9IGZ1bmN0aW9uIF93YWtlKCkge1xuICByZXR1cm4gIV90aWNrZXJBY3RpdmUgJiYgX3RpY2tlci53YWtlKCk7XG59LFxuICAgIC8vYWxzbyBlbnN1cmVzIHRoZSBjb3JlIGNsYXNzZXMgYXJlIGluaXRpYWxpemVkLlxuXG4vKlxuKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIEVBU0lOR1xuKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qL1xuX2Vhc2VNYXAgPSB7fSxcbiAgICBfY3VzdG9tRWFzZUV4cCA9IC9eW1xcZC5cXC1NXVtcXGQuXFwtLFxcc10vLFxuICAgIF9xdW90ZXNFeHAgPSAvW1wiJ10vZyxcbiAgICBfcGFyc2VPYmplY3RJblN0cmluZyA9IGZ1bmN0aW9uIF9wYXJzZU9iamVjdEluU3RyaW5nKHZhbHVlKSB7XG4gIC8vdGFrZXMgYSBzdHJpbmcgbGlrZSBcInt3aWdnbGVzOjEwLCB0eXBlOmFudGljaXBhdGV9KVwiIGFuZCB0dXJucyBpdCBpbnRvIGEgcmVhbCBvYmplY3QuIE5vdGljZSBpdCBlbmRzIGluIFwiKVwiIGFuZCBpbmNsdWRlcyB0aGUge30gd3JhcHBlcnMuIFRoaXMgaXMgYmVjYXVzZSB3ZSBvbmx5IHVzZSB0aGlzIGZ1bmN0aW9uIGZvciBwYXJzaW5nIGVhc2UgY29uZmlncyBhbmQgcHJpb3JpdGl6ZWQgb3B0aW1pemF0aW9uIHJhdGhlciB0aGFuIHJldXNhYmlsaXR5LlxuICB2YXIgb2JqID0ge30sXG4gICAgICBzcGxpdCA9IHZhbHVlLnN1YnN0cigxLCB2YWx1ZS5sZW5ndGggLSAzKS5zcGxpdChcIjpcIiksXG4gICAgICBrZXkgPSBzcGxpdFswXSxcbiAgICAgIGkgPSAxLFxuICAgICAgbCA9IHNwbGl0Lmxlbmd0aCxcbiAgICAgIGluZGV4LFxuICAgICAgdmFsLFxuICAgICAgcGFyc2VkVmFsO1xuXG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFsID0gc3BsaXRbaV07XG4gICAgaW5kZXggPSBpICE9PSBsIC0gMSA/IHZhbC5sYXN0SW5kZXhPZihcIixcIikgOiB2YWwubGVuZ3RoO1xuICAgIHBhcnNlZFZhbCA9IHZhbC5zdWJzdHIoMCwgaW5kZXgpO1xuICAgIG9ialtrZXldID0gaXNOYU4ocGFyc2VkVmFsKSA/IHBhcnNlZFZhbC5yZXBsYWNlKF9xdW90ZXNFeHAsIFwiXCIpLnRyaW0oKSA6ICtwYXJzZWRWYWw7XG4gICAga2V5ID0gdmFsLnN1YnN0cihpbmRleCArIDEpLnRyaW0oKTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59LFxuICAgIF92YWx1ZUluUGFyZW50aGVzZXMgPSBmdW5jdGlvbiBfdmFsdWVJblBhcmVudGhlc2VzKHZhbHVlKSB7XG4gIHZhciBvcGVuID0gdmFsdWUuaW5kZXhPZihcIihcIikgKyAxLFxuICAgICAgY2xvc2UgPSB2YWx1ZS5pbmRleE9mKFwiKVwiKSxcbiAgICAgIG5lc3RlZCA9IHZhbHVlLmluZGV4T2YoXCIoXCIsIG9wZW4pO1xuICByZXR1cm4gdmFsdWUuc3Vic3RyaW5nKG9wZW4sIH5uZXN0ZWQgJiYgbmVzdGVkIDwgY2xvc2UgPyB2YWx1ZS5pbmRleE9mKFwiKVwiLCBjbG9zZSArIDEpIDogY2xvc2UpO1xufSxcbiAgICBfY29uZmlnRWFzZUZyb21TdHJpbmcgPSBmdW5jdGlvbiBfY29uZmlnRWFzZUZyb21TdHJpbmcobmFtZSkge1xuICAvL25hbWUgY2FuIGJlIGEgc3RyaW5nIGxpa2UgXCJlbGFzdGljLm91dCgxLDAuNSlcIiwgYW5kIHBhc3MgaW4gX2Vhc2VNYXAgYXMgb2JqIGFuZCBpdCdsbCBwYXJzZSBpdCBvdXQgYW5kIGNhbGwgdGhlIGFjdHVhbCBmdW5jdGlvbiBsaWtlIF9lYXNlTWFwLkVsYXN0aWMuZWFzZU91dC5jb25maWcoMSwwLjUpLiBJdCB3aWxsIGFsc28gcGFyc2UgY3VzdG9tIGVhc2Ugc3RyaW5ncyBhcyBsb25nIGFzIEN1c3RvbUVhc2UgaXMgbG9hZGVkIGFuZCByZWdpc3RlcmVkIChpbnRlcm5hbGx5IGFzIF9lYXNlTWFwLl9DRSkuXG4gIHZhciBzcGxpdCA9IChuYW1lICsgXCJcIikuc3BsaXQoXCIoXCIpLFxuICAgICAgZWFzZSA9IF9lYXNlTWFwW3NwbGl0WzBdXTtcbiAgcmV0dXJuIGVhc2UgJiYgc3BsaXQubGVuZ3RoID4gMSAmJiBlYXNlLmNvbmZpZyA/IGVhc2UuY29uZmlnLmFwcGx5KG51bGwsIH5uYW1lLmluZGV4T2YoXCJ7XCIpID8gW19wYXJzZU9iamVjdEluU3RyaW5nKHNwbGl0WzFdKV0gOiBfdmFsdWVJblBhcmVudGhlc2VzKG5hbWUpLnNwbGl0KFwiLFwiKS5tYXAoX251bWVyaWNJZlBvc3NpYmxlKSkgOiBfZWFzZU1hcC5fQ0UgJiYgX2N1c3RvbUVhc2VFeHAudGVzdChuYW1lKSA/IF9lYXNlTWFwLl9DRShcIlwiLCBuYW1lKSA6IGVhc2U7XG59LFxuICAgIF9pbnZlcnRFYXNlID0gZnVuY3Rpb24gX2ludmVydEVhc2UoZWFzZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gMSAtIGVhc2UoMSAtIHApO1xuICB9O1xufSxcbiAgICAvLyBhbGxvdyB5b3lvRWFzZSB0byBiZSBzZXQgaW4gY2hpbGRyZW4gYW5kIGhhdmUgdGhvc2UgYWZmZWN0ZWQgd2hlbiB0aGUgcGFyZW50L2FuY2VzdG9yIHRpbWVsaW5lIHlveW9zLlxuX3Byb3BhZ2F0ZVlveW9FYXNlID0gZnVuY3Rpb24gX3Byb3BhZ2F0ZVlveW9FYXNlKHRpbWVsaW5lLCBpc1lveW8pIHtcbiAgdmFyIGNoaWxkID0gdGltZWxpbmUuX2ZpcnN0LFxuICAgICAgZWFzZTtcblxuICB3aGlsZSAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBUaW1lbGluZSkge1xuICAgICAgX3Byb3BhZ2F0ZVlveW9FYXNlKGNoaWxkLCBpc1lveW8pO1xuICAgIH0gZWxzZSBpZiAoY2hpbGQudmFycy55b3lvRWFzZSAmJiAoIWNoaWxkLl95b3lvIHx8ICFjaGlsZC5fcmVwZWF0KSAmJiBjaGlsZC5feW95byAhPT0gaXNZb3lvKSB7XG4gICAgICBpZiAoY2hpbGQudGltZWxpbmUpIHtcbiAgICAgICAgX3Byb3BhZ2F0ZVlveW9FYXNlKGNoaWxkLnRpbWVsaW5lLCBpc1lveW8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWFzZSA9IGNoaWxkLl9lYXNlO1xuICAgICAgICBjaGlsZC5fZWFzZSA9IGNoaWxkLl95RWFzZTtcbiAgICAgICAgY2hpbGQuX3lFYXNlID0gZWFzZTtcbiAgICAgICAgY2hpbGQuX3lveW8gPSBpc1lveW87XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcbiAgfVxufSxcbiAgICBfcGFyc2VFYXNlID0gZnVuY3Rpb24gX3BhcnNlRWFzZShlYXNlLCBkZWZhdWx0RWFzZSkge1xuICByZXR1cm4gIWVhc2UgPyBkZWZhdWx0RWFzZSA6IChfaXNGdW5jdGlvbihlYXNlKSA/IGVhc2UgOiBfZWFzZU1hcFtlYXNlXSB8fCBfY29uZmlnRWFzZUZyb21TdHJpbmcoZWFzZSkpIHx8IGRlZmF1bHRFYXNlO1xufSxcbiAgICBfaW5zZXJ0RWFzZSA9IGZ1bmN0aW9uIF9pbnNlcnRFYXNlKG5hbWVzLCBlYXNlSW4sIGVhc2VPdXQsIGVhc2VJbk91dCkge1xuICBpZiAoZWFzZU91dCA9PT0gdm9pZCAwKSB7XG4gICAgZWFzZU91dCA9IGZ1bmN0aW9uIGVhc2VPdXQocCkge1xuICAgICAgcmV0dXJuIDEgLSBlYXNlSW4oMSAtIHApO1xuICAgIH07XG4gIH1cblxuICBpZiAoZWFzZUluT3V0ID09PSB2b2lkIDApIHtcbiAgICBlYXNlSW5PdXQgPSBmdW5jdGlvbiBlYXNlSW5PdXQocCkge1xuICAgICAgcmV0dXJuIHAgPCAuNSA/IGVhc2VJbihwICogMikgLyAyIDogMSAtIGVhc2VJbigoMSAtIHApICogMikgLyAyO1xuICAgIH07XG4gIH1cblxuICB2YXIgZWFzZSA9IHtcbiAgICBlYXNlSW46IGVhc2VJbixcbiAgICBlYXNlT3V0OiBlYXNlT3V0LFxuICAgIGVhc2VJbk91dDogZWFzZUluT3V0XG4gIH0sXG4gICAgICBsb3dlcmNhc2VOYW1lO1xuXG4gIF9mb3JFYWNoTmFtZShuYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBfZWFzZU1hcFtuYW1lXSA9IF9nbG9iYWxzW25hbWVdID0gZWFzZTtcbiAgICBfZWFzZU1hcFtsb3dlcmNhc2VOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpXSA9IGVhc2VPdXQ7XG5cbiAgICBmb3IgKHZhciBwIGluIGVhc2UpIHtcbiAgICAgIF9lYXNlTWFwW2xvd2VyY2FzZU5hbWUgKyAocCA9PT0gXCJlYXNlSW5cIiA/IFwiLmluXCIgOiBwID09PSBcImVhc2VPdXRcIiA/IFwiLm91dFwiIDogXCIuaW5PdXRcIildID0gX2Vhc2VNYXBbbmFtZSArIFwiLlwiICsgcF0gPSBlYXNlW3BdO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGVhc2U7XG59LFxuICAgIF9lYXNlSW5PdXRGcm9tT3V0ID0gZnVuY3Rpb24gX2Vhc2VJbk91dEZyb21PdXQoZWFzZU91dCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcCA8IC41ID8gKDEgLSBlYXNlT3V0KDEgLSBwICogMikpIC8gMiA6IC41ICsgZWFzZU91dCgocCAtIC41KSAqIDIpIC8gMjtcbiAgfTtcbn0sXG4gICAgX2NvbmZpZ0VsYXN0aWMgPSBmdW5jdGlvbiBfY29uZmlnRWxhc3RpYyh0eXBlLCBhbXBsaXR1ZGUsIHBlcmlvZCkge1xuICB2YXIgcDEgPSBhbXBsaXR1ZGUgPj0gMSA/IGFtcGxpdHVkZSA6IDEsXG4gICAgICAvL25vdGU6IGlmIGFtcGxpdHVkZSBpcyA8IDEsIHdlIHNpbXBseSBhZGp1c3QgdGhlIHBlcmlvZCBmb3IgYSBtb3JlIG5hdHVyYWwgZmVlbC4gT3RoZXJ3aXNlIHRoZSBtYXRoIGRvZXNuJ3Qgd29yayByaWdodCBhbmQgdGhlIGN1cnZlIHN0YXJ0cyBhdCAxLlxuICBwMiA9IChwZXJpb2QgfHwgKHR5cGUgPyAuMyA6IC40NSkpIC8gKGFtcGxpdHVkZSA8IDEgPyBhbXBsaXR1ZGUgOiAxKSxcbiAgICAgIHAzID0gcDIgLyBfMlBJICogKE1hdGguYXNpbigxIC8gcDEpIHx8IDApLFxuICAgICAgZWFzZU91dCA9IGZ1bmN0aW9uIGVhc2VPdXQocCkge1xuICAgIHJldHVybiBwID09PSAxID8gMSA6IHAxICogTWF0aC5wb3coMiwgLTEwICogcCkgKiBfc2luKChwIC0gcDMpICogcDIpICsgMTtcbiAgfSxcbiAgICAgIGVhc2UgPSB0eXBlID09PSBcIm91dFwiID8gZWFzZU91dCA6IHR5cGUgPT09IFwiaW5cIiA/IGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIDEgLSBlYXNlT3V0KDEgLSBwKTtcbiAgfSA6IF9lYXNlSW5PdXRGcm9tT3V0KGVhc2VPdXQpO1xuXG4gIHAyID0gXzJQSSAvIHAyOyAvL3ByZWNhbGN1bGF0ZSB0byBvcHRpbWl6ZVxuXG4gIGVhc2UuY29uZmlnID0gZnVuY3Rpb24gKGFtcGxpdHVkZSwgcGVyaW9kKSB7XG4gICAgcmV0dXJuIF9jb25maWdFbGFzdGljKHR5cGUsIGFtcGxpdHVkZSwgcGVyaW9kKTtcbiAgfTtcblxuICByZXR1cm4gZWFzZTtcbn0sXG4gICAgX2NvbmZpZ0JhY2sgPSBmdW5jdGlvbiBfY29uZmlnQmFjayh0eXBlLCBvdmVyc2hvb3QpIHtcbiAgaWYgKG92ZXJzaG9vdCA9PT0gdm9pZCAwKSB7XG4gICAgb3ZlcnNob290ID0gMS43MDE1ODtcbiAgfVxuXG4gIHZhciBlYXNlT3V0ID0gZnVuY3Rpb24gZWFzZU91dChwKSB7XG4gICAgcmV0dXJuIHAgPyAtLXAgKiBwICogKChvdmVyc2hvb3QgKyAxKSAqIHAgKyBvdmVyc2hvb3QpICsgMSA6IDA7XG4gIH0sXG4gICAgICBlYXNlID0gdHlwZSA9PT0gXCJvdXRcIiA/IGVhc2VPdXQgOiB0eXBlID09PSBcImluXCIgPyBmdW5jdGlvbiAocCkge1xuICAgIHJldHVybiAxIC0gZWFzZU91dCgxIC0gcCk7XG4gIH0gOiBfZWFzZUluT3V0RnJvbU91dChlYXNlT3V0KTtcblxuICBlYXNlLmNvbmZpZyA9IGZ1bmN0aW9uIChvdmVyc2hvb3QpIHtcbiAgICByZXR1cm4gX2NvbmZpZ0JhY2sodHlwZSwgb3ZlcnNob290KTtcbiAgfTtcblxuICByZXR1cm4gZWFzZTtcbn07IC8vIGEgY2hlYXBlciAoa2IgYW5kIGNwdSkgYnV0IG1vcmUgbWlsZCB3YXkgdG8gZ2V0IGEgcGFyYW1ldGVyaXplZCB3ZWlnaHRlZCBlYXNlIGJ5IGZlZWRpbmcgaW4gYSB2YWx1ZSBiZXR3ZWVuIC0xIChlYXNlSW4pIGFuZCAxIChlYXNlT3V0KSB3aGVyZSAwIGlzIGxpbmVhci5cbi8vIF93ZWlnaHRlZEVhc2UgPSByYXRpbyA9PiB7XG4vLyBcdGxldCB5ID0gMC41ICsgcmF0aW8gLyAyO1xuLy8gXHRyZXR1cm4gcCA9PiAoMiAqICgxIC0gcCkgKiBwICogeSArIHAgKiBwKTtcbi8vIH0sXG4vLyBhIHN0cm9uZ2VyIChidXQgbW9yZSBleHBlbnNpdmUga2IvY3B1KSBwYXJhbWV0ZXJpemVkIHdlaWdodGVkIGVhc2UgdGhhdCBsZXRzIHlvdSBmZWVkIGluIGEgdmFsdWUgYmV0d2VlbiAtMSAoZWFzZUluKSBhbmQgMSAoZWFzZU91dCkgd2hlcmUgMCBpcyBsaW5lYXIuXG4vLyBfd2VpZ2h0ZWRFYXNlU3Ryb25nID0gcmF0aW8gPT4ge1xuLy8gXHRyYXRpbyA9IC41ICsgcmF0aW8gLyAyO1xuLy8gXHRsZXQgbyA9IDEgLyAzICogKHJhdGlvIDwgLjUgPyByYXRpbyA6IDEgLSByYXRpbyksXG4vLyBcdFx0YiA9IHJhdGlvIC0gbyxcbi8vIFx0XHRjID0gcmF0aW8gKyBvO1xuLy8gXHRyZXR1cm4gcCA9PiBwID09PSAxID8gcCA6IDMgKiBiICogKDEgLSBwKSAqICgxIC0gcCkgKiBwICsgMyAqIGMgKiAoMSAtIHApICogcCAqIHAgKyBwICogcCAqIHA7XG4vLyB9O1xuXG5cbl9mb3JFYWNoTmFtZShcIkxpbmVhcixRdWFkLEN1YmljLFF1YXJ0LFF1aW50LFN0cm9uZ1wiLCBmdW5jdGlvbiAobmFtZSwgaSkge1xuICB2YXIgcG93ZXIgPSBpIDwgNSA/IGkgKyAxIDogaTtcblxuICBfaW5zZXJ0RWFzZShuYW1lICsgXCIsUG93ZXJcIiArIChwb3dlciAtIDEpLCBpID8gZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gTWF0aC5wb3cocCwgcG93ZXIpO1xuICB9IDogZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gcDtcbiAgfSwgZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gMSAtIE1hdGgucG93KDEgLSBwLCBwb3dlcik7XG4gIH0sIGZ1bmN0aW9uIChwKSB7XG4gICAgcmV0dXJuIHAgPCAuNSA/IE1hdGgucG93KHAgKiAyLCBwb3dlcikgLyAyIDogMSAtIE1hdGgucG93KCgxIC0gcCkgKiAyLCBwb3dlcikgLyAyO1xuICB9KTtcbn0pO1xuXG5fZWFzZU1hcC5MaW5lYXIuZWFzZU5vbmUgPSBfZWFzZU1hcC5ub25lID0gX2Vhc2VNYXAuTGluZWFyLmVhc2VJbjtcblxuX2luc2VydEVhc2UoXCJFbGFzdGljXCIsIF9jb25maWdFbGFzdGljKFwiaW5cIiksIF9jb25maWdFbGFzdGljKFwib3V0XCIpLCBfY29uZmlnRWxhc3RpYygpKTtcblxuKGZ1bmN0aW9uIChuLCBjKSB7XG4gIHZhciBuMSA9IDEgLyBjLFxuICAgICAgbjIgPSAyICogbjEsXG4gICAgICBuMyA9IDIuNSAqIG4xLFxuICAgICAgZWFzZU91dCA9IGZ1bmN0aW9uIGVhc2VPdXQocCkge1xuICAgIHJldHVybiBwIDwgbjEgPyBuICogcCAqIHAgOiBwIDwgbjIgPyBuICogTWF0aC5wb3cocCAtIDEuNSAvIGMsIDIpICsgLjc1IDogcCA8IG4zID8gbiAqIChwIC09IDIuMjUgLyBjKSAqIHAgKyAuOTM3NSA6IG4gKiBNYXRoLnBvdyhwIC0gMi42MjUgLyBjLCAyKSArIC45ODQzNzU7XG4gIH07XG5cbiAgX2luc2VydEVhc2UoXCJCb3VuY2VcIiwgZnVuY3Rpb24gKHApIHtcbiAgICByZXR1cm4gMSAtIGVhc2VPdXQoMSAtIHApO1xuICB9LCBlYXNlT3V0KTtcbn0pKDcuNTYyNSwgMi43NSk7XG5cbl9pbnNlcnRFYXNlKFwiRXhwb1wiLCBmdW5jdGlvbiAocCkge1xuICByZXR1cm4gcCA/IE1hdGgucG93KDIsIDEwICogKHAgLSAxKSkgOiAwO1xufSk7XG5cbl9pbnNlcnRFYXNlKFwiQ2lyY1wiLCBmdW5jdGlvbiAocCkge1xuICByZXR1cm4gLShfc3FydCgxIC0gcCAqIHApIC0gMSk7XG59KTtcblxuX2luc2VydEVhc2UoXCJTaW5lXCIsIGZ1bmN0aW9uIChwKSB7XG4gIHJldHVybiBwID09PSAxID8gMSA6IC1fY29zKHAgKiBfSEFMRl9QSSkgKyAxO1xufSk7XG5cbl9pbnNlcnRFYXNlKFwiQmFja1wiLCBfY29uZmlnQmFjayhcImluXCIpLCBfY29uZmlnQmFjayhcIm91dFwiKSwgX2NvbmZpZ0JhY2soKSk7XG5cbl9lYXNlTWFwLlN0ZXBwZWRFYXNlID0gX2Vhc2VNYXAuc3RlcHMgPSBfZ2xvYmFscy5TdGVwcGVkRWFzZSA9IHtcbiAgY29uZmlnOiBmdW5jdGlvbiBjb25maWcoc3RlcHMsIGltbWVkaWF0ZVN0YXJ0KSB7XG4gICAgaWYgKHN0ZXBzID09PSB2b2lkIDApIHtcbiAgICAgIHN0ZXBzID0gMTtcbiAgICB9XG5cbiAgICB2YXIgcDEgPSAxIC8gc3RlcHMsXG4gICAgICAgIHAyID0gc3RlcHMgKyAoaW1tZWRpYXRlU3RhcnQgPyAwIDogMSksXG4gICAgICAgIHAzID0gaW1tZWRpYXRlU3RhcnQgPyAxIDogMCxcbiAgICAgICAgbWF4ID0gMSAtIF90aW55TnVtO1xuICAgIHJldHVybiBmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuICgocDIgKiBfY2xhbXAoMCwgbWF4LCBwKSB8IDApICsgcDMpICogcDE7XG4gICAgfTtcbiAgfVxufTtcbl9kZWZhdWx0cy5lYXNlID0gX2Vhc2VNYXBbXCJxdWFkLm91dFwiXTtcblxuX2ZvckVhY2hOYW1lKFwib25Db21wbGV0ZSxvblVwZGF0ZSxvblN0YXJ0LG9uUmVwZWF0LG9uUmV2ZXJzZUNvbXBsZXRlLG9uSW50ZXJydXB0XCIsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBfY2FsbGJhY2tOYW1lcyArPSBuYW1lICsgXCIsXCIgKyBuYW1lICsgXCJQYXJhbXMsXCI7XG59KTtcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ0FDSEVcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuXG5leHBvcnQgdmFyIEdTQ2FjaGUgPSBmdW5jdGlvbiBHU0NhY2hlKHRhcmdldCwgaGFybmVzcykge1xuICB0aGlzLmlkID0gX2dzSUQrKztcbiAgdGFyZ2V0Ll9nc2FwID0gdGhpcztcbiAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gIHRoaXMuaGFybmVzcyA9IGhhcm5lc3M7XG4gIHRoaXMuZ2V0ID0gaGFybmVzcyA/IGhhcm5lc3MuZ2V0IDogX2dldFByb3BlcnR5O1xuICB0aGlzLnNldCA9IGhhcm5lc3MgPyBoYXJuZXNzLmdldFNldHRlciA6IF9nZXRTZXR0ZXI7XG59O1xuLypcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBBTklNQVRJT05cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuZXhwb3J0IHZhciBBbmltYXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBbmltYXRpb24odmFycykge1xuICAgIHRoaXMudmFycyA9IHZhcnM7XG4gICAgdGhpcy5fZGVsYXkgPSArdmFycy5kZWxheSB8fCAwO1xuXG4gICAgaWYgKHRoaXMuX3JlcGVhdCA9IHZhcnMucmVwZWF0ID09PSBJbmZpbml0eSA/IC0yIDogdmFycy5yZXBlYXQgfHwgMCkge1xuICAgICAgLy8gVE9ETzogcmVwZWF0OiBJbmZpbml0eSBvbiBhIHRpbWVsaW5lJ3MgY2hpbGRyZW4gbXVzdCBmbGFnIHRoYXQgdGltZWxpbmUgaW50ZXJuYWxseSBhbmQgYWZmZWN0IGl0cyB0b3RhbER1cmF0aW9uLCBvdGhlcndpc2UgaXQnbGwgc3RvcCBpbiB0aGUgbmVnYXRpdmUgZGlyZWN0aW9uIHdoZW4gcmVhY2hpbmcgdGhlIHN0YXJ0LlxuICAgICAgdGhpcy5fckRlbGF5ID0gdmFycy5yZXBlYXREZWxheSB8fCAwO1xuICAgICAgdGhpcy5feW95byA9ICEhdmFycy55b3lvIHx8ICEhdmFycy55b3lvRWFzZTtcbiAgICB9XG5cbiAgICB0aGlzLl90cyA9IDE7XG5cbiAgICBfc2V0RHVyYXRpb24odGhpcywgK3ZhcnMuZHVyYXRpb24sIDEsIDEpO1xuXG4gICAgdGhpcy5kYXRhID0gdmFycy5kYXRhO1xuICAgIF90aWNrZXJBY3RpdmUgfHwgX3RpY2tlci53YWtlKCk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQW5pbWF0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVsYXkgPSBmdW5jdGlvbiBkZWxheSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSB8fCB2YWx1ZSA9PT0gMCkge1xuICAgICAgdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuc21vb3RoQ2hpbGRUaW1pbmcgJiYgdGhpcy5zdGFydFRpbWUodGhpcy5fc3RhcnQgKyB2YWx1ZSAtIHRoaXMuX2RlbGF5KTtcbiAgICAgIHRoaXMuX2RlbGF5ID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fZGVsYXk7XG4gIH07XG5cbiAgX3Byb3RvLmR1cmF0aW9uID0gZnVuY3Rpb24gZHVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudG90YWxEdXJhdGlvbih0aGlzLl9yZXBlYXQgPiAwID8gdmFsdWUgKyAodmFsdWUgKyB0aGlzLl9yRGVsYXkpICogdGhpcy5fcmVwZWF0IDogdmFsdWUpIDogdGhpcy50b3RhbER1cmF0aW9uKCkgJiYgdGhpcy5fZHVyO1xuICB9O1xuXG4gIF9wcm90by50b3RhbER1cmF0aW9uID0gZnVuY3Rpb24gdG90YWxEdXJhdGlvbih2YWx1ZSkge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3REdXI7XG4gICAgfVxuXG4gICAgdGhpcy5fZGlydHkgPSAwO1xuICAgIHJldHVybiBfc2V0RHVyYXRpb24odGhpcywgdGhpcy5fcmVwZWF0IDwgMCA/IHZhbHVlIDogKHZhbHVlIC0gdGhpcy5fcmVwZWF0ICogdGhpcy5fckRlbGF5KSAvICh0aGlzLl9yZXBlYXQgKyAxKSk7XG4gIH07XG5cbiAgX3Byb3RvLnRvdGFsVGltZSA9IGZ1bmN0aW9uIHRvdGFsVGltZShfdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIF93YWtlKCk7XG5cbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90VGltZTtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50ID0gdGhpcy5fZHA7XG5cbiAgICBpZiAocGFyZW50ICYmIHBhcmVudC5zbW9vdGhDaGlsZFRpbWluZyAmJiB0aGlzLl90cykge1xuICAgICAgX2FsaWduUGxheWhlYWQodGhpcywgX3RvdGFsVGltZSk7XG5cbiAgICAgICFwYXJlbnQuX2RwIHx8IHBhcmVudC5wYXJlbnQgfHwgX3Bvc3RBZGRDaGVja3MocGFyZW50LCB0aGlzKTsgLy8gZWRnZSBjYXNlOiBpZiB0aGlzIGlzIGEgY2hpbGQgb2YgYSB0aW1lbGluZSB0aGF0IGFscmVhZHkgY29tcGxldGVkLCBmb3IgZXhhbXBsZSwgd2UgbXVzdCByZS1hY3RpdmF0ZSB0aGUgcGFyZW50LlxuICAgICAgLy9pbiBjYXNlIGFueSBvZiB0aGUgYW5jZXN0b3IgdGltZWxpbmVzIGhhZCBjb21wbGV0ZWQgYnV0IHNob3VsZCBub3cgYmUgZW5hYmxlZCwgd2Ugc2hvdWxkIHJlc2V0IHRoZWlyIHRvdGFsVGltZSgpIHdoaWNoIHdpbGwgYWxzbyBlbnN1cmUgdGhhdCB0aGV5J3JlIGxpbmVkIHVwIHByb3Blcmx5IGFuZCBlbmFibGVkLiBTa2lwIGZvciBhbmltYXRpb25zIHRoYXQgYXJlIG9uIHRoZSByb290ICh3YXN0ZWZ1bCkuIEV4YW1wbGU6IGEgVGltZWxpbmVMaXRlLmV4cG9ydFJvb3QoKSBpcyBwZXJmb3JtZWQgd2hlbiB0aGVyZSdzIGEgcGF1c2VkIHR3ZWVuIG9uIHRoZSByb290LCB0aGUgZXhwb3J0IHdpbGwgbm90IGNvbXBsZXRlIHVudGlsIHRoYXQgdHdlZW4gaXMgdW5wYXVzZWQsIGJ1dCBpbWFnaW5lIGEgY2hpbGQgZ2V0cyByZXN0YXJ0ZWQgbGF0ZXIsIGFmdGVyIGFsbCBbdW5wYXVzZWRdIHR3ZWVucyBoYXZlIGNvbXBsZXRlZC4gVGhlIHN0YXJ0IG9mIHRoYXQgY2hpbGQgd291bGQgZ2V0IHB1c2hlZCBvdXQsIGJ1dCBvbmUgb2YgdGhlIGFuY2VzdG9ycyBtYXkgaGF2ZSBjb21wbGV0ZWQuXG5cbiAgICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50LnBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50LnBhcmVudC5fdGltZSAhPT0gcGFyZW50Ll9zdGFydCArIChwYXJlbnQuX3RzID49IDAgPyBwYXJlbnQuX3RUaW1lIC8gcGFyZW50Ll90cyA6IChwYXJlbnQudG90YWxEdXJhdGlvbigpIC0gcGFyZW50Ll90VGltZSkgLyAtcGFyZW50Ll90cykpIHtcbiAgICAgICAgICBwYXJlbnQudG90YWxUaW1lKHBhcmVudC5fdFRpbWUsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnBhcmVudCAmJiB0aGlzLl9kcC5hdXRvUmVtb3ZlQ2hpbGRyZW4gJiYgKHRoaXMuX3RzID4gMCAmJiBfdG90YWxUaW1lIDwgdGhpcy5fdER1ciB8fCB0aGlzLl90cyA8IDAgJiYgX3RvdGFsVGltZSA+IDAgfHwgIXRoaXMuX3REdXIgJiYgIV90b3RhbFRpbWUpKSB7XG4gICAgICAgIC8vaWYgdGhlIGFuaW1hdGlvbiBkb2Vzbid0IGhhdmUgYSBwYXJlbnQsIHB1dCBpdCBiYWNrIGludG8gaXRzIGxhc3QgcGFyZW50IChyZWNvcmRlZCBhcyBfZHAgZm9yIGV4YWN0bHkgY2FzZXMgbGlrZSB0aGlzKS4gTGltaXQgdG8gcGFyZW50cyB3aXRoIGF1dG9SZW1vdmVDaGlsZHJlbiAobGlrZSBnbG9iYWxUaW1lbGluZSkgc28gdGhhdCBpZiB0aGUgdXNlciBtYW51YWxseSByZW1vdmVzIGFuIGFuaW1hdGlvbiBmcm9tIGEgdGltZWxpbmUgYW5kIHRoZW4gYWx0ZXJzIGl0cyBwbGF5aGVhZCwgaXQgZG9lc24ndCBnZXQgYWRkZWQgYmFjayBpbi5cbiAgICAgICAgX2FkZFRvVGltZWxpbmUodGhpcy5fZHAsIHRoaXMsIHRoaXMuX3N0YXJ0IC0gdGhpcy5fZGVsYXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl90VGltZSAhPT0gX3RvdGFsVGltZSB8fCAhdGhpcy5fZHVyICYmICFzdXBwcmVzc0V2ZW50cyB8fCB0aGlzLl9pbml0dGVkICYmIE1hdGguYWJzKHRoaXMuX3pUaW1lKSA9PT0gX3RpbnlOdW0gfHwgIV90b3RhbFRpbWUgJiYgIXRoaXMuX2luaXR0ZWQgJiYgKHRoaXMuYWRkIHx8IHRoaXMuX3B0TG9va3VwKSkge1xuICAgICAgLy8gY2hlY2sgZm9yIF9wdExvb2t1cCBvbiBhIFR3ZWVuIGluc3RhbmNlIHRvIGVuc3VyZSBpdCBoYXMgYWN0dWFsbHkgZmluaXNoZWQgYmVpbmcgaW5zdGFudGlhdGVkLCBvdGhlcndpc2UgaWYgdGhpcy5yZXZlcnNlKCkgZ2V0cyBjYWxsZWQgaW4gdGhlIEFuaW1hdGlvbiBjb25zdHJ1Y3RvciwgaXQgY291bGQgdHJpZ2dlciBhIHJlbmRlcigpIGhlcmUgZXZlbiB0aG91Z2ggdGhlIF90YXJnZXRzIHdlcmVuJ3QgcG9wdWxhdGVkLCB0aHVzIHdoZW4gX2luaXQoKSBpcyBjYWxsZWQgdGhlcmUgd29uJ3QgYmUgYW55IFByb3BUd2VlbnMgKGl0J2xsIGFjdCBsaWtlIHRoZSB0d2VlbiBpcyBub24tZnVuY3Rpb25hbClcbiAgICAgIHRoaXMuX3RzIHx8ICh0aGlzLl9wVGltZSA9IF90b3RhbFRpbWUpOyAvLyBvdGhlcndpc2UsIGlmIGFuIGFuaW1hdGlvbiBpcyBwYXVzZWQsIHRoZW4gdGhlIHBsYXloZWFkIGlzIG1vdmVkIGJhY2sgdG8gemVybywgdGhlbiByZXN1bWVkLCBpdCdkIHJldmVydCBiYWNrIHRvIHRoZSBvcmlnaW5hbCB0aW1lIGF0IHRoZSBwYXVzZVxuICAgICAgLy9pZiAoIXRoaXMuX2xvY2spIHsgLy8gYXZvaWQgZW5kbGVzcyByZWN1cnNpb24gKG5vdCBzdXJlIHdlIG5lZWQgdGhpcyB5ZXQgb3IgaWYgaXQncyB3b3J0aCB0aGUgcGVyZm9ybWFuY2UgaGl0KVxuICAgICAgLy8gICB0aGlzLl9sb2NrID0gMTtcblxuICAgICAgX2xhenlTYWZlUmVuZGVyKHRoaXMsIF90b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzKTsgLy8gICB0aGlzLl9sb2NrID0gMDtcbiAgICAgIC8vfVxuXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnRpbWUgPSBmdW5jdGlvbiB0aW1lKHZhbHVlLCBzdXBwcmVzc0V2ZW50cykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50b3RhbFRpbWUoTWF0aC5taW4odGhpcy50b3RhbER1cmF0aW9uKCksIHZhbHVlICsgX2VsYXBzZWRDeWNsZUR1cmF0aW9uKHRoaXMpKSAlICh0aGlzLl9kdXIgKyB0aGlzLl9yRGVsYXkpIHx8ICh2YWx1ZSA/IHRoaXMuX2R1ciA6IDApLCBzdXBwcmVzc0V2ZW50cykgOiB0aGlzLl90aW1lOyAvLyBub3RlOiBpZiB0aGUgbW9kdWx1cyByZXN1bHRzIGluIDAsIHRoZSBwbGF5aGVhZCBjb3VsZCBiZSBleGFjdGx5IGF0IHRoZSBlbmQgb3IgdGhlIGJlZ2lubmluZywgYW5kIHdlIGFsd2F5cyBkZWZlciB0byB0aGUgRU5EIHdpdGggYSBub24temVybyB2YWx1ZSwgb3RoZXJ3aXNlIGlmIHlvdSBzZXQgdGhlIHRpbWUoKSB0byB0aGUgdmVyeSBlbmQgKGR1cmF0aW9uKCkpLCBpdCB3b3VsZCByZW5kZXIgYXQgdGhlIFNUQVJUIVxuICB9O1xuXG4gIF9wcm90by50b3RhbFByb2dyZXNzID0gZnVuY3Rpb24gdG90YWxQcm9ncmVzcyh2YWx1ZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudG90YWxUaW1lKHRoaXMudG90YWxEdXJhdGlvbigpICogdmFsdWUsIHN1cHByZXNzRXZlbnRzKSA6IHRoaXMudG90YWxEdXJhdGlvbigpID8gTWF0aC5taW4oMSwgdGhpcy5fdFRpbWUgLyB0aGlzLl90RHVyKSA6IHRoaXMucmF0aW87XG4gIH07XG5cbiAgX3Byb3RvLnByb2dyZXNzID0gZnVuY3Rpb24gcHJvZ3Jlc3ModmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnRvdGFsVGltZSh0aGlzLmR1cmF0aW9uKCkgKiAodGhpcy5feW95byAmJiAhKHRoaXMuaXRlcmF0aW9uKCkgJiAxKSA/IDEgLSB2YWx1ZSA6IHZhbHVlKSArIF9lbGFwc2VkQ3ljbGVEdXJhdGlvbih0aGlzKSwgc3VwcHJlc3NFdmVudHMpIDogdGhpcy5kdXJhdGlvbigpID8gTWF0aC5taW4oMSwgdGhpcy5fdGltZSAvIHRoaXMuX2R1cikgOiB0aGlzLnJhdGlvO1xuICB9O1xuXG4gIF9wcm90by5pdGVyYXRpb24gPSBmdW5jdGlvbiBpdGVyYXRpb24odmFsdWUsIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgdmFyIGN5Y2xlRHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uKCkgKyB0aGlzLl9yRGVsYXk7XG5cbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudG90YWxUaW1lKHRoaXMuX3RpbWUgKyAodmFsdWUgLSAxKSAqIGN5Y2xlRHVyYXRpb24sIHN1cHByZXNzRXZlbnRzKSA6IHRoaXMuX3JlcGVhdCA/IF9hbmltYXRpb25DeWNsZSh0aGlzLl90VGltZSwgY3ljbGVEdXJhdGlvbikgKyAxIDogMTtcbiAgfSAvLyBwb3RlbnRpYWwgZnV0dXJlIGFkZGl0aW9uOlxuICAvLyBpc1BsYXlpbmdCYWNrd2FyZHMoKSB7XG4gIC8vIFx0bGV0IGFuaW1hdGlvbiA9IHRoaXMsXG4gIC8vIFx0XHRvcmllbnRhdGlvbiA9IDE7IC8vIDEgPSBmb3J3YXJkLCAtMSA9IGJhY2t3YXJkXG4gIC8vIFx0d2hpbGUgKGFuaW1hdGlvbikge1xuICAvLyBcdFx0b3JpZW50YXRpb24gKj0gYW5pbWF0aW9uLnJldmVyc2VkKCkgfHwgKGFuaW1hdGlvbi5yZXBlYXQoKSAmJiAhKGFuaW1hdGlvbi5pdGVyYXRpb24oKSAmIDEpKSA/IC0xIDogMTtcbiAgLy8gXHRcdGFuaW1hdGlvbiA9IGFuaW1hdGlvbi5wYXJlbnQ7XG4gIC8vIFx0fVxuICAvLyBcdHJldHVybiBvcmllbnRhdGlvbiA8IDA7XG4gIC8vIH1cbiAgO1xuXG4gIF9wcm90by50aW1lU2NhbGUgPSBmdW5jdGlvbiB0aW1lU2NhbGUodmFsdWUpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ydHMgPT09IC1fdGlueU51bSA/IDAgOiB0aGlzLl9ydHM7IC8vIHJlY29yZGVkIHRpbWVTY2FsZS4gU3BlY2lhbCBjYXNlOiBpZiBzb21lb25lIGNhbGxzIHJldmVyc2UoKSBvbiBhbiBhbmltYXRpb24gd2l0aCB0aW1lU2NhbGUgb2YgMCwgd2UgYXNzaWduIGl0IC1fdGlueU51bSB0byByZW1lbWJlciBpdCdzIHJldmVyc2VkLlxuICAgIH1cblxuICAgIGlmICh0aGlzLl9ydHMgPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgdFRpbWUgPSB0aGlzLnBhcmVudCAmJiB0aGlzLl90cyA/IF9wYXJlbnRUb0NoaWxkVG90YWxUaW1lKHRoaXMucGFyZW50Ll90aW1lLCB0aGlzKSA6IHRoaXMuX3RUaW1lOyAvLyBtYWtlIHN1cmUgdG8gZG8gdGhlIHBhcmVudFRvQ2hpbGRUb3RhbFRpbWUoKSBCRUZPUkUgc2V0dGluZyB0aGUgbmV3IF90cyBiZWNhdXNlIHRoZSBvbGQgb25lIG11c3QgYmUgdXNlZCBpbiB0aGF0IGNhbGN1bGF0aW9uLlxuICAgIC8vIGZ1dHVyZSBhZGRpdGlvbj8gVXAgc2lkZTogZmFzdCBhbmQgbWluaW1hbCBmaWxlIHNpemUuIERvd24gc2lkZTogb25seSB3b3JrcyBvbiB0aGlzIGFuaW1hdGlvbjsgaWYgYSB0aW1lbGluZSBpcyByZXZlcnNlZCwgZm9yIGV4YW1wbGUsIGl0cyBjaGlsZHJlbnMnIG9uUmV2ZXJzZSB3b3VsZG4ndCBnZXQgY2FsbGVkLlxuICAgIC8vKCt2YWx1ZSA8IDAgJiYgdGhpcy5fcnRzID49IDApICYmIF9jYWxsYmFjayh0aGlzLCBcIm9uUmV2ZXJzZVwiLCB0cnVlKTtcbiAgICAvLyBwcmlvcml0aXplIHJlbmRlcmluZyB3aGVyZSB0aGUgcGFyZW50J3MgcGxheWhlYWQgbGluZXMgdXAgaW5zdGVhZCBvZiB0aGlzLl90VGltZSBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIGEgdHdlZW4gdGhhdCdzIGFuaW1hdGluZyBhbm90aGVyIHR3ZWVuJ3MgdGltZVNjYWxlIGluIHRoZSBzYW1lIHJlbmRlcmluZyBsb29wIChzYW1lIHBhcmVudCksIHRodXMgaWYgdGhlIHRpbWVTY2FsZSB0d2VlbiByZW5kZXJzIGZpcnN0LCBpdCB3b3VsZCBhbHRlciBfc3RhcnQgQkVGT1JFIF90VGltZSB3YXMgc2V0IG9uIHRoYXQgdGljayAoaW4gdGhlIHJlbmRlcmluZyBsb29wKSwgZWZmZWN0aXZlbHkgZnJlZXppbmcgaXQgdW50aWwgdGhlIHRpbWVTY2FsZSB0d2VlbiBmaW5pc2hlcy5cblxuICAgIHRoaXMuX3J0cyA9ICt2YWx1ZSB8fCAwO1xuICAgIHRoaXMuX3RzID0gdGhpcy5fcHMgfHwgdmFsdWUgPT09IC1fdGlueU51bSA/IDAgOiB0aGlzLl9ydHM7IC8vIF90cyBpcyB0aGUgZnVuY3Rpb25hbCB0aW1lU2NhbGUgd2hpY2ggd291bGQgYmUgMCBpZiB0aGUgYW5pbWF0aW9uIGlzIHBhdXNlZC5cblxuICAgIF9yZWNhY2hlQW5jZXN0b3JzKHRoaXMudG90YWxUaW1lKF9jbGFtcCgtdGhpcy5fZGVsYXksIHRoaXMuX3REdXIsIHRUaW1lKSwgdHJ1ZSkpO1xuXG4gICAgX3NldEVuZCh0aGlzKTsgLy8gaWYgcGFyZW50LnNtb290aENoaWxkVGltaW5nIHdhcyBmYWxzZSwgdGhlIGVuZCB0aW1lIGRpZG4ndCBnZXQgdXBkYXRlZCBpbiB0aGUgX2FsaWduUGxheWhlYWQoKSBtZXRob2QsIHNvIGRvIGl0IGhlcmUuXG5cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5wYXVzZWQgPSBmdW5jdGlvbiBwYXVzZWQodmFsdWUpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcHMgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLl9wcyA9IHZhbHVlO1xuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fcFRpbWUgPSB0aGlzLl90VGltZSB8fCBNYXRoLm1heCgtdGhpcy5fZGVsYXksIHRoaXMucmF3VGltZSgpKTsgLy8gaWYgdGhlIHBhdXNlIG9jY3VycyBkdXJpbmcgdGhlIGRlbGF5IHBoYXNlLCBtYWtlIHN1cmUgdGhhdCdzIGZhY3RvcmVkIGluIHdoZW4gcmVzdW1pbmcuXG5cbiAgICAgICAgdGhpcy5fdHMgPSB0aGlzLl9hY3QgPSAwOyAvLyBfdHMgaXMgdGhlIGZ1bmN0aW9uYWwgdGltZVNjYWxlLCBzbyBhIHBhdXNlZCB0d2VlbiB3b3VsZCBlZmZlY3RpdmVseSBoYXZlIGEgdGltZVNjYWxlIG9mIDAuIFdlIHJlY29yZCB0aGUgXCJyZWFsXCIgdGltZVNjYWxlIGFzIF9ydHMgKHJlY29yZGVkIHRpbWUgc2NhbGUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfd2FrZSgpO1xuXG4gICAgICAgIHRoaXMuX3RzID0gdGhpcy5fcnRzOyAvL29ubHkgZGVmZXIgdG8gX3BUaW1lIChwYXVzZVRpbWUpIGlmIHRUaW1lIGlzIHplcm8uIFJlbWVtYmVyLCBzb21lb25lIGNvdWxkIHBhdXNlKCkgYW4gYW5pbWF0aW9uLCB0aGVuIHNjcnViIHRoZSBwbGF5aGVhZCBhbmQgcmVzdW1lKCkuIElmIHRoZSBwYXJlbnQgZG9lc24ndCBoYXZlIHNtb290aENoaWxkVGltaW5nLCB3ZSByZW5kZXIgYXQgdGhlIHJhd1RpbWUoKSBiZWNhdXNlIHRoZSBzdGFydFRpbWUgd29uJ3QgZ2V0IHVwZGF0ZWQuXG5cbiAgICAgICAgdGhpcy50b3RhbFRpbWUodGhpcy5wYXJlbnQgJiYgIXRoaXMucGFyZW50LnNtb290aENoaWxkVGltaW5nID8gdGhpcy5yYXdUaW1lKCkgOiB0aGlzLl90VGltZSB8fCB0aGlzLl9wVGltZSwgdGhpcy5wcm9ncmVzcygpID09PSAxICYmIE1hdGguYWJzKHRoaXMuX3pUaW1lKSAhPT0gX3RpbnlOdW0gJiYgKHRoaXMuX3RUaW1lIC09IF90aW55TnVtKSk7IC8vIGVkZ2UgY2FzZTogYW5pbWF0aW9uLnByb2dyZXNzKDEpLnBhdXNlKCkucGxheSgpIHdvdWxkbid0IHJlbmRlciBhZ2FpbiBiZWNhdXNlIHRoZSBwbGF5aGVhZCBpcyBhbHJlYWR5IGF0IHRoZSBlbmQsIGJ1dCB0aGUgY2FsbCB0byB0b3RhbFRpbWUoKSBiZWxvdyB3aWxsIGFkZCBpdCBiYWNrIHRvIGl0cyBwYXJlbnQuLi5hbmQgbm90IHJlbW92ZSBpdCBhZ2FpbiAoc2luY2UgcmVtb3Zpbmcgb25seSBoYXBwZW5zIHVwb24gcmVuZGVyaW5nIGF0IGEgbmV3IHRpbWUpLiBPZmZzZXR0aW5nIHRoZSBfdFRpbWUgc2xpZ2h0bHkgaXMgZG9uZSBzaW1wbHkgdG8gY2F1c2UgdGhlIGZpbmFsIHJlbmRlciBpbiB0b3RhbFRpbWUoKSB0aGF0J2xsIHBvcCBpdCBvZmYgaXRzIHRpbWVsaW5lIChpZiBhdXRvUmVtb3ZlQ2hpbGRyZW4gaXMgdHJ1ZSwgb2YgY291cnNlKS4gQ2hlY2sgdG8gbWFrZSBzdXJlIF96VGltZSBpc24ndCAtX3RpbnlOdW0gdG8gYXZvaWQgYW4gZWRnZSBjYXNlIHdoZXJlIHRoZSBwbGF5aGVhZCBpcyBwdXNoZWQgdG8gdGhlIGVuZCBidXQgSU5TSURFIGEgdHdlZW4vY2FsbGJhY2ssIHRoZSB0aW1lbGluZSBpdHNlbGYgaXMgcGF1c2VkIHRodXMgaGFsdGluZyByZW5kZXJpbmcgYW5kIGxlYXZpbmcgYSBmZXcgdW5yZW5kZXJlZC4gV2hlbiByZXN1bWluZywgaXQgd291bGRuJ3QgcmVuZGVyIHRob3NlIG90aGVyd2lzZS5cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uc3RhcnRUaW1lID0gZnVuY3Rpb24gc3RhcnRUaW1lKHZhbHVlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3N0YXJ0ID0gdmFsdWU7XG4gICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpcy5fZHA7XG4gICAgICBwYXJlbnQgJiYgKHBhcmVudC5fc29ydCB8fCAhdGhpcy5wYXJlbnQpICYmIF9hZGRUb1RpbWVsaW5lKHBhcmVudCwgdGhpcywgdmFsdWUgLSB0aGlzLl9kZWxheSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RhcnQ7XG4gIH07XG5cbiAgX3Byb3RvLmVuZFRpbWUgPSBmdW5jdGlvbiBlbmRUaW1lKGluY2x1ZGVSZXBlYXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0ICsgKF9pc05vdEZhbHNlKGluY2x1ZGVSZXBlYXRzKSA/IHRoaXMudG90YWxEdXJhdGlvbigpIDogdGhpcy5kdXJhdGlvbigpKSAvIE1hdGguYWJzKHRoaXMuX3RzIHx8IDEpO1xuICB9O1xuXG4gIF9wcm90by5yYXdUaW1lID0gZnVuY3Rpb24gcmF3VGltZSh3cmFwUmVwZWF0cykge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzLl9kcDsgLy8gX2RwID0gZGV0YWNoZWQgcGFyZW50XG5cbiAgICByZXR1cm4gIXBhcmVudCA/IHRoaXMuX3RUaW1lIDogd3JhcFJlcGVhdHMgJiYgKCF0aGlzLl90cyB8fCB0aGlzLl9yZXBlYXQgJiYgdGhpcy5fdGltZSAmJiB0aGlzLnRvdGFsUHJvZ3Jlc3MoKSA8IDEpID8gdGhpcy5fdFRpbWUgJSAodGhpcy5fZHVyICsgdGhpcy5fckRlbGF5KSA6ICF0aGlzLl90cyA/IHRoaXMuX3RUaW1lIDogX3BhcmVudFRvQ2hpbGRUb3RhbFRpbWUocGFyZW50LnJhd1RpbWUod3JhcFJlcGVhdHMpLCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uZ2xvYmFsVGltZSA9IGZ1bmN0aW9uIGdsb2JhbFRpbWUocmF3VGltZSkge1xuICAgIHZhciBhbmltYXRpb24gPSB0aGlzLFxuICAgICAgICB0aW1lID0gYXJndW1lbnRzLmxlbmd0aCA/IHJhd1RpbWUgOiBhbmltYXRpb24ucmF3VGltZSgpO1xuXG4gICAgd2hpbGUgKGFuaW1hdGlvbikge1xuICAgICAgdGltZSA9IGFuaW1hdGlvbi5fc3RhcnQgKyB0aW1lIC8gKGFuaW1hdGlvbi5fdHMgfHwgMSk7XG4gICAgICBhbmltYXRpb24gPSBhbmltYXRpb24uX2RwO1xuICAgIH1cblxuICAgIHJldHVybiB0aW1lO1xuICB9O1xuXG4gIF9wcm90by5yZXBlYXQgPSBmdW5jdGlvbiByZXBlYXQodmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fcmVwZWF0ID0gdmFsdWUgPT09IEluZmluaXR5ID8gLTIgOiB2YWx1ZTtcbiAgICAgIHJldHVybiBfb25VcGRhdGVUb3RhbER1cmF0aW9uKHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZXBlYXQgPT09IC0yID8gSW5maW5pdHkgOiB0aGlzLl9yZXBlYXQ7XG4gIH07XG5cbiAgX3Byb3RvLnJlcGVhdERlbGF5ID0gZnVuY3Rpb24gcmVwZWF0RGVsYXkodmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdmFyIHRpbWUgPSB0aGlzLl90aW1lO1xuICAgICAgdGhpcy5fckRlbGF5ID0gdmFsdWU7XG5cbiAgICAgIF9vblVwZGF0ZVRvdGFsRHVyYXRpb24odGhpcyk7XG5cbiAgICAgIHJldHVybiB0aW1lID8gdGhpcy50aW1lKHRpbWUpIDogdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fckRlbGF5O1xuICB9O1xuXG4gIF9wcm90by55b3lvID0gZnVuY3Rpb24geW95byh2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl95b3lvID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5feW95bztcbiAgfTtcblxuICBfcHJvdG8uc2VlayA9IGZ1bmN0aW9uIHNlZWsocG9zaXRpb24sIHN1cHByZXNzRXZlbnRzKSB7XG4gICAgcmV0dXJuIHRoaXMudG90YWxUaW1lKF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKSwgX2lzTm90RmFsc2Uoc3VwcHJlc3NFdmVudHMpKTtcbiAgfTtcblxuICBfcHJvdG8ucmVzdGFydCA9IGZ1bmN0aW9uIHJlc3RhcnQoaW5jbHVkZURlbGF5LCBzdXBwcmVzc0V2ZW50cykge1xuICAgIHJldHVybiB0aGlzLnBsYXkoKS50b3RhbFRpbWUoaW5jbHVkZURlbGF5ID8gLXRoaXMuX2RlbGF5IDogMCwgX2lzTm90RmFsc2Uoc3VwcHJlc3NFdmVudHMpKTtcbiAgfTtcblxuICBfcHJvdG8ucGxheSA9IGZ1bmN0aW9uIHBsYXkoZnJvbSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICBmcm9tICE9IG51bGwgJiYgdGhpcy5zZWVrKGZyb20sIHN1cHByZXNzRXZlbnRzKTtcbiAgICByZXR1cm4gdGhpcy5yZXZlcnNlZChmYWxzZSkucGF1c2VkKGZhbHNlKTtcbiAgfTtcblxuICBfcHJvdG8ucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UoZnJvbSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICBmcm9tICE9IG51bGwgJiYgdGhpcy5zZWVrKGZyb20gfHwgdGhpcy50b3RhbER1cmF0aW9uKCksIHN1cHByZXNzRXZlbnRzKTtcbiAgICByZXR1cm4gdGhpcy5yZXZlcnNlZCh0cnVlKS5wYXVzZWQoZmFsc2UpO1xuICB9O1xuXG4gIF9wcm90by5wYXVzZSA9IGZ1bmN0aW9uIHBhdXNlKGF0VGltZSwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICBhdFRpbWUgIT0gbnVsbCAmJiB0aGlzLnNlZWsoYXRUaW1lLCBzdXBwcmVzc0V2ZW50cyk7XG4gICAgcmV0dXJuIHRoaXMucGF1c2VkKHRydWUpO1xuICB9O1xuXG4gIF9wcm90by5yZXN1bWUgPSBmdW5jdGlvbiByZXN1bWUoKSB7XG4gICAgcmV0dXJuIHRoaXMucGF1c2VkKGZhbHNlKTtcbiAgfTtcblxuICBfcHJvdG8ucmV2ZXJzZWQgPSBmdW5jdGlvbiByZXZlcnNlZCh2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAhIXZhbHVlICE9PSB0aGlzLnJldmVyc2VkKCkgJiYgdGhpcy50aW1lU2NhbGUoLXRoaXMuX3J0cyB8fCAodmFsdWUgPyAtX3RpbnlOdW0gOiAwKSk7IC8vIGluIGNhc2UgdGltZVNjYWxlIGlzIHplcm8sIHJldmVyc2luZyB3b3VsZCBoYXZlIG5vIGVmZmVjdCBzbyB3ZSB1c2UgX3RpbnlOdW0uXG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9ydHMgPCAwO1xuICB9O1xuXG4gIF9wcm90by5pbnZhbGlkYXRlID0gZnVuY3Rpb24gaW52YWxpZGF0ZSgpIHtcbiAgICB0aGlzLl9pbml0dGVkID0gdGhpcy5fYWN0ID0gMDtcbiAgICB0aGlzLl96VGltZSA9IC1fdGlueU51bTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uaXNBY3RpdmUgPSBmdW5jdGlvbiBpc0FjdGl2ZSgpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpcy5fZHAsXG4gICAgICAgIHN0YXJ0ID0gdGhpcy5fc3RhcnQsXG4gICAgICAgIHJhd1RpbWU7XG4gICAgcmV0dXJuICEhKCFwYXJlbnQgfHwgdGhpcy5fdHMgJiYgdGhpcy5faW5pdHRlZCAmJiBwYXJlbnQuaXNBY3RpdmUoKSAmJiAocmF3VGltZSA9IHBhcmVudC5yYXdUaW1lKHRydWUpKSA+PSBzdGFydCAmJiByYXdUaW1lIDwgdGhpcy5lbmRUaW1lKHRydWUpIC0gX3RpbnlOdW0pO1xuICB9O1xuXG4gIF9wcm90by5ldmVudENhbGxiYWNrID0gZnVuY3Rpb24gZXZlbnRDYWxsYmFjayh0eXBlLCBjYWxsYmFjaywgcGFyYW1zKSB7XG4gICAgdmFyIHZhcnMgPSB0aGlzLnZhcnM7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgZGVsZXRlIHZhcnNbdHlwZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXJzW3R5cGVdID0gY2FsbGJhY2s7XG4gICAgICAgIHBhcmFtcyAmJiAodmFyc1t0eXBlICsgXCJQYXJhbXNcIl0gPSBwYXJhbXMpO1xuICAgICAgICB0eXBlID09PSBcIm9uVXBkYXRlXCIgJiYgKHRoaXMuX29uVXBkYXRlID0gY2FsbGJhY2spO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gdmFyc1t0eXBlXTtcbiAgfTtcblxuICBfcHJvdG8udGhlbiA9IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICB2YXIgZiA9IF9pc0Z1bmN0aW9uKG9uRnVsZmlsbGVkKSA/IG9uRnVsZmlsbGVkIDogX3Bhc3NUaHJvdWdoLFxuICAgICAgICAgIF9yZXNvbHZlID0gZnVuY3Rpb24gX3Jlc29sdmUoKSB7XG4gICAgICAgIHZhciBfdGhlbiA9IHNlbGYudGhlbjtcbiAgICAgICAgc2VsZi50aGVuID0gbnVsbDsgLy8gdGVtcG9yYXJpbHkgbnVsbCB0aGUgdGhlbigpIG1ldGhvZCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2dyZWVuc29jay9HU0FQL2lzc3Vlcy8zMjIpXG5cbiAgICAgICAgX2lzRnVuY3Rpb24oZikgJiYgKGYgPSBmKHNlbGYpKSAmJiAoZi50aGVuIHx8IGYgPT09IHNlbGYpICYmIChzZWxmLnRoZW4gPSBfdGhlbik7XG4gICAgICAgIHJlc29sdmUoZik7XG4gICAgICAgIHNlbGYudGhlbiA9IF90aGVuO1xuICAgICAgfTtcblxuICAgICAgaWYgKHNlbGYuX2luaXR0ZWQgJiYgc2VsZi50b3RhbFByb2dyZXNzKCkgPT09IDEgJiYgc2VsZi5fdHMgPj0gMCB8fCAhc2VsZi5fdFRpbWUgJiYgc2VsZi5fdHMgPCAwKSB7XG4gICAgICAgIF9yZXNvbHZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZWxmLl9wcm9tID0gX3Jlc29sdmU7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmtpbGwgPSBmdW5jdGlvbiBraWxsKCkge1xuICAgIF9pbnRlcnJ1cHQodGhpcyk7XG4gIH07XG5cbiAgcmV0dXJuIEFuaW1hdGlvbjtcbn0oKTtcblxuX3NldERlZmF1bHRzKEFuaW1hdGlvbi5wcm90b3R5cGUsIHtcbiAgX3RpbWU6IDAsXG4gIF9zdGFydDogMCxcbiAgX2VuZDogMCxcbiAgX3RUaW1lOiAwLFxuICBfdER1cjogMCxcbiAgX2RpcnR5OiAwLFxuICBfcmVwZWF0OiAwLFxuICBfeW95bzogZmFsc2UsXG4gIHBhcmVudDogbnVsbCxcbiAgX2luaXR0ZWQ6IGZhbHNlLFxuICBfckRlbGF5OiAwLFxuICBfdHM6IDEsXG4gIF9kcDogMCxcbiAgcmF0aW86IDAsXG4gIF96VGltZTogLV90aW55TnVtLFxuICBfcHJvbTogMCxcbiAgX3BzOiBmYWxzZSxcbiAgX3J0czogMVxufSk7XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogVElNRUxJTkVcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5cbmV4cG9ydCB2YXIgVGltZWxpbmUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BbmltYXRpb24pIHtcbiAgX2luaGVyaXRzTG9vc2UoVGltZWxpbmUsIF9BbmltYXRpb24pO1xuXG4gIGZ1bmN0aW9uIFRpbWVsaW5lKHZhcnMsIHBvc2l0aW9uKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgaWYgKHZhcnMgPT09IHZvaWQgMCkge1xuICAgICAgdmFycyA9IHt9O1xuICAgIH1cblxuICAgIF90aGlzID0gX0FuaW1hdGlvbi5jYWxsKHRoaXMsIHZhcnMpIHx8IHRoaXM7XG4gICAgX3RoaXMubGFiZWxzID0ge307XG4gICAgX3RoaXMuc21vb3RoQ2hpbGRUaW1pbmcgPSAhIXZhcnMuc21vb3RoQ2hpbGRUaW1pbmc7XG4gICAgX3RoaXMuYXV0b1JlbW92ZUNoaWxkcmVuID0gISF2YXJzLmF1dG9SZW1vdmVDaGlsZHJlbjtcbiAgICBfdGhpcy5fc29ydCA9IF9pc05vdEZhbHNlKHZhcnMuc29ydENoaWxkcmVuKTtcbiAgICBfZ2xvYmFsVGltZWxpbmUgJiYgX2FkZFRvVGltZWxpbmUodmFycy5wYXJlbnQgfHwgX2dsb2JhbFRpbWVsaW5lLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgcG9zaXRpb24pO1xuICAgIHZhcnMucmV2ZXJzZWQgJiYgX3RoaXMucmV2ZXJzZSgpO1xuICAgIHZhcnMucGF1c2VkICYmIF90aGlzLnBhdXNlZCh0cnVlKTtcbiAgICB2YXJzLnNjcm9sbFRyaWdnZXIgJiYgX3Njcm9sbFRyaWdnZXIoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIHZhcnMuc2Nyb2xsVHJpZ2dlcik7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90bzIgPSBUaW1lbGluZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvMi50byA9IGZ1bmN0aW9uIHRvKHRhcmdldHMsIHZhcnMsIHBvc2l0aW9uKSB7XG4gICAgX2NyZWF0ZVR3ZWVuVHlwZSgwLCBhcmd1bWVudHMsIHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5mcm9tID0gZnVuY3Rpb24gZnJvbSh0YXJnZXRzLCB2YXJzLCBwb3NpdGlvbikge1xuICAgIF9jcmVhdGVUd2VlblR5cGUoMSwgYXJndW1lbnRzLCB0aGlzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuZnJvbVRvID0gZnVuY3Rpb24gZnJvbVRvKHRhcmdldHMsIGZyb21WYXJzLCB0b1ZhcnMsIHBvc2l0aW9uKSB7XG4gICAgX2NyZWF0ZVR3ZWVuVHlwZSgyLCBhcmd1bWVudHMsIHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5zZXQgPSBmdW5jdGlvbiBzZXQodGFyZ2V0cywgdmFycywgcG9zaXRpb24pIHtcbiAgICB2YXJzLmR1cmF0aW9uID0gMDtcbiAgICB2YXJzLnBhcmVudCA9IHRoaXM7XG4gICAgX2luaGVyaXREZWZhdWx0cyh2YXJzKS5yZXBlYXREZWxheSB8fCAodmFycy5yZXBlYXQgPSAwKTtcbiAgICB2YXJzLmltbWVkaWF0ZVJlbmRlciA9ICEhdmFycy5pbW1lZGlhdGVSZW5kZXI7XG4gICAgbmV3IFR3ZWVuKHRhcmdldHMsIHZhcnMsIF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKSwgMSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5jYWxsID0gZnVuY3Rpb24gY2FsbChjYWxsYmFjaywgcGFyYW1zLCBwb3NpdGlvbikge1xuICAgIHJldHVybiBfYWRkVG9UaW1lbGluZSh0aGlzLCBUd2Vlbi5kZWxheWVkQ2FsbCgwLCBjYWxsYmFjaywgcGFyYW1zKSwgcG9zaXRpb24pO1xuICB9IC8vT05MWSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSEgTWF5YmUgZGVsZXRlP1xuICA7XG5cbiAgX3Byb3RvMi5zdGFnZ2VyVG8gPSBmdW5jdGlvbiBzdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zKSB7XG4gICAgdmFycy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgIHZhcnMuc3RhZ2dlciA9IHZhcnMuc3RhZ2dlciB8fCBzdGFnZ2VyO1xuICAgIHZhcnMub25Db21wbGV0ZSA9IG9uQ29tcGxldGVBbGw7XG4gICAgdmFycy5vbkNvbXBsZXRlUGFyYW1zID0gb25Db21wbGV0ZUFsbFBhcmFtcztcbiAgICB2YXJzLnBhcmVudCA9IHRoaXM7XG4gICAgbmV3IFR3ZWVuKHRhcmdldHMsIHZhcnMsIF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5zdGFnZ2VyRnJvbSA9IGZ1bmN0aW9uIHN0YWdnZXJGcm9tKHRhcmdldHMsIGR1cmF0aW9uLCB2YXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcykge1xuICAgIHZhcnMucnVuQmFja3dhcmRzID0gMTtcbiAgICBfaW5oZXJpdERlZmF1bHRzKHZhcnMpLmltbWVkaWF0ZVJlbmRlciA9IF9pc05vdEZhbHNlKHZhcnMuaW1tZWRpYXRlUmVuZGVyKTtcbiAgICByZXR1cm4gdGhpcy5zdGFnZ2VyVG8odGFyZ2V0cywgZHVyYXRpb24sIHZhcnMsIHN0YWdnZXIsIHBvc2l0aW9uLCBvbkNvbXBsZXRlQWxsLCBvbkNvbXBsZXRlQWxsUGFyYW1zKTtcbiAgfTtcblxuICBfcHJvdG8yLnN0YWdnZXJGcm9tVG8gPSBmdW5jdGlvbiBzdGFnZ2VyRnJvbVRvKHRhcmdldHMsIGR1cmF0aW9uLCBmcm9tVmFycywgdG9WYXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcykge1xuICAgIHRvVmFycy5zdGFydEF0ID0gZnJvbVZhcnM7XG4gICAgX2luaGVyaXREZWZhdWx0cyh0b1ZhcnMpLmltbWVkaWF0ZVJlbmRlciA9IF9pc05vdEZhbHNlKHRvVmFycy5pbW1lZGlhdGVSZW5kZXIpO1xuICAgIHJldHVybiB0aGlzLnN0YWdnZXJUbyh0YXJnZXRzLCBkdXJhdGlvbiwgdG9WYXJzLCBzdGFnZ2VyLCBwb3NpdGlvbiwgb25Db21wbGV0ZUFsbCwgb25Db21wbGV0ZUFsbFBhcmFtcyk7XG4gIH07XG5cbiAgX3Byb3RvMi5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIodG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpIHtcbiAgICB2YXIgcHJldlRpbWUgPSB0aGlzLl90aW1lLFxuICAgICAgICB0RHVyID0gdGhpcy5fZGlydHkgPyB0aGlzLnRvdGFsRHVyYXRpb24oKSA6IHRoaXMuX3REdXIsXG4gICAgICAgIGR1ciA9IHRoaXMuX2R1cixcbiAgICAgICAgdFRpbWUgPSB0b3RhbFRpbWUgPD0gMCA/IDAgOiBfcm91bmRQcmVjaXNlKHRvdGFsVGltZSksXG4gICAgICAgIC8vIGlmIGEgcGF1c2VkIHRpbWVsaW5lIGlzIHJlc3VtZWQgKG9yIGl0cyBfc3RhcnQgaXMgdXBkYXRlZCBmb3IgYW5vdGhlciByZWFzb24uLi53aGljaCByb3VuZHMgaXQpLCB0aGF0IGNvdWxkIHJlc3VsdCBpbiB0aGUgcGxheWhlYWQgc2hpZnRpbmcgYSAqKnRpbnkqKiBhbW91bnQgYW5kIGEgemVyby1kdXJhdGlvbiBjaGlsZCBhdCB0aGF0IHNwb3QgbWF5IGdldCByZW5kZXJlZCBhdCBhIGRpZmZlcmVudCByYXRpbywgbGlrZSBpdHMgdG90YWxUaW1lIGluIHJlbmRlcigpIG1heSBiZSAxZS0xNyBpbnN0ZWFkIG9mIDAsIGZvciBleGFtcGxlLlxuICAgIGNyb3NzaW5nU3RhcnQgPSB0aGlzLl96VGltZSA8IDAgIT09IHRvdGFsVGltZSA8IDAgJiYgKHRoaXMuX2luaXR0ZWQgfHwgIWR1ciksXG4gICAgICAgIHRpbWUsXG4gICAgICAgIGNoaWxkLFxuICAgICAgICBuZXh0LFxuICAgICAgICBpdGVyYXRpb24sXG4gICAgICAgIGN5Y2xlRHVyYXRpb24sXG4gICAgICAgIHByZXZQYXVzZWQsXG4gICAgICAgIHBhdXNlVHdlZW4sXG4gICAgICAgIHRpbWVTY2FsZSxcbiAgICAgICAgcHJldlN0YXJ0LFxuICAgICAgICBwcmV2SXRlcmF0aW9uLFxuICAgICAgICB5b3lvLFxuICAgICAgICBpc1lveW87XG4gICAgdGhpcyAhPT0gX2dsb2JhbFRpbWVsaW5lICYmIHRUaW1lID4gdER1ciAmJiB0b3RhbFRpbWUgPj0gMCAmJiAodFRpbWUgPSB0RHVyKTtcblxuICAgIGlmICh0VGltZSAhPT0gdGhpcy5fdFRpbWUgfHwgZm9yY2UgfHwgY3Jvc3NpbmdTdGFydCkge1xuICAgICAgaWYgKHByZXZUaW1lICE9PSB0aGlzLl90aW1lICYmIGR1cikge1xuICAgICAgICAvL2lmIHRvdGFsRHVyYXRpb24oKSBmaW5kcyBhIGNoaWxkIHdpdGggYSBuZWdhdGl2ZSBzdGFydFRpbWUgYW5kIHNtb290aENoaWxkVGltaW5nIGlzIHRydWUsIHRoaW5ncyBnZXQgc2hpZnRlZCBhcm91bmQgaW50ZXJuYWxseSBzbyB3ZSBuZWVkIHRvIGFkanVzdCB0aGUgdGltZSBhY2NvcmRpbmdseS4gRm9yIGV4YW1wbGUsIGlmIGEgdHdlZW4gc3RhcnRzIGF0IC0zMCB3ZSBtdXN0IHNoaWZ0IEVWRVJZVEhJTkcgZm9yd2FyZCAzMCBzZWNvbmRzIGFuZCBtb3ZlIHRoaXMgdGltZWxpbmUncyBzdGFydFRpbWUgYmFja3dhcmQgYnkgMzAgc2Vjb25kcyBzbyB0aGF0IHRoaW5ncyBhbGlnbiB3aXRoIHRoZSBwbGF5aGVhZCAobm8ganVtcCkuXG4gICAgICAgIHRUaW1lICs9IHRoaXMuX3RpbWUgLSBwcmV2VGltZTtcbiAgICAgICAgdG90YWxUaW1lICs9IHRoaXMuX3RpbWUgLSBwcmV2VGltZTtcbiAgICAgIH1cblxuICAgICAgdGltZSA9IHRUaW1lO1xuICAgICAgcHJldlN0YXJ0ID0gdGhpcy5fc3RhcnQ7XG4gICAgICB0aW1lU2NhbGUgPSB0aGlzLl90cztcbiAgICAgIHByZXZQYXVzZWQgPSAhdGltZVNjYWxlO1xuXG4gICAgICBpZiAoY3Jvc3NpbmdTdGFydCkge1xuICAgICAgICBkdXIgfHwgKHByZXZUaW1lID0gdGhpcy5felRpbWUpOyAvL3doZW4gdGhlIHBsYXloZWFkIGFycml2ZXMgYXQgRVhBQ1RMWSB0aW1lIDAgKHJpZ2h0IG9uIHRvcCkgb2YgYSB6ZXJvLWR1cmF0aW9uIHRpbWVsaW5lLCB3ZSBuZWVkIHRvIGRpc2Nlcm4gaWYgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHNvIHRoYXQgd2hlbiB0aGUgcGxheWhlYWQgbW92ZXMgYWdhaW4gKG5leHQgdGltZSksIGl0J2xsIHRyaWdnZXIgdGhlIGNhbGxiYWNrLiBJZiBldmVudHMgYXJlIE5PVCBzdXBwcmVzc2VkLCBvYnZpb3VzbHkgdGhlIGNhbGxiYWNrIHdvdWxkIGJlIHRyaWdnZXJlZCBpbiB0aGlzIHJlbmRlci4gQmFzaWNhbGx5LCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUgZWl0aGVyIHdoZW4gdGhlIHBsYXloZWFkIEFSUklWRVMgb3IgTEVBVkVTIHRoaXMgZXhhY3Qgc3BvdCwgbm90IGJvdGguIEltYWdpbmUgZG9pbmcgYSB0aW1lbGluZS5zZWVrKDApIGFuZCB0aGVyZSdzIGEgY2FsbGJhY2sgdGhhdCBzaXRzIGF0IDAuIFNpbmNlIGV2ZW50cyBhcmUgc3VwcHJlc3NlZCBvbiB0aGF0IHNlZWsoKSBieSBkZWZhdWx0LCBub3RoaW5nIHdpbGwgZmlyZSwgYnV0IHdoZW4gdGhlIHBsYXloZWFkIG1vdmVzIG9mZiBvZiB0aGF0IHBvc2l0aW9uLCB0aGUgY2FsbGJhY2sgc2hvdWxkIGZpcmUuIFRoaXMgYmVoYXZpb3IgaXMgd2hhdCBwZW9wbGUgaW50dWl0aXZlbHkgZXhwZWN0LlxuXG4gICAgICAgICh0b3RhbFRpbWUgfHwgIXN1cHByZXNzRXZlbnRzKSAmJiAodGhpcy5felRpbWUgPSB0b3RhbFRpbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcmVwZWF0KSB7XG4gICAgICAgIC8vYWRqdXN0IHRoZSB0aW1lIGZvciByZXBlYXRzIGFuZCB5b3lvc1xuICAgICAgICB5b3lvID0gdGhpcy5feW95bztcbiAgICAgICAgY3ljbGVEdXJhdGlvbiA9IGR1ciArIHRoaXMuX3JEZWxheTtcblxuICAgICAgICBpZiAodGhpcy5fcmVwZWF0IDwgLTEgJiYgdG90YWxUaW1lIDwgMCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRvdGFsVGltZShjeWNsZUR1cmF0aW9uICogMTAwICsgdG90YWxUaW1lLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGltZSA9IF9yb3VuZFByZWNpc2UodFRpbWUgJSBjeWNsZUR1cmF0aW9uKTsgLy9yb3VuZCB0byBhdm9pZCBmbG9hdGluZyBwb2ludCBlcnJvcnMuICg0ICUgMC44IHNob3VsZCBiZSAwIGJ1dCBzb21lIGJyb3dzZXJzIHJlcG9ydCBpdCBhcyAwLjc5OTk5OTk5ISlcblxuICAgICAgICBpZiAodFRpbWUgPT09IHREdXIpIHtcbiAgICAgICAgICAvLyB0aGUgdER1ciA9PT0gdFRpbWUgaXMgZm9yIGVkZ2UgY2FzZXMgd2hlcmUgdGhlcmUncyBhIGxlbmd0aHkgZGVjaW1hbCBvbiB0aGUgZHVyYXRpb24gYW5kIGl0IG1heSByZWFjaCB0aGUgdmVyeSBlbmQgYnV0IHRoZSB0aW1lIGlzIHJlbmRlcmVkIGFzIG5vdC1xdWl0ZS10aGVyZSAocmVtZW1iZXIsIHREdXIgaXMgcm91bmRlZCB0byA0IGRlY2ltYWxzIHdoZXJlYXMgZHVyIGlzbid0KVxuICAgICAgICAgIGl0ZXJhdGlvbiA9IHRoaXMuX3JlcGVhdDtcbiAgICAgICAgICB0aW1lID0gZHVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZXJhdGlvbiA9IH5+KHRUaW1lIC8gY3ljbGVEdXJhdGlvbik7XG5cbiAgICAgICAgICBpZiAoaXRlcmF0aW9uICYmIGl0ZXJhdGlvbiA9PT0gdFRpbWUgLyBjeWNsZUR1cmF0aW9uKSB7XG4gICAgICAgICAgICB0aW1lID0gZHVyO1xuICAgICAgICAgICAgaXRlcmF0aW9uLS07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGltZSA+IGR1ciAmJiAodGltZSA9IGR1cik7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2SXRlcmF0aW9uID0gX2FuaW1hdGlvbkN5Y2xlKHRoaXMuX3RUaW1lLCBjeWNsZUR1cmF0aW9uKTtcbiAgICAgICAgIXByZXZUaW1lICYmIHRoaXMuX3RUaW1lICYmIHByZXZJdGVyYXRpb24gIT09IGl0ZXJhdGlvbiAmJiAocHJldkl0ZXJhdGlvbiA9IGl0ZXJhdGlvbik7IC8vIGVkZ2UgY2FzZSAtIGlmIHNvbWVvbmUgZG9lcyBhZGRQYXVzZSgpIGF0IHRoZSB2ZXJ5IGJlZ2lubmluZyBvZiBhIHJlcGVhdGluZyB0aW1lbGluZSwgdGhhdCBwYXVzZSBpcyB0ZWNobmljYWxseSBhdCB0aGUgc2FtZSBzcG90IGFzIHRoZSBlbmQgd2hpY2ggY2F1c2VzIHRoaXMuX3RpbWUgdG8gZ2V0IHNldCB0byAwIHdoZW4gdGhlIHRvdGFsVGltZSB3b3VsZCBub3JtYWxseSBwbGFjZSB0aGUgcGxheWhlYWQgYXQgdGhlIGVuZC4gU2VlIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9mb3J1bXMvdG9waWMvMjM4MjMtY2xvc2luZy1uYXYtYW5pbWF0aW9uLW5vdC13b3JraW5nLW9uLWllLWFuZC1pcGhvbmUtNi1tYXliZS1vdGhlci1vbGRlci1icm93c2VyLz90YWI9Y29tbWVudHMjY29tbWVudC0xMTMwMDVcblxuICAgICAgICBpZiAoeW95byAmJiBpdGVyYXRpb24gJiAxKSB7XG4gICAgICAgICAgdGltZSA9IGR1ciAtIHRpbWU7XG4gICAgICAgICAgaXNZb3lvID0gMTtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICBtYWtlIHN1cmUgY2hpbGRyZW4gYXQgdGhlIGVuZC9iZWdpbm5pbmcgb2YgdGhlIHRpbWVsaW5lIGFyZSByZW5kZXJlZCBwcm9wZXJseS4gSWYsIGZvciBleGFtcGxlLFxuICAgICAgICBhIDMtc2Vjb25kIGxvbmcgdGltZWxpbmUgcmVuZGVyZWQgYXQgMi45IHNlY29uZHMgcHJldmlvdXNseSwgYW5kIG5vdyByZW5kZXJzIGF0IDMuMiBzZWNvbmRzICh3aGljaFxuICAgICAgICB3b3VsZCBnZXQgdHJhbnNsYXRlZCB0byAyLjggc2Vjb25kcyBpZiB0aGUgdGltZWxpbmUgeW95b3Mgb3IgMC4yIHNlY29uZHMgaWYgaXQganVzdCByZXBlYXRzKSwgdGhlcmVcbiAgICAgICAgY291bGQgYmUgYSBjYWxsYmFjayBvciBhIHNob3J0IHR3ZWVuIHRoYXQncyBhdCAyLjk1IG9yIDMgc2Vjb25kcyBpbiB3aGljaCB3b3VsZG4ndCByZW5kZXIuIFNvXG4gICAgICAgIHdlIG5lZWQgdG8gcHVzaCB0aGUgdGltZWxpbmUgdG8gdGhlIGVuZCAoYW5kL29yIGJlZ2lubmluZyBkZXBlbmRpbmcgb24gaXRzIHlveW8gdmFsdWUpLiBBbHNvIHdlIG11c3RcbiAgICAgICAgZW5zdXJlIHRoYXQgemVyby1kdXJhdGlvbiB0d2VlbnMgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIG9yIGVuZCBvZiB0aGUgVGltZWxpbmUgd29yay5cbiAgICAgICAgKi9cblxuXG4gICAgICAgIGlmIChpdGVyYXRpb24gIT09IHByZXZJdGVyYXRpb24gJiYgIXRoaXMuX2xvY2spIHtcbiAgICAgICAgICB2YXIgcmV3aW5kaW5nID0geW95byAmJiBwcmV2SXRlcmF0aW9uICYgMSxcbiAgICAgICAgICAgICAgZG9lc1dyYXAgPSByZXdpbmRpbmcgPT09ICh5b3lvICYmIGl0ZXJhdGlvbiAmIDEpO1xuICAgICAgICAgIGl0ZXJhdGlvbiA8IHByZXZJdGVyYXRpb24gJiYgKHJld2luZGluZyA9ICFyZXdpbmRpbmcpO1xuICAgICAgICAgIHByZXZUaW1lID0gcmV3aW5kaW5nID8gMCA6IGR1cjtcbiAgICAgICAgICB0aGlzLl9sb2NrID0gMTtcbiAgICAgICAgICB0aGlzLnJlbmRlcihwcmV2VGltZSB8fCAoaXNZb3lvID8gMCA6IF9yb3VuZFByZWNpc2UoaXRlcmF0aW9uICogY3ljbGVEdXJhdGlvbikpLCBzdXBwcmVzc0V2ZW50cywgIWR1cikuX2xvY2sgPSAwO1xuICAgICAgICAgIHRoaXMuX3RUaW1lID0gdFRpbWU7IC8vIGlmIGEgdXNlciBnZXRzIHRoZSBpdGVyYXRpb24oKSBpbnNpZGUgdGhlIG9uUmVwZWF0LCBmb3IgZXhhbXBsZSwgaXQgc2hvdWxkIGJlIGFjY3VyYXRlLlxuXG4gICAgICAgICAgIXN1cHByZXNzRXZlbnRzICYmIHRoaXMucGFyZW50ICYmIF9jYWxsYmFjayh0aGlzLCBcIm9uUmVwZWF0XCIpO1xuICAgICAgICAgIHRoaXMudmFycy5yZXBlYXRSZWZyZXNoICYmICFpc1lveW8gJiYgKHRoaXMuaW52YWxpZGF0ZSgpLl9sb2NrID0gMSk7XG5cbiAgICAgICAgICBpZiAocHJldlRpbWUgJiYgcHJldlRpbWUgIT09IHRoaXMuX3RpbWUgfHwgcHJldlBhdXNlZCAhPT0gIXRoaXMuX3RzIHx8IHRoaXMudmFycy5vblJlcGVhdCAmJiAhdGhpcy5wYXJlbnQgJiYgIXRoaXMuX2FjdCkge1xuICAgICAgICAgICAgLy8gaWYgcHJldlRpbWUgaXMgMCBhbmQgd2UgcmVuZGVyIGF0IHRoZSB2ZXJ5IGVuZCwgX3RpbWUgd2lsbCBiZSB0aGUgZW5kLCB0aHVzIHdvbid0IG1hdGNoLiBTbyBpbiB0aGlzIGVkZ2UgY2FzZSwgcHJldlRpbWUgd29uJ3QgbWF0Y2ggX3RpbWUgYnV0IHRoYXQncyBva2F5LiBJZiBpdCBnZXRzIGtpbGxlZCBpbiB0aGUgb25SZXBlYXQsIGVqZWN0IGFzIHdlbGwuXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkdXIgPSB0aGlzLl9kdXI7IC8vIGluIGNhc2UgdGhlIGR1cmF0aW9uIGNoYW5nZWQgaW4gdGhlIG9uUmVwZWF0XG5cbiAgICAgICAgICB0RHVyID0gdGhpcy5fdER1cjtcblxuICAgICAgICAgIGlmIChkb2VzV3JhcCkge1xuICAgICAgICAgICAgdGhpcy5fbG9jayA9IDI7XG4gICAgICAgICAgICBwcmV2VGltZSA9IHJld2luZGluZyA/IGR1ciA6IC0wLjAwMDE7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcihwcmV2VGltZSwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnZhcnMucmVwZWF0UmVmcmVzaCAmJiAhaXNZb3lvICYmIHRoaXMuaW52YWxpZGF0ZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX2xvY2sgPSAwO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLl90cyAmJiAhcHJldlBhdXNlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgfSAvL2luIG9yZGVyIGZvciB5b3lvRWFzZSB0byB3b3JrIHByb3Blcmx5IHdoZW4gdGhlcmUncyBhIHN0YWdnZXIsIHdlIG11c3Qgc3dhcCBvdXQgdGhlIGVhc2UgaW4gZWFjaCBzdWItdHdlZW4uXG5cblxuICAgICAgICAgIF9wcm9wYWdhdGVZb3lvRWFzZSh0aGlzLCBpc1lveW8pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9oYXNQYXVzZSAmJiAhdGhpcy5fZm9yY2luZyAmJiB0aGlzLl9sb2NrIDwgMikge1xuICAgICAgICBwYXVzZVR3ZWVuID0gX2ZpbmROZXh0UGF1c2VUd2Vlbih0aGlzLCBfcm91bmRQcmVjaXNlKHByZXZUaW1lKSwgX3JvdW5kUHJlY2lzZSh0aW1lKSk7XG5cbiAgICAgICAgaWYgKHBhdXNlVHdlZW4pIHtcbiAgICAgICAgICB0VGltZSAtPSB0aW1lIC0gKHRpbWUgPSBwYXVzZVR3ZWVuLl9zdGFydCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fdFRpbWUgPSB0VGltZTtcbiAgICAgIHRoaXMuX3RpbWUgPSB0aW1lO1xuICAgICAgdGhpcy5fYWN0ID0gIXRpbWVTY2FsZTsgLy9hcyBsb25nIGFzIGl0J3Mgbm90IHBhdXNlZCwgZm9yY2UgaXQgdG8gYmUgYWN0aXZlIHNvIHRoYXQgaWYgdGhlIHVzZXIgcmVuZGVycyBpbmRlcGVuZGVudCBvZiB0aGUgcGFyZW50IHRpbWVsaW5lLCBpdCdsbCBiZSBmb3JjZWQgdG8gcmUtcmVuZGVyIG9uIHRoZSBuZXh0IHRpY2suXG5cbiAgICAgIGlmICghdGhpcy5faW5pdHRlZCkge1xuICAgICAgICB0aGlzLl9vblVwZGF0ZSA9IHRoaXMudmFycy5vblVwZGF0ZTtcbiAgICAgICAgdGhpcy5faW5pdHRlZCA9IDE7XG4gICAgICAgIHRoaXMuX3pUaW1lID0gdG90YWxUaW1lO1xuICAgICAgICBwcmV2VGltZSA9IDA7IC8vIHVwb24gaW5pdCwgdGhlIHBsYXloZWFkIHNob3VsZCBhbHdheXMgZ28gZm9yd2FyZDsgc29tZW9uZSBjb3VsZCBpbnZhbGlkYXRlKCkgYSBjb21wbGV0ZWQgdGltZWxpbmUgYW5kIHRoZW4gaWYgdGhleSByZXN0YXJ0KCksIHRoYXQgd291bGQgbWFrZSBjaGlsZCB0d2VlbnMgcmVuZGVyIGluIHJldmVyc2Ugb3JkZXIgd2hpY2ggY291bGQgbG9jayBpbiB0aGUgd3Jvbmcgc3RhcnRpbmcgdmFsdWVzIGlmIHRoZXkgYnVpbGQgb24gZWFjaCBvdGhlciwgbGlrZSB0bC50byhvYmosIHt4OiAxMDB9KS50byhvYmosIHt4OiAwfSkuXG4gICAgICB9XG5cbiAgICAgIGlmICghcHJldlRpbWUgJiYgdGltZSAmJiAhc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgICAgX2NhbGxiYWNrKHRoaXMsIFwib25TdGFydFwiKTtcblxuICAgICAgICBpZiAodGhpcy5fdFRpbWUgIT09IHRUaW1lKSB7XG4gICAgICAgICAgLy8gaW4gY2FzZSB0aGUgb25TdGFydCB0cmlnZ2VyZWQgYSByZW5kZXIgYXQgYSBkaWZmZXJlbnQgc3BvdCwgZWplY3QuIExpa2UgaWYgc29tZW9uZSBkaWQgYW5pbWF0aW9uLnBhdXNlKDAuNSkgb3Igc29tZXRoaW5nIGluc2lkZSB0aGUgb25TdGFydC5cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGltZSA+PSBwcmV2VGltZSAmJiB0b3RhbFRpbWUgPj0gMCkge1xuICAgICAgICBjaGlsZCA9IHRoaXMuX2ZpcnN0O1xuXG4gICAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICAgIG5leHQgPSBjaGlsZC5fbmV4dDtcblxuICAgICAgICAgIGlmICgoY2hpbGQuX2FjdCB8fCB0aW1lID49IGNoaWxkLl9zdGFydCkgJiYgY2hpbGQuX3RzICYmIHBhdXNlVHdlZW4gIT09IGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgIC8vIGFuIGV4dHJlbWUgZWRnZSBjYXNlIC0gdGhlIGNoaWxkJ3MgcmVuZGVyIGNvdWxkIGRvIHNvbWV0aGluZyBsaWtlIGtpbGwoKSB0aGUgXCJuZXh0XCIgb25lIGluIHRoZSBsaW5rZWQgbGlzdCwgb3IgcmVwYXJlbnQgaXQuIEluIHRoYXQgY2FzZSB3ZSBtdXN0IHJlLWluaXRpYXRlIHRoZSB3aG9sZSByZW5kZXIgdG8gYmUgc2FmZS5cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hpbGQucmVuZGVyKGNoaWxkLl90cyA+IDAgPyAodGltZSAtIGNoaWxkLl9zdGFydCkgKiBjaGlsZC5fdHMgOiAoY2hpbGQuX2RpcnR5ID8gY2hpbGQudG90YWxEdXJhdGlvbigpIDogY2hpbGQuX3REdXIpICsgKHRpbWUgLSBjaGlsZC5fc3RhcnQpICogY2hpbGQuX3RzLCBzdXBwcmVzc0V2ZW50cywgZm9yY2UpO1xuXG4gICAgICAgICAgICBpZiAodGltZSAhPT0gdGhpcy5fdGltZSB8fCAhdGhpcy5fdHMgJiYgIXByZXZQYXVzZWQpIHtcbiAgICAgICAgICAgICAgLy9pbiBjYXNlIGEgdHdlZW4gcGF1c2VzIG9yIHNlZWtzIHRoZSB0aW1lbGluZSB3aGVuIHJlbmRlcmluZywgbGlrZSBpbnNpZGUgb2YgYW4gb25VcGRhdGUvb25Db21wbGV0ZVxuICAgICAgICAgICAgICBwYXVzZVR3ZWVuID0gMDtcbiAgICAgICAgICAgICAgbmV4dCAmJiAodFRpbWUgKz0gdGhpcy5felRpbWUgPSAtX3RpbnlOdW0pOyAvLyBpdCBkaWRuJ3QgZmluaXNoIHJlbmRlcmluZywgc28gZmxhZyB6VGltZSBhcyBuZWdhdGl2ZSBzbyB0aGF0IHNvIHRoYXQgdGhlIG5leHQgdGltZSByZW5kZXIoKSBpcyBjYWxsZWQgaXQnbGwgYmUgZm9yY2VkICh0byByZW5kZXIgYW55IHJlbWFpbmluZyBjaGlsZHJlbilcblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGlsZCA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoaWxkID0gdGhpcy5fbGFzdDtcbiAgICAgICAgdmFyIGFkanVzdGVkVGltZSA9IHRvdGFsVGltZSA8IDAgPyB0b3RhbFRpbWUgOiB0aW1lOyAvL3doZW4gdGhlIHBsYXloZWFkIGdvZXMgYmFja3dhcmQgYmV5b25kIHRoZSBzdGFydCBvZiB0aGlzIHRpbWVsaW5lLCB3ZSBtdXN0IHBhc3MgdGhhdCBpbmZvcm1hdGlvbiBkb3duIHRvIHRoZSBjaGlsZCBhbmltYXRpb25zIHNvIHRoYXQgemVyby1kdXJhdGlvbiB0d2VlbnMga25vdyB3aGV0aGVyIHRvIHJlbmRlciB0aGVpciBzdGFydGluZyBvciBlbmRpbmcgdmFsdWVzLlxuXG4gICAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICAgIG5leHQgPSBjaGlsZC5fcHJldjtcblxuICAgICAgICAgIGlmICgoY2hpbGQuX2FjdCB8fCBhZGp1c3RlZFRpbWUgPD0gY2hpbGQuX2VuZCkgJiYgY2hpbGQuX3RzICYmIHBhdXNlVHdlZW4gIT09IGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgIC8vIGFuIGV4dHJlbWUgZWRnZSBjYXNlIC0gdGhlIGNoaWxkJ3MgcmVuZGVyIGNvdWxkIGRvIHNvbWV0aGluZyBsaWtlIGtpbGwoKSB0aGUgXCJuZXh0XCIgb25lIGluIHRoZSBsaW5rZWQgbGlzdCwgb3IgcmVwYXJlbnQgaXQuIEluIHRoYXQgY2FzZSB3ZSBtdXN0IHJlLWluaXRpYXRlIHRoZSB3aG9sZSByZW5kZXIgdG8gYmUgc2FmZS5cbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hpbGQucmVuZGVyKGNoaWxkLl90cyA+IDAgPyAoYWRqdXN0ZWRUaW1lIC0gY2hpbGQuX3N0YXJ0KSAqIGNoaWxkLl90cyA6IChjaGlsZC5fZGlydHkgPyBjaGlsZC50b3RhbER1cmF0aW9uKCkgOiBjaGlsZC5fdER1cikgKyAoYWRqdXN0ZWRUaW1lIC0gY2hpbGQuX3N0YXJ0KSAqIGNoaWxkLl90cywgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcblxuICAgICAgICAgICAgaWYgKHRpbWUgIT09IHRoaXMuX3RpbWUgfHwgIXRoaXMuX3RzICYmICFwcmV2UGF1c2VkKSB7XG4gICAgICAgICAgICAgIC8vaW4gY2FzZSBhIHR3ZWVuIHBhdXNlcyBvciBzZWVrcyB0aGUgdGltZWxpbmUgd2hlbiByZW5kZXJpbmcsIGxpa2UgaW5zaWRlIG9mIGFuIG9uVXBkYXRlL29uQ29tcGxldGVcbiAgICAgICAgICAgICAgcGF1c2VUd2VlbiA9IDA7XG4gICAgICAgICAgICAgIG5leHQgJiYgKHRUaW1lICs9IHRoaXMuX3pUaW1lID0gYWRqdXN0ZWRUaW1lID8gLV90aW55TnVtIDogX3RpbnlOdW0pOyAvLyBpdCBkaWRuJ3QgZmluaXNoIHJlbmRlcmluZywgc28gYWRqdXN0IHpUaW1lIHNvIHRoYXQgc28gdGhhdCB0aGUgbmV4dCB0aW1lIHJlbmRlcigpIGlzIGNhbGxlZCBpdCdsbCBiZSBmb3JjZWQgKHRvIHJlbmRlciBhbnkgcmVtYWluaW5nIGNoaWxkcmVuKVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoaWxkID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocGF1c2VUd2VlbiAmJiAhc3VwcHJlc3NFdmVudHMpIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICBwYXVzZVR3ZWVuLnJlbmRlcih0aW1lID49IHByZXZUaW1lID8gMCA6IC1fdGlueU51bSkuX3pUaW1lID0gdGltZSA+PSBwcmV2VGltZSA/IDEgOiAtMTtcblxuICAgICAgICBpZiAodGhpcy5fdHMpIHtcbiAgICAgICAgICAvL3RoZSBjYWxsYmFjayByZXN1bWVkIHBsYXliYWNrISBTbyBzaW5jZSB3ZSBtYXkgaGF2ZSBoZWxkIGJhY2sgdGhlIHBsYXloZWFkIGR1ZSB0byB3aGVyZSB0aGUgcGF1c2UgaXMgcG9zaXRpb25lZCwgZ28gYWhlYWQgYW5kIGp1bXAgdG8gd2hlcmUgaXQncyBTVVBQT1NFRCB0byBiZSAoaWYgbm8gcGF1c2UgaGFwcGVuZWQpLlxuICAgICAgICAgIHRoaXMuX3N0YXJ0ID0gcHJldlN0YXJ0OyAvL2lmIHRoZSBwYXVzZSB3YXMgYXQgYW4gZWFybGllciB0aW1lIGFuZCB0aGUgdXNlciByZXN1bWVkIGluIHRoZSBjYWxsYmFjaywgaXQgY291bGQgcmVwb3NpdGlvbiB0aGUgdGltZWxpbmUgKGNoYW5naW5nIGl0cyBzdGFydFRpbWUpLCB0aHJvd2luZyB0aGluZ3Mgb2ZmIHNsaWdodGx5LCBzbyB3ZSBtYWtlIHN1cmUgdGhlIF9zdGFydCBkb2Vzbid0IHNoaWZ0LlxuXG4gICAgICAgICAgX3NldEVuZCh0aGlzKTtcblxuICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcih0b3RhbFRpbWUsIHN1cHByZXNzRXZlbnRzLCBmb3JjZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fb25VcGRhdGUgJiYgIXN1cHByZXNzRXZlbnRzICYmIF9jYWxsYmFjayh0aGlzLCBcIm9uVXBkYXRlXCIsIHRydWUpO1xuICAgICAgaWYgKHRUaW1lID09PSB0RHVyICYmIHREdXIgPj0gdGhpcy50b3RhbER1cmF0aW9uKCkgfHwgIXRUaW1lICYmIHByZXZUaW1lKSBpZiAocHJldlN0YXJ0ID09PSB0aGlzLl9zdGFydCB8fCBNYXRoLmFicyh0aW1lU2NhbGUpICE9PSBNYXRoLmFicyh0aGlzLl90cykpIGlmICghdGhpcy5fbG9jaykge1xuICAgICAgICAodG90YWxUaW1lIHx8ICFkdXIpICYmICh0VGltZSA9PT0gdER1ciAmJiB0aGlzLl90cyA+IDAgfHwgIXRUaW1lICYmIHRoaXMuX3RzIDwgMCkgJiYgX3JlbW92ZUZyb21QYXJlbnQodGhpcywgMSk7IC8vIGRvbid0IHJlbW92ZSBpZiB0aGUgdGltZWxpbmUgaXMgcmV2ZXJzZWQgYW5kIHRoZSBwbGF5aGVhZCBpc24ndCBhdCAwLCBvdGhlcndpc2UgdGwucHJvZ3Jlc3MoMSkucmV2ZXJzZSgpIHdvbid0IHdvcmsuIE9ubHkgcmVtb3ZlIGlmIHRoZSBwbGF5aGVhZCBpcyBhdCB0aGUgZW5kIGFuZCB0aW1lU2NhbGUgaXMgcG9zaXRpdmUsIG9yIGlmIHRoZSBwbGF5aGVhZCBpcyBhdCAwIGFuZCB0aGUgdGltZVNjYWxlIGlzIG5lZ2F0aXZlLlxuXG4gICAgICAgIGlmICghc3VwcHJlc3NFdmVudHMgJiYgISh0b3RhbFRpbWUgPCAwICYmICFwcmV2VGltZSkgJiYgKHRUaW1lIHx8IHByZXZUaW1lIHx8ICF0RHVyKSkge1xuICAgICAgICAgIF9jYWxsYmFjayh0aGlzLCB0VGltZSA9PT0gdER1ciAmJiB0b3RhbFRpbWUgPj0gMCA/IFwib25Db21wbGV0ZVwiIDogXCJvblJldmVyc2VDb21wbGV0ZVwiLCB0cnVlKTtcblxuICAgICAgICAgIHRoaXMuX3Byb20gJiYgISh0VGltZSA8IHREdXIgJiYgdGhpcy50aW1lU2NhbGUoKSA+IDApICYmIHRoaXMuX3Byb20oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuYWRkID0gZnVuY3Rpb24gYWRkKGNoaWxkLCBwb3NpdGlvbikge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgX2lzTnVtYmVyKHBvc2l0aW9uKSB8fCAocG9zaXRpb24gPSBfcGFyc2VQb3NpdGlvbih0aGlzLCBwb3NpdGlvbiwgY2hpbGQpKTtcblxuICAgIGlmICghKGNoaWxkIGluc3RhbmNlb2YgQW5pbWF0aW9uKSkge1xuICAgICAgaWYgKF9pc0FycmF5KGNoaWxkKSkge1xuICAgICAgICBjaGlsZC5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLmFkZChvYmosIHBvc2l0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBpZiAoX2lzU3RyaW5nKGNoaWxkKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRMYWJlbChjaGlsZCwgcG9zaXRpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAoX2lzRnVuY3Rpb24oY2hpbGQpKSB7XG4gICAgICAgIGNoaWxkID0gVHdlZW4uZGVsYXllZENhbGwoMCwgY2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMgIT09IGNoaWxkID8gX2FkZFRvVGltZWxpbmUodGhpcywgY2hpbGQsIHBvc2l0aW9uKSA6IHRoaXM7IC8vZG9uJ3QgYWxsb3cgYSB0aW1lbGluZSB0byBiZSBhZGRlZCB0byBpdHNlbGYgYXMgYSBjaGlsZCFcbiAgfTtcblxuICBfcHJvdG8yLmdldENoaWxkcmVuID0gZnVuY3Rpb24gZ2V0Q2hpbGRyZW4obmVzdGVkLCB0d2VlbnMsIHRpbWVsaW5lcywgaWdub3JlQmVmb3JlVGltZSkge1xuICAgIGlmIChuZXN0ZWQgPT09IHZvaWQgMCkge1xuICAgICAgbmVzdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHdlZW5zID09PSB2b2lkIDApIHtcbiAgICAgIHR3ZWVucyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRpbWVsaW5lcyA9PT0gdm9pZCAwKSB7XG4gICAgICB0aW1lbGluZXMgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpZ25vcmVCZWZvcmVUaW1lID09PSB2b2lkIDApIHtcbiAgICAgIGlnbm9yZUJlZm9yZVRpbWUgPSAtX2JpZ051bTtcbiAgICB9XG5cbiAgICB2YXIgYSA9IFtdLFxuICAgICAgICBjaGlsZCA9IHRoaXMuX2ZpcnN0O1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQuX3N0YXJ0ID49IGlnbm9yZUJlZm9yZVRpbWUpIHtcbiAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVHdlZW4pIHtcbiAgICAgICAgICB0d2VlbnMgJiYgYS5wdXNoKGNoaWxkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aW1lbGluZXMgJiYgYS5wdXNoKGNoaWxkKTtcbiAgICAgICAgICBuZXN0ZWQgJiYgYS5wdXNoLmFwcGx5KGEsIGNoaWxkLmdldENoaWxkcmVuKHRydWUsIHR3ZWVucywgdGltZWxpbmVzKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gYTtcbiAgfTtcblxuICBfcHJvdG8yLmdldEJ5SWQgPSBmdW5jdGlvbiBnZXRCeUlkKGlkKSB7XG4gICAgdmFyIGFuaW1hdGlvbnMgPSB0aGlzLmdldENoaWxkcmVuKDEsIDEsIDEpLFxuICAgICAgICBpID0gYW5pbWF0aW9ucy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAoYW5pbWF0aW9uc1tpXS52YXJzLmlkID09PSBpZCkge1xuICAgICAgICByZXR1cm4gYW5pbWF0aW9uc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvMi5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoY2hpbGQpIHtcbiAgICBpZiAoX2lzU3RyaW5nKGNoaWxkKSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlTGFiZWwoY2hpbGQpO1xuICAgIH1cblxuICAgIGlmIChfaXNGdW5jdGlvbihjaGlsZCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmtpbGxUd2VlbnNPZihjaGlsZCk7XG4gICAgfVxuXG4gICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtKHRoaXMsIGNoaWxkKTtcblxuICAgIGlmIChjaGlsZCA9PT0gdGhpcy5fcmVjZW50KSB7XG4gICAgICB0aGlzLl9yZWNlbnQgPSB0aGlzLl9sYXN0O1xuICAgIH1cblxuICAgIHJldHVybiBfdW5jYWNoZSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8yLnRvdGFsVGltZSA9IGZ1bmN0aW9uIHRvdGFsVGltZShfdG90YWxUaW1lMiwgc3VwcHJlc3NFdmVudHMpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90VGltZTtcbiAgICB9XG5cbiAgICB0aGlzLl9mb3JjaW5nID0gMTtcblxuICAgIGlmICghdGhpcy5fZHAgJiYgdGhpcy5fdHMpIHtcbiAgICAgIC8vc3BlY2lhbCBjYXNlIGZvciB0aGUgZ2xvYmFsIHRpbWVsaW5lIChvciBhbnkgb3RoZXIgdGhhdCBoYXMgbm8gcGFyZW50IG9yIGRldGFjaGVkIHBhcmVudCkuXG4gICAgICB0aGlzLl9zdGFydCA9IF9yb3VuZFByZWNpc2UoX3RpY2tlci50aW1lIC0gKHRoaXMuX3RzID4gMCA/IF90b3RhbFRpbWUyIC8gdGhpcy5fdHMgOiAodGhpcy50b3RhbER1cmF0aW9uKCkgLSBfdG90YWxUaW1lMikgLyAtdGhpcy5fdHMpKTtcbiAgICB9XG5cbiAgICBfQW5pbWF0aW9uLnByb3RvdHlwZS50b3RhbFRpbWUuY2FsbCh0aGlzLCBfdG90YWxUaW1lMiwgc3VwcHJlc3NFdmVudHMpO1xuXG4gICAgdGhpcy5fZm9yY2luZyA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvMi5hZGRMYWJlbCA9IGZ1bmN0aW9uIGFkZExhYmVsKGxhYmVsLCBwb3NpdGlvbikge1xuICAgIHRoaXMubGFiZWxzW2xhYmVsXSA9IF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLnJlbW92ZUxhYmVsID0gZnVuY3Rpb24gcmVtb3ZlTGFiZWwobGFiZWwpIHtcbiAgICBkZWxldGUgdGhpcy5sYWJlbHNbbGFiZWxdO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzIuYWRkUGF1c2UgPSBmdW5jdGlvbiBhZGRQYXVzZShwb3NpdGlvbiwgY2FsbGJhY2ssIHBhcmFtcykge1xuICAgIHZhciB0ID0gVHdlZW4uZGVsYXllZENhbGwoMCwgY2FsbGJhY2sgfHwgX2VtcHR5RnVuYywgcGFyYW1zKTtcbiAgICB0LmRhdGEgPSBcImlzUGF1c2VcIjtcbiAgICB0aGlzLl9oYXNQYXVzZSA9IDE7XG4gICAgcmV0dXJuIF9hZGRUb1RpbWVsaW5lKHRoaXMsIHQsIF9wYXJzZVBvc2l0aW9uKHRoaXMsIHBvc2l0aW9uKSk7XG4gIH07XG5cbiAgX3Byb3RvMi5yZW1vdmVQYXVzZSA9IGZ1bmN0aW9uIHJlbW92ZVBhdXNlKHBvc2l0aW9uKSB7XG4gICAgdmFyIGNoaWxkID0gdGhpcy5fZmlyc3Q7XG4gICAgcG9zaXRpb24gPSBfcGFyc2VQb3NpdGlvbih0aGlzLCBwb3NpdGlvbik7XG5cbiAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgIGlmIChjaGlsZC5fc3RhcnQgPT09IHBvc2l0aW9uICYmIGNoaWxkLmRhdGEgPT09IFwiaXNQYXVzZVwiKSB7XG4gICAgICAgIF9yZW1vdmVGcm9tUGFyZW50KGNoaWxkKTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5fbmV4dDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvMi5raWxsVHdlZW5zT2YgPSBmdW5jdGlvbiBraWxsVHdlZW5zT2YodGFyZ2V0cywgcHJvcHMsIG9ubHlBY3RpdmUpIHtcbiAgICB2YXIgdHdlZW5zID0gdGhpcy5nZXRUd2VlbnNPZih0YXJnZXRzLCBvbmx5QWN0aXZlKSxcbiAgICAgICAgaSA9IHR3ZWVucy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBfb3ZlcndyaXRpbmdUd2VlbiAhPT0gdHdlZW5zW2ldICYmIHR3ZWVuc1tpXS5raWxsKHRhcmdldHMsIHByb3BzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8yLmdldFR3ZWVuc09mID0gZnVuY3Rpb24gZ2V0VHdlZW5zT2YodGFyZ2V0cywgb25seUFjdGl2ZSkge1xuICAgIHZhciBhID0gW10sXG4gICAgICAgIHBhcnNlZFRhcmdldHMgPSB0b0FycmF5KHRhcmdldHMpLFxuICAgICAgICBjaGlsZCA9IHRoaXMuX2ZpcnN0LFxuICAgICAgICBpc0dsb2JhbFRpbWUgPSBfaXNOdW1iZXIob25seUFjdGl2ZSksXG4gICAgICAgIC8vIGEgbnVtYmVyIGlzIGludGVycHJldGVkIGFzIGEgZ2xvYmFsIHRpbWUuIElmIHRoZSBhbmltYXRpb24gc3BhbnNcbiAgICBjaGlsZHJlbjtcblxuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVHdlZW4pIHtcbiAgICAgICAgaWYgKF9hcnJheUNvbnRhaW5zQW55KGNoaWxkLl90YXJnZXRzLCBwYXJzZWRUYXJnZXRzKSAmJiAoaXNHbG9iYWxUaW1lID8gKCFfb3ZlcndyaXRpbmdUd2VlbiB8fCBjaGlsZC5faW5pdHRlZCAmJiBjaGlsZC5fdHMpICYmIGNoaWxkLmdsb2JhbFRpbWUoMCkgPD0gb25seUFjdGl2ZSAmJiBjaGlsZC5nbG9iYWxUaW1lKGNoaWxkLnRvdGFsRHVyYXRpb24oKSkgPiBvbmx5QWN0aXZlIDogIW9ubHlBY3RpdmUgfHwgY2hpbGQuaXNBY3RpdmUoKSkpIHtcbiAgICAgICAgICAvLyBub3RlOiBpZiB0aGlzIGlzIGZvciBvdmVyd3JpdGluZywgaXQgc2hvdWxkIG9ubHkgYmUgZm9yIHR3ZWVucyB0aGF0IGFyZW4ndCBwYXVzZWQgYW5kIGFyZSBpbml0dGVkLlxuICAgICAgICAgIGEucHVzaChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKGNoaWxkcmVuID0gY2hpbGQuZ2V0VHdlZW5zT2YocGFyc2VkVGFyZ2V0cywgb25seUFjdGl2ZSkpLmxlbmd0aCkge1xuICAgICAgICBhLnB1c2guYXBwbHkoYSwgY2hpbGRyZW4pO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBhO1xuICB9IC8vIHBvdGVudGlhbCBmdXR1cmUgZmVhdHVyZSAtIHRhcmdldHMoKSBvbiB0aW1lbGluZXNcbiAgLy8gdGFyZ2V0cygpIHtcbiAgLy8gXHRsZXQgcmVzdWx0ID0gW107XG4gIC8vIFx0dGhpcy5nZXRDaGlsZHJlbih0cnVlLCB0cnVlLCBmYWxzZSkuZm9yRWFjaCh0ID0+IHJlc3VsdC5wdXNoKC4uLnQudGFyZ2V0cygpKSk7XG4gIC8vIFx0cmV0dXJuIHJlc3VsdC5maWx0ZXIoKHYsIGkpID0+IHJlc3VsdC5pbmRleE9mKHYpID09PSBpKTtcbiAgLy8gfVxuICA7XG5cbiAgX3Byb3RvMi50d2VlblRvID0gZnVuY3Rpb24gdHdlZW5Ubyhwb3NpdGlvbiwgdmFycykge1xuICAgIHZhcnMgPSB2YXJzIHx8IHt9O1xuXG4gICAgdmFyIHRsID0gdGhpcyxcbiAgICAgICAgZW5kVGltZSA9IF9wYXJzZVBvc2l0aW9uKHRsLCBwb3NpdGlvbiksXG4gICAgICAgIF92YXJzID0gdmFycyxcbiAgICAgICAgc3RhcnRBdCA9IF92YXJzLnN0YXJ0QXQsXG4gICAgICAgIF9vblN0YXJ0ID0gX3ZhcnMub25TdGFydCxcbiAgICAgICAgb25TdGFydFBhcmFtcyA9IF92YXJzLm9uU3RhcnRQYXJhbXMsXG4gICAgICAgIGltbWVkaWF0ZVJlbmRlciA9IF92YXJzLmltbWVkaWF0ZVJlbmRlcixcbiAgICAgICAgaW5pdHRlZCxcbiAgICAgICAgdHdlZW4gPSBUd2Vlbi50byh0bCwgX3NldERlZmF1bHRzKHtcbiAgICAgIGVhc2U6IHZhcnMuZWFzZSB8fCBcIm5vbmVcIixcbiAgICAgIGxhenk6IGZhbHNlLFxuICAgICAgaW1tZWRpYXRlUmVuZGVyOiBmYWxzZSxcbiAgICAgIHRpbWU6IGVuZFRpbWUsXG4gICAgICBvdmVyd3JpdGU6IFwiYXV0b1wiLFxuICAgICAgZHVyYXRpb246IHZhcnMuZHVyYXRpb24gfHwgTWF0aC5hYnMoKGVuZFRpbWUgLSAoc3RhcnRBdCAmJiBcInRpbWVcIiBpbiBzdGFydEF0ID8gc3RhcnRBdC50aW1lIDogdGwuX3RpbWUpKSAvIHRsLnRpbWVTY2FsZSgpKSB8fCBfdGlueU51bSxcbiAgICAgIG9uU3RhcnQ6IGZ1bmN0aW9uIG9uU3RhcnQoKSB7XG4gICAgICAgIHRsLnBhdXNlKCk7XG5cbiAgICAgICAgaWYgKCFpbml0dGVkKSB7XG4gICAgICAgICAgdmFyIGR1cmF0aW9uID0gdmFycy5kdXJhdGlvbiB8fCBNYXRoLmFicygoZW5kVGltZSAtIChzdGFydEF0ICYmIFwidGltZVwiIGluIHN0YXJ0QXQgPyBzdGFydEF0LnRpbWUgOiB0bC5fdGltZSkpIC8gdGwudGltZVNjYWxlKCkpO1xuICAgICAgICAgIHR3ZWVuLl9kdXIgIT09IGR1cmF0aW9uICYmIF9zZXREdXJhdGlvbih0d2VlbiwgZHVyYXRpb24sIDAsIDEpLnJlbmRlcih0d2Vlbi5fdGltZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgaW5pdHRlZCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICBfb25TdGFydCAmJiBfb25TdGFydC5hcHBseSh0d2Vlbiwgb25TdGFydFBhcmFtcyB8fCBbXSk7IC8vaW4gY2FzZSB0aGUgdXNlciBoYWQgYW4gb25TdGFydCBpbiB0aGUgdmFycyAtIHdlIGRvbid0IHdhbnQgdG8gb3ZlcndyaXRlIGl0LlxuICAgICAgfVxuICAgIH0sIHZhcnMpKTtcblxuICAgIHJldHVybiBpbW1lZGlhdGVSZW5kZXIgPyB0d2Vlbi5yZW5kZXIoMCkgOiB0d2VlbjtcbiAgfTtcblxuICBfcHJvdG8yLnR3ZWVuRnJvbVRvID0gZnVuY3Rpb24gdHdlZW5Gcm9tVG8oZnJvbVBvc2l0aW9uLCB0b1Bvc2l0aW9uLCB2YXJzKSB7XG4gICAgcmV0dXJuIHRoaXMudHdlZW5Ubyh0b1Bvc2l0aW9uLCBfc2V0RGVmYXVsdHMoe1xuICAgICAgc3RhcnRBdDoge1xuICAgICAgICB0aW1lOiBfcGFyc2VQb3NpdGlvbih0aGlzLCBmcm9tUG9zaXRpb24pXG4gICAgICB9XG4gICAgfSwgdmFycykpO1xuICB9O1xuXG4gIF9wcm90bzIucmVjZW50ID0gZnVuY3Rpb24gcmVjZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWNlbnQ7XG4gIH07XG5cbiAgX3Byb3RvMi5uZXh0TGFiZWwgPSBmdW5jdGlvbiBuZXh0TGFiZWwoYWZ0ZXJUaW1lKSB7XG4gICAgaWYgKGFmdGVyVGltZSA9PT0gdm9pZCAwKSB7XG4gICAgICBhZnRlclRpbWUgPSB0aGlzLl90aW1lO1xuICAgIH1cblxuICAgIHJldHVybiBfZ2V0TGFiZWxJbkRpcmVjdGlvbih0aGlzLCBfcGFyc2VQb3NpdGlvbih0aGlzLCBhZnRlclRpbWUpKTtcbiAgfTtcblxuICBfcHJvdG8yLnByZXZpb3VzTGFiZWwgPSBmdW5jdGlvbiBwcmV2aW91c0xhYmVsKGJlZm9yZVRpbWUpIHtcbiAgICBpZiAoYmVmb3JlVGltZSA9PT0gdm9pZCAwKSB7XG4gICAgICBiZWZvcmVUaW1lID0gdGhpcy5fdGltZTtcbiAgICB9XG5cbiAgICByZXR1cm4gX2dldExhYmVsSW5EaXJlY3Rpb24odGhpcywgX3BhcnNlUG9zaXRpb24odGhpcywgYmVmb3JlVGltZSksIDEpO1xuICB9O1xuXG4gIF9wcm90bzIuY3VycmVudExhYmVsID0gZnVuY3Rpb24gY3VycmVudExhYmVsKHZhbHVlKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnNlZWsodmFsdWUsIHRydWUpIDogdGhpcy5wcmV2aW91c0xhYmVsKHRoaXMuX3RpbWUgKyBfdGlueU51bSk7XG4gIH07XG5cbiAgX3Byb3RvMi5zaGlmdENoaWxkcmVuID0gZnVuY3Rpb24gc2hpZnRDaGlsZHJlbihhbW91bnQsIGFkanVzdExhYmVscywgaWdub3JlQmVmb3JlVGltZSkge1xuICAgIGlmIChpZ25vcmVCZWZvcmVUaW1lID09PSB2b2lkIDApIHtcbiAgICAgIGlnbm9yZUJlZm9yZVRpbWUgPSAwO1xuICAgIH1cblxuICAgIHZhciBjaGlsZCA9IHRoaXMuX2ZpcnN0LFxuICAgICAgICBsYWJlbHMgPSB0aGlzLmxhYmVscyxcbiAgICAgICAgcDtcblxuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkLl9zdGFydCA+PSBpZ25vcmVCZWZvcmVUaW1lKSB7XG4gICAgICAgIGNoaWxkLl9zdGFydCArPSBhbW91bnQ7XG4gICAgICAgIGNoaWxkLl9lbmQgKz0gYW1vdW50O1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgIH1cblxuICAgIGlmIChhZGp1c3RMYWJlbHMpIHtcbiAgICAgIGZvciAocCBpbiBsYWJlbHMpIHtcbiAgICAgICAgaWYgKGxhYmVsc1twXSA+PSBpZ25vcmVCZWZvcmVUaW1lKSB7XG4gICAgICAgICAgbGFiZWxzW3BdICs9IGFtb3VudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfdW5jYWNoZSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8yLmludmFsaWRhdGUgPSBmdW5jdGlvbiBpbnZhbGlkYXRlKCkge1xuICAgIHZhciBjaGlsZCA9IHRoaXMuX2ZpcnN0O1xuICAgIHRoaXMuX2xvY2sgPSAwO1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBjaGlsZC5pbnZhbGlkYXRlKCk7XG4gICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiBfQW5pbWF0aW9uLnByb3RvdHlwZS5pbnZhbGlkYXRlLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvMi5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKGluY2x1ZGVMYWJlbHMpIHtcbiAgICBpZiAoaW5jbHVkZUxhYmVscyA9PT0gdm9pZCAwKSB7XG4gICAgICBpbmNsdWRlTGFiZWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGQgPSB0aGlzLl9maXJzdCxcbiAgICAgICAgbmV4dDtcblxuICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgbmV4dCA9IGNoaWxkLl9uZXh0O1xuICAgICAgdGhpcy5yZW1vdmUoY2hpbGQpO1xuICAgICAgY2hpbGQgPSBuZXh0O1xuICAgIH1cblxuICAgIHRoaXMuX2RwICYmICh0aGlzLl90aW1lID0gdGhpcy5fdFRpbWUgPSB0aGlzLl9wVGltZSA9IDApO1xuICAgIGluY2x1ZGVMYWJlbHMgJiYgKHRoaXMubGFiZWxzID0ge30pO1xuICAgIHJldHVybiBfdW5jYWNoZSh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8yLnRvdGFsRHVyYXRpb24gPSBmdW5jdGlvbiB0b3RhbER1cmF0aW9uKHZhbHVlKSB7XG4gICAgdmFyIG1heCA9IDAsXG4gICAgICAgIHNlbGYgPSB0aGlzLFxuICAgICAgICBjaGlsZCA9IHNlbGYuX2xhc3QsXG4gICAgICAgIHByZXZTdGFydCA9IF9iaWdOdW0sXG4gICAgICAgIHByZXYsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBwYXJlbnQ7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHNlbGYudGltZVNjYWxlKChzZWxmLl9yZXBlYXQgPCAwID8gc2VsZi5kdXJhdGlvbigpIDogc2VsZi50b3RhbER1cmF0aW9uKCkpIC8gKHNlbGYucmV2ZXJzZWQoKSA/IC12YWx1ZSA6IHZhbHVlKSk7XG4gICAgfVxuXG4gICAgaWYgKHNlbGYuX2RpcnR5KSB7XG4gICAgICBwYXJlbnQgPSBzZWxmLnBhcmVudDtcblxuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIHByZXYgPSBjaGlsZC5fcHJldjsgLy9yZWNvcmQgaXQgaGVyZSBpbiBjYXNlIHRoZSB0d2VlbiBjaGFuZ2VzIHBvc2l0aW9uIGluIHRoZSBzZXF1ZW5jZS4uLlxuXG4gICAgICAgIGNoaWxkLl9kaXJ0eSAmJiBjaGlsZC50b3RhbER1cmF0aW9uKCk7IC8vY291bGQgY2hhbmdlIHRoZSB0d2Vlbi5fc3RhcnRUaW1lLCBzbyBtYWtlIHN1cmUgdGhlIGFuaW1hdGlvbidzIGNhY2hlIGlzIGNsZWFuIGJlZm9yZSBhbmFseXppbmcgaXQuXG5cbiAgICAgICAgc3RhcnQgPSBjaGlsZC5fc3RhcnQ7XG5cbiAgICAgICAgaWYgKHN0YXJ0ID4gcHJldlN0YXJ0ICYmIHNlbGYuX3NvcnQgJiYgY2hpbGQuX3RzICYmICFzZWxmLl9sb2NrKSB7XG4gICAgICAgICAgLy9pbiBjYXNlIG9uZSBvZiB0aGUgdHdlZW5zIHNoaWZ0ZWQgb3V0IG9mIG9yZGVyLCBpdCBuZWVkcyB0byBiZSByZS1pbnNlcnRlZCBpbnRvIHRoZSBjb3JyZWN0IHBvc2l0aW9uIGluIHRoZSBzZXF1ZW5jZVxuICAgICAgICAgIHNlbGYuX2xvY2sgPSAxOyAvL3ByZXZlbnQgZW5kbGVzcyByZWN1cnNpdmUgY2FsbHMgLSB0aGVyZSBhcmUgbWV0aG9kcyB0aGF0IGdldCB0cmlnZ2VyZWQgdGhhdCBjaGVjayBkdXJhdGlvbi90b3RhbER1cmF0aW9uIHdoZW4gd2UgYWRkKCkuXG5cbiAgICAgICAgICBfYWRkVG9UaW1lbGluZShzZWxmLCBjaGlsZCwgc3RhcnQgLSBjaGlsZC5fZGVsYXksIDEpLl9sb2NrID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2U3RhcnQgPSBzdGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGFydCA8IDAgJiYgY2hpbGQuX3RzKSB7XG4gICAgICAgICAgLy9jaGlsZHJlbiBhcmVuJ3QgYWxsb3dlZCB0byBoYXZlIG5lZ2F0aXZlIHN0YXJ0VGltZXMgdW5sZXNzIHNtb290aENoaWxkVGltaW5nIGlzIHRydWUsIHNvIGFkanVzdCBoZXJlIGlmIG9uZSBpcyBmb3VuZC5cbiAgICAgICAgICBtYXggLT0gc3RhcnQ7XG5cbiAgICAgICAgICBpZiAoIXBhcmVudCAmJiAhc2VsZi5fZHAgfHwgcGFyZW50ICYmIHBhcmVudC5zbW9vdGhDaGlsZFRpbWluZykge1xuICAgICAgICAgICAgc2VsZi5fc3RhcnQgKz0gc3RhcnQgLyBzZWxmLl90cztcbiAgICAgICAgICAgIHNlbGYuX3RpbWUgLT0gc3RhcnQ7XG4gICAgICAgICAgICBzZWxmLl90VGltZSAtPSBzdGFydDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxmLnNoaWZ0Q2hpbGRyZW4oLXN0YXJ0LCBmYWxzZSwgLTFlOTk5KTtcbiAgICAgICAgICBwcmV2U3RhcnQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQuX2VuZCA+IG1heCAmJiBjaGlsZC5fdHMgJiYgKG1heCA9IGNoaWxkLl9lbmQpO1xuICAgICAgICBjaGlsZCA9IHByZXY7XG4gICAgICB9XG5cbiAgICAgIF9zZXREdXJhdGlvbihzZWxmLCBzZWxmID09PSBfZ2xvYmFsVGltZWxpbmUgJiYgc2VsZi5fdGltZSA+IG1heCA/IHNlbGYuX3RpbWUgOiBtYXgsIDEsIDEpO1xuXG4gICAgICBzZWxmLl9kaXJ0eSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGYuX3REdXI7XG4gIH07XG5cbiAgVGltZWxpbmUudXBkYXRlUm9vdCA9IGZ1bmN0aW9uIHVwZGF0ZVJvb3QodGltZSkge1xuICAgIGlmIChfZ2xvYmFsVGltZWxpbmUuX3RzKSB7XG4gICAgICBfbGF6eVNhZmVSZW5kZXIoX2dsb2JhbFRpbWVsaW5lLCBfcGFyZW50VG9DaGlsZFRvdGFsVGltZSh0aW1lLCBfZ2xvYmFsVGltZWxpbmUpKTtcblxuICAgICAgX2xhc3RSZW5kZXJlZEZyYW1lID0gX3RpY2tlci5mcmFtZTtcbiAgICB9XG5cbiAgICBpZiAoX3RpY2tlci5mcmFtZSA+PSBfbmV4dEdDRnJhbWUpIHtcbiAgICAgIF9uZXh0R0NGcmFtZSArPSBfY29uZmlnLmF1dG9TbGVlcCB8fCAxMjA7XG4gICAgICB2YXIgY2hpbGQgPSBfZ2xvYmFsVGltZWxpbmUuX2ZpcnN0O1xuICAgICAgaWYgKCFjaGlsZCB8fCAhY2hpbGQuX3RzKSBpZiAoX2NvbmZpZy5hdXRvU2xlZXAgJiYgX3RpY2tlci5fbGlzdGVuZXJzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgd2hpbGUgKGNoaWxkICYmICFjaGlsZC5fdHMpIHtcbiAgICAgICAgICBjaGlsZCA9IGNoaWxkLl9uZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGQgfHwgX3RpY2tlci5zbGVlcCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVGltZWxpbmU7XG59KEFuaW1hdGlvbik7XG5cbl9zZXREZWZhdWx0cyhUaW1lbGluZS5wcm90b3R5cGUsIHtcbiAgX2xvY2s6IDAsXG4gIF9oYXNQYXVzZTogMCxcbiAgX2ZvcmNpbmc6IDBcbn0pO1xuXG52YXIgX2FkZENvbXBsZXhTdHJpbmdQcm9wVHdlZW4gPSBmdW5jdGlvbiBfYWRkQ29tcGxleFN0cmluZ1Byb3BUd2Vlbih0YXJnZXQsIHByb3AsIHN0YXJ0LCBlbmQsIHNldHRlciwgc3RyaW5nRmlsdGVyLCBmdW5jUGFyYW0pIHtcbiAgLy9ub3RlOiB3ZSBjYWxsIF9hZGRDb21wbGV4U3RyaW5nUHJvcFR3ZWVuLmNhbGwodHdlZW5JbnN0YW5jZS4uLikgdG8gZW5zdXJlIHRoYXQgaXQncyBzY29wZWQgcHJvcGVybHkuIFdlIG1heSBjYWxsIGl0IGZyb20gd2l0aGluIGEgcGx1Z2luIHRvbywgdGh1cyBcInRoaXNcIiB3b3VsZCByZWZlciB0byB0aGUgcGx1Z2luLlxuICB2YXIgcHQgPSBuZXcgUHJvcFR3ZWVuKHRoaXMuX3B0LCB0YXJnZXQsIHByb3AsIDAsIDEsIF9yZW5kZXJDb21wbGV4U3RyaW5nLCBudWxsLCBzZXR0ZXIpLFxuICAgICAgaW5kZXggPSAwLFxuICAgICAgbWF0Y2hJbmRleCA9IDAsXG4gICAgICByZXN1bHQsXG4gICAgICBzdGFydE51bXMsXG4gICAgICBjb2xvcixcbiAgICAgIGVuZE51bSxcbiAgICAgIGNodW5rLFxuICAgICAgc3RhcnROdW0sXG4gICAgICBoYXNSYW5kb20sXG4gICAgICBhO1xuICBwdC5iID0gc3RhcnQ7XG4gIHB0LmUgPSBlbmQ7XG4gIHN0YXJ0ICs9IFwiXCI7IC8vZW5zdXJlIHZhbHVlcyBhcmUgc3RyaW5nc1xuXG4gIGVuZCArPSBcIlwiO1xuXG4gIGlmIChoYXNSYW5kb20gPSB+ZW5kLmluZGV4T2YoXCJyYW5kb20oXCIpKSB7XG4gICAgZW5kID0gX3JlcGxhY2VSYW5kb20oZW5kKTtcbiAgfVxuXG4gIGlmIChzdHJpbmdGaWx0ZXIpIHtcbiAgICBhID0gW3N0YXJ0LCBlbmRdO1xuICAgIHN0cmluZ0ZpbHRlcihhLCB0YXJnZXQsIHByb3ApOyAvL3Bhc3MgYW4gYXJyYXkgd2l0aCB0aGUgc3RhcnRpbmcgYW5kIGVuZGluZyB2YWx1ZXMgYW5kIGxldCB0aGUgZmlsdGVyIGRvIHdoYXRldmVyIGl0IG5lZWRzIHRvIHRoZSB2YWx1ZXMuXG5cbiAgICBzdGFydCA9IGFbMF07XG4gICAgZW5kID0gYVsxXTtcbiAgfVxuXG4gIHN0YXJ0TnVtcyA9IHN0YXJ0Lm1hdGNoKF9jb21wbGV4U3RyaW5nTnVtRXhwKSB8fCBbXTtcblxuICB3aGlsZSAocmVzdWx0ID0gX2NvbXBsZXhTdHJpbmdOdW1FeHAuZXhlYyhlbmQpKSB7XG4gICAgZW5kTnVtID0gcmVzdWx0WzBdO1xuICAgIGNodW5rID0gZW5kLnN1YnN0cmluZyhpbmRleCwgcmVzdWx0LmluZGV4KTtcblxuICAgIGlmIChjb2xvcikge1xuICAgICAgY29sb3IgPSAoY29sb3IgKyAxKSAlIDU7XG4gICAgfSBlbHNlIGlmIChjaHVuay5zdWJzdHIoLTUpID09PSBcInJnYmEoXCIpIHtcbiAgICAgIGNvbG9yID0gMTtcbiAgICB9XG5cbiAgICBpZiAoZW5kTnVtICE9PSBzdGFydE51bXNbbWF0Y2hJbmRleCsrXSkge1xuICAgICAgc3RhcnROdW0gPSBwYXJzZUZsb2F0KHN0YXJ0TnVtc1ttYXRjaEluZGV4IC0gMV0pIHx8IDA7IC8vdGhlc2UgbmVzdGVkIFByb3BUd2VlbnMgYXJlIGhhbmRsZWQgaW4gYSBzcGVjaWFsIHdheSAtIHdlJ2xsIG5ldmVyIGFjdHVhbGx5IGNhbGwgYSByZW5kZXIgb3Igc2V0dGVyIG1ldGhvZCBvbiB0aGVtLiBXZSdsbCBqdXN0IGxvb3AgdGhyb3VnaCB0aGVtIGluIHRoZSBwYXJlbnQgY29tcGxleCBzdHJpbmcgUHJvcFR3ZWVuJ3MgcmVuZGVyIG1ldGhvZC5cblxuICAgICAgcHQuX3B0ID0ge1xuICAgICAgICBfbmV4dDogcHQuX3B0LFxuICAgICAgICBwOiBjaHVuayB8fCBtYXRjaEluZGV4ID09PSAxID8gY2h1bmsgOiBcIixcIixcbiAgICAgICAgLy9ub3RlOiBTVkcgc3BlYyBhbGxvd3Mgb21pc3Npb24gb2YgY29tbWEvc3BhY2Ugd2hlbiBhIG5lZ2F0aXZlIHNpZ24gaXMgd2VkZ2VkIGJldHdlZW4gdHdvIG51bWJlcnMsIGxpa2UgMi41LTUuMyBpbnN0ZWFkIG9mIDIuNSwtNS4zIGJ1dCB3aGVuIHR3ZWVuaW5nLCB0aGUgbmVnYXRpdmUgdmFsdWUgbWF5IHN3aXRjaCB0byBwb3NpdGl2ZSwgc28gd2UgaW5zZXJ0IHRoZSBjb21tYSBqdXN0IGluIGNhc2UuXG4gICAgICAgIHM6IHN0YXJ0TnVtLFxuICAgICAgICBjOiBlbmROdW0uY2hhckF0KDEpID09PSBcIj1cIiA/IHBhcnNlRmxvYXQoZW5kTnVtLnN1YnN0cigyKSkgKiAoZW5kTnVtLmNoYXJBdCgwKSA9PT0gXCItXCIgPyAtMSA6IDEpIDogcGFyc2VGbG9hdChlbmROdW0pIC0gc3RhcnROdW0sXG4gICAgICAgIG06IGNvbG9yICYmIGNvbG9yIDwgNCA/IE1hdGgucm91bmQgOiAwXG4gICAgICB9O1xuICAgICAgaW5kZXggPSBfY29tcGxleFN0cmluZ051bUV4cC5sYXN0SW5kZXg7XG4gICAgfVxuICB9XG5cbiAgcHQuYyA9IGluZGV4IDwgZW5kLmxlbmd0aCA/IGVuZC5zdWJzdHJpbmcoaW5kZXgsIGVuZC5sZW5ndGgpIDogXCJcIjsgLy93ZSB1c2UgdGhlIFwiY1wiIG9mIHRoZSBQcm9wVHdlZW4gdG8gc3RvcmUgdGhlIGZpbmFsIHBhcnQgb2YgdGhlIHN0cmluZyAoYWZ0ZXIgdGhlIGxhc3QgbnVtYmVyKVxuXG4gIHB0LmZwID0gZnVuY1BhcmFtO1xuXG4gIGlmIChfcmVsRXhwLnRlc3QoZW5kKSB8fCBoYXNSYW5kb20pIHtcbiAgICBwdC5lID0gMDsgLy9pZiB0aGUgZW5kIHN0cmluZyBjb250YWlucyByZWxhdGl2ZSB2YWx1ZXMgb3IgZHluYW1pYyByYW5kb20oLi4uKSB2YWx1ZXMsIGRlbGV0ZSB0aGUgZW5kIGl0IHNvIHRoYXQgb24gdGhlIGZpbmFsIHJlbmRlciB3ZSBkb24ndCBhY3R1YWxseSBzZXQgaXQgdG8gdGhlIHN0cmluZyB3aXRoICs9IG9yIC09IGNoYXJhY3RlcnMgKGZvcmNlcyBpdCB0byB1c2UgdGhlIGNhbGN1bGF0ZWQgdmFsdWUpLlxuICB9XG5cbiAgdGhpcy5fcHQgPSBwdDsgLy9zdGFydCB0aGUgbGlua2VkIGxpc3Qgd2l0aCB0aGlzIG5ldyBQcm9wVHdlZW4uIFJlbWVtYmVyLCB3ZSBjYWxsIF9hZGRDb21wbGV4U3RyaW5nUHJvcFR3ZWVuLmNhbGwodHdlZW5JbnN0YW5jZS4uLikgdG8gZW5zdXJlIHRoYXQgaXQncyBzY29wZWQgcHJvcGVybHkuIFdlIG1heSBjYWxsIGl0IGZyb20gd2l0aGluIGEgcGx1Z2luIHRvbywgdGh1cyBcInRoaXNcIiB3b3VsZCByZWZlciB0byB0aGUgcGx1Z2luLlxuXG4gIHJldHVybiBwdDtcbn0sXG4gICAgX2FkZFByb3BUd2VlbiA9IGZ1bmN0aW9uIF9hZGRQcm9wVHdlZW4odGFyZ2V0LCBwcm9wLCBzdGFydCwgZW5kLCBpbmRleCwgdGFyZ2V0cywgbW9kaWZpZXIsIHN0cmluZ0ZpbHRlciwgZnVuY1BhcmFtKSB7XG4gIF9pc0Z1bmN0aW9uKGVuZCkgJiYgKGVuZCA9IGVuZChpbmRleCB8fCAwLCB0YXJnZXQsIHRhcmdldHMpKTtcbiAgdmFyIGN1cnJlbnRWYWx1ZSA9IHRhcmdldFtwcm9wXSxcbiAgICAgIHBhcnNlZFN0YXJ0ID0gc3RhcnQgIT09IFwiZ2V0XCIgPyBzdGFydCA6ICFfaXNGdW5jdGlvbihjdXJyZW50VmFsdWUpID8gY3VycmVudFZhbHVlIDogZnVuY1BhcmFtID8gdGFyZ2V0W3Byb3AuaW5kZXhPZihcInNldFwiKSB8fCAhX2lzRnVuY3Rpb24odGFyZ2V0W1wiZ2V0XCIgKyBwcm9wLnN1YnN0cigzKV0pID8gcHJvcCA6IFwiZ2V0XCIgKyBwcm9wLnN1YnN0cigzKV0oZnVuY1BhcmFtKSA6IHRhcmdldFtwcm9wXSgpLFxuICAgICAgc2V0dGVyID0gIV9pc0Z1bmN0aW9uKGN1cnJlbnRWYWx1ZSkgPyBfc2V0dGVyUGxhaW4gOiBmdW5jUGFyYW0gPyBfc2V0dGVyRnVuY1dpdGhQYXJhbSA6IF9zZXR0ZXJGdW5jLFxuICAgICAgcHQ7XG5cbiAgaWYgKF9pc1N0cmluZyhlbmQpKSB7XG4gICAgaWYgKH5lbmQuaW5kZXhPZihcInJhbmRvbShcIikpIHtcbiAgICAgIGVuZCA9IF9yZXBsYWNlUmFuZG9tKGVuZCk7XG4gICAgfVxuXG4gICAgaWYgKGVuZC5jaGFyQXQoMSkgPT09IFwiPVwiKSB7XG4gICAgICBwdCA9IHBhcnNlRmxvYXQocGFyc2VkU3RhcnQpICsgcGFyc2VGbG9hdChlbmQuc3Vic3RyKDIpKSAqIChlbmQuY2hhckF0KDApID09PSBcIi1cIiA/IC0xIDogMSkgKyAoZ2V0VW5pdChwYXJzZWRTdGFydCkgfHwgMCk7XG5cbiAgICAgIGlmIChwdCB8fCBwdCA9PT0gMCkge1xuICAgICAgICAvLyB0byBhdm9pZCBpc05hTiwgbGlrZSBpZiBzb21lb25lIHBhc3NlcyBpbiBhIHZhbHVlIGxpa2UgXCIhPSB3aGF0ZXZlclwiXG4gICAgICAgIGVuZCA9IHB0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChwYXJzZWRTdGFydCAhPT0gZW5kKSB7XG4gICAgaWYgKCFpc05hTihwYXJzZWRTdGFydCAqIGVuZCkgJiYgZW5kICE9PSBcIlwiKSB7XG4gICAgICAvLyBmdW4gZmFjdDogYW55IG51bWJlciBtdWx0aXBsaWVkIGJ5IFwiXCIgaXMgZXZhbHVhdGVkIGFzIHRoZSBudW1iZXIgMCFcbiAgICAgIHB0ID0gbmV3IFByb3BUd2Vlbih0aGlzLl9wdCwgdGFyZ2V0LCBwcm9wLCArcGFyc2VkU3RhcnQgfHwgMCwgZW5kIC0gKHBhcnNlZFN0YXJ0IHx8IDApLCB0eXBlb2YgY3VycmVudFZhbHVlID09PSBcImJvb2xlYW5cIiA/IF9yZW5kZXJCb29sZWFuIDogX3JlbmRlclBsYWluLCAwLCBzZXR0ZXIpO1xuICAgICAgZnVuY1BhcmFtICYmIChwdC5mcCA9IGZ1bmNQYXJhbSk7XG4gICAgICBtb2RpZmllciAmJiBwdC5tb2RpZmllcihtb2RpZmllciwgdGhpcywgdGFyZ2V0KTtcbiAgICAgIHJldHVybiB0aGlzLl9wdCA9IHB0O1xuICAgIH1cblxuICAgICFjdXJyZW50VmFsdWUgJiYgIShwcm9wIGluIHRhcmdldCkgJiYgX21pc3NpbmdQbHVnaW4ocHJvcCwgZW5kKTtcbiAgICByZXR1cm4gX2FkZENvbXBsZXhTdHJpbmdQcm9wVHdlZW4uY2FsbCh0aGlzLCB0YXJnZXQsIHByb3AsIHBhcnNlZFN0YXJ0LCBlbmQsIHNldHRlciwgc3RyaW5nRmlsdGVyIHx8IF9jb25maWcuc3RyaW5nRmlsdGVyLCBmdW5jUGFyYW0pO1xuICB9XG59LFxuICAgIC8vY3JlYXRlcyBhIGNvcHkgb2YgdGhlIHZhcnMgb2JqZWN0IGFuZCBwcm9jZXNzZXMgYW55IGZ1bmN0aW9uLWJhc2VkIHZhbHVlcyAocHV0dGluZyB0aGUgcmVzdWx0aW5nIHZhbHVlcyBkaXJlY3RseSBpbnRvIHRoZSBjb3B5KSBhcyB3ZWxsIGFzIHN0cmluZ3Mgd2l0aCBcInJhbmRvbSgpXCIgaW4gdGhlbS4gSXQgZG9lcyBOT1QgcHJvY2VzcyByZWxhdGl2ZSB2YWx1ZXMuXG5fcHJvY2Vzc1ZhcnMgPSBmdW5jdGlvbiBfcHJvY2Vzc1ZhcnModmFycywgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cywgdHdlZW4pIHtcbiAgX2lzRnVuY3Rpb24odmFycykgJiYgKHZhcnMgPSBfcGFyc2VGdW5jT3JTdHJpbmcodmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpKTtcblxuICBpZiAoIV9pc09iamVjdCh2YXJzKSB8fCB2YXJzLnN0eWxlICYmIHZhcnMubm9kZVR5cGUgfHwgX2lzQXJyYXkodmFycykgfHwgX2lzVHlwZWRBcnJheSh2YXJzKSkge1xuICAgIHJldHVybiBfaXNTdHJpbmcodmFycykgPyBfcGFyc2VGdW5jT3JTdHJpbmcodmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIHRhcmdldHMpIDogdmFycztcbiAgfVxuXG4gIHZhciBjb3B5ID0ge30sXG4gICAgICBwO1xuXG4gIGZvciAocCBpbiB2YXJzKSB7XG4gICAgY29weVtwXSA9IF9wYXJzZUZ1bmNPclN0cmluZyh2YXJzW3BdLCB0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cyk7XG4gIH1cblxuICByZXR1cm4gY29weTtcbn0sXG4gICAgX2NoZWNrUGx1Z2luID0gZnVuY3Rpb24gX2NoZWNrUGx1Z2luKHByb3BlcnR5LCB2YXJzLCB0d2VlbiwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cykge1xuICB2YXIgcGx1Z2luLCBwdCwgcHRMb29rdXAsIGk7XG5cbiAgaWYgKF9wbHVnaW5zW3Byb3BlcnR5XSAmJiAocGx1Z2luID0gbmV3IF9wbHVnaW5zW3Byb3BlcnR5XSgpKS5pbml0KHRhcmdldCwgcGx1Z2luLnJhd1ZhcnMgPyB2YXJzW3Byb3BlcnR5XSA6IF9wcm9jZXNzVmFycyh2YXJzW3Byb3BlcnR5XSwgaW5kZXgsIHRhcmdldCwgdGFyZ2V0cywgdHdlZW4pLCB0d2VlbiwgaW5kZXgsIHRhcmdldHMpICE9PSBmYWxzZSkge1xuICAgIHR3ZWVuLl9wdCA9IHB0ID0gbmV3IFByb3BUd2Vlbih0d2Vlbi5fcHQsIHRhcmdldCwgcHJvcGVydHksIDAsIDEsIHBsdWdpbi5yZW5kZXIsIHBsdWdpbiwgMCwgcGx1Z2luLnByaW9yaXR5KTtcblxuICAgIGlmICh0d2VlbiAhPT0gX3F1aWNrVHdlZW4pIHtcbiAgICAgIHB0TG9va3VwID0gdHdlZW4uX3B0TG9va3VwW3R3ZWVuLl90YXJnZXRzLmluZGV4T2YodGFyZ2V0KV07IC8vbm90ZTogd2UgY2FuJ3QgdXNlIHR3ZWVuLl9wdExvb2t1cFtpbmRleF0gYmVjYXVzZSBmb3Igc3RhZ2dlcmVkIHR3ZWVucywgdGhlIGluZGV4IGZyb20gdGhlIGZ1bGxUYXJnZXRzIGFycmF5IHdvbid0IG1hdGNoIHdoYXQgaXQgaXMgaW4gZWFjaCBpbmRpdmlkdWFsIHR3ZWVuIHRoYXQgc3Bhd25zIGZyb20gdGhlIHN0YWdnZXIuXG5cbiAgICAgIGkgPSBwbHVnaW4uX3Byb3BzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBwdExvb2t1cFtwbHVnaW4uX3Byb3BzW2ldXSA9IHB0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwbHVnaW47XG59LFxuICAgIF9vdmVyd3JpdGluZ1R3ZWVuLFxuICAgIC8vc3RvcmUgYSByZWZlcmVuY2UgdGVtcG9yYXJpbHkgc28gd2UgY2FuIGF2b2lkIG92ZXJ3cml0aW5nIGl0c2VsZi5cbl9pbml0VHdlZW4gPSBmdW5jdGlvbiBfaW5pdFR3ZWVuKHR3ZWVuLCB0aW1lKSB7XG4gIHZhciB2YXJzID0gdHdlZW4udmFycyxcbiAgICAgIGVhc2UgPSB2YXJzLmVhc2UsXG4gICAgICBzdGFydEF0ID0gdmFycy5zdGFydEF0LFxuICAgICAgaW1tZWRpYXRlUmVuZGVyID0gdmFycy5pbW1lZGlhdGVSZW5kZXIsXG4gICAgICBsYXp5ID0gdmFycy5sYXp5LFxuICAgICAgb25VcGRhdGUgPSB2YXJzLm9uVXBkYXRlLFxuICAgICAgb25VcGRhdGVQYXJhbXMgPSB2YXJzLm9uVXBkYXRlUGFyYW1zLFxuICAgICAgY2FsbGJhY2tTY29wZSA9IHZhcnMuY2FsbGJhY2tTY29wZSxcbiAgICAgIHJ1bkJhY2t3YXJkcyA9IHZhcnMucnVuQmFja3dhcmRzLFxuICAgICAgeW95b0Vhc2UgPSB2YXJzLnlveW9FYXNlLFxuICAgICAga2V5ZnJhbWVzID0gdmFycy5rZXlmcmFtZXMsXG4gICAgICBhdXRvUmV2ZXJ0ID0gdmFycy5hdXRvUmV2ZXJ0LFxuICAgICAgZHVyID0gdHdlZW4uX2R1cixcbiAgICAgIHByZXZTdGFydEF0ID0gdHdlZW4uX3N0YXJ0QXQsXG4gICAgICB0YXJnZXRzID0gdHdlZW4uX3RhcmdldHMsXG4gICAgICBwYXJlbnQgPSB0d2Vlbi5wYXJlbnQsXG4gICAgICBmdWxsVGFyZ2V0cyA9IHBhcmVudCAmJiBwYXJlbnQuZGF0YSA9PT0gXCJuZXN0ZWRcIiA/IHBhcmVudC5wYXJlbnQuX3RhcmdldHMgOiB0YXJnZXRzLFxuICAgICAgYXV0b092ZXJ3cml0ZSA9IHR3ZWVuLl9vdmVyd3JpdGUgPT09IFwiYXV0b1wiICYmICFfc3VwcHJlc3NPdmVyd3JpdGVzLFxuICAgICAgdGwgPSB0d2Vlbi50aW1lbGluZSxcbiAgICAgIGNsZWFuVmFycyxcbiAgICAgIGksXG4gICAgICBwLFxuICAgICAgcHQsXG4gICAgICB0YXJnZXQsXG4gICAgICBoYXNQcmlvcml0eSxcbiAgICAgIGdzRGF0YSxcbiAgICAgIGhhcm5lc3MsXG4gICAgICBwbHVnaW4sXG4gICAgICBwdExvb2t1cCxcbiAgICAgIGluZGV4LFxuICAgICAgaGFybmVzc1ZhcnMsXG4gICAgICBvdmVyd3JpdHRlbjtcbiAgdGwgJiYgKCFrZXlmcmFtZXMgfHwgIWVhc2UpICYmIChlYXNlID0gXCJub25lXCIpO1xuICB0d2Vlbi5fZWFzZSA9IF9wYXJzZUVhc2UoZWFzZSwgX2RlZmF1bHRzLmVhc2UpO1xuICB0d2Vlbi5feUVhc2UgPSB5b3lvRWFzZSA/IF9pbnZlcnRFYXNlKF9wYXJzZUVhc2UoeW95b0Vhc2UgPT09IHRydWUgPyBlYXNlIDogeW95b0Vhc2UsIF9kZWZhdWx0cy5lYXNlKSkgOiAwO1xuXG4gIGlmICh5b3lvRWFzZSAmJiB0d2Vlbi5feW95byAmJiAhdHdlZW4uX3JlcGVhdCkge1xuICAgIC8vdGhlcmUgbXVzdCBoYXZlIGJlZW4gYSBwYXJlbnQgdGltZWxpbmUgd2l0aCB5b3lvOnRydWUgdGhhdCBpcyBjdXJyZW50bHkgaW4gaXRzIHlveW8gcGhhc2UsIHNvIGZsaXAgdGhlIGVhc2VzLlxuICAgIHlveW9FYXNlID0gdHdlZW4uX3lFYXNlO1xuICAgIHR3ZWVuLl95RWFzZSA9IHR3ZWVuLl9lYXNlO1xuICAgIHR3ZWVuLl9lYXNlID0geW95b0Vhc2U7XG4gIH1cblxuICB0d2Vlbi5fZnJvbSA9ICF0bCAmJiAhIXZhcnMucnVuQmFja3dhcmRzOyAvL25lc3RlZCB0aW1lbGluZXMgc2hvdWxkIG5ldmVyIHJ1biBiYWNrd2FyZHMgLSB0aGUgYmFja3dhcmRzLW5lc3MgaXMgaW4gdGhlIGNoaWxkIHR3ZWVucy5cblxuICBpZiAoIXRsIHx8IGtleWZyYW1lcyAmJiAhdmFycy5zdGFnZ2VyKSB7XG4gICAgLy9pZiB0aGVyZSdzIGFuIGludGVybmFsIHRpbWVsaW5lLCBza2lwIGFsbCB0aGUgcGFyc2luZyBiZWNhdXNlIHdlIHBhc3NlZCB0aGF0IHRhc2sgZG93biB0aGUgY2hhaW4uXG4gICAgaGFybmVzcyA9IHRhcmdldHNbMF0gPyBfZ2V0Q2FjaGUodGFyZ2V0c1swXSkuaGFybmVzcyA6IDA7XG4gICAgaGFybmVzc1ZhcnMgPSBoYXJuZXNzICYmIHZhcnNbaGFybmVzcy5wcm9wXTsgLy9zb21lb25lIG1heSBuZWVkIHRvIHNwZWNpZnkgQ1NTLXNwZWNpZmljIHZhbHVlcyBBTkQgbm9uLUNTUyB2YWx1ZXMsIGxpa2UgaWYgdGhlIGVsZW1lbnQgaGFzIGFuIFwieFwiIHByb3BlcnR5IHBsdXMgaXQncyBhIHN0YW5kYXJkIERPTSBlbGVtZW50LiBXZSBhbGxvdyBwZW9wbGUgdG8gZGlzdGluZ3Vpc2ggYnkgd3JhcHBpbmcgcGx1Z2luLXNwZWNpZmljIHN0dWZmIGluIGEgY3NzOnt9IG9iamVjdCBmb3IgZXhhbXBsZS5cblxuICAgIGNsZWFuVmFycyA9IF9jb3B5RXhjbHVkaW5nKHZhcnMsIF9yZXNlcnZlZFByb3BzKTtcbiAgICBwcmV2U3RhcnRBdCAmJiBfcmVtb3ZlRnJvbVBhcmVudChwcmV2U3RhcnRBdC5yZW5kZXIoLTEsIHRydWUpKTtcblxuICAgIGlmIChzdGFydEF0KSB7XG4gICAgICBfcmVtb3ZlRnJvbVBhcmVudCh0d2Vlbi5fc3RhcnRBdCA9IFR3ZWVuLnNldCh0YXJnZXRzLCBfc2V0RGVmYXVsdHMoe1xuICAgICAgICBkYXRhOiBcImlzU3RhcnRcIixcbiAgICAgICAgb3ZlcndyaXRlOiBmYWxzZSxcbiAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgIGltbWVkaWF0ZVJlbmRlcjogdHJ1ZSxcbiAgICAgICAgbGF6eTogX2lzTm90RmFsc2UobGF6eSksXG4gICAgICAgIHN0YXJ0QXQ6IG51bGwsXG4gICAgICAgIGRlbGF5OiAwLFxuICAgICAgICBvblVwZGF0ZTogb25VcGRhdGUsXG4gICAgICAgIG9uVXBkYXRlUGFyYW1zOiBvblVwZGF0ZVBhcmFtcyxcbiAgICAgICAgY2FsbGJhY2tTY29wZTogY2FsbGJhY2tTY29wZSxcbiAgICAgICAgc3RhZ2dlcjogMFxuICAgICAgfSwgc3RhcnRBdCkpKTsgLy9jb3B5IHRoZSBwcm9wZXJ0aWVzL3ZhbHVlcyBpbnRvIGEgbmV3IG9iamVjdCB0byBhdm9pZCBjb2xsaXNpb25zLCBsaWtlIHZhciB0byA9IHt4OjB9LCBmcm9tID0ge3g6NTAwfTsgdGltZWxpbmUuZnJvbVRvKGUsIGZyb20sIHRvKS5mcm9tVG8oZSwgdG8sIGZyb20pO1xuXG5cbiAgICAgIHRpbWUgPCAwICYmICFpbW1lZGlhdGVSZW5kZXIgJiYgIWF1dG9SZXZlcnQgJiYgdHdlZW4uX3N0YXJ0QXQucmVuZGVyKC0xLCB0cnVlKTsgLy8gcmFyZSBlZGdlIGNhc2UsIGxpa2UgaWYgYSByZW5kZXIgaXMgZm9yY2VkIGluIHRoZSBuZWdhdGl2ZSBkaXJlY3Rpb24gb2YgYSBub24taW5pdHRlZCB0d2Vlbi5cblxuICAgICAgaWYgKGltbWVkaWF0ZVJlbmRlcikge1xuICAgICAgICB0aW1lID4gMCAmJiAhYXV0b1JldmVydCAmJiAodHdlZW4uX3N0YXJ0QXQgPSAwKTsgLy90d2VlbnMgdGhhdCByZW5kZXIgaW1tZWRpYXRlbHkgKGxpa2UgbW9zdCBmcm9tKCkgYW5kIGZyb21UbygpIHR3ZWVucykgc2hvdWxkbid0IHJldmVydCB3aGVuIHRoZWlyIHBhcmVudCB0aW1lbGluZSdzIHBsYXloZWFkIGdvZXMgYmFja3dhcmQgcGFzdCB0aGUgc3RhcnRUaW1lIGJlY2F1c2UgdGhlIGluaXRpYWwgcmVuZGVyIGNvdWxkIGhhdmUgaGFwcGVuZWQgYW55dGltZSBhbmQgaXQgc2hvdWxkbid0IGJlIGRpcmVjdGx5IGNvcnJlbGF0ZWQgdG8gdGhpcyB0d2VlbidzIHN0YXJ0VGltZS4gSW1hZ2luZSBzZXR0aW5nIHVwIGEgY29tcGxleCBhbmltYXRpb24gd2hlcmUgdGhlIGJlZ2lubmluZyBzdGF0ZXMgb2YgdmFyaW91cyBvYmplY3RzIGFyZSByZW5kZXJlZCBpbW1lZGlhdGVseSBidXQgdGhlIHR3ZWVuIGRvZXNuJ3QgaGFwcGVuIGZvciBxdWl0ZSBzb21lIHRpbWUgLSBpZiB3ZSByZXZlcnQgdG8gdGhlIHN0YXJ0aW5nIHZhbHVlcyBhcyBzb29uIGFzIHRoZSBwbGF5aGVhZCBnb2VzIGJhY2t3YXJkIHBhc3QgdGhlIHR3ZWVuJ3Mgc3RhcnRUaW1lLCBpdCB3aWxsIHRocm93IHRoaW5ncyBvZmYgdmlzdWFsbHkuIFJldmVyc2lvbiBzaG91bGQgb25seSBoYXBwZW4gaW4gVGltZWxpbmUgaW5zdGFuY2VzIHdoZXJlIGltbWVkaWF0ZVJlbmRlciB3YXMgZmFsc2Ugb3Igd2hlbiBhdXRvUmV2ZXJ0IGlzIGV4cGxpY2l0bHkgc2V0IHRvIHRydWUuXG5cbiAgICAgICAgaWYgKGR1ciAmJiB0aW1lIDw9IDApIHtcbiAgICAgICAgICB0aW1lICYmICh0d2Vlbi5felRpbWUgPSB0aW1lKTtcbiAgICAgICAgICByZXR1cm47IC8vd2Ugc2tpcCBpbml0aWFsaXphdGlvbiBoZXJlIHNvIHRoYXQgb3ZlcndyaXRpbmcgZG9lc24ndCBvY2N1ciB1bnRpbCB0aGUgdHdlZW4gYWN0dWFsbHkgYmVnaW5zLiBPdGhlcndpc2UsIGlmIHlvdSBjcmVhdGUgc2V2ZXJhbCBpbW1lZGlhdGVSZW5kZXI6dHJ1ZSB0d2VlbnMgb2YgdGhlIHNhbWUgdGFyZ2V0L3Byb3BlcnRpZXMgdG8gZHJvcCBpbnRvIGEgVGltZWxpbmUsIHRoZSBsYXN0IG9uZSBjcmVhdGVkIHdvdWxkIG92ZXJ3cml0ZSB0aGUgZmlyc3Qgb25lcyBiZWNhdXNlIHRoZXkgZGlkbid0IGdldCBwbGFjZWQgaW50byB0aGUgdGltZWxpbmUgeWV0IGJlZm9yZSB0aGUgZmlyc3QgcmVuZGVyIG9jY3VycyBhbmQga2lja3MgaW4gb3ZlcndyaXRpbmcuXG4gICAgICAgIH0gLy8gaWYgKHRpbWUgPiAwKSB7XG4gICAgICAgIC8vIFx0YXV0b1JldmVydCB8fCAodHdlZW4uX3N0YXJ0QXQgPSAwKTsgLy90d2VlbnMgdGhhdCByZW5kZXIgaW1tZWRpYXRlbHkgKGxpa2UgbW9zdCBmcm9tKCkgYW5kIGZyb21UbygpIHR3ZWVucykgc2hvdWxkbid0IHJldmVydCB3aGVuIHRoZWlyIHBhcmVudCB0aW1lbGluZSdzIHBsYXloZWFkIGdvZXMgYmFja3dhcmQgcGFzdCB0aGUgc3RhcnRUaW1lIGJlY2F1c2UgdGhlIGluaXRpYWwgcmVuZGVyIGNvdWxkIGhhdmUgaGFwcGVuZWQgYW55dGltZSBhbmQgaXQgc2hvdWxkbid0IGJlIGRpcmVjdGx5IGNvcnJlbGF0ZWQgdG8gdGhpcyB0d2VlbidzIHN0YXJ0VGltZS4gSW1hZ2luZSBzZXR0aW5nIHVwIGEgY29tcGxleCBhbmltYXRpb24gd2hlcmUgdGhlIGJlZ2lubmluZyBzdGF0ZXMgb2YgdmFyaW91cyBvYmplY3RzIGFyZSByZW5kZXJlZCBpbW1lZGlhdGVseSBidXQgdGhlIHR3ZWVuIGRvZXNuJ3QgaGFwcGVuIGZvciBxdWl0ZSBzb21lIHRpbWUgLSBpZiB3ZSByZXZlcnQgdG8gdGhlIHN0YXJ0aW5nIHZhbHVlcyBhcyBzb29uIGFzIHRoZSBwbGF5aGVhZCBnb2VzIGJhY2t3YXJkIHBhc3QgdGhlIHR3ZWVuJ3Mgc3RhcnRUaW1lLCBpdCB3aWxsIHRocm93IHRoaW5ncyBvZmYgdmlzdWFsbHkuIFJldmVyc2lvbiBzaG91bGQgb25seSBoYXBwZW4gaW4gVGltZWxpbmUgaW5zdGFuY2VzIHdoZXJlIGltbWVkaWF0ZVJlbmRlciB3YXMgZmFsc2Ugb3Igd2hlbiBhdXRvUmV2ZXJ0IGlzIGV4cGxpY2l0bHkgc2V0IHRvIHRydWUuXG4gICAgICAgIC8vIH0gZWxzZSBpZiAoZHVyICYmICEodGltZSA8IDAgJiYgcHJldlN0YXJ0QXQpKSB7XG4gICAgICAgIC8vIFx0dGltZSAmJiAodHdlZW4uX3pUaW1lID0gdGltZSk7XG4gICAgICAgIC8vIFx0cmV0dXJuOyAvL3dlIHNraXAgaW5pdGlhbGl6YXRpb24gaGVyZSBzbyB0aGF0IG92ZXJ3cml0aW5nIGRvZXNuJ3Qgb2NjdXIgdW50aWwgdGhlIHR3ZWVuIGFjdHVhbGx5IGJlZ2lucy4gT3RoZXJ3aXNlLCBpZiB5b3UgY3JlYXRlIHNldmVyYWwgaW1tZWRpYXRlUmVuZGVyOnRydWUgdHdlZW5zIG9mIHRoZSBzYW1lIHRhcmdldC9wcm9wZXJ0aWVzIHRvIGRyb3AgaW50byBhIFRpbWVsaW5lLCB0aGUgbGFzdCBvbmUgY3JlYXRlZCB3b3VsZCBvdmVyd3JpdGUgdGhlIGZpcnN0IG9uZXMgYmVjYXVzZSB0aGV5IGRpZG4ndCBnZXQgcGxhY2VkIGludG8gdGhlIHRpbWVsaW5lIHlldCBiZWZvcmUgdGhlIGZpcnN0IHJlbmRlciBvY2N1cnMgYW5kIGtpY2tzIGluIG92ZXJ3cml0aW5nLlxuICAgICAgICAvLyB9XG5cbiAgICAgIH0gZWxzZSBpZiAoYXV0b1JldmVydCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdHdlZW4uX3N0YXJ0QXQgPSAwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocnVuQmFja3dhcmRzICYmIGR1cikge1xuICAgICAgLy9mcm9tKCkgdHdlZW5zIG11c3QgYmUgaGFuZGxlZCB1bmlxdWVseTogdGhlaXIgYmVnaW5uaW5nIHZhbHVlcyBtdXN0IGJlIHJlbmRlcmVkIGJ1dCB3ZSBkb24ndCB3YW50IG92ZXJ3cml0aW5nIHRvIG9jY3VyIHlldCAod2hlbiB0aW1lIGlzIHN0aWxsIDApLiBXYWl0IHVudGlsIHRoZSB0d2VlbiBhY3R1YWxseSBiZWdpbnMgYmVmb3JlIGRvaW5nIGFsbCB0aGUgcm91dGluZXMgbGlrZSBvdmVyd3JpdGluZy4gQXQgdGhhdCB0aW1lLCB3ZSBzaG91bGQgcmVuZGVyIGF0IHRoZSBFTkQgb2YgdGhlIHR3ZWVuIHRvIGVuc3VyZSB0aGF0IHRoaW5ncyBpbml0aWFsaXplIGNvcnJlY3RseSAocmVtZW1iZXIsIGZyb20oKSB0d2VlbnMgZ28gYmFja3dhcmRzKVxuICAgICAgaWYgKHByZXZTdGFydEF0KSB7XG4gICAgICAgICFhdXRvUmV2ZXJ0ICYmICh0d2Vlbi5fc3RhcnRBdCA9IDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZSAmJiAoaW1tZWRpYXRlUmVuZGVyID0gZmFsc2UpOyAvL2luIHJhcmUgY2FzZXMgKGxpa2UgaWYgYSBmcm9tKCkgdHdlZW4gcnVucyBhbmQgdGhlbiBpcyBpbnZhbGlkYXRlKCktZWQpLCBpbW1lZGlhdGVSZW5kZXIgY291bGQgYmUgdHJ1ZSBidXQgdGhlIGluaXRpYWwgZm9yY2VkLXJlbmRlciBnZXRzIHNraXBwZWQsIHNvIHRoZXJlJ3Mgbm8gbmVlZCB0byBmb3JjZSB0aGUgcmVuZGVyIGluIHRoaXMgY29udGV4dCB3aGVuIHRoZSBfdGltZSBpcyBncmVhdGVyIHRoYW4gMFxuXG4gICAgICAgIHAgPSBfc2V0RGVmYXVsdHMoe1xuICAgICAgICAgIG92ZXJ3cml0ZTogZmFsc2UsXG4gICAgICAgICAgZGF0YTogXCJpc0Zyb21TdGFydFwiLFxuICAgICAgICAgIC8vd2UgdGFnIHRoZSB0d2VlbiB3aXRoIGFzIFwiaXNGcm9tU3RhcnRcIiBzbyB0aGF0IGlmIFtpbnNpZGUgYSBwbHVnaW5dIHdlIG5lZWQgdG8gb25seSBkbyBzb21ldGhpbmcgYXQgdGhlIHZlcnkgRU5EIG9mIGEgdHdlZW4sIHdlIGhhdmUgYSB3YXkgb2YgaWRlbnRpZnlpbmcgdGhpcyB0d2VlbiBhcyBtZXJlbHkgdGhlIG9uZSB0aGF0J3Mgc2V0dGluZyB0aGUgYmVnaW5uaW5nIHZhbHVlcyBmb3IgYSBcImZyb20oKVwiIHR3ZWVuLiBGb3IgZXhhbXBsZSwgY2xlYXJQcm9wcyBpbiBDU1NQbHVnaW4gc2hvdWxkIG9ubHkgZ2V0IGFwcGxpZWQgYXQgdGhlIHZlcnkgRU5EIG9mIGEgdHdlZW4gYW5kIHdpdGhvdXQgdGhpcyB0YWcsIGZyb20oLi4ue2hlaWdodDoxMDAsIGNsZWFyUHJvcHM6XCJoZWlnaHRcIiwgZGVsYXk6MX0pIHdvdWxkIHdpcGUgdGhlIGhlaWdodCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0d2VlbiBhbmQgYWZ0ZXIgMSBzZWNvbmQsIGl0J2Qga2ljayBiYWNrIGluLlxuICAgICAgICAgIGxhenk6IGltbWVkaWF0ZVJlbmRlciAmJiBfaXNOb3RGYWxzZShsYXp5KSxcbiAgICAgICAgICBpbW1lZGlhdGVSZW5kZXI6IGltbWVkaWF0ZVJlbmRlcixcbiAgICAgICAgICAvL3plcm8tZHVyYXRpb24gdHdlZW5zIHJlbmRlciBpbW1lZGlhdGVseSBieSBkZWZhdWx0LCBidXQgaWYgd2UncmUgbm90IHNwZWNpZmljYWxseSBpbnN0cnVjdGVkIHRvIHJlbmRlciB0aGlzIHR3ZWVuIGltbWVkaWF0ZWx5LCB3ZSBzaG91bGQgc2tpcCB0aGlzIGFuZCBtZXJlbHkgX2luaXQoKSB0byByZWNvcmQgdGhlIHN0YXJ0aW5nIHZhbHVlcyAocmVuZGVyaW5nIHRoZW0gaW1tZWRpYXRlbHkgd291bGQgcHVzaCB0aGVtIHRvIGNvbXBsZXRpb24gd2hpY2ggaXMgd2FzdGVmdWwgaW4gdGhhdCBjYXNlIC0gd2UnZCBoYXZlIHRvIHJlbmRlcigtMSkgaW1tZWRpYXRlbHkgYWZ0ZXIpXG4gICAgICAgICAgc3RhZ2dlcjogMCxcbiAgICAgICAgICBwYXJlbnQ6IHBhcmVudCAvL2Vuc3VyZXMgdGhhdCBuZXN0ZWQgdHdlZW5zIHRoYXQgaGFkIGEgc3RhZ2dlciBhcmUgaGFuZGxlZCBwcm9wZXJseSwgbGlrZSBnc2FwLmZyb20oXCIuY2xhc3NcIiwge3k6Z3NhcC51dGlscy53cmFwKFstMTAwLDEwMF0pfSlcblxuICAgICAgICB9LCBjbGVhblZhcnMpO1xuICAgICAgICBoYXJuZXNzVmFycyAmJiAocFtoYXJuZXNzLnByb3BdID0gaGFybmVzc1ZhcnMpOyAvLyBpbiBjYXNlIHNvbWVvbmUgZG9lcyBzb21ldGhpbmcgbGlrZSAuZnJvbSguLi4sIHtjc3M6e319KVxuXG4gICAgICAgIF9yZW1vdmVGcm9tUGFyZW50KHR3ZWVuLl9zdGFydEF0ID0gVHdlZW4uc2V0KHRhcmdldHMsIHApKTtcblxuICAgICAgICB0aW1lIDwgMCAmJiB0d2Vlbi5fc3RhcnRBdC5yZW5kZXIoLTEsIHRydWUpOyAvLyByYXJlIGVkZ2UgY2FzZSwgbGlrZSBpZiBhIHJlbmRlciBpcyBmb3JjZWQgaW4gdGhlIG5lZ2F0aXZlIGRpcmVjdGlvbiBvZiBhIG5vbi1pbml0dGVkIGZyb20oKSB0d2Vlbi5cblxuICAgICAgICB0d2Vlbi5felRpbWUgPSB0aW1lO1xuXG4gICAgICAgIGlmICghaW1tZWRpYXRlUmVuZGVyKSB7XG4gICAgICAgICAgX2luaXRUd2Vlbih0d2Vlbi5fc3RhcnRBdCwgX3RpbnlOdW0pOyAvL2Vuc3VyZXMgdGhhdCB0aGUgaW5pdGlhbCB2YWx1ZXMgYXJlIHJlY29yZGVkXG5cbiAgICAgICAgfSBlbHNlIGlmICghdGltZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHR3ZWVuLl9wdCA9IDA7XG4gICAgbGF6eSA9IGR1ciAmJiBfaXNOb3RGYWxzZShsYXp5KSB8fCBsYXp5ICYmICFkdXI7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdGFyZ2V0ID0gdGFyZ2V0c1tpXTtcbiAgICAgIGdzRGF0YSA9IHRhcmdldC5fZ3NhcCB8fCBfaGFybmVzcyh0YXJnZXRzKVtpXS5fZ3NhcDtcbiAgICAgIHR3ZWVuLl9wdExvb2t1cFtpXSA9IHB0TG9va3VwID0ge307XG4gICAgICBfbGF6eUxvb2t1cFtnc0RhdGEuaWRdICYmIF9sYXp5VHdlZW5zLmxlbmd0aCAmJiBfbGF6eVJlbmRlcigpOyAvL2lmIG90aGVyIHR3ZWVucyBvZiB0aGUgc2FtZSB0YXJnZXQgaGF2ZSByZWNlbnRseSBpbml0dGVkIGJ1dCBoYXZlbid0IHJlbmRlcmVkIHlldCwgd2UndmUgZ290IHRvIGZvcmNlIHRoZSByZW5kZXIgc28gdGhhdCB0aGUgc3RhcnRpbmcgdmFsdWVzIGFyZSBjb3JyZWN0IChpbWFnaW5lIHBvcHVsYXRpbmcgYSB0aW1lbGluZSB3aXRoIGEgYnVuY2ggb2Ygc2VxdWVudGlhbCB0d2VlbnMgYW5kIHRoZW4ganVtcGluZyB0byB0aGUgZW5kKVxuXG4gICAgICBpbmRleCA9IGZ1bGxUYXJnZXRzID09PSB0YXJnZXRzID8gaSA6IGZ1bGxUYXJnZXRzLmluZGV4T2YodGFyZ2V0KTtcblxuICAgICAgaWYgKGhhcm5lc3MgJiYgKHBsdWdpbiA9IG5ldyBoYXJuZXNzKCkpLmluaXQodGFyZ2V0LCBoYXJuZXNzVmFycyB8fCBjbGVhblZhcnMsIHR3ZWVuLCBpbmRleCwgZnVsbFRhcmdldHMpICE9PSBmYWxzZSkge1xuICAgICAgICB0d2Vlbi5fcHQgPSBwdCA9IG5ldyBQcm9wVHdlZW4odHdlZW4uX3B0LCB0YXJnZXQsIHBsdWdpbi5uYW1lLCAwLCAxLCBwbHVnaW4ucmVuZGVyLCBwbHVnaW4sIDAsIHBsdWdpbi5wcmlvcml0eSk7XG5cbiAgICAgICAgcGx1Z2luLl9wcm9wcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgcHRMb29rdXBbbmFtZV0gPSBwdDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcGx1Z2luLnByaW9yaXR5ICYmIChoYXNQcmlvcml0eSA9IDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWhhcm5lc3MgfHwgaGFybmVzc1ZhcnMpIHtcbiAgICAgICAgZm9yIChwIGluIGNsZWFuVmFycykge1xuICAgICAgICAgIGlmIChfcGx1Z2luc1twXSAmJiAocGx1Z2luID0gX2NoZWNrUGx1Z2luKHAsIGNsZWFuVmFycywgdHdlZW4sIGluZGV4LCB0YXJnZXQsIGZ1bGxUYXJnZXRzKSkpIHtcbiAgICAgICAgICAgIHBsdWdpbi5wcmlvcml0eSAmJiAoaGFzUHJpb3JpdHkgPSAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHRMb29rdXBbcF0gPSBwdCA9IF9hZGRQcm9wVHdlZW4uY2FsbCh0d2VlbiwgdGFyZ2V0LCBwLCBcImdldFwiLCBjbGVhblZhcnNbcF0sIGluZGV4LCBmdWxsVGFyZ2V0cywgMCwgdmFycy5zdHJpbmdGaWx0ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0d2Vlbi5fb3AgJiYgdHdlZW4uX29wW2ldICYmIHR3ZWVuLmtpbGwodGFyZ2V0LCB0d2Vlbi5fb3BbaV0pO1xuXG4gICAgICBpZiAoYXV0b092ZXJ3cml0ZSAmJiB0d2Vlbi5fcHQpIHtcbiAgICAgICAgX292ZXJ3cml0aW5nVHdlZW4gPSB0d2VlbjtcblxuICAgICAgICBfZ2xvYmFsVGltZWxpbmUua2lsbFR3ZWVuc09mKHRhcmdldCwgcHRMb29rdXAsIHR3ZWVuLmdsb2JhbFRpbWUodGltZSkpOyAvLyBtYWtlIHN1cmUgdGhlIG92ZXJ3cml0aW5nIGRvZXNuJ3Qgb3ZlcndyaXRlIFRISVMgdHdlZW4hISFcblxuXG4gICAgICAgIG92ZXJ3cml0dGVuID0gIXR3ZWVuLnBhcmVudDtcbiAgICAgICAgX292ZXJ3cml0aW5nVHdlZW4gPSAwO1xuICAgICAgfVxuXG4gICAgICB0d2Vlbi5fcHQgJiYgbGF6eSAmJiAoX2xhenlMb29rdXBbZ3NEYXRhLmlkXSA9IDEpO1xuICAgIH1cblxuICAgIGhhc1ByaW9yaXR5ICYmIF9zb3J0UHJvcFR3ZWVuc0J5UHJpb3JpdHkodHdlZW4pO1xuICAgIHR3ZWVuLl9vbkluaXQgJiYgdHdlZW4uX29uSW5pdCh0d2Vlbik7IC8vcGx1Z2lucyBsaWtlIFJvdW5kUHJvcHMgbXVzdCB3YWl0IHVudGlsIEFMTCBvZiB0aGUgUHJvcFR3ZWVucyBhcmUgaW5zdGFudGlhdGVkLiBJbiB0aGUgcGx1Z2luJ3MgaW5pdCgpIGZ1bmN0aW9uLCBpdCBzZXRzIHRoZSBfb25Jbml0IG9uIHRoZSB0d2VlbiBpbnN0YW5jZS4gTWF5IG5vdCBiZSBwcmV0dHkvaW50dWl0aXZlLCBidXQgaXQncyBmYXN0IGFuZCBrZWVwcyBmaWxlIHNpemUgZG93bi5cbiAgfVxuXG4gIHR3ZWVuLl9vblVwZGF0ZSA9IG9uVXBkYXRlO1xuICB0d2Vlbi5faW5pdHRlZCA9ICghdHdlZW4uX29wIHx8IHR3ZWVuLl9wdCkgJiYgIW92ZXJ3cml0dGVuOyAvLyBpZiBvdmVyd3JpdHRlblByb3BzIHJlc3VsdGVkIGluIHRoZSBlbnRpcmUgdHdlZW4gYmVpbmcga2lsbGVkLCBkbyBOT1QgZmxhZyBpdCBhcyBpbml0dGVkIG9yIGVsc2UgaXQgbWF5IHJlbmRlciBmb3Igb25lIHRpY2suXG5cbiAga2V5ZnJhbWVzICYmIHRpbWUgPD0gMCAmJiB0bC5yZW5kZXIoX2JpZ051bSwgdHJ1ZSwgdHJ1ZSk7IC8vIGlmIHRoZXJlJ3MgYSAwJSBrZXlmcmFtZSwgaXQnbGwgcmVuZGVyIGluIHRoZSBcImJlZm9yZVwiIHN0YXRlIGZvciBhbnkgc3RhZ2dlcmVkL2RlbGF5ZWQgYW5pbWF0aW9ucyB0aHVzIHdoZW4gdGhlIGZvbGxvd2luZyB0d2VlbiBpbml0aWFsaXplcywgaXQnbGwgdXNlIHRoZSBcImJlZm9yZVwiIHN0YXRlIGluc3RlYWQgb2YgdGhlIFwiYWZ0ZXJcIiBzdGF0ZSBhcyB0aGUgaW5pdGlhbCB2YWx1ZXMuXG59LFxuICAgIF9hZGRBbGlhc2VzVG9WYXJzID0gZnVuY3Rpb24gX2FkZEFsaWFzZXNUb1ZhcnModGFyZ2V0cywgdmFycykge1xuICB2YXIgaGFybmVzcyA9IHRhcmdldHNbMF0gPyBfZ2V0Q2FjaGUodGFyZ2V0c1swXSkuaGFybmVzcyA6IDAsXG4gICAgICBwcm9wZXJ0eUFsaWFzZXMgPSBoYXJuZXNzICYmIGhhcm5lc3MuYWxpYXNlcyxcbiAgICAgIGNvcHksXG4gICAgICBwLFxuICAgICAgaSxcbiAgICAgIGFsaWFzZXM7XG5cbiAgaWYgKCFwcm9wZXJ0eUFsaWFzZXMpIHtcbiAgICByZXR1cm4gdmFycztcbiAgfVxuXG4gIGNvcHkgPSBfbWVyZ2Uoe30sIHZhcnMpO1xuXG4gIGZvciAocCBpbiBwcm9wZXJ0eUFsaWFzZXMpIHtcbiAgICBpZiAocCBpbiBjb3B5KSB7XG4gICAgICBhbGlhc2VzID0gcHJvcGVydHlBbGlhc2VzW3BdLnNwbGl0KFwiLFwiKTtcbiAgICAgIGkgPSBhbGlhc2VzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb3B5W2FsaWFzZXNbaV1dID0gY29weVtwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29weTtcbn0sXG4gICAgLy8gcGFyc2VzIG11bHRpcGxlIGZvcm1hdHMsIGxpa2Uge1wiMCVcIjoge3g6IDEwMH0sIHtcIjUwJVwiOiB7eDogLTIwfX0gYW5kIHsgeDoge1wiMCVcIjogMTAwLCBcIjUwJVwiOiAtMjB9IH0sIGFuZCBhbiBcImVhc2VcIiBjYW4gYmUgc2V0IG9uIGFueSBvYmplY3QuIFdlIHBvcHVsYXRlIGFuIFwiYWxsUHJvcHNcIiBvYmplY3Qgd2l0aCBhbiBBcnJheSBmb3IgZWFjaCBwcm9wZXJ0eSwgbGlrZSB7eDogW3t9LCB7fV0sIHk6W3t9LCB7fV19IHdpdGggZGF0YSBmb3IgZWFjaCBwcm9wZXJ0eSB0d2Vlbi4gVGhlIG9iamVjdHMgaGF2ZSBhIFwidFwiICh0aW1lKSwgXCJ2XCIsICh2YWx1ZSksIGFuZCBcImVcIiAoZWFzZSkgcHJvcGVydHkuIFRoaXMgYWxsb3dzIHVzIHRvIHBpZWNlIHRvZ2V0aGVyIGEgdGltZWxpbmUgbGF0ZXIuXG5fcGFyc2VLZXlmcmFtZSA9IGZ1bmN0aW9uIF9wYXJzZUtleWZyYW1lKHByb3AsIG9iaiwgYWxsUHJvcHMsIGVhc2VFYWNoKSB7XG4gIHZhciBlYXNlID0gb2JqLmVhc2UgfHwgZWFzZUVhY2ggfHwgXCJwb3dlcjEuaW5PdXRcIixcbiAgICAgIHAsXG4gICAgICBhO1xuXG4gIGlmIChfaXNBcnJheShvYmopKSB7XG4gICAgYSA9IGFsbFByb3BzW3Byb3BdIHx8IChhbGxQcm9wc1twcm9wXSA9IFtdKTsgLy8gdCA9IHRpbWUgKG91dCBvZiAxMDApLCB2ID0gdmFsdWUsIGUgPSBlYXNlXG5cbiAgICBvYmouZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGkpIHtcbiAgICAgIHJldHVybiBhLnB1c2goe1xuICAgICAgICB0OiBpIC8gKG9iai5sZW5ndGggLSAxKSAqIDEwMCxcbiAgICAgICAgdjogdmFsdWUsXG4gICAgICAgIGU6IGVhc2VcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGZvciAocCBpbiBvYmopIHtcbiAgICAgIGEgPSBhbGxQcm9wc1twXSB8fCAoYWxsUHJvcHNbcF0gPSBbXSk7XG4gICAgICBwID09PSBcImVhc2VcIiB8fCBhLnB1c2goe1xuICAgICAgICB0OiBwYXJzZUZsb2F0KHByb3ApLFxuICAgICAgICB2OiBvYmpbcF0sXG4gICAgICAgIGU6IGVhc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufSxcbiAgICBfcGFyc2VGdW5jT3JTdHJpbmcgPSBmdW5jdGlvbiBfcGFyc2VGdW5jT3JTdHJpbmcodmFsdWUsIHR3ZWVuLCBpLCB0YXJnZXQsIHRhcmdldHMpIHtcbiAgcmV0dXJuIF9pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwodHdlZW4sIGksIHRhcmdldCwgdGFyZ2V0cykgOiBfaXNTdHJpbmcodmFsdWUpICYmIH52YWx1ZS5pbmRleE9mKFwicmFuZG9tKFwiKSA/IF9yZXBsYWNlUmFuZG9tKHZhbHVlKSA6IHZhbHVlO1xufSxcbiAgICBfc3RhZ2dlclR3ZWVuUHJvcHMgPSBfY2FsbGJhY2tOYW1lcyArIFwicmVwZWF0LHJlcGVhdERlbGF5LHlveW8scmVwZWF0UmVmcmVzaCx5b3lvRWFzZVwiLFxuICAgIF9zdGFnZ2VyUHJvcHNUb1NraXAgPSB7fTtcblxuX2ZvckVhY2hOYW1lKF9zdGFnZ2VyVHdlZW5Qcm9wcyArIFwiLGlkLHN0YWdnZXIsZGVsYXksZHVyYXRpb24scGF1c2VkLHNjcm9sbFRyaWdnZXJcIiwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIF9zdGFnZ2VyUHJvcHNUb1NraXBbbmFtZV0gPSAxO1xufSk7XG4vKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIFRXRUVOXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cblxuZXhwb3J0IHZhciBUd2VlbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0FuaW1hdGlvbjIpIHtcbiAgX2luaGVyaXRzTG9vc2UoVHdlZW4sIF9BbmltYXRpb24yKTtcblxuICBmdW5jdGlvbiBUd2Vlbih0YXJnZXRzLCB2YXJzLCBwb3NpdGlvbiwgc2tpcEluaGVyaXQpIHtcbiAgICB2YXIgX3RoaXMzO1xuXG4gICAgaWYgKHR5cGVvZiB2YXJzID09PSBcIm51bWJlclwiKSB7XG4gICAgICBwb3NpdGlvbi5kdXJhdGlvbiA9IHZhcnM7XG4gICAgICB2YXJzID0gcG9zaXRpb247XG4gICAgICBwb3NpdGlvbiA9IG51bGw7XG4gICAgfVxuXG4gICAgX3RoaXMzID0gX0FuaW1hdGlvbjIuY2FsbCh0aGlzLCBza2lwSW5oZXJpdCA/IHZhcnMgOiBfaW5oZXJpdERlZmF1bHRzKHZhcnMpKSB8fCB0aGlzO1xuICAgIHZhciBfdGhpczMkdmFycyA9IF90aGlzMy52YXJzLFxuICAgICAgICBkdXJhdGlvbiA9IF90aGlzMyR2YXJzLmR1cmF0aW9uLFxuICAgICAgICBkZWxheSA9IF90aGlzMyR2YXJzLmRlbGF5LFxuICAgICAgICBpbW1lZGlhdGVSZW5kZXIgPSBfdGhpczMkdmFycy5pbW1lZGlhdGVSZW5kZXIsXG4gICAgICAgIHN0YWdnZXIgPSBfdGhpczMkdmFycy5zdGFnZ2VyLFxuICAgICAgICBvdmVyd3JpdGUgPSBfdGhpczMkdmFycy5vdmVyd3JpdGUsXG4gICAgICAgIGtleWZyYW1lcyA9IF90aGlzMyR2YXJzLmtleWZyYW1lcyxcbiAgICAgICAgZGVmYXVsdHMgPSBfdGhpczMkdmFycy5kZWZhdWx0cyxcbiAgICAgICAgc2Nyb2xsVHJpZ2dlciA9IF90aGlzMyR2YXJzLnNjcm9sbFRyaWdnZXIsXG4gICAgICAgIHlveW9FYXNlID0gX3RoaXMzJHZhcnMueW95b0Vhc2UsXG4gICAgICAgIHBhcmVudCA9IHZhcnMucGFyZW50IHx8IF9nbG9iYWxUaW1lbGluZSxcbiAgICAgICAgcGFyc2VkVGFyZ2V0cyA9IChfaXNBcnJheSh0YXJnZXRzKSB8fCBfaXNUeXBlZEFycmF5KHRhcmdldHMpID8gX2lzTnVtYmVyKHRhcmdldHNbMF0pIDogXCJsZW5ndGhcIiBpbiB2YXJzKSA/IFt0YXJnZXRzXSA6IHRvQXJyYXkodGFyZ2V0cyksXG4gICAgICAgIHRsLFxuICAgICAgICBpLFxuICAgICAgICBjb3B5LFxuICAgICAgICBsLFxuICAgICAgICBwLFxuICAgICAgICBjdXJUYXJnZXQsXG4gICAgICAgIHN0YWdnZXJGdW5jLFxuICAgICAgICBzdGFnZ2VyVmFyc1RvTWVyZ2U7XG4gICAgX3RoaXMzLl90YXJnZXRzID0gcGFyc2VkVGFyZ2V0cy5sZW5ndGggPyBfaGFybmVzcyhwYXJzZWRUYXJnZXRzKSA6IF93YXJuKFwiR1NBUCB0YXJnZXQgXCIgKyB0YXJnZXRzICsgXCIgbm90IGZvdW5kLiBodHRwczovL2dyZWVuc29jay5jb21cIiwgIV9jb25maWcubnVsbFRhcmdldFdhcm4pIHx8IFtdO1xuICAgIF90aGlzMy5fcHRMb29rdXAgPSBbXTsgLy9Qcm9wVHdlZW4gbG9va3VwLiBBbiBhcnJheSBjb250YWluaW5nIGFuIG9iamVjdCBmb3IgZWFjaCB0YXJnZXQsIGhhdmluZyBrZXlzIGZvciBlYWNoIHR3ZWVuaW5nIHByb3BlcnR5XG5cbiAgICBfdGhpczMuX292ZXJ3cml0ZSA9IG92ZXJ3cml0ZTtcblxuICAgIGlmIChrZXlmcmFtZXMgfHwgc3RhZ2dlciB8fCBfaXNGdW5jT3JTdHJpbmcoZHVyYXRpb24pIHx8IF9pc0Z1bmNPclN0cmluZyhkZWxheSkpIHtcbiAgICAgIHZhcnMgPSBfdGhpczMudmFycztcbiAgICAgIHRsID0gX3RoaXMzLnRpbWVsaW5lID0gbmV3IFRpbWVsaW5lKHtcbiAgICAgICAgZGF0YTogXCJuZXN0ZWRcIixcbiAgICAgICAgZGVmYXVsdHM6IGRlZmF1bHRzIHx8IHt9XG4gICAgICB9KTtcbiAgICAgIHRsLmtpbGwoKTtcbiAgICAgIHRsLnBhcmVudCA9IHRsLl9kcCA9IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKTtcbiAgICAgIHRsLl9zdGFydCA9IDA7XG5cbiAgICAgIGlmIChzdGFnZ2VyIHx8IF9pc0Z1bmNPclN0cmluZyhkdXJhdGlvbikgfHwgX2lzRnVuY09yU3RyaW5nKGRlbGF5KSkge1xuICAgICAgICBsID0gcGFyc2VkVGFyZ2V0cy5sZW5ndGg7XG4gICAgICAgIHN0YWdnZXJGdW5jID0gc3RhZ2dlciAmJiBkaXN0cmlidXRlKHN0YWdnZXIpO1xuXG4gICAgICAgIGlmIChfaXNPYmplY3Qoc3RhZ2dlcikpIHtcbiAgICAgICAgICAvL3VzZXJzIGNhbiBwYXNzIGluIGNhbGxiYWNrcyBsaWtlIG9uU3RhcnQvb25Db21wbGV0ZSBpbiB0aGUgc3RhZ2dlciBvYmplY3QuIFRoZXNlIHNob3VsZCBmaXJlIHdpdGggZWFjaCBpbmRpdmlkdWFsIHR3ZWVuLlxuICAgICAgICAgIGZvciAocCBpbiBzdGFnZ2VyKSB7XG4gICAgICAgICAgICBpZiAofl9zdGFnZ2VyVHdlZW5Qcm9wcy5pbmRleE9mKHApKSB7XG4gICAgICAgICAgICAgIHN0YWdnZXJWYXJzVG9NZXJnZSB8fCAoc3RhZ2dlclZhcnNUb01lcmdlID0ge30pO1xuICAgICAgICAgICAgICBzdGFnZ2VyVmFyc1RvTWVyZ2VbcF0gPSBzdGFnZ2VyW3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBjb3B5ID0gX2NvcHlFeGNsdWRpbmcodmFycywgX3N0YWdnZXJQcm9wc1RvU2tpcCk7XG4gICAgICAgICAgY29weS5zdGFnZ2VyID0gMDtcbiAgICAgICAgICB5b3lvRWFzZSAmJiAoY29weS55b3lvRWFzZSA9IHlveW9FYXNlKTtcbiAgICAgICAgICBzdGFnZ2VyVmFyc1RvTWVyZ2UgJiYgX21lcmdlKGNvcHksIHN0YWdnZXJWYXJzVG9NZXJnZSk7XG4gICAgICAgICAgY3VyVGFyZ2V0ID0gcGFyc2VkVGFyZ2V0c1tpXTsgLy9kb24ndCBqdXN0IGNvcHkgZHVyYXRpb24gb3IgZGVsYXkgYmVjYXVzZSBpZiB0aGV5J3JlIGEgc3RyaW5nIG9yIGZ1bmN0aW9uLCB3ZSdkIGVuZCB1cCBpbiBhbiBpbmZpbml0ZSBsb29wIGJlY2F1c2UgX2lzRnVuY09yU3RyaW5nKCkgd291bGQgZXZhbHVhdGUgYXMgdHJ1ZSBpbiB0aGUgY2hpbGQgdHdlZW5zLCBlbnRlcmluZyB0aGlzIGxvb3AsIGV0Yy4gU28gd2UgcGFyc2UgdGhlIHZhbHVlIHN0cmFpZ2h0IGZyb20gdmFycyBhbmQgZGVmYXVsdCB0byAwLlxuXG4gICAgICAgICAgY29weS5kdXJhdGlvbiA9ICtfcGFyc2VGdW5jT3JTdHJpbmcoZHVyYXRpb24sIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKSwgaSwgY3VyVGFyZ2V0LCBwYXJzZWRUYXJnZXRzKTtcbiAgICAgICAgICBjb3B5LmRlbGF5ID0gKCtfcGFyc2VGdW5jT3JTdHJpbmcoZGVsYXksIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKSwgaSwgY3VyVGFyZ2V0LCBwYXJzZWRUYXJnZXRzKSB8fCAwKSAtIF90aGlzMy5fZGVsYXk7XG5cbiAgICAgICAgICBpZiAoIXN0YWdnZXIgJiYgbCA9PT0gMSAmJiBjb3B5LmRlbGF5KSB7XG4gICAgICAgICAgICAvLyBpZiBzb21lb25lIGRvZXMgZGVsYXk6XCJyYW5kb20oMSwgNSlcIiwgcmVwZWF0Oi0xLCBmb3IgZXhhbXBsZSwgdGhlIGRlbGF5IHNob3VsZG4ndCBiZSBpbnNpZGUgdGhlIHJlcGVhdC5cbiAgICAgICAgICAgIF90aGlzMy5fZGVsYXkgPSBkZWxheSA9IGNvcHkuZGVsYXk7XG4gICAgICAgICAgICBfdGhpczMuX3N0YXJ0ICs9IGRlbGF5O1xuICAgICAgICAgICAgY29weS5kZWxheSA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGwudG8oY3VyVGFyZ2V0LCBjb3B5LCBzdGFnZ2VyRnVuYyA/IHN0YWdnZXJGdW5jKGksIGN1clRhcmdldCwgcGFyc2VkVGFyZ2V0cykgOiAwKTtcbiAgICAgICAgICB0bC5fZWFzZSA9IF9lYXNlTWFwLm5vbmU7XG4gICAgICAgIH1cblxuICAgICAgICB0bC5kdXJhdGlvbigpID8gZHVyYXRpb24gPSBkZWxheSA9IDAgOiBfdGhpczMudGltZWxpbmUgPSAwOyAvLyBpZiB0aGUgdGltZWxpbmUncyBkdXJhdGlvbiBpcyAwLCB3ZSBkb24ndCBuZWVkIGEgdGltZWxpbmUgaW50ZXJuYWxseSFcbiAgICAgIH0gZWxzZSBpZiAoa2V5ZnJhbWVzKSB7XG4gICAgICAgIF9pbmhlcml0RGVmYXVsdHMoX3NldERlZmF1bHRzKHRsLnZhcnMuZGVmYXVsdHMsIHtcbiAgICAgICAgICBlYXNlOiBcIm5vbmVcIlxuICAgICAgICB9KSk7XG5cbiAgICAgICAgdGwuX2Vhc2UgPSBfcGFyc2VFYXNlKGtleWZyYW1lcy5lYXNlIHx8IHZhcnMuZWFzZSB8fCBcIm5vbmVcIik7XG4gICAgICAgIHZhciB0aW1lID0gMCxcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBrZixcbiAgICAgICAgICAgIHY7XG5cbiAgICAgICAgaWYgKF9pc0FycmF5KGtleWZyYW1lcykpIHtcbiAgICAgICAgICBrZXlmcmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZnJhbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0bC50byhwYXJzZWRUYXJnZXRzLCBmcmFtZSwgXCI+XCIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvcHkgPSB7fTtcblxuICAgICAgICAgIGZvciAocCBpbiBrZXlmcmFtZXMpIHtcbiAgICAgICAgICAgIHAgPT09IFwiZWFzZVwiIHx8IHAgPT09IFwiZWFzZUVhY2hcIiB8fCBfcGFyc2VLZXlmcmFtZShwLCBrZXlmcmFtZXNbcF0sIGNvcHksIGtleWZyYW1lcy5lYXNlRWFjaCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChwIGluIGNvcHkpIHtcbiAgICAgICAgICAgIGEgPSBjb3B5W3BdLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGEudCAtIGIudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGltZSA9IDA7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGtmID0gYVtpXTtcbiAgICAgICAgICAgICAgdiA9IHtcbiAgICAgICAgICAgICAgICBlYXNlOiBrZi5lLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAoa2YudCAtIChpID8gYVtpIC0gMV0udCA6IDApKSAvIDEwMCAqIGR1cmF0aW9uXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIHZbcF0gPSBrZi52O1xuICAgICAgICAgICAgICB0bC50byhwYXJzZWRUYXJnZXRzLCB2LCB0aW1lKTtcbiAgICAgICAgICAgICAgdGltZSArPSB2LmR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRsLmR1cmF0aW9uKCkgPCBkdXJhdGlvbiAmJiB0bC50byh7fSwge1xuICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uIC0gdGwuZHVyYXRpb24oKVxuICAgICAgICAgIH0pOyAvLyBpbiBjYXNlIGtleWZyYW1lcyBkaWRuJ3QgZ28gdG8gMTAwJVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGR1cmF0aW9uIHx8IF90aGlzMy5kdXJhdGlvbihkdXJhdGlvbiA9IHRsLmR1cmF0aW9uKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpczMudGltZWxpbmUgPSAwOyAvL3NwZWVkIG9wdGltaXphdGlvbiwgZmFzdGVyIGxvb2t1cHMgKG5vIGdvaW5nIHVwIHRoZSBwcm90b3R5cGUgY2hhaW4pXG4gICAgfVxuXG4gICAgaWYgKG92ZXJ3cml0ZSA9PT0gdHJ1ZSAmJiAhX3N1cHByZXNzT3ZlcndyaXRlcykge1xuICAgICAgX292ZXJ3cml0aW5nVHdlZW4gPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMyk7XG5cbiAgICAgIF9nbG9iYWxUaW1lbGluZS5raWxsVHdlZW5zT2YocGFyc2VkVGFyZ2V0cyk7XG5cbiAgICAgIF9vdmVyd3JpdGluZ1R3ZWVuID0gMDtcbiAgICB9XG5cbiAgICBfYWRkVG9UaW1lbGluZShwYXJlbnQsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKSwgcG9zaXRpb24pO1xuXG4gICAgdmFycy5yZXZlcnNlZCAmJiBfdGhpczMucmV2ZXJzZSgpO1xuICAgIHZhcnMucGF1c2VkICYmIF90aGlzMy5wYXVzZWQodHJ1ZSk7XG5cbiAgICBpZiAoaW1tZWRpYXRlUmVuZGVyIHx8ICFkdXJhdGlvbiAmJiAha2V5ZnJhbWVzICYmIF90aGlzMy5fc3RhcnQgPT09IF9yb3VuZFByZWNpc2UocGFyZW50Ll90aW1lKSAmJiBfaXNOb3RGYWxzZShpbW1lZGlhdGVSZW5kZXIpICYmIF9oYXNOb1BhdXNlZEFuY2VzdG9ycyhfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzMykpICYmIHBhcmVudC5kYXRhICE9PSBcIm5lc3RlZFwiKSB7XG4gICAgICBfdGhpczMuX3RUaW1lID0gLV90aW55TnVtOyAvL2ZvcmNlcyBhIHJlbmRlciB3aXRob3V0IGhhdmluZyB0byBzZXQgdGhlIHJlbmRlcigpIFwiZm9yY2VcIiBwYXJhbWV0ZXIgdG8gdHJ1ZSBiZWNhdXNlIHdlIHdhbnQgdG8gYWxsb3cgbGF6eWluZyBieSBkZWZhdWx0ICh1c2luZyB0aGUgXCJmb3JjZVwiIHBhcmFtZXRlciBhbHdheXMgZm9yY2VzIGFuIGltbWVkaWF0ZSBmdWxsIHJlbmRlcilcblxuICAgICAgX3RoaXMzLnJlbmRlcihNYXRoLm1heCgwLCAtZGVsYXkpKTsgLy9pbiBjYXNlIGRlbGF5IGlzIG5lZ2F0aXZlXG5cbiAgICB9XG5cbiAgICBzY3JvbGxUcmlnZ2VyICYmIF9zY3JvbGxUcmlnZ2VyKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKSwgc2Nyb2xsVHJpZ2dlcik7XG4gICAgcmV0dXJuIF90aGlzMztcbiAgfVxuXG4gIHZhciBfcHJvdG8zID0gVHdlZW4ucHJvdG90eXBlO1xuXG4gIF9wcm90bzMucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKSB7XG4gICAgdmFyIHByZXZUaW1lID0gdGhpcy5fdGltZSxcbiAgICAgICAgdER1ciA9IHRoaXMuX3REdXIsXG4gICAgICAgIGR1ciA9IHRoaXMuX2R1cixcbiAgICAgICAgdFRpbWUgPSB0b3RhbFRpbWUgPiB0RHVyIC0gX3RpbnlOdW0gJiYgdG90YWxUaW1lID49IDAgPyB0RHVyIDogdG90YWxUaW1lIDwgX3RpbnlOdW0gPyAwIDogdG90YWxUaW1lLFxuICAgICAgICB0aW1lLFxuICAgICAgICBwdCxcbiAgICAgICAgaXRlcmF0aW9uLFxuICAgICAgICBjeWNsZUR1cmF0aW9uLFxuICAgICAgICBwcmV2SXRlcmF0aW9uLFxuICAgICAgICBpc1lveW8sXG4gICAgICAgIHJhdGlvLFxuICAgICAgICB0aW1lbGluZSxcbiAgICAgICAgeW95b0Vhc2U7XG5cbiAgICBpZiAoIWR1cikge1xuICAgICAgX3JlbmRlclplcm9EdXJhdGlvblR3ZWVuKHRoaXMsIHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgICB9IGVsc2UgaWYgKHRUaW1lICE9PSB0aGlzLl90VGltZSB8fCAhdG90YWxUaW1lIHx8IGZvcmNlIHx8ICF0aGlzLl9pbml0dGVkICYmIHRoaXMuX3RUaW1lIHx8IHRoaXMuX3N0YXJ0QXQgJiYgdGhpcy5felRpbWUgPCAwICE9PSB0b3RhbFRpbWUgPCAwKSB7XG4gICAgICAvL3RoaXMgc2Vuc2VzIGlmIHdlJ3JlIGNyb3NzaW5nIG92ZXIgdGhlIHN0YXJ0IHRpbWUsIGluIHdoaWNoIGNhc2Ugd2UgbXVzdCByZWNvcmQgX3pUaW1lIGFuZCBmb3JjZSB0aGUgcmVuZGVyLCBidXQgd2UgZG8gaXQgaW4gdGhpcyBsZW5ndGh5IGNvbmRpdGlvbmFsIHdheSBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyAodXN1YWxseSB3ZSBjYW4gc2tpcCB0aGUgY2FsY3VsYXRpb25zKTogdGhpcy5faW5pdHRlZCAmJiAodGhpcy5felRpbWUgPCAwKSAhPT0gKHRvdGFsVGltZSA8IDApXG4gICAgICB0aW1lID0gdFRpbWU7XG4gICAgICB0aW1lbGluZSA9IHRoaXMudGltZWxpbmU7XG5cbiAgICAgIGlmICh0aGlzLl9yZXBlYXQpIHtcbiAgICAgICAgLy9hZGp1c3QgdGhlIHRpbWUgZm9yIHJlcGVhdHMgYW5kIHlveW9zXG4gICAgICAgIGN5Y2xlRHVyYXRpb24gPSBkdXIgKyB0aGlzLl9yRGVsYXk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3JlcGVhdCA8IC0xICYmIHRvdGFsVGltZSA8IDApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50b3RhbFRpbWUoY3ljbGVEdXJhdGlvbiAqIDEwMCArIHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRpbWUgPSBfcm91bmRQcmVjaXNlKHRUaW1lICUgY3ljbGVEdXJhdGlvbik7IC8vcm91bmQgdG8gYXZvaWQgZmxvYXRpbmcgcG9pbnQgZXJyb3JzLiAoNCAlIDAuOCBzaG91bGQgYmUgMCBidXQgc29tZSBicm93c2VycyByZXBvcnQgaXQgYXMgMC43OTk5OTk5OSEpXG5cbiAgICAgICAgaWYgKHRUaW1lID09PSB0RHVyKSB7XG4gICAgICAgICAgLy8gdGhlIHREdXIgPT09IHRUaW1lIGlzIGZvciBlZGdlIGNhc2VzIHdoZXJlIHRoZXJlJ3MgYSBsZW5ndGh5IGRlY2ltYWwgb24gdGhlIGR1cmF0aW9uIGFuZCBpdCBtYXkgcmVhY2ggdGhlIHZlcnkgZW5kIGJ1dCB0aGUgdGltZSBpcyByZW5kZXJlZCBhcyBub3QtcXVpdGUtdGhlcmUgKHJlbWVtYmVyLCB0RHVyIGlzIHJvdW5kZWQgdG8gNCBkZWNpbWFscyB3aGVyZWFzIGR1ciBpc24ndClcbiAgICAgICAgICBpdGVyYXRpb24gPSB0aGlzLl9yZXBlYXQ7XG4gICAgICAgICAgdGltZSA9IGR1cjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVyYXRpb24gPSB+fih0VGltZSAvIGN5Y2xlRHVyYXRpb24pO1xuXG4gICAgICAgICAgaWYgKGl0ZXJhdGlvbiAmJiBpdGVyYXRpb24gPT09IHRUaW1lIC8gY3ljbGVEdXJhdGlvbikge1xuICAgICAgICAgICAgdGltZSA9IGR1cjtcbiAgICAgICAgICAgIGl0ZXJhdGlvbi0tO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRpbWUgPiBkdXIgJiYgKHRpbWUgPSBkdXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaXNZb3lvID0gdGhpcy5feW95byAmJiBpdGVyYXRpb24gJiAxO1xuXG4gICAgICAgIGlmIChpc1lveW8pIHtcbiAgICAgICAgICB5b3lvRWFzZSA9IHRoaXMuX3lFYXNlO1xuICAgICAgICAgIHRpbWUgPSBkdXIgLSB0aW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldkl0ZXJhdGlvbiA9IF9hbmltYXRpb25DeWNsZSh0aGlzLl90VGltZSwgY3ljbGVEdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKHRpbWUgPT09IHByZXZUaW1lICYmICFmb3JjZSAmJiB0aGlzLl9pbml0dGVkKSB7XG4gICAgICAgICAgLy9jb3VsZCBiZSBkdXJpbmcgdGhlIHJlcGVhdERlbGF5IHBhcnQuIE5vIG5lZWQgdG8gcmVuZGVyIGFuZCBmaXJlIGNhbGxiYWNrcy5cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpdGVyYXRpb24gIT09IHByZXZJdGVyYXRpb24pIHtcbiAgICAgICAgICB0aW1lbGluZSAmJiB0aGlzLl95RWFzZSAmJiBfcHJvcGFnYXRlWW95b0Vhc2UodGltZWxpbmUsIGlzWW95byk7IC8vcmVwZWF0UmVmcmVzaCBmdW5jdGlvbmFsaXR5XG5cbiAgICAgICAgICBpZiAodGhpcy52YXJzLnJlcGVhdFJlZnJlc2ggJiYgIWlzWW95byAmJiAhdGhpcy5fbG9jaykge1xuICAgICAgICAgICAgdGhpcy5fbG9jayA9IGZvcmNlID0gMTsgLy9mb3JjZSwgb3RoZXJ3aXNlIGlmIGxhenkgaXMgdHJ1ZSwgdGhlIF9hdHRlbXB0SW5pdFR3ZWVuKCkgd2lsbCByZXR1cm4gYW5kIHdlJ2xsIGp1bXAgb3V0IGFuZCBnZXQgY2F1Z2h0IGJvdW5jaW5nIG9uIGVhY2ggdGljay5cblxuICAgICAgICAgICAgdGhpcy5yZW5kZXIoX3JvdW5kUHJlY2lzZShjeWNsZUR1cmF0aW9uICogaXRlcmF0aW9uKSwgdHJ1ZSkuaW52YWxpZGF0ZSgpLl9sb2NrID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9pbml0dGVkKSB7XG4gICAgICAgIGlmIChfYXR0ZW1wdEluaXRUd2Vlbih0aGlzLCB0b3RhbFRpbWUgPCAwID8gdG90YWxUaW1lIDogdGltZSwgZm9yY2UsIHN1cHByZXNzRXZlbnRzKSkge1xuICAgICAgICAgIHRoaXMuX3RUaW1lID0gMDsgLy8gaW4gY29uc3RydWN0b3IgaWYgaW1tZWRpYXRlUmVuZGVyIGlzIHRydWUsIHdlIHNldCBfdFRpbWUgdG8gLV90aW55TnVtIHRvIGhhdmUgdGhlIHBsYXloZWFkIGNyb3NzIHRoZSBzdGFydGluZyBwb2ludCBidXQgd2UgY2FuJ3QgbGVhdmUgX3RUaW1lIGFzIGEgbmVnYXRpdmUgbnVtYmVyLlxuXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZHVyICE9PSB0aGlzLl9kdXIpIHtcbiAgICAgICAgICAvLyB3aGlsZSBpbml0dGluZywgYSBwbHVnaW4gbGlrZSBJbmVydGlhUGx1Z2luIG1pZ2h0IGFsdGVyIHRoZSBkdXJhdGlvbiwgc28gcmVydW4gZnJvbSB0aGUgc3RhcnQgdG8gZW5zdXJlIGV2ZXJ5dGhpbmcgcmVuZGVycyBhcyBpdCBzaG91bGQuXG4gICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKHRvdGFsVGltZSwgc3VwcHJlc3NFdmVudHMsIGZvcmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl90VGltZSA9IHRUaW1lO1xuICAgICAgdGhpcy5fdGltZSA9IHRpbWU7XG5cbiAgICAgIGlmICghdGhpcy5fYWN0ICYmIHRoaXMuX3RzKSB7XG4gICAgICAgIHRoaXMuX2FjdCA9IDE7IC8vYXMgbG9uZyBhcyBpdCdzIG5vdCBwYXVzZWQsIGZvcmNlIGl0IHRvIGJlIGFjdGl2ZSBzbyB0aGF0IGlmIHRoZSB1c2VyIHJlbmRlcnMgaW5kZXBlbmRlbnQgb2YgdGhlIHBhcmVudCB0aW1lbGluZSwgaXQnbGwgYmUgZm9yY2VkIHRvIHJlLXJlbmRlciBvbiB0aGUgbmV4dCB0aWNrLlxuXG4gICAgICAgIHRoaXMuX2xhenkgPSAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJhdGlvID0gcmF0aW8gPSAoeW95b0Vhc2UgfHwgdGhpcy5fZWFzZSkodGltZSAvIGR1cik7XG5cbiAgICAgIGlmICh0aGlzLl9mcm9tKSB7XG4gICAgICAgIHRoaXMucmF0aW8gPSByYXRpbyA9IDEgLSByYXRpbztcbiAgICAgIH1cblxuICAgICAgaWYgKHRpbWUgJiYgIXByZXZUaW1lICYmICFzdXBwcmVzc0V2ZW50cykge1xuICAgICAgICBfY2FsbGJhY2sodGhpcywgXCJvblN0YXJ0XCIpO1xuXG4gICAgICAgIGlmICh0aGlzLl90VGltZSAhPT0gdFRpbWUpIHtcbiAgICAgICAgICAvLyBpbiBjYXNlIHRoZSBvblN0YXJ0IHRyaWdnZXJlZCBhIHJlbmRlciBhdCBhIGRpZmZlcmVudCBzcG90LCBlamVjdC4gTGlrZSBpZiBzb21lb25lIGRpZCBhbmltYXRpb24ucGF1c2UoMC41KSBvciBzb21ldGhpbmcgaW5zaWRlIHRoZSBvblN0YXJ0LlxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHB0ID0gdGhpcy5fcHQ7XG5cbiAgICAgIHdoaWxlIChwdCkge1xuICAgICAgICBwdC5yKHJhdGlvLCBwdC5kKTtcbiAgICAgICAgcHQgPSBwdC5fbmV4dDtcbiAgICAgIH1cblxuICAgICAgdGltZWxpbmUgJiYgdGltZWxpbmUucmVuZGVyKHRvdGFsVGltZSA8IDAgPyB0b3RhbFRpbWUgOiAhdGltZSAmJiBpc1lveW8gPyAtX3RpbnlOdW0gOiB0aW1lbGluZS5fZHVyICogdGltZWxpbmUuX2Vhc2UodGltZSAvIHRoaXMuX2R1ciksIHN1cHByZXNzRXZlbnRzLCBmb3JjZSkgfHwgdGhpcy5fc3RhcnRBdCAmJiAodGhpcy5felRpbWUgPSB0b3RhbFRpbWUpO1xuXG4gICAgICBpZiAodGhpcy5fb25VcGRhdGUgJiYgIXN1cHByZXNzRXZlbnRzKSB7XG4gICAgICAgIHRvdGFsVGltZSA8IDAgJiYgdGhpcy5fc3RhcnRBdCAmJiB0aGlzLl9zdGFydEF0LnJlbmRlcih0b3RhbFRpbWUsIHRydWUsIGZvcmNlKTsgLy9ub3RlOiBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgd2UgdHVjayB0aGlzIGNvbmRpdGlvbmFsIGxvZ2ljIGluc2lkZSBsZXNzIHRyYXZlbGVkIGFyZWFzIChtb3N0IHR3ZWVucyBkb24ndCBoYXZlIGFuIG9uVXBkYXRlKS4gV2UnZCBqdXN0IGhhdmUgaXQgYXQgdGhlIGVuZCBiZWZvcmUgdGhlIG9uQ29tcGxldGUsIGJ1dCB0aGUgdmFsdWVzIHNob3VsZCBiZSB1cGRhdGVkIGJlZm9yZSBhbnkgb25VcGRhdGUgaXMgY2FsbGVkLCBzbyB3ZSBBTFNPIHB1dCBpdCBoZXJlIGFuZCB0aGVuIGlmIGl0J3Mgbm90IGNhbGxlZCwgd2UgZG8gc28gbGF0ZXIgbmVhciB0aGUgb25Db21wbGV0ZS5cblxuICAgICAgICBfY2FsbGJhY2sodGhpcywgXCJvblVwZGF0ZVwiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVwZWF0ICYmIGl0ZXJhdGlvbiAhPT0gcHJldkl0ZXJhdGlvbiAmJiB0aGlzLnZhcnMub25SZXBlYXQgJiYgIXN1cHByZXNzRXZlbnRzICYmIHRoaXMucGFyZW50ICYmIF9jYWxsYmFjayh0aGlzLCBcIm9uUmVwZWF0XCIpO1xuXG4gICAgICBpZiAoKHRUaW1lID09PSB0aGlzLl90RHVyIHx8ICF0VGltZSkgJiYgdGhpcy5fdFRpbWUgPT09IHRUaW1lKSB7XG4gICAgICAgIHRvdGFsVGltZSA8IDAgJiYgdGhpcy5fc3RhcnRBdCAmJiAhdGhpcy5fb25VcGRhdGUgJiYgdGhpcy5fc3RhcnRBdC5yZW5kZXIodG90YWxUaW1lLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgKHRvdGFsVGltZSB8fCAhZHVyKSAmJiAodFRpbWUgPT09IHRoaXMuX3REdXIgJiYgdGhpcy5fdHMgPiAwIHx8ICF0VGltZSAmJiB0aGlzLl90cyA8IDApICYmIF9yZW1vdmVGcm9tUGFyZW50KHRoaXMsIDEpOyAvLyBkb24ndCByZW1vdmUgaWYgd2UncmUgcmVuZGVyaW5nIGF0IGV4YWN0bHkgYSB0aW1lIG9mIDAsIGFzIHRoZXJlIGNvdWxkIGJlIGF1dG9SZXZlcnQgdmFsdWVzIHRoYXQgc2hvdWxkIGdldCBzZXQgb24gdGhlIG5leHQgdGljayAoaWYgdGhlIHBsYXloZWFkIGdvZXMgYmFja3dhcmQgYmV5b25kIHRoZSBzdGFydFRpbWUsIG5lZ2F0aXZlIHRvdGFsVGltZSkuIERvbid0IHJlbW92ZSBpZiB0aGUgdGltZWxpbmUgaXMgcmV2ZXJzZWQgYW5kIHRoZSBwbGF5aGVhZCBpc24ndCBhdCAwLCBvdGhlcndpc2UgdGwucHJvZ3Jlc3MoMSkucmV2ZXJzZSgpIHdvbid0IHdvcmsuIE9ubHkgcmVtb3ZlIGlmIHRoZSBwbGF5aGVhZCBpcyBhdCB0aGUgZW5kIGFuZCB0aW1lU2NhbGUgaXMgcG9zaXRpdmUsIG9yIGlmIHRoZSBwbGF5aGVhZCBpcyBhdCAwIGFuZCB0aGUgdGltZVNjYWxlIGlzIG5lZ2F0aXZlLlxuXG4gICAgICAgIGlmICghc3VwcHJlc3NFdmVudHMgJiYgISh0b3RhbFRpbWUgPCAwICYmICFwcmV2VGltZSkgJiYgKHRUaW1lIHx8IHByZXZUaW1lKSkge1xuICAgICAgICAgIC8vIGlmIHByZXZUaW1lIGFuZCB0VGltZSBhcmUgemVybywgd2Ugc2hvdWxkbid0IGZpcmUgdGhlIG9uUmV2ZXJzZUNvbXBsZXRlLiBUaGlzIGNvdWxkIGhhcHBlbiBpZiB5b3UgZ3NhcC50byguLi4ge3BhdXNlZDp0cnVlfSkucGxheSgpO1xuICAgICAgICAgIF9jYWxsYmFjayh0aGlzLCB0VGltZSA9PT0gdER1ciA/IFwib25Db21wbGV0ZVwiIDogXCJvblJldmVyc2VDb21wbGV0ZVwiLCB0cnVlKTtcblxuICAgICAgICAgIHRoaXMuX3Byb20gJiYgISh0VGltZSA8IHREdXIgJiYgdGhpcy50aW1lU2NhbGUoKSA+IDApICYmIHRoaXMuX3Byb20oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90bzMudGFyZ2V0cyA9IGZ1bmN0aW9uIHRhcmdldHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RhcmdldHM7XG4gIH07XG5cbiAgX3Byb3RvMy5pbnZhbGlkYXRlID0gZnVuY3Rpb24gaW52YWxpZGF0ZSgpIHtcbiAgICB0aGlzLl9wdCA9IHRoaXMuX29wID0gdGhpcy5fc3RhcnRBdCA9IHRoaXMuX29uVXBkYXRlID0gdGhpcy5fbGF6eSA9IHRoaXMucmF0aW8gPSAwO1xuICAgIHRoaXMuX3B0TG9va3VwID0gW107XG4gICAgdGhpcy50aW1lbGluZSAmJiB0aGlzLnRpbWVsaW5lLmludmFsaWRhdGUoKTtcbiAgICByZXR1cm4gX0FuaW1hdGlvbjIucHJvdG90eXBlLmludmFsaWRhdGUuY2FsbCh0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8zLmtpbGwgPSBmdW5jdGlvbiBraWxsKHRhcmdldHMsIHZhcnMpIHtcbiAgICBpZiAodmFycyA9PT0gdm9pZCAwKSB7XG4gICAgICB2YXJzID0gXCJhbGxcIjtcbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldHMgJiYgKCF2YXJzIHx8IHZhcnMgPT09IFwiYWxsXCIpKSB7XG4gICAgICB0aGlzLl9sYXp5ID0gdGhpcy5fcHQgPSAwO1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50ID8gX2ludGVycnVwdCh0aGlzKSA6IHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGltZWxpbmUpIHtcbiAgICAgIHZhciB0RHVyID0gdGhpcy50aW1lbGluZS50b3RhbER1cmF0aW9uKCk7XG4gICAgICB0aGlzLnRpbWVsaW5lLmtpbGxUd2VlbnNPZih0YXJnZXRzLCB2YXJzLCBfb3ZlcndyaXRpbmdUd2VlbiAmJiBfb3ZlcndyaXRpbmdUd2Vlbi52YXJzLm92ZXJ3cml0ZSAhPT0gdHJ1ZSkuX2ZpcnN0IHx8IF9pbnRlcnJ1cHQodGhpcyk7IC8vIGlmIG5vdGhpbmcgaXMgbGVmdCB0d2VlbmluZywgaW50ZXJydXB0LlxuXG4gICAgICB0aGlzLnBhcmVudCAmJiB0RHVyICE9PSB0aGlzLnRpbWVsaW5lLnRvdGFsRHVyYXRpb24oKSAmJiBfc2V0RHVyYXRpb24odGhpcywgdGhpcy5fZHVyICogdGhpcy50aW1lbGluZS5fdER1ciAvIHREdXIsIDAsIDEpOyAvLyBpZiBhIG5lc3RlZCB0d2VlbiBpcyBraWxsZWQgdGhhdCBjaGFuZ2VzIHRoZSBkdXJhdGlvbiwgaXQgc2hvdWxkIGFmZmVjdCB0aGlzIHR3ZWVuJ3MgZHVyYXRpb24uIFdlIG11c3QgdXNlIHRoZSByYXRpbywgdGhvdWdoLCBiZWNhdXNlIHNvbWV0aW1lcyB0aGUgaW50ZXJuYWwgdGltZWxpbmUgaXMgc3RyZXRjaGVkIGxpa2UgZm9yIGtleWZyYW1lcyB3aGVyZSB0aGV5IGRvbid0IGFsbCBhZGQgdXAgdG8gd2hhdGV2ZXIgdGhlIHBhcmVudCB0d2VlbidzIGR1cmF0aW9uIHdhcyBzZXQgdG8uXG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBwYXJzZWRUYXJnZXRzID0gdGhpcy5fdGFyZ2V0cyxcbiAgICAgICAga2lsbGluZ1RhcmdldHMgPSB0YXJnZXRzID8gdG9BcnJheSh0YXJnZXRzKSA6IHBhcnNlZFRhcmdldHMsXG4gICAgICAgIHByb3BUd2Vlbkxvb2t1cCA9IHRoaXMuX3B0TG9va3VwLFxuICAgICAgICBmaXJzdFBUID0gdGhpcy5fcHQsXG4gICAgICAgIG92ZXJ3cml0dGVuUHJvcHMsXG4gICAgICAgIGN1ckxvb2t1cCxcbiAgICAgICAgY3VyT3ZlcndyaXRlUHJvcHMsXG4gICAgICAgIHByb3BzLFxuICAgICAgICBwLFxuICAgICAgICBwdCxcbiAgICAgICAgaTtcblxuICAgIGlmICgoIXZhcnMgfHwgdmFycyA9PT0gXCJhbGxcIikgJiYgX2FycmF5c01hdGNoKHBhcnNlZFRhcmdldHMsIGtpbGxpbmdUYXJnZXRzKSkge1xuICAgICAgdmFycyA9PT0gXCJhbGxcIiAmJiAodGhpcy5fcHQgPSAwKTtcbiAgICAgIHJldHVybiBfaW50ZXJydXB0KHRoaXMpO1xuICAgIH1cblxuICAgIG92ZXJ3cml0dGVuUHJvcHMgPSB0aGlzLl9vcCA9IHRoaXMuX29wIHx8IFtdO1xuXG4gICAgaWYgKHZhcnMgIT09IFwiYWxsXCIpIHtcbiAgICAgIC8vc28gcGVvcGxlIGNhbiBwYXNzIGluIGEgY29tbWEtZGVsaW1pdGVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXNcbiAgICAgIGlmIChfaXNTdHJpbmcodmFycykpIHtcbiAgICAgICAgcCA9IHt9O1xuXG4gICAgICAgIF9mb3JFYWNoTmFtZSh2YXJzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgIHJldHVybiBwW25hbWVdID0gMTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFycyA9IHA7XG4gICAgICB9XG5cbiAgICAgIHZhcnMgPSBfYWRkQWxpYXNlc1RvVmFycyhwYXJzZWRUYXJnZXRzLCB2YXJzKTtcbiAgICB9XG5cbiAgICBpID0gcGFyc2VkVGFyZ2V0cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAofmtpbGxpbmdUYXJnZXRzLmluZGV4T2YocGFyc2VkVGFyZ2V0c1tpXSkpIHtcbiAgICAgICAgY3VyTG9va3VwID0gcHJvcFR3ZWVuTG9va3VwW2ldO1xuXG4gICAgICAgIGlmICh2YXJzID09PSBcImFsbFwiKSB7XG4gICAgICAgICAgb3ZlcndyaXR0ZW5Qcm9wc1tpXSA9IHZhcnM7XG4gICAgICAgICAgcHJvcHMgPSBjdXJMb29rdXA7XG4gICAgICAgICAgY3VyT3ZlcndyaXRlUHJvcHMgPSB7fTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJPdmVyd3JpdGVQcm9wcyA9IG92ZXJ3cml0dGVuUHJvcHNbaV0gPSBvdmVyd3JpdHRlblByb3BzW2ldIHx8IHt9O1xuICAgICAgICAgIHByb3BzID0gdmFycztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAocCBpbiBwcm9wcykge1xuICAgICAgICAgIHB0ID0gY3VyTG9va3VwICYmIGN1ckxvb2t1cFtwXTtcblxuICAgICAgICAgIGlmIChwdCkge1xuICAgICAgICAgICAgaWYgKCEoXCJraWxsXCIgaW4gcHQuZCkgfHwgcHQuZC5raWxsKHApID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIF9yZW1vdmVMaW5rZWRMaXN0SXRlbSh0aGlzLCBwdCwgXCJfcHRcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlbGV0ZSBjdXJMb29rdXBbcF07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGN1ck92ZXJ3cml0ZVByb3BzICE9PSBcImFsbFwiKSB7XG4gICAgICAgICAgICBjdXJPdmVyd3JpdGVQcm9wc1twXSA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5faW5pdHRlZCAmJiAhdGhpcy5fcHQgJiYgZmlyc3RQVCAmJiBfaW50ZXJydXB0KHRoaXMpOyAvL2lmIGFsbCB0d2VlbmluZyBwcm9wZXJ0aWVzIGFyZSBraWxsZWQsIGtpbGwgdGhlIHR3ZWVuLiBXaXRob3V0IHRoaXMgbGluZSwgaWYgdGhlcmUncyBhIHR3ZWVuIHdpdGggbXVsdGlwbGUgdGFyZ2V0cyBhbmQgdGhlbiB5b3Uga2lsbFR3ZWVuc09mKCkgZWFjaCB0YXJnZXQgaW5kaXZpZHVhbGx5LCB0aGUgdHdlZW4gd291bGQgdGVjaG5pY2FsbHkgc3RpbGwgcmVtYWluIGFjdGl2ZSBhbmQgZmlyZSBpdHMgb25Db21wbGV0ZSBldmVuIHRob3VnaCB0aGVyZSBhcmVuJ3QgYW55IG1vcmUgcHJvcGVydGllcyB0d2VlbmluZy5cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIFR3ZWVuLnRvID0gZnVuY3Rpb24gdG8odGFyZ2V0cywgdmFycykge1xuICAgIHJldHVybiBuZXcgVHdlZW4odGFyZ2V0cywgdmFycywgYXJndW1lbnRzWzJdKTtcbiAgfTtcblxuICBUd2Vlbi5mcm9tID0gZnVuY3Rpb24gZnJvbSh0YXJnZXRzLCB2YXJzKSB7XG4gICAgcmV0dXJuIF9jcmVhdGVUd2VlblR5cGUoMSwgYXJndW1lbnRzKTtcbiAgfTtcblxuICBUd2Vlbi5kZWxheWVkQ2FsbCA9IGZ1bmN0aW9uIGRlbGF5ZWRDYWxsKGRlbGF5LCBjYWxsYmFjaywgcGFyYW1zLCBzY29wZSkge1xuICAgIHJldHVybiBuZXcgVHdlZW4oY2FsbGJhY2ssIDAsIHtcbiAgICAgIGltbWVkaWF0ZVJlbmRlcjogZmFsc2UsXG4gICAgICBsYXp5OiBmYWxzZSxcbiAgICAgIG92ZXJ3cml0ZTogZmFsc2UsXG4gICAgICBkZWxheTogZGVsYXksXG4gICAgICBvbkNvbXBsZXRlOiBjYWxsYmFjayxcbiAgICAgIG9uUmV2ZXJzZUNvbXBsZXRlOiBjYWxsYmFjayxcbiAgICAgIG9uQ29tcGxldGVQYXJhbXM6IHBhcmFtcyxcbiAgICAgIG9uUmV2ZXJzZUNvbXBsZXRlUGFyYW1zOiBwYXJhbXMsXG4gICAgICBjYWxsYmFja1Njb3BlOiBzY29wZVxuICAgIH0pO1xuICB9O1xuXG4gIFR3ZWVuLmZyb21UbyA9IGZ1bmN0aW9uIGZyb21Ubyh0YXJnZXRzLCBmcm9tVmFycywgdG9WYXJzKSB7XG4gICAgcmV0dXJuIF9jcmVhdGVUd2VlblR5cGUoMiwgYXJndW1lbnRzKTtcbiAgfTtcblxuICBUd2Vlbi5zZXQgPSBmdW5jdGlvbiBzZXQodGFyZ2V0cywgdmFycykge1xuICAgIHZhcnMuZHVyYXRpb24gPSAwO1xuICAgIHZhcnMucmVwZWF0RGVsYXkgfHwgKHZhcnMucmVwZWF0ID0gMCk7XG4gICAgcmV0dXJuIG5ldyBUd2Vlbih0YXJnZXRzLCB2YXJzKTtcbiAgfTtcblxuICBUd2Vlbi5raWxsVHdlZW5zT2YgPSBmdW5jdGlvbiBraWxsVHdlZW5zT2YodGFyZ2V0cywgcHJvcHMsIG9ubHlBY3RpdmUpIHtcbiAgICByZXR1cm4gX2dsb2JhbFRpbWVsaW5lLmtpbGxUd2VlbnNPZih0YXJnZXRzLCBwcm9wcywgb25seUFjdGl2ZSk7XG4gIH07XG5cbiAgcmV0dXJuIFR3ZWVuO1xufShBbmltYXRpb24pO1xuXG5fc2V0RGVmYXVsdHMoVHdlZW4ucHJvdG90eXBlLCB7XG4gIF90YXJnZXRzOiBbXSxcbiAgX2xhenk6IDAsXG4gIF9zdGFydEF0OiAwLFxuICBfb3A6IDAsXG4gIF9vbkluaXQ6IDBcbn0pOyAvL2FkZCB0aGUgcGVydGluZW50IHRpbWVsaW5lIG1ldGhvZHMgdG8gVHdlZW4gaW5zdGFuY2VzIHNvIHRoYXQgdXNlcnMgY2FuIGNoYWluIGNvbnZlbmllbnRseSBhbmQgY3JlYXRlIGEgdGltZWxpbmUgYXV0b21hdGljYWxseS4gKHJlbW92ZWQgZHVlIHRvIGNvbmNlcm5zIHRoYXQgaXQnZCB1bHRpbWF0ZWx5IGFkZCB0byBtb3JlIGNvbmZ1c2lvbiBlc3BlY2lhbGx5IGZvciBiZWdpbm5lcnMpXG4vLyBfZm9yRWFjaE5hbWUoXCJ0byxmcm9tLGZyb21UbyxzZXQsY2FsbCxhZGQsYWRkTGFiZWwsYWRkUGF1c2VcIiwgbmFtZSA9PiB7XG4vLyBcdFR3ZWVuLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuLy8gXHRcdGxldCB0bCA9IG5ldyBUaW1lbGluZSgpO1xuLy8gXHRcdHJldHVybiBfYWRkVG9UaW1lbGluZSh0bCwgdGhpcylbbmFtZV0uYXBwbHkodGwsIHRvQXJyYXkoYXJndW1lbnRzKSk7XG4vLyBcdH1cbi8vIH0pO1xuLy9mb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS4gTGV2ZXJhZ2UgdGhlIHRpbWVsaW5lIGNhbGxzLlxuXG5cbl9mb3JFYWNoTmFtZShcInN0YWdnZXJUbyxzdGFnZ2VyRnJvbSxzdGFnZ2VyRnJvbVRvXCIsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIFR3ZWVuW25hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0bCA9IG5ldyBUaW1lbGluZSgpLFxuICAgICAgICBwYXJhbXMgPSBfc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgcGFyYW1zLnNwbGljZShuYW1lID09PSBcInN0YWdnZXJGcm9tVG9cIiA/IDUgOiA0LCAwLCAwKTtcbiAgICByZXR1cm4gdGxbbmFtZV0uYXBwbHkodGwsIHBhcmFtcyk7XG4gIH07XG59KTtcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogUFJPUFRXRUVOXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cblxudmFyIF9zZXR0ZXJQbGFpbiA9IGZ1bmN0aW9uIF9zZXR0ZXJQbGFpbih0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5XSA9IHZhbHVlO1xufSxcbiAgICBfc2V0dGVyRnVuYyA9IGZ1bmN0aW9uIF9zZXR0ZXJGdW5jKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiB0YXJnZXRbcHJvcGVydHldKHZhbHVlKTtcbn0sXG4gICAgX3NldHRlckZ1bmNXaXRoUGFyYW0gPSBmdW5jdGlvbiBfc2V0dGVyRnVuY1dpdGhQYXJhbSh0YXJnZXQsIHByb3BlcnR5LCB2YWx1ZSwgZGF0YSkge1xuICByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5XShkYXRhLmZwLCB2YWx1ZSk7XG59LFxuICAgIF9zZXR0ZXJBdHRyaWJ1dGUgPSBmdW5jdGlvbiBfc2V0dGVyQXR0cmlidXRlKHRhcmdldCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiB0YXJnZXQuc2V0QXR0cmlidXRlKHByb3BlcnR5LCB2YWx1ZSk7XG59LFxuICAgIF9nZXRTZXR0ZXIgPSBmdW5jdGlvbiBfZ2V0U2V0dGVyKHRhcmdldCwgcHJvcGVydHkpIHtcbiAgcmV0dXJuIF9pc0Z1bmN0aW9uKHRhcmdldFtwcm9wZXJ0eV0pID8gX3NldHRlckZ1bmMgOiBfaXNVbmRlZmluZWQodGFyZ2V0W3Byb3BlcnR5XSkgJiYgdGFyZ2V0LnNldEF0dHJpYnV0ZSA/IF9zZXR0ZXJBdHRyaWJ1dGUgOiBfc2V0dGVyUGxhaW47XG59LFxuICAgIF9yZW5kZXJQbGFpbiA9IGZ1bmN0aW9uIF9yZW5kZXJQbGFpbihyYXRpbywgZGF0YSkge1xuICByZXR1cm4gZGF0YS5zZXQoZGF0YS50LCBkYXRhLnAsIE1hdGgucm91bmQoKGRhdGEucyArIGRhdGEuYyAqIHJhdGlvKSAqIDEwMDAwMDApIC8gMTAwMDAwMCwgZGF0YSk7XG59LFxuICAgIF9yZW5kZXJCb29sZWFuID0gZnVuY3Rpb24gX3JlbmRlckJvb2xlYW4ocmF0aW8sIGRhdGEpIHtcbiAgcmV0dXJuIGRhdGEuc2V0KGRhdGEudCwgZGF0YS5wLCAhIShkYXRhLnMgKyBkYXRhLmMgKiByYXRpbyksIGRhdGEpO1xufSxcbiAgICBfcmVuZGVyQ29tcGxleFN0cmluZyA9IGZ1bmN0aW9uIF9yZW5kZXJDb21wbGV4U3RyaW5nKHJhdGlvLCBkYXRhKSB7XG4gIHZhciBwdCA9IGRhdGEuX3B0LFxuICAgICAgcyA9IFwiXCI7XG5cbiAgaWYgKCFyYXRpbyAmJiBkYXRhLmIpIHtcbiAgICAvL2IgPSBiZWdpbm5pbmcgc3RyaW5nXG4gICAgcyA9IGRhdGEuYjtcbiAgfSBlbHNlIGlmIChyYXRpbyA9PT0gMSAmJiBkYXRhLmUpIHtcbiAgICAvL2UgPSBlbmRpbmcgc3RyaW5nXG4gICAgcyA9IGRhdGEuZTtcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAocHQpIHtcbiAgICAgIHMgPSBwdC5wICsgKHB0Lm0gPyBwdC5tKHB0LnMgKyBwdC5jICogcmF0aW8pIDogTWF0aC5yb3VuZCgocHQucyArIHB0LmMgKiByYXRpbykgKiAxMDAwMCkgLyAxMDAwMCkgKyBzOyAvL3dlIHVzZSB0aGUgXCJwXCIgcHJvcGVydHkgZm9yIHRoZSB0ZXh0IGluYmV0d2VlbiAobGlrZSBhIHN1ZmZpeCkuIEFuZCBpbiB0aGUgY29udGV4dCBvZiBhIGNvbXBsZXggc3RyaW5nLCB0aGUgbW9kaWZpZXIgKG0pIGlzIHR5cGljYWxseSBqdXN0IE1hdGgucm91bmQoKSwgbGlrZSBmb3IgUkdCIGNvbG9ycy5cblxuICAgICAgcHQgPSBwdC5fbmV4dDtcbiAgICB9XG5cbiAgICBzICs9IGRhdGEuYzsgLy93ZSB1c2UgdGhlIFwiY1wiIG9mIHRoZSBQcm9wVHdlZW4gdG8gc3RvcmUgdGhlIGZpbmFsIGNodW5rIG9mIG5vbi1udW1lcmljIHRleHQuXG4gIH1cblxuICBkYXRhLnNldChkYXRhLnQsIGRhdGEucCwgcywgZGF0YSk7XG59LFxuICAgIF9yZW5kZXJQcm9wVHdlZW5zID0gZnVuY3Rpb24gX3JlbmRlclByb3BUd2VlbnMocmF0aW8sIGRhdGEpIHtcbiAgdmFyIHB0ID0gZGF0YS5fcHQ7XG5cbiAgd2hpbGUgKHB0KSB7XG4gICAgcHQucihyYXRpbywgcHQuZCk7XG4gICAgcHQgPSBwdC5fbmV4dDtcbiAgfVxufSxcbiAgICBfYWRkUGx1Z2luTW9kaWZpZXIgPSBmdW5jdGlvbiBfYWRkUGx1Z2luTW9kaWZpZXIobW9kaWZpZXIsIHR3ZWVuLCB0YXJnZXQsIHByb3BlcnR5KSB7XG4gIHZhciBwdCA9IHRoaXMuX3B0LFxuICAgICAgbmV4dDtcblxuICB3aGlsZSAocHQpIHtcbiAgICBuZXh0ID0gcHQuX25leHQ7XG4gICAgcHQucCA9PT0gcHJvcGVydHkgJiYgcHQubW9kaWZpZXIobW9kaWZpZXIsIHR3ZWVuLCB0YXJnZXQpO1xuICAgIHB0ID0gbmV4dDtcbiAgfVxufSxcbiAgICBfa2lsbFByb3BUd2VlbnNPZiA9IGZ1bmN0aW9uIF9raWxsUHJvcFR3ZWVuc09mKHByb3BlcnR5KSB7XG4gIHZhciBwdCA9IHRoaXMuX3B0LFxuICAgICAgaGFzTm9uRGVwZW5kZW50UmVtYWluaW5nLFxuICAgICAgbmV4dDtcblxuICB3aGlsZSAocHQpIHtcbiAgICBuZXh0ID0gcHQuX25leHQ7XG5cbiAgICBpZiAocHQucCA9PT0gcHJvcGVydHkgJiYgIXB0Lm9wIHx8IHB0Lm9wID09PSBwcm9wZXJ0eSkge1xuICAgICAgX3JlbW92ZUxpbmtlZExpc3RJdGVtKHRoaXMsIHB0LCBcIl9wdFwiKTtcbiAgICB9IGVsc2UgaWYgKCFwdC5kZXApIHtcbiAgICAgIGhhc05vbkRlcGVuZGVudFJlbWFpbmluZyA9IDE7XG4gICAgfVxuXG4gICAgcHQgPSBuZXh0O1xuICB9XG5cbiAgcmV0dXJuICFoYXNOb25EZXBlbmRlbnRSZW1haW5pbmc7XG59LFxuICAgIF9zZXR0ZXJXaXRoTW9kaWZpZXIgPSBmdW5jdGlvbiBfc2V0dGVyV2l0aE1vZGlmaWVyKHRhcmdldCwgcHJvcGVydHksIHZhbHVlLCBkYXRhKSB7XG4gIGRhdGEubVNldCh0YXJnZXQsIHByb3BlcnR5LCBkYXRhLm0uY2FsbChkYXRhLnR3ZWVuLCB2YWx1ZSwgZGF0YS5tdCksIGRhdGEpO1xufSxcbiAgICBfc29ydFByb3BUd2VlbnNCeVByaW9yaXR5ID0gZnVuY3Rpb24gX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eShwYXJlbnQpIHtcbiAgdmFyIHB0ID0gcGFyZW50Ll9wdCxcbiAgICAgIG5leHQsXG4gICAgICBwdDIsXG4gICAgICBmaXJzdCxcbiAgICAgIGxhc3Q7IC8vc29ydHMgdGhlIFByb3BUd2VlbiBsaW5rZWQgbGlzdCBpbiBvcmRlciBvZiBwcmlvcml0eSBiZWNhdXNlIHNvbWUgcGx1Z2lucyBuZWVkIHRvIGRvIHRoZWlyIHdvcmsgYWZ0ZXIgQUxMIG9mIHRoZSBQcm9wVHdlZW5zIHdlcmUgY3JlYXRlZCAobGlrZSBSb3VuZFByb3BzUGx1Z2luIGFuZCBNb2RpZmllcnNQbHVnaW4pXG5cbiAgd2hpbGUgKHB0KSB7XG4gICAgbmV4dCA9IHB0Ll9uZXh0O1xuICAgIHB0MiA9IGZpcnN0O1xuXG4gICAgd2hpbGUgKHB0MiAmJiBwdDIucHIgPiBwdC5wcikge1xuICAgICAgcHQyID0gcHQyLl9uZXh0O1xuICAgIH1cblxuICAgIGlmIChwdC5fcHJldiA9IHB0MiA/IHB0Mi5fcHJldiA6IGxhc3QpIHtcbiAgICAgIHB0Ll9wcmV2Ll9uZXh0ID0gcHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpcnN0ID0gcHQ7XG4gICAgfVxuXG4gICAgaWYgKHB0Ll9uZXh0ID0gcHQyKSB7XG4gICAgICBwdDIuX3ByZXYgPSBwdDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdCA9IHB0O1xuICAgIH1cblxuICAgIHB0ID0gbmV4dDtcbiAgfVxuXG4gIHBhcmVudC5fcHQgPSBmaXJzdDtcbn07IC8vUHJvcFR3ZWVuIGtleTogdCA9IHRhcmdldCwgcCA9IHByb3AsIHIgPSByZW5kZXJlciwgZCA9IGRhdGEsIHMgPSBzdGFydCwgYyA9IGNoYW5nZSwgb3AgPSBvdmVyd3JpdGVQcm9wZXJ0eSAoT05MWSBwb3B1bGF0ZWQgd2hlbiBpdCdzIGRpZmZlcmVudCB0aGFuIHApLCBwciA9IHByaW9yaXR5LCBfbmV4dC9fcHJldiBmb3IgdGhlIGxpbmtlZCBsaXN0IHNpYmxpbmdzLCBzZXQgPSBzZXR0ZXIsIG0gPSBtb2RpZmllciwgbVNldCA9IG1vZGlmaWVyU2V0dGVyICh0aGUgb3JpZ2luYWwgc2V0dGVyLCBiZWZvcmUgYSBtb2RpZmllciB3YXMgYWRkZWQpXG5cblxuZXhwb3J0IHZhciBQcm9wVHdlZW4gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQcm9wVHdlZW4obmV4dCwgdGFyZ2V0LCBwcm9wLCBzdGFydCwgY2hhbmdlLCByZW5kZXJlciwgZGF0YSwgc2V0dGVyLCBwcmlvcml0eSkge1xuICAgIHRoaXMudCA9IHRhcmdldDtcbiAgICB0aGlzLnMgPSBzdGFydDtcbiAgICB0aGlzLmMgPSBjaGFuZ2U7XG4gICAgdGhpcy5wID0gcHJvcDtcbiAgICB0aGlzLnIgPSByZW5kZXJlciB8fCBfcmVuZGVyUGxhaW47XG4gICAgdGhpcy5kID0gZGF0YSB8fCB0aGlzO1xuICAgIHRoaXMuc2V0ID0gc2V0dGVyIHx8IF9zZXR0ZXJQbGFpbjtcbiAgICB0aGlzLnByID0gcHJpb3JpdHkgfHwgMDtcbiAgICB0aGlzLl9uZXh0ID0gbmV4dDtcblxuICAgIGlmIChuZXh0KSB7XG4gICAgICBuZXh0Ll9wcmV2ID0gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgX3Byb3RvNCA9IFByb3BUd2Vlbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvNC5tb2RpZmllciA9IGZ1bmN0aW9uIG1vZGlmaWVyKGZ1bmMsIHR3ZWVuLCB0YXJnZXQpIHtcbiAgICB0aGlzLm1TZXQgPSB0aGlzLm1TZXQgfHwgdGhpcy5zZXQ7IC8vaW4gY2FzZSBpdCB3YXMgYWxyZWFkeSBzZXQgKGEgUHJvcFR3ZWVuIGNhbiBvbmx5IGhhdmUgb25lIG1vZGlmaWVyKVxuXG4gICAgdGhpcy5zZXQgPSBfc2V0dGVyV2l0aE1vZGlmaWVyO1xuICAgIHRoaXMubSA9IGZ1bmM7XG4gICAgdGhpcy5tdCA9IHRhcmdldDsgLy9tb2RpZmllciB0YXJnZXRcblxuICAgIHRoaXMudHdlZW4gPSB0d2VlbjtcbiAgfTtcblxuICByZXR1cm4gUHJvcFR3ZWVuO1xufSgpOyAvL0luaXRpYWxpemF0aW9uIHRhc2tzXG5cbl9mb3JFYWNoTmFtZShfY2FsbGJhY2tOYW1lcyArIFwicGFyZW50LGR1cmF0aW9uLGVhc2UsZGVsYXksb3ZlcndyaXRlLHJ1bkJhY2t3YXJkcyxzdGFydEF0LHlveW8saW1tZWRpYXRlUmVuZGVyLHJlcGVhdCxyZXBlYXREZWxheSxkYXRhLHBhdXNlZCxyZXZlcnNlZCxsYXp5LGNhbGxiYWNrU2NvcGUsc3RyaW5nRmlsdGVyLGlkLHlveW9FYXNlLHN0YWdnZXIsaW5oZXJpdCxyZXBlYXRSZWZyZXNoLGtleWZyYW1lcyxhdXRvUmV2ZXJ0LHNjcm9sbFRyaWdnZXJcIiwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIF9yZXNlcnZlZFByb3BzW25hbWVdID0gMTtcbn0pO1xuXG5fZ2xvYmFscy5Ud2Vlbk1heCA9IF9nbG9iYWxzLlR3ZWVuTGl0ZSA9IFR3ZWVuO1xuX2dsb2JhbHMuVGltZWxpbmVMaXRlID0gX2dsb2JhbHMuVGltZWxpbmVNYXggPSBUaW1lbGluZTtcbl9nbG9iYWxUaW1lbGluZSA9IG5ldyBUaW1lbGluZSh7XG4gIHNvcnRDaGlsZHJlbjogZmFsc2UsXG4gIGRlZmF1bHRzOiBfZGVmYXVsdHMsXG4gIGF1dG9SZW1vdmVDaGlsZHJlbjogdHJ1ZSxcbiAgaWQ6IFwicm9vdFwiLFxuICBzbW9vdGhDaGlsZFRpbWluZzogdHJ1ZVxufSk7XG5fY29uZmlnLnN0cmluZ0ZpbHRlciA9IF9jb2xvclN0cmluZ0ZpbHRlcjtcbi8qXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogR1NBUFxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG52YXIgX2dzYXAgPSB7XG4gIHJlZ2lzdGVyUGx1Z2luOiBmdW5jdGlvbiByZWdpc3RlclBsdWdpbigpIHtcbiAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgcmV0dXJuIF9jcmVhdGVQbHVnaW4oY29uZmlnKTtcbiAgICB9KTtcbiAgfSxcbiAgdGltZWxpbmU6IGZ1bmN0aW9uIHRpbWVsaW5lKHZhcnMpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVsaW5lKHZhcnMpO1xuICB9LFxuICBnZXRUd2VlbnNPZjogZnVuY3Rpb24gZ2V0VHdlZW5zT2YodGFyZ2V0cywgb25seUFjdGl2ZSkge1xuICAgIHJldHVybiBfZ2xvYmFsVGltZWxpbmUuZ2V0VHdlZW5zT2YodGFyZ2V0cywgb25seUFjdGl2ZSk7XG4gIH0sXG4gIGdldFByb3BlcnR5OiBmdW5jdGlvbiBnZXRQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5LCB1bml0LCB1bmNhY2hlKSB7XG4gICAgX2lzU3RyaW5nKHRhcmdldCkgJiYgKHRhcmdldCA9IHRvQXJyYXkodGFyZ2V0KVswXSk7IC8vaW4gY2FzZSBzZWxlY3RvciB0ZXh0IG9yIGFuIGFycmF5IGlzIHBhc3NlZCBpblxuXG4gICAgdmFyIGdldHRlciA9IF9nZXRDYWNoZSh0YXJnZXQgfHwge30pLmdldCxcbiAgICAgICAgZm9ybWF0ID0gdW5pdCA/IF9wYXNzVGhyb3VnaCA6IF9udW1lcmljSWZQb3NzaWJsZTtcblxuICAgIHVuaXQgPT09IFwibmF0aXZlXCIgJiYgKHVuaXQgPSBcIlwiKTtcbiAgICByZXR1cm4gIXRhcmdldCA/IHRhcmdldCA6ICFwcm9wZXJ0eSA/IGZ1bmN0aW9uIChwcm9wZXJ0eSwgdW5pdCwgdW5jYWNoZSkge1xuICAgICAgcmV0dXJuIGZvcm1hdCgoX3BsdWdpbnNbcHJvcGVydHldICYmIF9wbHVnaW5zW3Byb3BlcnR5XS5nZXQgfHwgZ2V0dGVyKSh0YXJnZXQsIHByb3BlcnR5LCB1bml0LCB1bmNhY2hlKSk7XG4gICAgfSA6IGZvcm1hdCgoX3BsdWdpbnNbcHJvcGVydHldICYmIF9wbHVnaW5zW3Byb3BlcnR5XS5nZXQgfHwgZ2V0dGVyKSh0YXJnZXQsIHByb3BlcnR5LCB1bml0LCB1bmNhY2hlKSk7XG4gIH0sXG4gIHF1aWNrU2V0dGVyOiBmdW5jdGlvbiBxdWlja1NldHRlcih0YXJnZXQsIHByb3BlcnR5LCB1bml0KSB7XG4gICAgdGFyZ2V0ID0gdG9BcnJheSh0YXJnZXQpO1xuXG4gICAgaWYgKHRhcmdldC5sZW5ndGggPiAxKSB7XG4gICAgICB2YXIgc2V0dGVycyA9IHRhcmdldC5tYXAoZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgcmV0dXJuIGdzYXAucXVpY2tTZXR0ZXIodCwgcHJvcGVydHksIHVuaXQpO1xuICAgICAgfSksXG4gICAgICAgICAgbCA9IHNldHRlcnMubGVuZ3RoO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgaSA9IGw7XG5cbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIHNldHRlcnNbaV0odmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRhcmdldCA9IHRhcmdldFswXSB8fCB7fTtcblxuICAgIHZhciBQbHVnaW4gPSBfcGx1Z2luc1twcm9wZXJ0eV0sXG4gICAgICAgIGNhY2hlID0gX2dldENhY2hlKHRhcmdldCksXG4gICAgICAgIHAgPSBjYWNoZS5oYXJuZXNzICYmIChjYWNoZS5oYXJuZXNzLmFsaWFzZXMgfHwge30pW3Byb3BlcnR5XSB8fCBwcm9wZXJ0eSxcbiAgICAgICAgLy8gaW4gY2FzZSBpdCdzIGFuIGFsaWFzLCBsaWtlIFwicm90YXRlXCIgZm9yIFwicm90YXRpb25cIi5cbiAgICBzZXR0ZXIgPSBQbHVnaW4gPyBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZhciBwID0gbmV3IFBsdWdpbigpO1xuICAgICAgX3F1aWNrVHdlZW4uX3B0ID0gMDtcbiAgICAgIHAuaW5pdCh0YXJnZXQsIHVuaXQgPyB2YWx1ZSArIHVuaXQgOiB2YWx1ZSwgX3F1aWNrVHdlZW4sIDAsIFt0YXJnZXRdKTtcbiAgICAgIHAucmVuZGVyKDEsIHApO1xuICAgICAgX3F1aWNrVHdlZW4uX3B0ICYmIF9yZW5kZXJQcm9wVHdlZW5zKDEsIF9xdWlja1R3ZWVuKTtcbiAgICB9IDogY2FjaGUuc2V0KHRhcmdldCwgcCk7XG5cbiAgICByZXR1cm4gUGx1Z2luID8gc2V0dGVyIDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gc2V0dGVyKHRhcmdldCwgcCwgdW5pdCA/IHZhbHVlICsgdW5pdCA6IHZhbHVlLCBjYWNoZSwgMSk7XG4gICAgfTtcbiAgfSxcbiAgaXNUd2VlbmluZzogZnVuY3Rpb24gaXNUd2VlbmluZyh0YXJnZXRzKSB7XG4gICAgcmV0dXJuIF9nbG9iYWxUaW1lbGluZS5nZXRUd2VlbnNPZih0YXJnZXRzLCB0cnVlKS5sZW5ndGggPiAwO1xuICB9LFxuICBkZWZhdWx0czogZnVuY3Rpb24gZGVmYXVsdHModmFsdWUpIHtcbiAgICB2YWx1ZSAmJiB2YWx1ZS5lYXNlICYmICh2YWx1ZS5lYXNlID0gX3BhcnNlRWFzZSh2YWx1ZS5lYXNlLCBfZGVmYXVsdHMuZWFzZSkpO1xuICAgIHJldHVybiBfbWVyZ2VEZWVwKF9kZWZhdWx0cywgdmFsdWUgfHwge30pO1xuICB9LFxuICBjb25maWc6IGZ1bmN0aW9uIGNvbmZpZyh2YWx1ZSkge1xuICAgIHJldHVybiBfbWVyZ2VEZWVwKF9jb25maWcsIHZhbHVlIHx8IHt9KTtcbiAgfSxcbiAgcmVnaXN0ZXJFZmZlY3Q6IGZ1bmN0aW9uIHJlZ2lzdGVyRWZmZWN0KF9yZWYzKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmMy5uYW1lLFxuICAgICAgICBlZmZlY3QgPSBfcmVmMy5lZmZlY3QsXG4gICAgICAgIHBsdWdpbnMgPSBfcmVmMy5wbHVnaW5zLFxuICAgICAgICBkZWZhdWx0cyA9IF9yZWYzLmRlZmF1bHRzLFxuICAgICAgICBleHRlbmRUaW1lbGluZSA9IF9yZWYzLmV4dGVuZFRpbWVsaW5lO1xuICAgIChwbHVnaW5zIHx8IFwiXCIpLnNwbGl0KFwiLFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW5OYW1lKSB7XG4gICAgICByZXR1cm4gcGx1Z2luTmFtZSAmJiAhX3BsdWdpbnNbcGx1Z2luTmFtZV0gJiYgIV9nbG9iYWxzW3BsdWdpbk5hbWVdICYmIF93YXJuKG5hbWUgKyBcIiBlZmZlY3QgcmVxdWlyZXMgXCIgKyBwbHVnaW5OYW1lICsgXCIgcGx1Z2luLlwiKTtcbiAgICB9KTtcblxuICAgIF9lZmZlY3RzW25hbWVdID0gZnVuY3Rpb24gKHRhcmdldHMsIHZhcnMsIHRsKSB7XG4gICAgICByZXR1cm4gZWZmZWN0KHRvQXJyYXkodGFyZ2V0cyksIF9zZXREZWZhdWx0cyh2YXJzIHx8IHt9LCBkZWZhdWx0cyksIHRsKTtcbiAgICB9O1xuXG4gICAgaWYgKGV4dGVuZFRpbWVsaW5lKSB7XG4gICAgICBUaW1lbGluZS5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiAodGFyZ2V0cywgdmFycywgcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKF9lZmZlY3RzW25hbWVdKHRhcmdldHMsIF9pc09iamVjdCh2YXJzKSA/IHZhcnMgOiAocG9zaXRpb24gPSB2YXJzKSAmJiB7fSwgdGhpcyksIHBvc2l0aW9uKTtcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICByZWdpc3RlckVhc2U6IGZ1bmN0aW9uIHJlZ2lzdGVyRWFzZShuYW1lLCBlYXNlKSB7XG4gICAgX2Vhc2VNYXBbbmFtZV0gPSBfcGFyc2VFYXNlKGVhc2UpO1xuICB9LFxuICBwYXJzZUVhc2U6IGZ1bmN0aW9uIHBhcnNlRWFzZShlYXNlLCBkZWZhdWx0RWFzZSkge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gX3BhcnNlRWFzZShlYXNlLCBkZWZhdWx0RWFzZSkgOiBfZWFzZU1hcDtcbiAgfSxcbiAgZ2V0QnlJZDogZnVuY3Rpb24gZ2V0QnlJZChpZCkge1xuICAgIHJldHVybiBfZ2xvYmFsVGltZWxpbmUuZ2V0QnlJZChpZCk7XG4gIH0sXG4gIGV4cG9ydFJvb3Q6IGZ1bmN0aW9uIGV4cG9ydFJvb3QodmFycywgaW5jbHVkZURlbGF5ZWRDYWxscykge1xuICAgIGlmICh2YXJzID09PSB2b2lkIDApIHtcbiAgICAgIHZhcnMgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgdGwgPSBuZXcgVGltZWxpbmUodmFycyksXG4gICAgICAgIGNoaWxkLFxuICAgICAgICBuZXh0O1xuICAgIHRsLnNtb290aENoaWxkVGltaW5nID0gX2lzTm90RmFsc2UodmFycy5zbW9vdGhDaGlsZFRpbWluZyk7XG5cbiAgICBfZ2xvYmFsVGltZWxpbmUucmVtb3ZlKHRsKTtcblxuICAgIHRsLl9kcCA9IDA7IC8vb3RoZXJ3aXNlIGl0J2xsIGdldCByZS1hY3RpdmF0ZWQgd2hlbiBhZGRpbmcgY2hpbGRyZW4gYW5kIGJlIHJlLWludHJvZHVjZWQgaW50byBfZ2xvYmFsVGltZWxpbmUncyBsaW5rZWQgbGlzdCAodGhlbiBhZGRlZCB0byBpdHNlbGYpLlxuXG4gICAgdGwuX3RpbWUgPSB0bC5fdFRpbWUgPSBfZ2xvYmFsVGltZWxpbmUuX3RpbWU7XG4gICAgY2hpbGQgPSBfZ2xvYmFsVGltZWxpbmUuX2ZpcnN0O1xuXG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICBuZXh0ID0gY2hpbGQuX25leHQ7XG5cbiAgICAgIGlmIChpbmNsdWRlRGVsYXllZENhbGxzIHx8ICEoIWNoaWxkLl9kdXIgJiYgY2hpbGQgaW5zdGFuY2VvZiBUd2VlbiAmJiBjaGlsZC52YXJzLm9uQ29tcGxldGUgPT09IGNoaWxkLl90YXJnZXRzWzBdKSkge1xuICAgICAgICBfYWRkVG9UaW1lbGluZSh0bCwgY2hpbGQsIGNoaWxkLl9zdGFydCAtIGNoaWxkLl9kZWxheSk7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gbmV4dDtcbiAgICB9XG5cbiAgICBfYWRkVG9UaW1lbGluZShfZ2xvYmFsVGltZWxpbmUsIHRsLCAwKTtcblxuICAgIHJldHVybiB0bDtcbiAgfSxcbiAgdXRpbHM6IHtcbiAgICB3cmFwOiB3cmFwLFxuICAgIHdyYXBZb3lvOiB3cmFwWW95byxcbiAgICBkaXN0cmlidXRlOiBkaXN0cmlidXRlLFxuICAgIHJhbmRvbTogcmFuZG9tLFxuICAgIHNuYXA6IHNuYXAsXG4gICAgbm9ybWFsaXplOiBub3JtYWxpemUsXG4gICAgZ2V0VW5pdDogZ2V0VW5pdCxcbiAgICBjbGFtcDogY2xhbXAsXG4gICAgc3BsaXRDb2xvcjogc3BsaXRDb2xvcixcbiAgICB0b0FycmF5OiB0b0FycmF5LFxuICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICBtYXBSYW5nZTogbWFwUmFuZ2UsXG4gICAgcGlwZTogcGlwZSxcbiAgICB1bml0aXplOiB1bml0aXplLFxuICAgIGludGVycG9sYXRlOiBpbnRlcnBvbGF0ZSxcbiAgICBzaHVmZmxlOiBzaHVmZmxlXG4gIH0sXG4gIGluc3RhbGw6IF9pbnN0YWxsLFxuICBlZmZlY3RzOiBfZWZmZWN0cyxcbiAgdGlja2VyOiBfdGlja2VyLFxuICB1cGRhdGVSb290OiBUaW1lbGluZS51cGRhdGVSb290LFxuICBwbHVnaW5zOiBfcGx1Z2lucyxcbiAgZ2xvYmFsVGltZWxpbmU6IF9nbG9iYWxUaW1lbGluZSxcbiAgY29yZToge1xuICAgIFByb3BUd2VlbjogUHJvcFR3ZWVuLFxuICAgIGdsb2JhbHM6IF9hZGRHbG9iYWwsXG4gICAgVHdlZW46IFR3ZWVuLFxuICAgIFRpbWVsaW5lOiBUaW1lbGluZSxcbiAgICBBbmltYXRpb246IEFuaW1hdGlvbixcbiAgICBnZXRDYWNoZTogX2dldENhY2hlLFxuICAgIF9yZW1vdmVMaW5rZWRMaXN0SXRlbTogX3JlbW92ZUxpbmtlZExpc3RJdGVtLFxuICAgIHN1cHByZXNzT3ZlcndyaXRlczogZnVuY3Rpb24gc3VwcHJlc3NPdmVyd3JpdGVzKHZhbHVlKSB7XG4gICAgICByZXR1cm4gX3N1cHByZXNzT3ZlcndyaXRlcyA9IHZhbHVlO1xuICAgIH1cbiAgfVxufTtcblxuX2ZvckVhY2hOYW1lKFwidG8sZnJvbSxmcm9tVG8sZGVsYXllZENhbGwsc2V0LGtpbGxUd2VlbnNPZlwiLCBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gX2dzYXBbbmFtZV0gPSBUd2VlbltuYW1lXTtcbn0pO1xuXG5fdGlja2VyLmFkZChUaW1lbGluZS51cGRhdGVSb290KTtcblxuX3F1aWNrVHdlZW4gPSBfZ3NhcC50byh7fSwge1xuICBkdXJhdGlvbjogMFxufSk7IC8vIC0tLS0gRVhUUkEgUExVR0lOUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgX2dldFBsdWdpblByb3BUd2VlbiA9IGZ1bmN0aW9uIF9nZXRQbHVnaW5Qcm9wVHdlZW4ocGx1Z2luLCBwcm9wKSB7XG4gIHZhciBwdCA9IHBsdWdpbi5fcHQ7XG5cbiAgd2hpbGUgKHB0ICYmIHB0LnAgIT09IHByb3AgJiYgcHQub3AgIT09IHByb3AgJiYgcHQuZnAgIT09IHByb3ApIHtcbiAgICBwdCA9IHB0Ll9uZXh0O1xuICB9XG5cbiAgcmV0dXJuIHB0O1xufSxcbiAgICBfYWRkTW9kaWZpZXJzID0gZnVuY3Rpb24gX2FkZE1vZGlmaWVycyh0d2VlbiwgbW9kaWZpZXJzKSB7XG4gIHZhciB0YXJnZXRzID0gdHdlZW4uX3RhcmdldHMsXG4gICAgICBwLFxuICAgICAgaSxcbiAgICAgIHB0O1xuXG4gIGZvciAocCBpbiBtb2RpZmllcnMpIHtcbiAgICBpID0gdGFyZ2V0cy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBwdCA9IHR3ZWVuLl9wdExvb2t1cFtpXVtwXTtcblxuICAgICAgaWYgKHB0ICYmIChwdCA9IHB0LmQpKSB7XG4gICAgICAgIGlmIChwdC5fcHQpIHtcbiAgICAgICAgICAvLyBpcyBhIHBsdWdpblxuICAgICAgICAgIHB0ID0gX2dldFBsdWdpblByb3BUd2VlbihwdCwgcCk7XG4gICAgICAgIH1cblxuICAgICAgICBwdCAmJiBwdC5tb2RpZmllciAmJiBwdC5tb2RpZmllcihtb2RpZmllcnNbcF0sIHR3ZWVuLCB0YXJnZXRzW2ldLCBwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sXG4gICAgX2J1aWxkTW9kaWZpZXJQbHVnaW4gPSBmdW5jdGlvbiBfYnVpbGRNb2RpZmllclBsdWdpbihuYW1lLCBtb2RpZmllcikge1xuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgcmF3VmFyczogMSxcbiAgICAvL2Rvbid0IHByZS1wcm9jZXNzIGZ1bmN0aW9uLWJhc2VkIHZhbHVlcyBvciBcInJhbmRvbSgpXCIgc3RyaW5ncy5cbiAgICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFycywgdHdlZW4pIHtcbiAgICAgIHR3ZWVuLl9vbkluaXQgPSBmdW5jdGlvbiAodHdlZW4pIHtcbiAgICAgICAgdmFyIHRlbXAsIHA7XG5cbiAgICAgICAgaWYgKF9pc1N0cmluZyh2YXJzKSkge1xuICAgICAgICAgIHRlbXAgPSB7fTtcblxuICAgICAgICAgIF9mb3JFYWNoTmFtZSh2YXJzLCBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRlbXBbbmFtZV0gPSAxO1xuICAgICAgICAgIH0pOyAvL2lmIHRoZSB1c2VyIHBhc3NlcyBpbiBhIGNvbW1hLWRlbGltaXRlZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzIHRvIHJvdW5kUHJvcHMsIGxpa2UgXCJ4LHlcIiwgd2Ugcm91bmQgdG8gd2hvbGUgbnVtYmVycy5cblxuXG4gICAgICAgICAgdmFycyA9IHRlbXA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobW9kaWZpZXIpIHtcbiAgICAgICAgICB0ZW1wID0ge307XG5cbiAgICAgICAgICBmb3IgKHAgaW4gdmFycykge1xuICAgICAgICAgICAgdGVtcFtwXSA9IG1vZGlmaWVyKHZhcnNbcF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhcnMgPSB0ZW1wO1xuICAgICAgICB9XG5cbiAgICAgICAgX2FkZE1vZGlmaWVycyh0d2VlbiwgdmFycyk7XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07IC8vcmVnaXN0ZXIgY29yZSBwbHVnaW5zXG5cblxuZXhwb3J0IHZhciBnc2FwID0gX2dzYXAucmVnaXN0ZXJQbHVnaW4oe1xuICBuYW1lOiBcImF0dHJcIixcbiAgaW5pdDogZnVuY3Rpb24gaW5pdCh0YXJnZXQsIHZhcnMsIHR3ZWVuLCBpbmRleCwgdGFyZ2V0cykge1xuICAgIHZhciBwLCBwdDtcblxuICAgIGZvciAocCBpbiB2YXJzKSB7XG4gICAgICBwdCA9IHRoaXMuYWRkKHRhcmdldCwgXCJzZXRBdHRyaWJ1dGVcIiwgKHRhcmdldC5nZXRBdHRyaWJ1dGUocCkgfHwgMCkgKyBcIlwiLCB2YXJzW3BdLCBpbmRleCwgdGFyZ2V0cywgMCwgMCwgcCk7XG4gICAgICBwdCAmJiAocHQub3AgPSBwKTtcblxuICAgICAgdGhpcy5fcHJvcHMucHVzaChwKTtcbiAgICB9XG4gIH1cbn0sIHtcbiAgbmFtZTogXCJlbmRBcnJheVwiLFxuICBpbml0OiBmdW5jdGlvbiBpbml0KHRhcmdldCwgdmFsdWUpIHtcbiAgICB2YXIgaSA9IHZhbHVlLmxlbmd0aDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHRoaXMuYWRkKHRhcmdldCwgaSwgdGFyZ2V0W2ldIHx8IDAsIHZhbHVlW2ldKTtcbiAgICB9XG4gIH1cbn0sIF9idWlsZE1vZGlmaWVyUGx1Z2luKFwicm91bmRQcm9wc1wiLCBfcm91bmRNb2RpZmllciksIF9idWlsZE1vZGlmaWVyUGx1Z2luKFwibW9kaWZpZXJzXCIpLCBfYnVpbGRNb2RpZmllclBsdWdpbihcInNuYXBcIiwgc25hcCkpIHx8IF9nc2FwOyAvL3RvIHByZXZlbnQgdGhlIGNvcmUgcGx1Z2lucyBmcm9tIGJlaW5nIGRyb3BwZWQgdmlhIGFnZ3Jlc3NpdmUgdHJlZSBzaGFraW5nLCB3ZSBtdXN0IGluY2x1ZGUgdGhlbSBpbiB0aGUgdmFyaWFibGUgZGVjbGFyYXRpb24gaW4gdGhpcyB3YXkuXG5cblR3ZWVuLnZlcnNpb24gPSBUaW1lbGluZS52ZXJzaW9uID0gZ3NhcC52ZXJzaW9uID0gXCIzLjkuMVwiO1xuX2NvcmVSZWFkeSA9IDE7XG5fd2luZG93RXhpc3RzKCkgJiYgX3dha2UoKTtcbnZhciBQb3dlcjAgPSBfZWFzZU1hcC5Qb3dlcjAsXG4gICAgUG93ZXIxID0gX2Vhc2VNYXAuUG93ZXIxLFxuICAgIFBvd2VyMiA9IF9lYXNlTWFwLlBvd2VyMixcbiAgICBQb3dlcjMgPSBfZWFzZU1hcC5Qb3dlcjMsXG4gICAgUG93ZXI0ID0gX2Vhc2VNYXAuUG93ZXI0LFxuICAgIExpbmVhciA9IF9lYXNlTWFwLkxpbmVhcixcbiAgICBRdWFkID0gX2Vhc2VNYXAuUXVhZCxcbiAgICBDdWJpYyA9IF9lYXNlTWFwLkN1YmljLFxuICAgIFF1YXJ0ID0gX2Vhc2VNYXAuUXVhcnQsXG4gICAgUXVpbnQgPSBfZWFzZU1hcC5RdWludCxcbiAgICBTdHJvbmcgPSBfZWFzZU1hcC5TdHJvbmcsXG4gICAgRWxhc3RpYyA9IF9lYXNlTWFwLkVsYXN0aWMsXG4gICAgQmFjayA9IF9lYXNlTWFwLkJhY2ssXG4gICAgU3RlcHBlZEVhc2UgPSBfZWFzZU1hcC5TdGVwcGVkRWFzZSxcbiAgICBCb3VuY2UgPSBfZWFzZU1hcC5Cb3VuY2UsXG4gICAgU2luZSA9IF9lYXNlTWFwLlNpbmUsXG4gICAgRXhwbyA9IF9lYXNlTWFwLkV4cG8sXG4gICAgQ2lyYyA9IF9lYXNlTWFwLkNpcmM7XG5leHBvcnQgeyBQb3dlcjAsIFBvd2VyMSwgUG93ZXIyLCBQb3dlcjMsIFBvd2VyNCwgTGluZWFyLCBRdWFkLCBDdWJpYywgUXVhcnQsIFF1aW50LCBTdHJvbmcsIEVsYXN0aWMsIEJhY2ssIFN0ZXBwZWRFYXNlLCBCb3VuY2UsIFNpbmUsIEV4cG8sIENpcmMgfTtcbmV4cG9ydCB7IFR3ZWVuIGFzIFR3ZWVuTWF4LCBUd2VlbiBhcyBUd2VlbkxpdGUsIFRpbWVsaW5lIGFzIFRpbWVsaW5lTWF4LCBUaW1lbGluZSBhcyBUaW1lbGluZUxpdGUsIGdzYXAgYXMgZGVmYXVsdCwgd3JhcCwgd3JhcFlveW8sIGRpc3RyaWJ1dGUsIHJhbmRvbSwgc25hcCwgbm9ybWFsaXplLCBnZXRVbml0LCBjbGFtcCwgc3BsaXRDb2xvciwgdG9BcnJheSwgc2VsZWN0b3IsIG1hcFJhbmdlLCBwaXBlLCB1bml0aXplLCBpbnRlcnBvbGF0ZSwgc2h1ZmZsZSB9OyAvL2V4cG9ydCBzb21lIGludGVybmFsIG1ldGhvZHMvb3JvamVjdHMgZm9yIHVzZSBpbiBDU1NQbHVnaW4gc28gdGhhdCB3ZSBjYW4gZXh0ZXJuYWxpemUgdGhhdCBmaWxlIGFuZCBhbGxvdyBjdXN0b20gYnVpbGRzIHRoYXQgZXhjbHVkZSBpdC5cblxuZXhwb3J0IHsgX2dldFByb3BlcnR5LCBfbnVtRXhwLCBfbnVtV2l0aFVuaXRFeHAsIF9pc1N0cmluZywgX2lzVW5kZWZpbmVkLCBfcmVuZGVyQ29tcGxleFN0cmluZywgX3JlbEV4cCwgX3NldERlZmF1bHRzLCBfcmVtb3ZlTGlua2VkTGlzdEl0ZW0sIF9mb3JFYWNoTmFtZSwgX3NvcnRQcm9wVHdlZW5zQnlQcmlvcml0eSwgX2NvbG9yU3RyaW5nRmlsdGVyLCBfcmVwbGFjZVJhbmRvbSwgX2NoZWNrUGx1Z2luLCBfcGx1Z2lucywgX3RpY2tlciwgX2NvbmZpZywgX3JvdW5kTW9kaWZpZXIsIF9yb3VuZCwgX21pc3NpbmdQbHVnaW4sIF9nZXRTZXR0ZXIsIF9nZXRDYWNoZSwgX2NvbG9yRXhwIH07IiwiLyohXG4gKiBtYXRyaXggMy45LjFcbiAqIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbVxuICpcbiAqIENvcHlyaWdodCAyMDA4LTIwMjEsIEdyZWVuU29jay4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFN1YmplY3QgdG8gdGhlIHRlcm1zIGF0IGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9zdGFuZGFyZC1saWNlbnNlIG9yIGZvclxuICogQ2x1YiBHcmVlblNvY2sgbWVtYmVycywgdGhlIGFncmVlbWVudCBpc3N1ZWQgd2l0aCB0aGF0IG1lbWJlcnNoaXAuXG4gKiBAYXV0aG9yOiBKYWNrIERveWxlLCBqYWNrQGdyZWVuc29jay5jb21cbiovXG5cbi8qIGVzbGludC1kaXNhYmxlICovXG52YXIgX2RvYyxcbiAgICBfd2luLFxuICAgIF9kb2NFbGVtZW50LFxuICAgIF9ib2R5LFxuICAgIF9kaXZDb250YWluZXIsXG4gICAgX3N2Z0NvbnRhaW5lcixcbiAgICBfaWRlbnRpdHlNYXRyaXgsXG4gICAgX2dFbCxcbiAgICBfdHJhbnNmb3JtUHJvcCA9IFwidHJhbnNmb3JtXCIsXG4gICAgX3RyYW5zZm9ybU9yaWdpblByb3AgPSBfdHJhbnNmb3JtUHJvcCArIFwiT3JpZ2luXCIsXG4gICAgX2hhc09mZnNldEJ1ZyxcbiAgICBfc2V0RG9jID0gZnVuY3Rpb24gX3NldERvYyhlbGVtZW50KSB7XG4gIHZhciBkb2MgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQgfHwgZWxlbWVudDtcblxuICBpZiAoIShfdHJhbnNmb3JtUHJvcCBpbiBlbGVtZW50LnN0eWxlKSAmJiBcIm1zVHJhbnNmb3JtXCIgaW4gZWxlbWVudC5zdHlsZSkge1xuICAgIC8vdG8gaW1wcm92ZSBjb21wYXRpYmlsaXR5IHdpdGggb2xkIE1pY3Jvc29mdCBicm93c2Vyc1xuICAgIF90cmFuc2Zvcm1Qcm9wID0gXCJtc1RyYW5zZm9ybVwiO1xuICAgIF90cmFuc2Zvcm1PcmlnaW5Qcm9wID0gX3RyYW5zZm9ybVByb3AgKyBcIk9yaWdpblwiO1xuICB9XG5cbiAgd2hpbGUgKGRvYy5wYXJlbnROb2RlICYmIChkb2MgPSBkb2MucGFyZW50Tm9kZSkpIHt9XG5cbiAgX3dpbiA9IHdpbmRvdztcbiAgX2lkZW50aXR5TWF0cml4ID0gbmV3IE1hdHJpeDJEKCk7XG5cbiAgaWYgKGRvYykge1xuICAgIF9kb2MgPSBkb2M7XG4gICAgX2RvY0VsZW1lbnQgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgIF9ib2R5ID0gZG9jLmJvZHk7XG4gICAgX2dFbCA9IF9kb2MuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJnXCIpOyAvLyBwcmV2ZW50IGFueSBleGlzdGluZyBDU1MgZnJvbSB0cmFuc2Zvcm1pbmcgaXRcblxuICAgIF9nRWwuc3R5bGUudHJhbnNmb3JtID0gXCJub25lXCI7IC8vIG5vdyB0ZXN0IGZvciB0aGUgb2Zmc2V0IHJlcG9ydGluZyBidWcuIFVzZSBmZWF0dXJlIGRldGVjdGlvbiBpbnN0ZWFkIG9mIGJyb3dzZXIgc25pZmZpbmcgdG8gbWFrZSB0aGluZ3MgbW9yZSBidWxsZXRwcm9vZiBhbmQgZnV0dXJlLXByb29mLiBIb3BlZnVsbHkgU2FmYXJpIHdpbGwgZml4IHRoZWlyIGJ1ZyBzb29uIGJ1dCBpdCdzIDIwMjAgYW5kIGl0J3Mgc3RpbGwgbm90IGZpeGVkLlxuXG4gICAgdmFyIGQxID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgIGQyID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cbiAgICBfYm9keS5hcHBlbmRDaGlsZChkMSk7XG5cbiAgICBkMS5hcHBlbmRDaGlsZChkMik7XG4gICAgZDEuc3R5bGUucG9zaXRpb24gPSBcInN0YXRpY1wiO1xuICAgIGQxLnN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IFwidHJhbnNsYXRlM2QoMCwwLDFweClcIjtcbiAgICBfaGFzT2Zmc2V0QnVnID0gZDIub2Zmc2V0UGFyZW50ICE9PSBkMTtcblxuICAgIF9ib2R5LnJlbW92ZUNoaWxkKGQxKTtcbiAgfVxuXG4gIHJldHVybiBkb2M7XG59LFxuICAgIF9mb3JjZU5vblplcm9TY2FsZSA9IGZ1bmN0aW9uIF9mb3JjZU5vblplcm9TY2FsZShlKSB7XG4gIC8vIHdhbGtzIHVwIHRoZSBlbGVtZW50J3MgYW5jZXN0b3JzIGFuZCBmaW5kcyBhbnkgdGhhdCBoYWQgdGhlaXIgc2NhbGUgc2V0IHRvIDAgdmlhIEdTQVAsIGFuZCBjaGFuZ2VzIHRoZW0gdG8gMC4wMDAxIHRvIGVuc3VyZSB0aGF0IG1lYXN1cmVtZW50cyB3b3JrLiBGaXJlZm94IGhhcyBhIGJ1ZyB0aGF0IGNhdXNlcyBpdCB0byBpbmNvcnJlY3RseSByZXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgd2hlbiBzY2FsZSBpcyAwLlxuICB2YXIgYSwgY2FjaGU7XG5cbiAgd2hpbGUgKGUgJiYgZSAhPT0gX2JvZHkpIHtcbiAgICBjYWNoZSA9IGUuX2dzYXA7XG4gICAgY2FjaGUgJiYgY2FjaGUudW5jYWNoZSAmJiBjYWNoZS5nZXQoZSwgXCJ4XCIpOyAvLyBmb3JjZSByZS1wYXJzaW5nIG9mIHRyYW5zZm9ybXMgaWYgbmVjZXNzYXJ5XG5cbiAgICBpZiAoY2FjaGUgJiYgIWNhY2hlLnNjYWxlWCAmJiAhY2FjaGUuc2NhbGVZICYmIGNhY2hlLnJlbmRlclRyYW5zZm9ybSkge1xuICAgICAgY2FjaGUuc2NhbGVYID0gY2FjaGUuc2NhbGVZID0gMWUtNDtcbiAgICAgIGNhY2hlLnJlbmRlclRyYW5zZm9ybSgxLCBjYWNoZSk7XG4gICAgICBhID8gYS5wdXNoKGNhY2hlKSA6IGEgPSBbY2FjaGVdO1xuICAgIH1cblxuICAgIGUgPSBlLnBhcmVudE5vZGU7XG4gIH1cblxuICByZXR1cm4gYTtcbn0sXG4gICAgLy8gcG9zc2libGUgZnV0dXJlIGFkZGl0aW9uOiBwYXNzIGFuIGVsZW1lbnQgdG8gX2ZvcmNlRGlzcGxheSgpIGFuZCBpdCdsbCB3YWxrIHVwIGFsbCBpdHMgYW5jZXN0b3JzIGFuZCBtYWtlIHN1cmUgYW55dGhpbmcgd2l0aCBkaXNwbGF5OiBub25lIGlzIHNldCB0byBkaXNwbGF5OiBibG9jaywgYW5kIGlmIHRoZXJlJ3Mgbm8gcGFyZW50Tm9kZSwgaXQnbGwgYWRkIGl0IHRvIHRoZSBib2R5LiBJdCByZXR1cm5zIGFuIEFycmF5IHRoYXQgeW91IGNhbiB0aGVuIGZlZWQgdG8gX3JldmVydERpc3BsYXkoKSB0byBoYXZlIGl0IHJldmVydCBhbGwgdGhlIGNoYW5nZXMgaXQgbWFkZS5cbi8vIF9mb3JjZURpc3BsYXkgPSBlID0+IHtcbi8vIFx0bGV0IGEgPSBbXSxcbi8vIFx0XHRwYXJlbnQ7XG4vLyBcdHdoaWxlIChlICYmIGUgIT09IF9ib2R5KSB7XG4vLyBcdFx0cGFyZW50ID0gZS5wYXJlbnROb2RlO1xuLy8gXHRcdChfd2luLmdldENvbXB1dGVkU3R5bGUoZSkuZGlzcGxheSA9PT0gXCJub25lXCIgfHwgIXBhcmVudCkgJiYgYS5wdXNoKGUsIGUuc3R5bGUuZGlzcGxheSwgcGFyZW50KSAmJiAoZS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiKTtcbi8vIFx0XHRwYXJlbnQgfHwgX2JvZHkuYXBwZW5kQ2hpbGQoZSk7XG4vLyBcdFx0ZSA9IHBhcmVudDtcbi8vIFx0fVxuLy8gXHRyZXR1cm4gYTtcbi8vIH0sXG4vLyBfcmV2ZXJ0RGlzcGxheSA9IGEgPT4ge1xuLy8gXHRmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKz0zKSB7XG4vLyBcdFx0YVtpKzFdID8gKGFbaV0uc3R5bGUuZGlzcGxheSA9IGFbaSsxXSkgOiBhW2ldLnN0eWxlLnJlbW92ZVByb3BlcnR5KFwiZGlzcGxheVwiKTtcbi8vIFx0XHRhW2krMl0gfHwgYVtpXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGFbaV0pO1xuLy8gXHR9XG4vLyB9LFxuX3N2Z1RlbXBzID0gW10sXG4gICAgLy93ZSBjcmVhdGUgMyBlbGVtZW50cyBmb3IgU1ZHLCBhbmQgMyBmb3Igb3RoZXIgRE9NIGVsZW1lbnRzIGFuZCBjYWNoZSB0aGVtIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBUaGV5IGdldCBuZXN0ZWQgaW4gX2RpdkNvbnRhaW5lciBhbmQgX3N2Z0NvbnRhaW5lciBzbyB0aGF0IGp1c3Qgb25lIGVsZW1lbnQgaXMgYWRkZWQgdG8gdGhlIERPTSBvbiBlYWNoIHN1Y2Nlc3NpdmUgYXR0ZW1wdC4gQWdhaW4sIHBlcmZvcm1hbmNlIGlzIGtleS5cbl9kaXZUZW1wcyA9IFtdLFxuICAgIF9nZXREb2NTY3JvbGxUb3AgPSBmdW5jdGlvbiBfZ2V0RG9jU2Nyb2xsVG9wKCkge1xuICByZXR1cm4gX3dpbi5wYWdlWU9mZnNldCB8fCBfZG9jLnNjcm9sbFRvcCB8fCBfZG9jRWxlbWVudC5zY3JvbGxUb3AgfHwgX2JvZHkuc2Nyb2xsVG9wIHx8IDA7XG59LFxuICAgIF9nZXREb2NTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gX2dldERvY1Njcm9sbExlZnQoKSB7XG4gIHJldHVybiBfd2luLnBhZ2VYT2Zmc2V0IHx8IF9kb2Muc2Nyb2xsTGVmdCB8fCBfZG9jRWxlbWVudC5zY3JvbGxMZWZ0IHx8IF9ib2R5LnNjcm9sbExlZnQgfHwgMDtcbn0sXG4gICAgX3N2Z093bmVyID0gZnVuY3Rpb24gX3N2Z093bmVyKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQub3duZXJTVkdFbGVtZW50IHx8ICgoZWxlbWVudC50YWdOYW1lICsgXCJcIikudG9Mb3dlckNhc2UoKSA9PT0gXCJzdmdcIiA/IGVsZW1lbnQgOiBudWxsKTtcbn0sXG4gICAgX2lzRml4ZWQgPSBmdW5jdGlvbiBfaXNGaXhlZChlbGVtZW50KSB7XG4gIGlmIChfd2luLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09IFwiZml4ZWRcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZTtcblxuICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgLy8gYXZvaWQgZG9jdW1lbnQgZnJhZ21lbnRzIHdoaWNoIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAgcmV0dXJuIF9pc0ZpeGVkKGVsZW1lbnQpO1xuICB9XG59LFxuICAgIF9jcmVhdGVTaWJsaW5nID0gZnVuY3Rpb24gX2NyZWF0ZVNpYmxpbmcoZWxlbWVudCwgaSkge1xuICBpZiAoZWxlbWVudC5wYXJlbnROb2RlICYmIChfZG9jIHx8IF9zZXREb2MoZWxlbWVudCkpKSB7XG4gICAgdmFyIHN2ZyA9IF9zdmdPd25lcihlbGVtZW50KSxcbiAgICAgICAgbnMgPSBzdmcgPyBzdmcuZ2V0QXR0cmlidXRlKFwieG1sbnNcIikgfHwgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIDogXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIsXG4gICAgICAgIHR5cGUgPSBzdmcgPyBpID8gXCJyZWN0XCIgOiBcImdcIiA6IFwiZGl2XCIsXG4gICAgICAgIHggPSBpICE9PSAyID8gMCA6IDEwMCxcbiAgICAgICAgeSA9IGkgPT09IDMgPyAxMDAgOiAwLFxuICAgICAgICBjc3MgPSBcInBvc2l0aW9uOmFic29sdXRlO2Rpc3BsYXk6YmxvY2s7cG9pbnRlci1ldmVudHM6bm9uZTttYXJnaW46MDtwYWRkaW5nOjA7XCIsXG4gICAgICAgIGUgPSBfZG9jLmNyZWF0ZUVsZW1lbnROUyA/IF9kb2MuY3JlYXRlRWxlbWVudE5TKG5zLnJlcGxhY2UoL15odHRwcy8sIFwiaHR0cFwiKSwgdHlwZSkgOiBfZG9jLmNyZWF0ZUVsZW1lbnQodHlwZSk7XG5cbiAgICBpZiAoaSkge1xuICAgICAgaWYgKCFzdmcpIHtcbiAgICAgICAgaWYgKCFfZGl2Q29udGFpbmVyKSB7XG4gICAgICAgICAgX2RpdkNvbnRhaW5lciA9IF9jcmVhdGVTaWJsaW5nKGVsZW1lbnQpO1xuICAgICAgICAgIF9kaXZDb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IGNzcztcbiAgICAgICAgfVxuXG4gICAgICAgIGUuc3R5bGUuY3NzVGV4dCA9IGNzcyArIFwid2lkdGg6MC4xcHg7aGVpZ2h0OjAuMXB4O3RvcDpcIiArIHkgKyBcInB4O2xlZnQ6XCIgKyB4ICsgXCJweFwiO1xuXG4gICAgICAgIF9kaXZDb250YWluZXIuYXBwZW5kQ2hpbGQoZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfc3ZnQ29udGFpbmVyIHx8IChfc3ZnQ29udGFpbmVyID0gX2NyZWF0ZVNpYmxpbmcoZWxlbWVudCkpO1xuICAgICAgICBlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIDAuMDEpO1xuICAgICAgICBlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCAwLjAxKTtcbiAgICAgICAgZS5zZXRBdHRyaWJ1dGUoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCIpXCIpO1xuXG4gICAgICAgIF9zdmdDb250YWluZXIuYXBwZW5kQ2hpbGQoZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGU7XG4gIH1cblxuICB0aHJvdyBcIk5lZWQgZG9jdW1lbnQgYW5kIHBhcmVudC5cIjtcbn0sXG4gICAgX2NvbnNvbGlkYXRlID0gZnVuY3Rpb24gX2NvbnNvbGlkYXRlKG0pIHtcbiAgLy8gcmVwbGFjZXMgU1ZHVHJhbnNmb3JtTGlzdC5jb25zb2xpZGF0ZSgpIGJlY2F1c2UgYSBidWcgaW4gRmlyZWZveCBjYXVzZXMgaXQgdG8gYnJlYWsgcG9pbnRlciBldmVudHMuIFNlZSBodHRwczovL2dyZWVuc29jay5jb20vZm9ydW1zL3RvcGljLzIzMjQ4LXRvdWNoLWlzLW5vdC13b3JraW5nLW9uLWRyYWdnYWJsZS1pbi1maXJlZm94LXdpbmRvd3MtdjMyNC8/dGFiPWNvbW1lbnRzI2NvbW1lbnQtMTA5ODAwXG4gIHZhciBjID0gbmV3IE1hdHJpeDJEKCksXG4gICAgICBpID0gMDtcblxuICBmb3IgKDsgaSA8IG0ubnVtYmVyT2ZJdGVtczsgaSsrKSB7XG4gICAgYy5tdWx0aXBseShtLmdldEl0ZW0oaSkubWF0cml4KTtcbiAgfVxuXG4gIHJldHVybiBjO1xufSxcbiAgICBfZ2V0Q1RNID0gZnVuY3Rpb24gX2dldENUTShzdmcpIHtcbiAgdmFyIG0gPSBzdmcuZ2V0Q1RNKCksXG4gICAgICB0cmFuc2Zvcm07XG5cbiAgaWYgKCFtKSB7XG4gICAgLy8gRmlyZWZveCByZXR1cm5zIG51bGwgZm9yIGdldENUTSgpIG9uIHJvb3QgPHN2Zz4gZWxlbWVudHMsIHNvIHRoaXMgaXMgYSB3b3JrYXJvdW5kIHVzaW5nIGEgPGc+IHRoYXQgd2UgdGVtcG9yYXJpbHkgYXBwZW5kLlxuICAgIHRyYW5zZm9ybSA9IHN2Zy5zdHlsZVtfdHJhbnNmb3JtUHJvcF07XG4gICAgc3ZnLnN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IFwibm9uZVwiOyAvLyBhIGJ1ZyBpbiBGaXJlZm94IGNhdXNlcyBjc3MgdHJhbnNmb3JtcyB0byBjb250YW1pbmF0ZSB0aGUgZ2V0Q1RNKClcblxuICAgIHN2Zy5hcHBlbmRDaGlsZChfZ0VsKTtcbiAgICBtID0gX2dFbC5nZXRDVE0oKTtcbiAgICBzdmcucmVtb3ZlQ2hpbGQoX2dFbCk7XG4gICAgdHJhbnNmb3JtID8gc3ZnLnN0eWxlW190cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybSA6IHN2Zy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShfdHJhbnNmb3JtUHJvcC5yZXBsYWNlKC8oW0EtWl0pL2csIFwiLSQxXCIpLnRvTG93ZXJDYXNlKCkpO1xuICB9XG5cbiAgcmV0dXJuIG0gfHwgX2lkZW50aXR5TWF0cml4LmNsb25lKCk7IC8vIEZpcmVmb3ggd2lsbCBzdGlsbCByZXR1cm4gbnVsbCBpZiB0aGUgPHN2Zz4gaGFzIGEgd2lkdGgvaGVpZ2h0IG9mIDAgaW4gdGhlIGJyb3dzZXIuXG59LFxuICAgIF9wbGFjZVNpYmxpbmdzID0gZnVuY3Rpb24gX3BsYWNlU2libGluZ3MoZWxlbWVudCwgYWRqdXN0R09mZnNldCkge1xuICB2YXIgc3ZnID0gX3N2Z093bmVyKGVsZW1lbnQpLFxuICAgICAgaXNSb290U1ZHID0gZWxlbWVudCA9PT0gc3ZnLFxuICAgICAgc2libGluZ3MgPSBzdmcgPyBfc3ZnVGVtcHMgOiBfZGl2VGVtcHMsXG4gICAgICBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGUsXG4gICAgICBjb250YWluZXIsXG4gICAgICBtLFxuICAgICAgYixcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgY3M7XG5cbiAgaWYgKGVsZW1lbnQgPT09IF93aW4pIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHNpYmxpbmdzLmxlbmd0aCB8fCBzaWJsaW5ncy5wdXNoKF9jcmVhdGVTaWJsaW5nKGVsZW1lbnQsIDEpLCBfY3JlYXRlU2libGluZyhlbGVtZW50LCAyKSwgX2NyZWF0ZVNpYmxpbmcoZWxlbWVudCwgMykpO1xuICBjb250YWluZXIgPSBzdmcgPyBfc3ZnQ29udGFpbmVyIDogX2RpdkNvbnRhaW5lcjtcblxuICBpZiAoc3ZnKSB7XG4gICAgaWYgKGlzUm9vdFNWRykge1xuICAgICAgYiA9IF9nZXRDVE0oZWxlbWVudCk7XG4gICAgICB4ID0gLWIuZSAvIGIuYTtcbiAgICAgIHkgPSAtYi5mIC8gYi5kO1xuICAgICAgbSA9IF9pZGVudGl0eU1hdHJpeDtcbiAgICB9IGVsc2Uge1xuICAgICAgYiA9IGVsZW1lbnQuZ2V0QkJveCgpO1xuICAgICAgbSA9IGVsZW1lbnQudHJhbnNmb3JtID8gZWxlbWVudC50cmFuc2Zvcm0uYmFzZVZhbCA6IHt9OyAvLyBJRTExIGRvZXNuJ3QgZm9sbG93IHRoZSBzcGVjLlxuXG4gICAgICBtID0gIW0ubnVtYmVyT2ZJdGVtcyA/IF9pZGVudGl0eU1hdHJpeCA6IG0ubnVtYmVyT2ZJdGVtcyA+IDEgPyBfY29uc29saWRhdGUobSkgOiBtLmdldEl0ZW0oMCkubWF0cml4OyAvLyBkb24ndCBjYWxsIG0uY29uc29saWRhdGUoKS5tYXRyaXggYmVjYXVzZSBhIGJ1ZyBpbiBGaXJlZm94IG1ha2VzIHBvaW50ZXIgZXZlbnRzIG5vdCB3b3JrIHdoZW4gY29uc29saWRhdGUoKSBpcyBjYWxsZWQgb24gdGhlIHNhbWUgdGljayBhcyBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSEgU2VlIGh0dHBzOi8vZ3JlZW5zb2NrLmNvbS9mb3J1bXMvdG9waWMvMjMyNDgtdG91Y2gtaXMtbm90LXdvcmtpbmctb24tZHJhZ2dhYmxlLWluLWZpcmVmb3gtd2luZG93cy12MzI0Lz90YWI9Y29tbWVudHMjY29tbWVudC0xMDk4MDBcblxuICAgICAgeCA9IG0uYSAqIGIueCArIG0uYyAqIGIueTtcbiAgICAgIHkgPSBtLmIgKiBiLnggKyBtLmQgKiBiLnk7XG4gICAgfVxuXG4gICAgaWYgKGFkanVzdEdPZmZzZXQgJiYgZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiZ1wiKSB7XG4gICAgICB4ID0geSA9IDA7XG4gICAgfVxuXG4gICAgKGlzUm9vdFNWRyA/IHN2ZyA6IHBhcmVudCkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsIFwibWF0cml4KFwiICsgbS5hICsgXCIsXCIgKyBtLmIgKyBcIixcIiArIG0uYyArIFwiLFwiICsgbS5kICsgXCIsXCIgKyAobS5lICsgeCkgKyBcIixcIiArIChtLmYgKyB5KSArIFwiKVwiKTtcbiAgfSBlbHNlIHtcbiAgICB4ID0geSA9IDA7XG5cbiAgICBpZiAoX2hhc09mZnNldEJ1Zykge1xuICAgICAgLy8gc29tZSBicm93c2VycyAobGlrZSBTYWZhcmkpIGhhdmUgYSBidWcgdGhhdCBjYXVzZXMgdGhlbSB0byBtaXNyZXBvcnQgb2Zmc2V0IHZhbHVlcy4gV2hlbiBhbiBhbmNlc3RvciBlbGVtZW50IGhhcyBhIHRyYW5zZm9ybSBhcHBsaWVkLCBpdCdzIHN1cHBvc2VkIHRvIHRyZWF0IGl0IGFzIGlmIGl0J3MgcG9zaXRpb246IHJlbGF0aXZlIChuZXcgY29udGV4dCkuIFNhZmFyaSBib3RjaGVzIHRoaXMsIHNvIHdlIG5lZWQgdG8gZmluZCB0aGUgY2xvc2VzdCBhbmNlc3RvciAoYmV0d2VlbiB0aGUgZWxlbWVudCBhbmQgaXRzIG9mZnNldFBhcmVudCkgdGhhdCBoYXMgYSB0cmFuc2Zvcm0gYXBwbGllZCBhbmQgaWYgb25lIGlzIGZvdW5kLCBncmFiIGl0cyBvZmZzZXRUb3AvTGVmdCBhbmQgc3VidHJhY3QgdGhlbSB0byBjb21wZW5zYXRlLlxuICAgICAgbSA9IGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuICAgICAgYiA9IGVsZW1lbnQ7XG5cbiAgICAgIHdoaWxlIChiICYmIChiID0gYi5wYXJlbnROb2RlKSAmJiBiICE9PSBtICYmIGIucGFyZW50Tm9kZSkge1xuICAgICAgICBpZiAoKF93aW4uZ2V0Q29tcHV0ZWRTdHlsZShiKVtfdHJhbnNmb3JtUHJvcF0gKyBcIlwiKS5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgeCA9IGIub2Zmc2V0TGVmdDtcbiAgICAgICAgICB5ID0gYi5vZmZzZXRUb3A7XG4gICAgICAgICAgYiA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjcyA9IF93aW4uZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuICAgIGlmIChjcy5wb3NpdGlvbiAhPT0gXCJhYnNvbHV0ZVwiICYmIGNzLnBvc2l0aW9uICE9PSBcImZpeGVkXCIpIHtcbiAgICAgIG0gPSBlbGVtZW50Lm9mZnNldFBhcmVudDtcblxuICAgICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQgIT09IG0pIHtcbiAgICAgICAgLy8gaWYgdGhlcmUncyBhbiBhbmNlc3RvciBlbGVtZW50IGJldHdlZW4gdGhlIGVsZW1lbnQgYW5kIGl0cyBvZmZzZXRQYXJlbnQgdGhhdCdzIHNjcm9sbGVkLCB3ZSBtdXN0IGZhY3RvciB0aGF0IGluLlxuICAgICAgICB4ICs9IHBhcmVudC5zY3JvbGxMZWZ0IHx8IDA7XG4gICAgICAgIHkgKz0gcGFyZW50LnNjcm9sbFRvcCB8fCAwO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBiID0gY29udGFpbmVyLnN0eWxlO1xuICAgIGIudG9wID0gZWxlbWVudC5vZmZzZXRUb3AgLSB5ICsgXCJweFwiO1xuICAgIGIubGVmdCA9IGVsZW1lbnQub2Zmc2V0TGVmdCAtIHggKyBcInB4XCI7XG4gICAgYltfdHJhbnNmb3JtUHJvcF0gPSBjc1tfdHJhbnNmb3JtUHJvcF07XG4gICAgYltfdHJhbnNmb3JtT3JpZ2luUHJvcF0gPSBjc1tfdHJhbnNmb3JtT3JpZ2luUHJvcF07IC8vIGIuYm9yZGVyID0gbS5ib3JkZXI7XG4gICAgLy8gYi5ib3JkZXJMZWZ0U3R5bGUgPSBtLmJvcmRlckxlZnRTdHlsZTtcbiAgICAvLyBiLmJvcmRlclRvcFN0eWxlID0gbS5ib3JkZXJUb3BTdHlsZTtcbiAgICAvLyBiLmJvcmRlckxlZnRXaWR0aCA9IG0uYm9yZGVyTGVmdFdpZHRoO1xuICAgIC8vIGIuYm9yZGVyVG9wV2lkdGggPSBtLmJvcmRlclRvcFdpZHRoO1xuXG4gICAgYi5wb3NpdGlvbiA9IGNzLnBvc2l0aW9uID09PSBcImZpeGVkXCIgPyBcImZpeGVkXCIgOiBcImFic29sdXRlXCI7XG4gICAgZWxlbWVudC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gIH1cblxuICByZXR1cm4gY29udGFpbmVyO1xufSxcbiAgICBfc2V0TWF0cml4ID0gZnVuY3Rpb24gX3NldE1hdHJpeChtLCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIG0uYSA9IGE7XG4gIG0uYiA9IGI7XG4gIG0uYyA9IGM7XG4gIG0uZCA9IGQ7XG4gIG0uZSA9IGU7XG4gIG0uZiA9IGY7XG4gIHJldHVybiBtO1xufTtcblxuZXhwb3J0IHZhciBNYXRyaXgyRCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1hdHJpeDJEKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICBpZiAoYSA9PT0gdm9pZCAwKSB7XG4gICAgICBhID0gMTtcbiAgICB9XG5cbiAgICBpZiAoYiA9PT0gdm9pZCAwKSB7XG4gICAgICBiID0gMDtcbiAgICB9XG5cbiAgICBpZiAoYyA9PT0gdm9pZCAwKSB7XG4gICAgICBjID0gMDtcbiAgICB9XG5cbiAgICBpZiAoZCA9PT0gdm9pZCAwKSB7XG4gICAgICBkID0gMTtcbiAgICB9XG5cbiAgICBpZiAoZSA9PT0gdm9pZCAwKSB7XG4gICAgICBlID0gMDtcbiAgICB9XG5cbiAgICBpZiAoZiA9PT0gdm9pZCAwKSB7XG4gICAgICBmID0gMDtcbiAgICB9XG5cbiAgICBfc2V0TWF0cml4KHRoaXMsIGEsIGIsIGMsIGQsIGUsIGYpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IE1hdHJpeDJELnByb3RvdHlwZTtcblxuICBfcHJvdG8uaW52ZXJzZSA9IGZ1bmN0aW9uIGludmVyc2UoKSB7XG4gICAgdmFyIGEgPSB0aGlzLmEsXG4gICAgICAgIGIgPSB0aGlzLmIsXG4gICAgICAgIGMgPSB0aGlzLmMsXG4gICAgICAgIGQgPSB0aGlzLmQsXG4gICAgICAgIGUgPSB0aGlzLmUsXG4gICAgICAgIGYgPSB0aGlzLmYsXG4gICAgICAgIGRldGVybWluYW50ID0gYSAqIGQgLSBiICogYyB8fCAxZS0xMDtcbiAgICByZXR1cm4gX3NldE1hdHJpeCh0aGlzLCBkIC8gZGV0ZXJtaW5hbnQsIC1iIC8gZGV0ZXJtaW5hbnQsIC1jIC8gZGV0ZXJtaW5hbnQsIGEgLyBkZXRlcm1pbmFudCwgKGMgKiBmIC0gZCAqIGUpIC8gZGV0ZXJtaW5hbnQsIC0oYSAqIGYgLSBiICogZSkgLyBkZXRlcm1pbmFudCk7XG4gIH07XG5cbiAgX3Byb3RvLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkobWF0cml4KSB7XG4gICAgdmFyIGEgPSB0aGlzLmEsXG4gICAgICAgIGIgPSB0aGlzLmIsXG4gICAgICAgIGMgPSB0aGlzLmMsXG4gICAgICAgIGQgPSB0aGlzLmQsXG4gICAgICAgIGUgPSB0aGlzLmUsXG4gICAgICAgIGYgPSB0aGlzLmYsXG4gICAgICAgIGEyID0gbWF0cml4LmEsXG4gICAgICAgIGIyID0gbWF0cml4LmMsXG4gICAgICAgIGMyID0gbWF0cml4LmIsXG4gICAgICAgIGQyID0gbWF0cml4LmQsXG4gICAgICAgIGUyID0gbWF0cml4LmUsXG4gICAgICAgIGYyID0gbWF0cml4LmY7XG4gICAgcmV0dXJuIF9zZXRNYXRyaXgodGhpcywgYTIgKiBhICsgYzIgKiBjLCBhMiAqIGIgKyBjMiAqIGQsIGIyICogYSArIGQyICogYywgYjIgKiBiICsgZDIgKiBkLCBlICsgZTIgKiBhICsgZjIgKiBjLCBmICsgZTIgKiBiICsgZjIgKiBkKTtcbiAgfTtcblxuICBfcHJvdG8uY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDJEKHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIHRoaXMuZCwgdGhpcy5lLCB0aGlzLmYpO1xuICB9O1xuXG4gIF9wcm90by5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMobWF0cml4KSB7XG4gICAgdmFyIGEgPSB0aGlzLmEsXG4gICAgICAgIGIgPSB0aGlzLmIsXG4gICAgICAgIGMgPSB0aGlzLmMsXG4gICAgICAgIGQgPSB0aGlzLmQsXG4gICAgICAgIGUgPSB0aGlzLmUsXG4gICAgICAgIGYgPSB0aGlzLmY7XG4gICAgcmV0dXJuIGEgPT09IG1hdHJpeC5hICYmIGIgPT09IG1hdHJpeC5iICYmIGMgPT09IG1hdHJpeC5jICYmIGQgPT09IG1hdHJpeC5kICYmIGUgPT09IG1hdHJpeC5lICYmIGYgPT09IG1hdHJpeC5mO1xuICB9O1xuXG4gIF9wcm90by5hcHBseSA9IGZ1bmN0aW9uIGFwcGx5KHBvaW50LCBkZWNvcmF0ZWUpIHtcbiAgICBpZiAoZGVjb3JhdGVlID09PSB2b2lkIDApIHtcbiAgICAgIGRlY29yYXRlZSA9IHt9O1xuICAgIH1cblxuICAgIHZhciB4ID0gcG9pbnQueCxcbiAgICAgICAgeSA9IHBvaW50LnksXG4gICAgICAgIGEgPSB0aGlzLmEsXG4gICAgICAgIGIgPSB0aGlzLmIsXG4gICAgICAgIGMgPSB0aGlzLmMsXG4gICAgICAgIGQgPSB0aGlzLmQsXG4gICAgICAgIGUgPSB0aGlzLmUsXG4gICAgICAgIGYgPSB0aGlzLmY7XG4gICAgZGVjb3JhdGVlLnggPSB4ICogYSArIHkgKiBjICsgZSB8fCAwO1xuICAgIGRlY29yYXRlZS55ID0geCAqIGIgKyB5ICogZCArIGYgfHwgMDtcbiAgICByZXR1cm4gZGVjb3JhdGVlO1xuICB9O1xuXG4gIHJldHVybiBNYXRyaXgyRDtcbn0oKTsgLy8gRmVlZCBpbiBhbiBlbGVtZW50IGFuZCBpdCdsbCByZXR1cm4gYSAyRCBtYXRyaXggKG9wdGlvbmFsbHkgaW52ZXJ0ZWQpIHNvIHRoYXQgeW91IGNhbiB0cmFuc2xhdGUgYmV0d2VlbiBjb29yZGluYXRlIHNwYWNlcy5cbi8vIEludmVydGluZyBsZXRzIHlvdSB0cmFuc2xhdGUgYSBnbG9iYWwgcG9pbnQgaW50byBhIGxvY2FsIGNvb3JkaW5hdGUgc3BhY2UuIE5vIGludmVydGluZyBsZXRzIHlvdSBnbyB0aGUgb3RoZXIgd2F5LlxuLy8gV2UgbmVlZGVkIHRoaXMgdG8gd29yayBhcm91bmQgdmFyaW91cyBicm93c2VyIGJ1Z3MsIGxpa2UgRmlyZWZveCBkb2Vzbid0IGFjY3VyYXRlbHkgcmVwb3J0IGdldFNjcmVlbkNUTSgpIHdoZW4gdGhlcmVcbi8vIGFyZSB0cmFuc2Zvcm1zIGFwcGxpZWQgdG8gYW5jZXN0b3IgZWxlbWVudHMuXG4vLyBUaGUgbWF0cml4IG1hdGggdG8gY29udmVydCBhbnkgeC95IGNvb3JkaW5hdGUgaXMgYXMgZm9sbG93cywgd2hpY2ggaXMgd3JhcHBlZCBpbiBhIGNvbnZlbmllbnQgYXBwbHkoKSBtZXRob2Qgb2YgTWF0cml4MkQgYWJvdmU6XG4vLyAgICAgdHggPSBtLmEgKiB4ICsgbS5jICogeSArIG0uZVxuLy8gICAgIHR5ID0gbS5iICogeCArIG0uZCAqIHkgKyBtLmZcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEdsb2JhbE1hdHJpeChlbGVtZW50LCBpbnZlcnNlLCBhZGp1c3RHT2Zmc2V0LCBpbmNsdWRlU2Nyb2xsSW5GaXhlZCkge1xuICAvLyBhZGp1c3RHT2Zmc2V0IGlzIHR5cGljYWxseSB1c2VkIG9ubHkgd2hlbiBncmFiYmluZyBhbiBlbGVtZW50J3MgUEFSRU5UJ3MgZ2xvYmFsIG1hdHJpeCwgYW5kIGl0IGlnbm9yZXMgdGhlIHgveSBvZmZzZXQgb2YgYW55IFNWRyA8Zz4gZWxlbWVudHMgYmVjYXVzZSB0aGV5IGJlaGF2ZSBpbiBhIHNwZWNpYWwgd2F5LlxuICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQucGFyZW50Tm9kZSB8fCAoX2RvYyB8fCBfc2V0RG9jKGVsZW1lbnQpKS5kb2N1bWVudEVsZW1lbnQgPT09IGVsZW1lbnQpIHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeDJEKCk7XG4gIH1cblxuICB2YXIgemVyb1NjYWxlcyA9IF9mb3JjZU5vblplcm9TY2FsZShlbGVtZW50KSxcbiAgICAgIHN2ZyA9IF9zdmdPd25lcihlbGVtZW50KSxcbiAgICAgIHRlbXBzID0gc3ZnID8gX3N2Z1RlbXBzIDogX2RpdlRlbXBzLFxuICAgICAgY29udGFpbmVyID0gX3BsYWNlU2libGluZ3MoZWxlbWVudCwgYWRqdXN0R09mZnNldCksXG4gICAgICBiMSA9IHRlbXBzWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgYjIgPSB0ZW1wc1sxXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIGIzID0gdGVtcHNbMl0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBwYXJlbnQgPSBjb250YWluZXIucGFyZW50Tm9kZSxcbiAgICAgIGlzRml4ZWQgPSAhaW5jbHVkZVNjcm9sbEluRml4ZWQgJiYgX2lzRml4ZWQoZWxlbWVudCksXG4gICAgICBtID0gbmV3IE1hdHJpeDJEKChiMi5sZWZ0IC0gYjEubGVmdCkgLyAxMDAsIChiMi50b3AgLSBiMS50b3ApIC8gMTAwLCAoYjMubGVmdCAtIGIxLmxlZnQpIC8gMTAwLCAoYjMudG9wIC0gYjEudG9wKSAvIDEwMCwgYjEubGVmdCArIChpc0ZpeGVkID8gMCA6IF9nZXREb2NTY3JvbGxMZWZ0KCkpLCBiMS50b3AgKyAoaXNGaXhlZCA/IDAgOiBfZ2V0RG9jU2Nyb2xsVG9wKCkpKTtcblxuICBwYXJlbnQucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTtcblxuICBpZiAoemVyb1NjYWxlcykge1xuICAgIGIxID0gemVyb1NjYWxlcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoYjEtLSkge1xuICAgICAgYjIgPSB6ZXJvU2NhbGVzW2IxXTtcbiAgICAgIGIyLnNjYWxlWCA9IGIyLnNjYWxlWSA9IDA7XG4gICAgICBiMi5yZW5kZXJUcmFuc2Zvcm0oMSwgYjIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbnZlcnNlID8gbS5pbnZlcnNlKCkgOiBtO1xufVxuZXhwb3J0IHsgX2dldERvY1Njcm9sbFRvcCwgX2dldERvY1Njcm9sbExlZnQsIF9zZXREb2MsIF9pc0ZpeGVkLCBfZ2V0Q1RNIH07IC8vIGV4cG9ydCBmdW5jdGlvbiBnZXRNYXRyaXgoZWxlbWVudCkge1xuLy8gXHRfZG9jIHx8IF9zZXREb2MoZWxlbWVudCk7XG4vLyBcdGxldCBtID0gKF93aW4uZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KVtfdHJhbnNmb3JtUHJvcF0gKyBcIlwiKS5zdWJzdHIoNykubWF0Y2goL1stLl0qXFxkK1suZVxcLStdKlxcZCpbZVxcLVxcK10qXFxkKi9nKSxcbi8vIFx0XHRpczJEID0gbSAmJiBtLmxlbmd0aCA9PT0gNjtcbi8vIFx0cmV0dXJuICFtIHx8IG0ubGVuZ3RoIDwgNiA/IG5ldyBNYXRyaXgyRCgpIDogbmV3IE1hdHJpeDJEKCttWzBdLCArbVsxXSwgK21baXMyRCA/IDIgOiA0XSwgK21baXMyRCA/IDMgOiA1XSwgK21baXMyRCA/IDQgOiAxMl0sICttW2lzMkQgPyA1IDogMTNdKTtcbi8vIH0iLCIvKiFcbiAqIHBhdGhzIDMuOS4xXG4gKiBodHRwczovL2dyZWVuc29jay5jb21cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOC0yMDIxLCBHcmVlblNvY2suIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBTdWJqZWN0IHRvIHRoZSB0ZXJtcyBhdCBodHRwczovL2dyZWVuc29jay5jb20vc3RhbmRhcmQtbGljZW5zZSBvciBmb3JcbiAqIENsdWIgR3JlZW5Tb2NrIG1lbWJlcnMsIHRoZSBhZ3JlZW1lbnQgaXNzdWVkIHdpdGggdGhhdCBtZW1iZXJzaGlwLlxuICogQGF1dGhvcjogSmFjayBEb3lsZSwgamFja0BncmVlbnNvY2suY29tXG4qL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xudmFyIF9zdmdQYXRoRXhwID0gL1thY2hsbXFzdHZ6XXwoLT9cXGQqXFwuP1xcZCooPzplW1xcLStdP1xcZCspPylbMC05XS9pZyxcbiAgICBfbnVtYmVyc0V4cCA9IC8oPzooLSk/XFxkKlxcLj9cXGQqKD86ZVtcXC0rXT9cXGQrKT8pWzAtOV0vaWcsXG4gICAgX3NjaWVudGlmaWMgPSAvW1xcK1xcLV0/XFxkKlxcLj9cXGQrZVtcXCtcXC1dP1xcZCsvaWcsXG4gICAgX3NlbGVjdG9yRXhwID0gLyheWyNcXC5dW2Etel18W2EteV1bYS16XSkvaSxcbiAgICBfREVHMlJBRCA9IE1hdGguUEkgLyAxODAsXG4gICAgX1JBRDJERUcgPSAxODAgLyBNYXRoLlBJLFxuICAgIF9zaW4gPSBNYXRoLnNpbixcbiAgICBfY29zID0gTWF0aC5jb3MsXG4gICAgX2FicyA9IE1hdGguYWJzLFxuICAgIF9zcXJ0ID0gTWF0aC5zcXJ0LFxuICAgIF9hdGFuMiA9IE1hdGguYXRhbjIsXG4gICAgX2xhcmdlTnVtID0gMWU4LFxuICAgIF9pc1N0cmluZyA9IGZ1bmN0aW9uIF9pc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xufSxcbiAgICBfaXNOdW1iZXIgPSBmdW5jdGlvbiBfaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIjtcbn0sXG4gICAgX2lzVW5kZWZpbmVkID0gZnVuY3Rpb24gX2lzVW5kZWZpbmVkKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCI7XG59LFxuICAgIF90ZW1wID0ge30sXG4gICAgX3RlbXAyID0ge30sXG4gICAgX3JvdW5kaW5nTnVtID0gMWU1LFxuICAgIF93cmFwUHJvZ3Jlc3MgPSBmdW5jdGlvbiBfd3JhcFByb2dyZXNzKHByb2dyZXNzKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKChwcm9ncmVzcyArIF9sYXJnZU51bSkgJSAxICogX3JvdW5kaW5nTnVtKSAvIF9yb3VuZGluZ051bSB8fCAocHJvZ3Jlc3MgPCAwID8gMCA6IDEpO1xufSxcbiAgICAvL2lmIHByb2dyZXNzIGxhbmRzIG9uIDEsIHRoZSAlIHdpbGwgbWFrZSBpdCAwIHdoaWNoIGlzIHdoeSB3ZSB8fCAxLCBidXQgbm90IGlmIGl0J3MgbmVnYXRpdmUgYmVjYXVzZSBpdCBtYWtlcyBtb3JlIHNlbnNlIGZvciBtb3Rpb24gdG8gZW5kIGF0IDAgaW4gdGhhdCBjYXNlLlxuX3JvdW5kID0gZnVuY3Rpb24gX3JvdW5kKHZhbHVlKSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogX3JvdW5kaW5nTnVtKSAvIF9yb3VuZGluZ051bSB8fCAwO1xufSxcbiAgICBfcm91bmRQcmVjaXNlID0gZnVuY3Rpb24gX3JvdW5kUHJlY2lzZSh2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSAqIDFlMTApIC8gMWUxMCB8fCAwO1xufSxcbiAgICBfc3BsaXRTZWdtZW50ID0gZnVuY3Rpb24gX3NwbGl0U2VnbWVudChyYXdQYXRoLCBzZWdJbmRleCwgaSwgdCkge1xuICB2YXIgc2VnbWVudCA9IHJhd1BhdGhbc2VnSW5kZXhdLFxuICAgICAgc2hpZnQgPSB0ID09PSAxID8gNiA6IHN1YmRpdmlkZVNlZ21lbnQoc2VnbWVudCwgaSwgdCk7XG5cbiAgaWYgKHNoaWZ0ICYmIHNoaWZ0ICsgaSArIDIgPCBzZWdtZW50Lmxlbmd0aCkge1xuICAgIHJhd1BhdGguc3BsaWNlKHNlZ0luZGV4LCAwLCBzZWdtZW50LnNsaWNlKDAsIGkgKyBzaGlmdCArIDIpKTtcbiAgICBzZWdtZW50LnNwbGljZSgwLCBpICsgc2hpZnQpO1xuICAgIHJldHVybiAxO1xuICB9XG59LFxuICAgIF9nZXRTYW1wbGVJbmRleCA9IGZ1bmN0aW9uIF9nZXRTYW1wbGVJbmRleChzYW1wbGVzLCBsZW5ndGgsIHByb2dyZXNzKSB7XG4gIC8vIHNsaWdodGx5IHNsb3dlciB3YXkgdGhhbiBkb2luZyB0aGlzICh3aGVuIHRoZXJlJ3Mgbm8gbG9va3VwKTogc2VnbWVudC5sb29rdXBbcHJvZ3Jlc3MgPCAxID8gfn4obGVuZ3RoIC8gc2VnbWVudC5taW5MZW5ndGgpIDogc2VnbWVudC5sb29rdXAubGVuZ3RoIC0gMV0gfHwgMDtcbiAgdmFyIGwgPSBzYW1wbGVzLmxlbmd0aCxcbiAgICAgIGkgPSB+fihwcm9ncmVzcyAqIGwpO1xuXG4gIGlmIChzYW1wbGVzW2ldID4gbGVuZ3RoKSB7XG4gICAgd2hpbGUgKC0taSAmJiBzYW1wbGVzW2ldID4gbGVuZ3RoKSB7fVxuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzYW1wbGVzWysraV0gPCBsZW5ndGggJiYgaSA8IGwpIHt9XG4gIH1cblxuICByZXR1cm4gaSA8IGwgPyBpIDogbCAtIDE7XG59LFxuICAgIF9yZXZlcnNlUmF3UGF0aCA9IGZ1bmN0aW9uIF9yZXZlcnNlUmF3UGF0aChyYXdQYXRoLCBza2lwT3V0ZXIpIHtcbiAgdmFyIGkgPSByYXdQYXRoLmxlbmd0aDtcbiAgc2tpcE91dGVyIHx8IHJhd1BhdGgucmV2ZXJzZSgpO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICByYXdQYXRoW2ldLnJldmVyc2VkIHx8IHJldmVyc2VTZWdtZW50KHJhd1BhdGhbaV0pO1xuICB9XG59LFxuICAgIF9jb3B5TWV0YURhdGEgPSBmdW5jdGlvbiBfY29weU1ldGFEYXRhKHNvdXJjZSwgY29weSkge1xuICBjb3B5LnRvdGFsTGVuZ3RoID0gc291cmNlLnRvdGFsTGVuZ3RoO1xuXG4gIGlmIChzb3VyY2Uuc2FtcGxlcykge1xuICAgIC8vc2VnbWVudFxuICAgIGNvcHkuc2FtcGxlcyA9IHNvdXJjZS5zYW1wbGVzLnNsaWNlKDApO1xuICAgIGNvcHkubG9va3VwID0gc291cmNlLmxvb2t1cC5zbGljZSgwKTtcbiAgICBjb3B5Lm1pbkxlbmd0aCA9IHNvdXJjZS5taW5MZW5ndGg7XG4gICAgY29weS5yZXNvbHV0aW9uID0gc291cmNlLnJlc29sdXRpb247XG4gIH0gZWxzZSBpZiAoc291cmNlLnRvdGFsUG9pbnRzKSB7XG4gICAgLy9yYXdQYXRoXG4gICAgY29weS50b3RhbFBvaW50cyA9IHNvdXJjZS50b3RhbFBvaW50cztcbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufSxcbiAgICAvL3B1c2hlcyBhIG5ldyBzZWdtZW50IGludG8gYSByYXdQYXRoLCBidXQgaWYgaXRzIHN0YXJ0aW5nIHZhbHVlcyBtYXRjaCB0aGUgZW5kaW5nIHZhbHVlcyBvZiB0aGUgbGFzdCBzZWdtZW50LCBpdCdsbCBtZXJnZSBpdCBpbnRvIHRoYXQgc2FtZSBzZWdtZW50ICh0byByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWdtZW50cylcbl9hcHBlbmRPck1lcmdlID0gZnVuY3Rpb24gX2FwcGVuZE9yTWVyZ2UocmF3UGF0aCwgc2VnbWVudCkge1xuICB2YXIgaW5kZXggPSByYXdQYXRoLmxlbmd0aCxcbiAgICAgIHByZXZTZWcgPSByYXdQYXRoW2luZGV4IC0gMV0gfHwgW10sXG4gICAgICBsID0gcHJldlNlZy5sZW5ndGg7XG5cbiAgaWYgKGluZGV4ICYmIHNlZ21lbnRbMF0gPT09IHByZXZTZWdbbCAtIDJdICYmIHNlZ21lbnRbMV0gPT09IHByZXZTZWdbbCAtIDFdKSB7XG4gICAgc2VnbWVudCA9IHByZXZTZWcuY29uY2F0KHNlZ21lbnQuc2xpY2UoMikpO1xuICAgIGluZGV4LS07XG4gIH1cblxuICByYXdQYXRoW2luZGV4XSA9IHNlZ21lbnQ7XG59LFxuICAgIF9iZXN0RGlzdGFuY2U7XG4vKiBURVJNSU5PTE9HWVxuIC0gUmF3UGF0aCAtIGFuIGFycmF5IG9mIGFycmF5cywgb25lIGZvciBlYWNoIFNlZ21lbnQuIEEgc2luZ2xlIFJhd1BhdGggY291bGQgaGF2ZSBtdWx0aXBsZSBcIk1cIiBjb21tYW5kcywgZGVmaW5pbmcgU2VnbWVudHMgKHBhdGhzIGFyZW4ndCBhbHdheXMgY29ubmVjdGVkKS5cbiAtIFNlZ21lbnQgLSBhbiBhcnJheSBjb250YWluaW5nIGEgc2VxdWVuY2Ugb2YgQ3ViaWMgQmV6aWVyIGNvb3JkaW5hdGVzIGluIGFsdGVybmF0aW5nIHgsIHksIHgsIHkgZm9ybWF0LiBTdGFydGluZyBhbmNob3IsIHRoZW4gY29udHJvbCBwb2ludCAxLCBjb250cm9sIHBvaW50IDIsIGFuZCBlbmRpbmcgYW5jaG9yLCB0aGVuIHRoZSBuZXh0IGNvbnRyb2wgcG9pbnQgMSwgY29udHJvbCBwb2ludCAyLCBhbmNob3IsIGV0Yy4gVXNlcyBsZXNzIG1lbW9yeSB0aGFuIGFuIGFycmF5IHdpdGggYSBidW5jaCBvZiB7eCwgeX0gcG9pbnRzLlxuIC0gQmV6aWVyIC0gYSBzaW5nbGUgY3ViaWMgQmV6aWVyIHdpdGggYSBzdGFydGluZyBhbmNob3IsIHR3byBjb250cm9sIHBvaW50cywgYW5kIGFuIGVuZGluZyBhbmNob3IuXG4gLSB0aGUgdmFyaWFibGUgXCJ0XCIgaXMgdHlwaWNhbGx5IHRoZSBwb3NpdGlvbiBhbG9uZyBhbiBpbmRpdmlkdWFsIEJlemllciBwYXRoICh0aW1lKSBhbmQgaXQncyBOT1QgbGluZWFyLCBtZWFuaW5nIGl0IGNvdWxkIGFjY2VsZXJhdGUvZGVjZWxlcmF0ZSBiYXNlZCBvbiB0aGUgY29udHJvbCBwb2ludHMgd2hlcmVhcyB0aGUgXCJwXCIgb3IgXCJwcm9ncmVzc1wiIHZhbHVlIGlzIGxpbmVhcmx5IG1hcHBlZCB0byB0aGUgd2hvbGUgcGF0aCwgc28gaXQgc2hvdWxkbid0IHJlYWxseSBhY2NlbGVyYXRlL2RlY2VsZXJhdGUgYmFzZWQgb24gY29udHJvbCBwb2ludHMuIFNvIGEgcHJvZ3Jlc3Mgb2YgMC4yIHdvdWxkIGJlIGFsbW9zdCBleGFjdGx5IDIwJSBhbG9uZyB0aGUgcGF0aC4gXCJ0XCIgaXMgT05MWSBpbiBhbiBpbmRpdmlkdWFsIEJlemllciBwaWVjZS5cbiAqL1xuLy9hY2NlcHRzIGJhc2ljIHNlbGVjdG9yIHRleHQsIGEgcGF0aCBpbnN0YW5jZSwgYSBSYXdQYXRoIGluc3RhbmNlLCBvciBhIFNlZ21lbnQgYW5kIHJldHVybnMgYSBSYXdQYXRoIChtYWtlcyBpdCBlYXN5IHRvIGhvbW9nZW5pemUgdGhpbmdzKS4gSWYgYW4gZWxlbWVudCBvciBzZWxlY3RvciB0ZXh0IGlzIHBhc3NlZCBpbiwgaXQnbGwgYWxzbyBjYWNoZSB0aGUgdmFsdWUgc28gdGhhdCBpZiBpdCdzIHF1ZXJpZWQgYWdhaW4sIGl0J2xsIGp1c3QgdGFrZSB0aGUgcGF0aCBkYXRhIGZyb20gdGhlcmUgaW5zdGVhZCBvZiBwYXJzaW5nIGl0IGFsbCBvdmVyIGFnYWluIChhcyBsb25nIGFzIHRoZSBwYXRoIGRhdGEgaXRzZWxmIGhhc24ndCBjaGFuZ2VkIC0gaXQnbGwgY2hlY2spLlxuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSYXdQYXRoKHZhbHVlKSB7XG4gIHZhbHVlID0gX2lzU3RyaW5nKHZhbHVlKSAmJiBfc2VsZWN0b3JFeHAudGVzdCh2YWx1ZSkgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHZhbHVlKSB8fCB2YWx1ZSA6IHZhbHVlO1xuICB2YXIgZSA9IHZhbHVlLmdldEF0dHJpYnV0ZSA/IHZhbHVlIDogMCxcbiAgICAgIHJhd1BhdGg7XG5cbiAgaWYgKGUgJiYgKHZhbHVlID0gdmFsdWUuZ2V0QXR0cmlidXRlKFwiZFwiKSkpIHtcbiAgICAvL2ltcGxlbWVudHMgY2FjaGluZ1xuICAgIGlmICghZS5fZ3NQYXRoKSB7XG4gICAgICBlLl9nc1BhdGggPSB7fTtcbiAgICB9XG5cbiAgICByYXdQYXRoID0gZS5fZ3NQYXRoW3ZhbHVlXTtcbiAgICByZXR1cm4gcmF3UGF0aCAmJiAhcmF3UGF0aC5fZGlydHkgPyByYXdQYXRoIDogZS5fZ3NQYXRoW3ZhbHVlXSA9IHN0cmluZ1RvUmF3UGF0aCh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gIXZhbHVlID8gY29uc29sZS53YXJuKFwiRXhwZWN0aW5nIGEgPHBhdGg+IGVsZW1lbnQgb3IgYW4gU1ZHIHBhdGggZGF0YSBzdHJpbmdcIikgOiBfaXNTdHJpbmcodmFsdWUpID8gc3RyaW5nVG9SYXdQYXRoKHZhbHVlKSA6IF9pc051bWJlcih2YWx1ZVswXSkgPyBbdmFsdWVdIDogdmFsdWU7XG59IC8vY29waWVzIGEgUmF3UGF0aCBXSVRIT1VUIHRoZSBsZW5ndGggbWV0YSBkYXRhIChmb3Igc3BlZWQpXG5cbmV4cG9ydCBmdW5jdGlvbiBjb3B5UmF3UGF0aChyYXdQYXRoKSB7XG4gIHZhciBhID0gW10sXG4gICAgICBpID0gMDtcblxuICBmb3IgKDsgaSA8IHJhd1BhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBhW2ldID0gX2NvcHlNZXRhRGF0YShyYXdQYXRoW2ldLCByYXdQYXRoW2ldLnNsaWNlKDApKTtcbiAgfVxuXG4gIHJldHVybiBfY29weU1ldGFEYXRhKHJhd1BhdGgsIGEpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJldmVyc2VTZWdtZW50KHNlZ21lbnQpIHtcbiAgdmFyIGkgPSAwLFxuICAgICAgeTtcbiAgc2VnbWVudC5yZXZlcnNlKCk7IC8vdGhpcyB3aWxsIGludmVydCB0aGUgb3JkZXIgeSwgeCwgeSwgeCBzbyB3ZSBtdXN0IGZsaXAgaXQgYmFjay5cblxuICBmb3IgKDsgaSA8IHNlZ21lbnQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB5ID0gc2VnbWVudFtpXTtcbiAgICBzZWdtZW50W2ldID0gc2VnbWVudFtpICsgMV07XG4gICAgc2VnbWVudFtpICsgMV0gPSB5O1xuICB9XG5cbiAgc2VnbWVudC5yZXZlcnNlZCA9ICFzZWdtZW50LnJldmVyc2VkO1xufVxuXG52YXIgX2NyZWF0ZVBhdGggPSBmdW5jdGlvbiBfY3JlYXRlUGF0aChlLCBpZ25vcmUpIHtcbiAgdmFyIHBhdGggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInBhdGhcIiksXG4gICAgICBhdHRyID0gW10uc2xpY2UuY2FsbChlLmF0dHJpYnV0ZXMpLFxuICAgICAgaSA9IGF0dHIubGVuZ3RoLFxuICAgICAgbmFtZTtcbiAgaWdub3JlID0gXCIsXCIgKyBpZ25vcmUgKyBcIixcIjtcblxuICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICBuYW1lID0gYXR0cltpXS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpOyAvL2luIE1pY3Jvc29mdCBFZGdlLCBpZiB5b3UgZG9uJ3Qgc2V0IHRoZSBhdHRyaWJ1dGUgd2l0aCBhIGxvd2VyY2FzZSBuYW1lLCBpdCBkb2Vzbid0IHJlbmRlciBjb3JyZWN0bHkhIFN1cGVyIHdlaXJkLlxuXG4gICAgaWYgKGlnbm9yZS5pbmRleE9mKFwiLFwiICsgbmFtZSArIFwiLFwiKSA8IDApIHtcbiAgICAgIHBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgbmFtZSwgYXR0cltpXS5ub2RlVmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXRoO1xufSxcbiAgICBfdHlwZUF0dHJzID0ge1xuICByZWN0OiBcInJ4LHJ5LHgseSx3aWR0aCxoZWlnaHRcIixcbiAgY2lyY2xlOiBcInIsY3gsY3lcIixcbiAgZWxsaXBzZTogXCJyeCxyeSxjeCxjeVwiLFxuICBsaW5lOiBcIngxLHgyLHkxLHkyXCJcbn0sXG4gICAgX2F0dHJUb09iaiA9IGZ1bmN0aW9uIF9hdHRyVG9PYmooZSwgYXR0cnMpIHtcbiAgdmFyIHByb3BzID0gYXR0cnMgPyBhdHRycy5zcGxpdChcIixcIikgOiBbXSxcbiAgICAgIG9iaiA9IHt9LFxuICAgICAgaSA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoLS1pID4gLTEpIHtcbiAgICBvYmpbcHJvcHNbaV1dID0gK2UuZ2V0QXR0cmlidXRlKHByb3BzW2ldKSB8fCAwO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07IC8vY29udmVydHMgYW4gU1ZHIHNoYXBlIGxpa2UgPGNpcmNsZT4sIDxyZWN0PiwgPHBvbHlnb24+LCA8cG9seWxpbmU+LCA8ZWxsaXBzZT4sIGV0Yy4gdG8gYSA8cGF0aD4sIHN3YXBwaW5nIGl0IGluIGFuZCBjb3B5aW5nIHRoZSBhdHRyaWJ1dGVzIHRvIG1hdGNoLlxuXG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VG9QYXRoKGVsZW1lbnQsIHN3YXApIHtcbiAgdmFyIHR5cGUgPSBlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgIGNpcmMgPSAwLjU1MjI4NDc0OTgzMSxcbiAgICAgIGRhdGEsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHIsXG4gICAgICByeSxcbiAgICAgIHBhdGgsXG4gICAgICByY2lyYyxcbiAgICAgIHJ5Y2lyYyxcbiAgICAgIHBvaW50cyxcbiAgICAgIHcsXG4gICAgICBoLFxuICAgICAgeDIsXG4gICAgICB4MyxcbiAgICAgIHg0LFxuICAgICAgeDUsXG4gICAgICB4NixcbiAgICAgIHkyLFxuICAgICAgeTMsXG4gICAgICB5NCxcbiAgICAgIHk1LFxuICAgICAgeTYsXG4gICAgICBhdHRyO1xuXG4gIGlmICh0eXBlID09PSBcInBhdGhcIiB8fCAhZWxlbWVudC5nZXRCQm94KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICBwYXRoID0gX2NyZWF0ZVBhdGgoZWxlbWVudCwgXCJ4LHksd2lkdGgsaGVpZ2h0LGN4LGN5LHJ4LHJ5LHIseDEseDIseTEseTIscG9pbnRzXCIpO1xuICBhdHRyID0gX2F0dHJUb09iaihlbGVtZW50LCBfdHlwZUF0dHJzW3R5cGVdKTtcblxuICBpZiAodHlwZSA9PT0gXCJyZWN0XCIpIHtcbiAgICByID0gYXR0ci5yeDtcbiAgICByeSA9IGF0dHIucnkgfHwgcjtcbiAgICB4ID0gYXR0ci54O1xuICAgIHkgPSBhdHRyLnk7XG4gICAgdyA9IGF0dHIud2lkdGggLSByICogMjtcbiAgICBoID0gYXR0ci5oZWlnaHQgLSByeSAqIDI7XG5cbiAgICBpZiAociB8fCByeSkge1xuICAgICAgLy9pZiB0aGVyZSBhcmUgcm91bmRlZCBjb3JuZXJzLCByZW5kZXIgY3ViaWMgYmV6aWVyc1xuICAgICAgeDIgPSB4ICsgciAqICgxIC0gY2lyYyk7XG4gICAgICB4MyA9IHggKyByO1xuICAgICAgeDQgPSB4MyArIHc7XG4gICAgICB4NSA9IHg0ICsgciAqIGNpcmM7XG4gICAgICB4NiA9IHg0ICsgcjtcbiAgICAgIHkyID0geSArIHJ5ICogKDEgLSBjaXJjKTtcbiAgICAgIHkzID0geSArIHJ5O1xuICAgICAgeTQgPSB5MyArIGg7XG4gICAgICB5NSA9IHk0ICsgcnkgKiBjaXJjO1xuICAgICAgeTYgPSB5NCArIHJ5O1xuICAgICAgZGF0YSA9IFwiTVwiICsgeDYgKyBcIixcIiArIHkzICsgXCIgVlwiICsgeTQgKyBcIiBDXCIgKyBbeDYsIHk1LCB4NSwgeTYsIHg0LCB5NiwgeDQgLSAoeDQgLSB4MykgLyAzLCB5NiwgeDMgKyAoeDQgLSB4MykgLyAzLCB5NiwgeDMsIHk2LCB4MiwgeTYsIHgsIHk1LCB4LCB5NCwgeCwgeTQgLSAoeTQgLSB5MykgLyAzLCB4LCB5MyArICh5NCAtIHkzKSAvIDMsIHgsIHkzLCB4LCB5MiwgeDIsIHksIHgzLCB5LCB4MyArICh4NCAtIHgzKSAvIDMsIHksIHg0IC0gKHg0IC0geDMpIC8gMywgeSwgeDQsIHksIHg1LCB5LCB4NiwgeTIsIHg2LCB5M10uam9pbihcIixcIikgKyBcInpcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IFwiTVwiICsgKHggKyB3KSArIFwiLFwiICsgeSArIFwiIHZcIiArIGggKyBcIiBoXCIgKyAtdyArIFwiIHZcIiArIC1oICsgXCIgaFwiICsgdyArIFwielwiO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSBcImNpcmNsZVwiIHx8IHR5cGUgPT09IFwiZWxsaXBzZVwiKSB7XG4gICAgaWYgKHR5cGUgPT09IFwiY2lyY2xlXCIpIHtcbiAgICAgIHIgPSByeSA9IGF0dHIucjtcbiAgICAgIHJ5Y2lyYyA9IHIgKiBjaXJjO1xuICAgIH0gZWxzZSB7XG4gICAgICByID0gYXR0ci5yeDtcbiAgICAgIHJ5ID0gYXR0ci5yeTtcbiAgICAgIHJ5Y2lyYyA9IHJ5ICogY2lyYztcbiAgICB9XG5cbiAgICB4ID0gYXR0ci5jeDtcbiAgICB5ID0gYXR0ci5jeTtcbiAgICByY2lyYyA9IHIgKiBjaXJjO1xuICAgIGRhdGEgPSBcIk1cIiArICh4ICsgcikgKyBcIixcIiArIHkgKyBcIiBDXCIgKyBbeCArIHIsIHkgKyByeWNpcmMsIHggKyByY2lyYywgeSArIHJ5LCB4LCB5ICsgcnksIHggLSByY2lyYywgeSArIHJ5LCB4IC0gciwgeSArIHJ5Y2lyYywgeCAtIHIsIHksIHggLSByLCB5IC0gcnljaXJjLCB4IC0gcmNpcmMsIHkgLSByeSwgeCwgeSAtIHJ5LCB4ICsgcmNpcmMsIHkgLSByeSwgeCArIHIsIHkgLSByeWNpcmMsIHggKyByLCB5XS5qb2luKFwiLFwiKSArIFwielwiO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibGluZVwiKSB7XG4gICAgZGF0YSA9IFwiTVwiICsgYXR0ci54MSArIFwiLFwiICsgYXR0ci55MSArIFwiIExcIiArIGF0dHIueDIgKyBcIixcIiArIGF0dHIueTI7IC8vcHJldmlvdXNseSwgd2UganVzdCBjb252ZXJ0ZWQgdG8gXCJNeCx5IEx4LHlcIiBidXQgU2FmYXJpIGhhcyBidWdzIHRoYXQgY2F1c2UgdGhhdCBub3QgdG8gcmVuZGVyIHByb3Blcmx5IHdoZW4gdXNpbmcgYSBzdHJva2UtZGFzaGFycmF5IHRoYXQncyBub3QgZnVsbHkgdmlzaWJsZSEgVXNpbmcgYSBjdWJpYyBiZXppZXIgZml4ZXMgdGhhdCBpc3N1ZS5cbiAgfSBlbHNlIGlmICh0eXBlID09PSBcInBvbHlsaW5lXCIgfHwgdHlwZSA9PT0gXCJwb2x5Z29uXCIpIHtcbiAgICBwb2ludHMgPSAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJwb2ludHNcIikgKyBcIlwiKS5tYXRjaChfbnVtYmVyc0V4cCkgfHwgW107XG4gICAgeCA9IHBvaW50cy5zaGlmdCgpO1xuICAgIHkgPSBwb2ludHMuc2hpZnQoKTtcbiAgICBkYXRhID0gXCJNXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCIgTFwiICsgcG9pbnRzLmpvaW4oXCIsXCIpO1xuXG4gICAgaWYgKHR5cGUgPT09IFwicG9seWdvblwiKSB7XG4gICAgICBkYXRhICs9IFwiLFwiICsgeCArIFwiLFwiICsgeSArIFwielwiO1xuICAgIH1cbiAgfVxuXG4gIHBhdGguc2V0QXR0cmlidXRlKFwiZFwiLCByYXdQYXRoVG9TdHJpbmcocGF0aC5fZ3NSYXdQYXRoID0gc3RyaW5nVG9SYXdQYXRoKGRhdGEpKSk7XG5cbiAgaWYgKHN3YXAgJiYgZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShwYXRoLCBlbGVtZW50KTtcbiAgICBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gcGF0aDtcbn0gLy9yZXR1cm5zIHRoZSByb3RhdGlvbiAoaW4gZGVncmVlcykgYXQgYSBwYXJ0aWN1bGFyIHByb2dyZXNzIG9uIGEgcmF3UGF0aCAodGhlIHNsb3BlIG9mIHRoZSB0YW5nZW50KVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Um90YXRpb25BdFByb2dyZXNzKHJhd1BhdGgsIHByb2dyZXNzKSB7XG4gIHZhciBkID0gZ2V0UHJvZ3Jlc3NEYXRhKHJhd1BhdGgsIHByb2dyZXNzID49IDEgPyAxIC0gMWUtOSA6IHByb2dyZXNzID8gcHJvZ3Jlc3MgOiAxZS05KTtcbiAgcmV0dXJuIGdldFJvdGF0aW9uQXRCZXppZXJUKGQuc2VnbWVudCwgZC5pLCBkLnQpO1xufVxuXG5mdW5jdGlvbiBnZXRSb3RhdGlvbkF0QmV6aWVyVChzZWdtZW50LCBpLCB0KSB7XG4gIHZhciBhID0gc2VnbWVudFtpXSxcbiAgICAgIGIgPSBzZWdtZW50W2kgKyAyXSxcbiAgICAgIGMgPSBzZWdtZW50W2kgKyA0XSxcbiAgICAgIHg7XG4gIGEgKz0gKGIgLSBhKSAqIHQ7XG4gIGIgKz0gKGMgLSBiKSAqIHQ7XG4gIGEgKz0gKGIgLSBhKSAqIHQ7XG4gIHggPSBiICsgKGMgKyAoc2VnbWVudFtpICsgNl0gLSBjKSAqIHQgLSBiKSAqIHQgLSBhO1xuICBhID0gc2VnbWVudFtpICsgMV07XG4gIGIgPSBzZWdtZW50W2kgKyAzXTtcbiAgYyA9IHNlZ21lbnRbaSArIDVdO1xuICBhICs9IChiIC0gYSkgKiB0O1xuICBiICs9IChjIC0gYikgKiB0O1xuICBhICs9IChiIC0gYSkgKiB0O1xuICByZXR1cm4gX3JvdW5kKF9hdGFuMihiICsgKGMgKyAoc2VnbWVudFtpICsgN10gLSBjKSAqIHQgLSBiKSAqIHQgLSBhLCB4KSAqIF9SQUQyREVHKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNsaWNlUmF3UGF0aChyYXdQYXRoLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IF9pc1VuZGVmaW5lZChlbmQpID8gMSA6IF9yb3VuZFByZWNpc2UoZW5kKSB8fCAwOyAvLyB3ZSBtdXN0IHJvdW5kIHRvIGF2b2lkIGlzc3VlcyBsaWtlIDQuMTUgLyA4ID0gMC44MzAwMDAwMDAwMDAwMDAxIGluc3RlYWQgb2YgMC44MyBvciAyLjggLyA1ID0gMC41NTk5OTk5OTk5OTk5OTk5IGluc3RlYWQgb2YgMC41NiBhbmQgaWYgc29tZW9uZSBpcyBkb2luZyBhIGxvb3AgbGlrZSBzdGFydDogMi44IC8gMC41LCBlbmQ6IDIuOCAvIDAuNSArIDEuXG5cbiAgc3RhcnQgPSBfcm91bmRQcmVjaXNlKHN0YXJ0KSB8fCAwO1xuICB2YXIgbG9vcHMgPSBNYXRoLm1heCgwLCB+fihfYWJzKGVuZCAtIHN0YXJ0KSAtIDFlLTgpKSxcbiAgICAgIHBhdGggPSBjb3B5UmF3UGF0aChyYXdQYXRoKTtcblxuICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICBzdGFydCA9IDEgLSBzdGFydDtcbiAgICBlbmQgPSAxIC0gZW5kO1xuXG4gICAgX3JldmVyc2VSYXdQYXRoKHBhdGgpO1xuXG4gICAgcGF0aC50b3RhbExlbmd0aCA9IDA7XG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA8IDApIHtcbiAgICB2YXIgb2Zmc2V0ID0gTWF0aC5hYnMofn5NYXRoLm1pbihzdGFydCwgZW5kKSkgKyAxO1xuICAgIHN0YXJ0ICs9IG9mZnNldDtcbiAgICBlbmQgKz0gb2Zmc2V0O1xuICB9XG5cbiAgcGF0aC50b3RhbExlbmd0aCB8fCBjYWNoZVJhd1BhdGhNZWFzdXJlbWVudHMocGF0aCk7XG4gIHZhciB3cmFwID0gZW5kID4gMSxcbiAgICAgIHMgPSBnZXRQcm9ncmVzc0RhdGEocGF0aCwgc3RhcnQsIF90ZW1wLCB0cnVlKSxcbiAgICAgIGUgPSBnZXRQcm9ncmVzc0RhdGEocGF0aCwgZW5kLCBfdGVtcDIpLFxuICAgICAgZVNlZyA9IGUuc2VnbWVudCxcbiAgICAgIHNTZWcgPSBzLnNlZ21lbnQsXG4gICAgICBlU2VnSW5kZXggPSBlLnNlZ0luZGV4LFxuICAgICAgc1NlZ0luZGV4ID0gcy5zZWdJbmRleCxcbiAgICAgIGVpID0gZS5pLFxuICAgICAgc2kgPSBzLmksXG4gICAgICBzYW1lU2VnbWVudCA9IHNTZWdJbmRleCA9PT0gZVNlZ0luZGV4LFxuICAgICAgc2FtZUJlemllciA9IGVpID09PSBzaSAmJiBzYW1lU2VnbWVudCxcbiAgICAgIHdyYXBzQmVoaW5kLFxuICAgICAgc1NoaWZ0LFxuICAgICAgZVNoaWZ0LFxuICAgICAgaSxcbiAgICAgIGNvcHksXG4gICAgICB0b3RhbFNlZ21lbnRzLFxuICAgICAgbCxcbiAgICAgIGo7XG5cbiAgaWYgKHdyYXAgfHwgbG9vcHMpIHtcbiAgICB3cmFwc0JlaGluZCA9IGVTZWdJbmRleCA8IHNTZWdJbmRleCB8fCBzYW1lU2VnbWVudCAmJiBlaSA8IHNpIHx8IHNhbWVCZXppZXIgJiYgZS50IDwgcy50O1xuXG4gICAgaWYgKF9zcGxpdFNlZ21lbnQocGF0aCwgc1NlZ0luZGV4LCBzaSwgcy50KSkge1xuICAgICAgc1NlZ0luZGV4Kys7XG5cbiAgICAgIGlmICghd3JhcHNCZWhpbmQpIHtcbiAgICAgICAgZVNlZ0luZGV4Kys7XG5cbiAgICAgICAgaWYgKHNhbWVCZXppZXIpIHtcbiAgICAgICAgICBlLnQgPSAoZS50IC0gcy50KSAvICgxIC0gcy50KTtcbiAgICAgICAgICBlaSA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoc2FtZVNlZ21lbnQpIHtcbiAgICAgICAgICBlaSAtPSBzaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChNYXRoLmFicygxIC0gKGVuZCAtIHN0YXJ0KSkgPCAxZS01KSB7XG4gICAgICBlU2VnSW5kZXggPSBzU2VnSW5kZXggLSAxO1xuICAgIH0gZWxzZSBpZiAoIWUudCAmJiBlU2VnSW5kZXgpIHtcbiAgICAgIGVTZWdJbmRleC0tO1xuICAgIH0gZWxzZSBpZiAoX3NwbGl0U2VnbWVudChwYXRoLCBlU2VnSW5kZXgsIGVpLCBlLnQpICYmIHdyYXBzQmVoaW5kKSB7XG4gICAgICBzU2VnSW5kZXgrKztcbiAgICB9XG5cbiAgICBpZiAocy50ID09PSAxKSB7XG4gICAgICBzU2VnSW5kZXggPSAoc1NlZ0luZGV4ICsgMSkgJSBwYXRoLmxlbmd0aDtcbiAgICB9XG5cbiAgICBjb3B5ID0gW107XG4gICAgdG90YWxTZWdtZW50cyA9IHBhdGgubGVuZ3RoO1xuICAgIGwgPSAxICsgdG90YWxTZWdtZW50cyAqIGxvb3BzO1xuICAgIGogPSBzU2VnSW5kZXg7XG4gICAgbCArPSAodG90YWxTZWdtZW50cyAtIHNTZWdJbmRleCArIGVTZWdJbmRleCkgJSB0b3RhbFNlZ21lbnRzO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgX2FwcGVuZE9yTWVyZ2UoY29weSwgcGF0aFtqKysgJSB0b3RhbFNlZ21lbnRzXSk7XG4gICAgfVxuXG4gICAgcGF0aCA9IGNvcHk7XG4gIH0gZWxzZSB7XG4gICAgZVNoaWZ0ID0gZS50ID09PSAxID8gNiA6IHN1YmRpdmlkZVNlZ21lbnQoZVNlZywgZWksIGUudCk7XG5cbiAgICBpZiAoc3RhcnQgIT09IGVuZCkge1xuICAgICAgc1NoaWZ0ID0gc3ViZGl2aWRlU2VnbWVudChzU2VnLCBzaSwgc2FtZUJlemllciA/IHMudCAvIGUudCA6IHMudCk7XG4gICAgICBzYW1lU2VnbWVudCAmJiAoZVNoaWZ0ICs9IHNTaGlmdCk7XG4gICAgICBlU2VnLnNwbGljZShlaSArIGVTaGlmdCArIDIpO1xuICAgICAgKHNTaGlmdCB8fCBzaSkgJiYgc1NlZy5zcGxpY2UoMCwgc2kgKyBzU2hpZnQpO1xuICAgICAgaSA9IHBhdGgubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIC8vY2hvcCBvZmYgYW55IGV4dHJhIHNlZ21lbnRzXG4gICAgICAgIChpIDwgc1NlZ0luZGV4IHx8IGkgPiBlU2VnSW5kZXgpICYmIHBhdGguc3BsaWNlKGksIDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlU2VnLmFuZ2xlID0gZ2V0Um90YXRpb25BdEJlemllclQoZVNlZywgZWkgKyBlU2hpZnQsIDApOyAvL3JlY29yZCB0aGUgdmFsdWUgYmVmb3JlIHdlIGNob3AgYmVjYXVzZSBpdCdsbCBiZSBpbXBvc3NpYmxlIHRvIGRldGVybWluZSB0aGUgYW5nbGUgYWZ0ZXIgaXRzIGxlbmd0aCBpcyAwIVxuXG4gICAgICBlaSArPSBlU2hpZnQ7XG4gICAgICBzID0gZVNlZ1tlaV07XG4gICAgICBlID0gZVNlZ1tlaSArIDFdO1xuICAgICAgZVNlZy5sZW5ndGggPSBlU2VnLnRvdGFsTGVuZ3RoID0gMDtcbiAgICAgIGVTZWcudG90YWxQb2ludHMgPSBwYXRoLnRvdGFsUG9pbnRzID0gODtcbiAgICAgIGVTZWcucHVzaChzLCBlLCBzLCBlLCBzLCBlLCBzLCBlKTtcbiAgICB9XG4gIH1cblxuICBwYXRoLnRvdGFsTGVuZ3RoID0gMDtcbiAgcmV0dXJuIHBhdGg7XG59IC8vbWVhc3VyZXMgYSBTZWdtZW50IGFjY29yZGluZyB0byBpdHMgcmVzb2x1dGlvbiAoc28gaWYgc2VnbWVudC5yZXNvbHV0aW9uIGlzIDYsIGZvciBleGFtcGxlLCBpdCdsbCB0YWtlIDYgc2FtcGxlcyBlcXVhbGx5IGFjcm9zcyBlYWNoIEJlemllcikgYW5kIGNyZWF0ZS9wb3B1bGF0ZSBhIFwic2FtcGxlc1wiIEFycmF5IHRoYXQgaGFzIHRoZSBsZW5ndGggdXAgdG8gZWFjaCBvZiB0aG9zZSBzYW1wbGUgcG9pbnRzIChhbHdheXMgaW5jcmVhc2luZyBmcm9tIHRoZSBzdGFydCkgYXMgd2VsbCBhcyBhIFwibG9va3VwXCIgYXJyYXkgdGhhdCdzIGJyb2tlbiB1cCBhY2NvcmRpbmcgdG8gdGhlIHNtYWxsZXN0IGRpc3RhbmNlIGJldHdlZW4gMiBzYW1wbGVzLiBUaGlzIGdpdmVzIHVzIGEgdmVyeSBmYXN0IHdheSBvZiBsb29raW5nIHVwIGEgcHJvZ3Jlc3MgcG9zaXRpb24gcmF0aGVyIHRoYW4gbG9vcGluZyB0aHJvdWdoIGFsbCB0aGUgcG9pbnRzL0JlemllcnMuIFlvdSBjYW4gb3B0aW9uYWxseSBoYXZlIGl0IG9ubHkgbWVhc3VyZSBhIHN1YnNldCwgc3RhcnRpbmcgYXQgc3RhcnRJbmRleCBhbmQgZ29pbmcgZm9yIGEgc3BlY2lmaWMgbnVtYmVyIG9mIGJlemllcnMgKHJlbWVtYmVyLCB0aGVyZSBhcmUgMyB4L3kgcGFpcnMgZWFjaCwgZm9yIGEgdG90YWwgb2YgNiBlbGVtZW50cyBmb3IgZWFjaCBCZXppZXIpLiBJdCB3aWxsIGFsc28gcG9wdWxhdGUgYSBcInRvdGFsTGVuZ3RoXCIgcHJvcGVydHksIGJ1dCB0aGF0J3Mgbm90IGdlbmVyYWxseSBzdXBlciBhY2N1cmF0ZSBiZWNhdXNlIGJ5IGRlZmF1bHQgaXQnbGwgb25seSB0YWtlIDYgc2FtcGxlcyBwZXIgQmV6aWVyLiBCdXQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIGl0J3MgcGVyZmVjdGx5IGFkZXF1YXRlIGZvciBtZWFzdXJpbmcgcHJvZ3Jlc3MgdmFsdWVzIGFsb25nIHRoZSBwYXRoLiBJZiB5b3UgbmVlZCBhIG1vcmUgYWNjdXJhdGUgdG90YWxMZW5ndGgsIGVpdGhlciBpbmNyZWFzZSB0aGUgcmVzb2x1dGlvbiBvciB1c2UgdGhlIG1vcmUgYWR2YW5jZWQgYmV6aWVyVG9Qb2ludHMoKSBtZXRob2Qgd2hpY2gga2VlcHMgYWRkaW5nIHBvaW50cyB1bnRpbCB0aGV5IGRvbid0IGRldmlhdGUgYnkgbW9yZSB0aGFuIGEgY2VydGFpbiBwcmVjaXNpb24gdmFsdWUuXG5cbmZ1bmN0aW9uIG1lYXN1cmVTZWdtZW50KHNlZ21lbnQsIHN0YXJ0SW5kZXgsIGJlemllclF0eSkge1xuICBzdGFydEluZGV4ID0gc3RhcnRJbmRleCB8fCAwO1xuXG4gIGlmICghc2VnbWVudC5zYW1wbGVzKSB7XG4gICAgc2VnbWVudC5zYW1wbGVzID0gW107XG4gICAgc2VnbWVudC5sb29rdXAgPSBbXTtcbiAgfVxuXG4gIHZhciByZXNvbHV0aW9uID0gfn5zZWdtZW50LnJlc29sdXRpb24gfHwgMTIsXG4gICAgICBpbmMgPSAxIC8gcmVzb2x1dGlvbixcbiAgICAgIGVuZEluZGV4ID0gYmV6aWVyUXR5ID8gc3RhcnRJbmRleCArIGJlemllclF0eSAqIDYgKyAxIDogc2VnbWVudC5sZW5ndGgsXG4gICAgICB4MSA9IHNlZ21lbnRbc3RhcnRJbmRleF0sXG4gICAgICB5MSA9IHNlZ21lbnRbc3RhcnRJbmRleCArIDFdLFxuICAgICAgc2FtcGxlc0luZGV4ID0gc3RhcnRJbmRleCA/IHN0YXJ0SW5kZXggLyA2ICogcmVzb2x1dGlvbiA6IDAsXG4gICAgICBzYW1wbGVzID0gc2VnbWVudC5zYW1wbGVzLFxuICAgICAgbG9va3VwID0gc2VnbWVudC5sb29rdXAsXG4gICAgICBtaW4gPSAoc3RhcnRJbmRleCA/IHNlZ21lbnQubWluTGVuZ3RoIDogX2xhcmdlTnVtKSB8fCBfbGFyZ2VOdW0sXG4gICAgICBwcmV2TGVuZ3RoID0gc2FtcGxlc1tzYW1wbGVzSW5kZXggKyBiZXppZXJRdHkgKiByZXNvbHV0aW9uIC0gMV0sXG4gICAgICBsZW5ndGggPSBzdGFydEluZGV4ID8gc2FtcGxlc1tzYW1wbGVzSW5kZXggLSAxXSA6IDAsXG4gICAgICBpLFxuICAgICAgaixcbiAgICAgIHg0LFxuICAgICAgeDMsXG4gICAgICB4MixcbiAgICAgIHhkLFxuICAgICAgeGQxLFxuICAgICAgeTQsXG4gICAgICB5MyxcbiAgICAgIHkyLFxuICAgICAgeWQsXG4gICAgICB5ZDEsXG4gICAgICBpbnYsXG4gICAgICB0LFxuICAgICAgbGVuZ3RoSW5kZXgsXG4gICAgICBsLFxuICAgICAgc2VnTGVuZ3RoO1xuICBzYW1wbGVzLmxlbmd0aCA9IGxvb2t1cC5sZW5ndGggPSAwO1xuXG4gIGZvciAoaiA9IHN0YXJ0SW5kZXggKyAyOyBqIDwgZW5kSW5kZXg7IGogKz0gNikge1xuICAgIHg0ID0gc2VnbWVudFtqICsgNF0gLSB4MTtcbiAgICB4MyA9IHNlZ21lbnRbaiArIDJdIC0geDE7XG4gICAgeDIgPSBzZWdtZW50W2pdIC0geDE7XG4gICAgeTQgPSBzZWdtZW50W2ogKyA1XSAtIHkxO1xuICAgIHkzID0gc2VnbWVudFtqICsgM10gLSB5MTtcbiAgICB5MiA9IHNlZ21lbnRbaiArIDFdIC0geTE7XG4gICAgeGQgPSB4ZDEgPSB5ZCA9IHlkMSA9IDA7XG5cbiAgICBpZiAoX2Ficyh4NCkgPCAuMDEgJiYgX2Ficyh5NCkgPCAuMDEgJiYgX2Ficyh4MikgKyBfYWJzKHkyKSA8IC4wMSkge1xuICAgICAgLy9kdW1wIHBvaW50cyB0aGF0IGFyZSBzdWZmaWNpZW50bHkgY2xvc2UgKGJhc2ljYWxseSByaWdodCBvbiB0b3Agb2YgZWFjaCBvdGhlciwgbWFraW5nIGEgYmV6aWVyIHN1cGVyIHRpbnkgb3IgMCBsZW5ndGgpXG4gICAgICBpZiAoc2VnbWVudC5sZW5ndGggPiA4KSB7XG4gICAgICAgIHNlZ21lbnQuc3BsaWNlKGosIDYpO1xuICAgICAgICBqIC09IDY7XG4gICAgICAgIGVuZEluZGV4IC09IDY7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDE7IGkgPD0gcmVzb2x1dGlvbjsgaSsrKSB7XG4gICAgICAgIHQgPSBpbmMgKiBpO1xuICAgICAgICBpbnYgPSAxIC0gdDtcbiAgICAgICAgeGQgPSB4ZDEgLSAoeGQxID0gKHQgKiB0ICogeDQgKyAzICogaW52ICogKHQgKiB4MyArIGludiAqIHgyKSkgKiB0KTtcbiAgICAgICAgeWQgPSB5ZDEgLSAoeWQxID0gKHQgKiB0ICogeTQgKyAzICogaW52ICogKHQgKiB5MyArIGludiAqIHkyKSkgKiB0KTtcbiAgICAgICAgbCA9IF9zcXJ0KHlkICogeWQgKyB4ZCAqIHhkKTtcblxuICAgICAgICBpZiAobCA8IG1pbikge1xuICAgICAgICAgIG1pbiA9IGw7XG4gICAgICAgIH1cblxuICAgICAgICBsZW5ndGggKz0gbDtcbiAgICAgICAgc2FtcGxlc1tzYW1wbGVzSW5kZXgrK10gPSBsZW5ndGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgeDEgKz0geDQ7XG4gICAgeTEgKz0geTQ7XG4gIH1cblxuICBpZiAocHJldkxlbmd0aCkge1xuICAgIHByZXZMZW5ndGggLT0gbGVuZ3RoO1xuXG4gICAgZm9yICg7IHNhbXBsZXNJbmRleCA8IHNhbXBsZXMubGVuZ3RoOyBzYW1wbGVzSW5kZXgrKykge1xuICAgICAgc2FtcGxlc1tzYW1wbGVzSW5kZXhdICs9IHByZXZMZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNhbXBsZXMubGVuZ3RoICYmIG1pbikge1xuICAgIHNlZ21lbnQudG90YWxMZW5ndGggPSBzZWdMZW5ndGggPSBzYW1wbGVzW3NhbXBsZXMubGVuZ3RoIC0gMV0gfHwgMDtcbiAgICBzZWdtZW50Lm1pbkxlbmd0aCA9IG1pbjtcblxuICAgIGlmIChzZWdMZW5ndGggLyBtaW4gPCA5OTk5KSB7XG4gICAgICAvLyBpZiB0aGUgbG9va3VwIHdvdWxkIHJlcXVpcmUgdG9vIG1hbnkgdmFsdWVzIChtZW1vcnkgcHJvYmxlbSksIHdlIHNraXAgdGhpcyBhbmQgaW5zdGVhZCB3ZSB1c2UgYSBsb29wIHRvIGxvb2t1cCB2YWx1ZXMgZGlyZWN0bHkgaW4gdGhlIHNhbXBsZXMgQXJyYXlcbiAgICAgIGwgPSBsZW5ndGhJbmRleCA9IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdMZW5ndGg7IGkgKz0gbWluKSB7XG4gICAgICAgIGxvb2t1cFtsKytdID0gc2FtcGxlc1tsZW5ndGhJbmRleF0gPCBpID8gKytsZW5ndGhJbmRleCA6IGxlbmd0aEluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZWdtZW50LnRvdGFsTGVuZ3RoID0gc2FtcGxlc1swXSA9IDA7XG4gIH1cblxuICByZXR1cm4gc3RhcnRJbmRleCA/IGxlbmd0aCAtIHNhbXBsZXNbc3RhcnRJbmRleCAvIDIgLSAxXSA6IGxlbmd0aDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhY2hlUmF3UGF0aE1lYXN1cmVtZW50cyhyYXdQYXRoLCByZXNvbHV0aW9uKSB7XG4gIHZhciBwYXRoTGVuZ3RoLCBwb2ludHMsIGk7XG5cbiAgZm9yIChpID0gcGF0aExlbmd0aCA9IHBvaW50cyA9IDA7IGkgPCByYXdQYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgcmF3UGF0aFtpXS5yZXNvbHV0aW9uID0gfn5yZXNvbHV0aW9uIHx8IDEyOyAvL3N0ZXBzIHBlciBCZXppZXIgY3VydmUgKGFuY2hvciwgMiBjb250cm9sIHBvaW50cywgdG8gYW5jaG9yKVxuXG4gICAgcG9pbnRzICs9IHJhd1BhdGhbaV0ubGVuZ3RoO1xuICAgIHBhdGhMZW5ndGggKz0gbWVhc3VyZVNlZ21lbnQocmF3UGF0aFtpXSk7XG4gIH1cblxuICByYXdQYXRoLnRvdGFsUG9pbnRzID0gcG9pbnRzO1xuICByYXdQYXRoLnRvdGFsTGVuZ3RoID0gcGF0aExlbmd0aDtcbiAgcmV0dXJuIHJhd1BhdGg7XG59IC8vZGl2aWRlIHNlZ21lbnRbaV0gYXQgcG9zaXRpb24gdCAodmFsdWUgYmV0d2VlbiAwIGFuZCAxLCBwcm9ncmVzcyBhbG9uZyB0aGF0IHBhcnRpY3VsYXIgY3ViaWMgYmV6aWVyIHNlZ21lbnQgdGhhdCBzdGFydHMgYXQgc2VnbWVudFtpXSkuIFJldHVybnMgaG93IG1hbnkgZWxlbWVudHMgd2VyZSBzcGxpY2VkIGludG8gdGhlIHNlZ21lbnQgYXJyYXkgKGVpdGhlciAwIG9yIDYpXG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJkaXZpZGVTZWdtZW50KHNlZ21lbnQsIGksIHQpIHtcbiAgaWYgKHQgPD0gMCB8fCB0ID49IDEpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBheCA9IHNlZ21lbnRbaV0sXG4gICAgICBheSA9IHNlZ21lbnRbaSArIDFdLFxuICAgICAgY3AxeCA9IHNlZ21lbnRbaSArIDJdLFxuICAgICAgY3AxeSA9IHNlZ21lbnRbaSArIDNdLFxuICAgICAgY3AyeCA9IHNlZ21lbnRbaSArIDRdLFxuICAgICAgY3AyeSA9IHNlZ21lbnRbaSArIDVdLFxuICAgICAgYnggPSBzZWdtZW50W2kgKyA2XSxcbiAgICAgIGJ5ID0gc2VnbWVudFtpICsgN10sXG4gICAgICB4MWEgPSBheCArIChjcDF4IC0gYXgpICogdCxcbiAgICAgIHgyID0gY3AxeCArIChjcDJ4IC0gY3AxeCkgKiB0LFxuICAgICAgeTFhID0gYXkgKyAoY3AxeSAtIGF5KSAqIHQsXG4gICAgICB5MiA9IGNwMXkgKyAoY3AyeSAtIGNwMXkpICogdCxcbiAgICAgIHgxID0geDFhICsgKHgyIC0geDFhKSAqIHQsXG4gICAgICB5MSA9IHkxYSArICh5MiAtIHkxYSkgKiB0LFxuICAgICAgeDJhID0gY3AyeCArIChieCAtIGNwMngpICogdCxcbiAgICAgIHkyYSA9IGNwMnkgKyAoYnkgLSBjcDJ5KSAqIHQ7XG4gIHgyICs9ICh4MmEgLSB4MikgKiB0O1xuICB5MiArPSAoeTJhIC0geTIpICogdDtcbiAgc2VnbWVudC5zcGxpY2UoaSArIDIsIDQsIF9yb3VuZCh4MWEpLCAvL2ZpcnN0IGNvbnRyb2wgcG9pbnRcbiAgX3JvdW5kKHkxYSksIF9yb3VuZCh4MSksIC8vc2Vjb25kIGNvbnRyb2wgcG9pbnRcbiAgX3JvdW5kKHkxKSwgX3JvdW5kKHgxICsgKHgyIC0geDEpICogdCksIC8vbmV3IGZhYnJpY2F0ZWQgYW5jaG9yIG9uIGxpbmVcbiAgX3JvdW5kKHkxICsgKHkyIC0geTEpICogdCksIF9yb3VuZCh4MiksIC8vdGhpcmQgY29udHJvbCBwb2ludFxuICBfcm91bmQoeTIpLCBfcm91bmQoeDJhKSwgLy9mb3VydGggY29udHJvbCBwb2ludFxuICBfcm91bmQoeTJhKSk7XG4gIHNlZ21lbnQuc2FtcGxlcyAmJiBzZWdtZW50LnNhbXBsZXMuc3BsaWNlKGkgLyA2ICogc2VnbWVudC5yZXNvbHV0aW9uIHwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gIHJldHVybiA2O1xufSAvLyByZXR1cm5zIGFuIG9iamVjdCB7cGF0aCwgc2VnbWVudCwgc2VnSW5kZXgsIGksIHR9XG5cbmZ1bmN0aW9uIGdldFByb2dyZXNzRGF0YShyYXdQYXRoLCBwcm9ncmVzcywgZGVjb3JhdGVlLCBwdXNoVG9OZXh0SWZBdEVuZCkge1xuICBkZWNvcmF0ZWUgPSBkZWNvcmF0ZWUgfHwge307XG4gIHJhd1BhdGgudG90YWxMZW5ndGggfHwgY2FjaGVSYXdQYXRoTWVhc3VyZW1lbnRzKHJhd1BhdGgpO1xuXG4gIGlmIChwcm9ncmVzcyA8IDAgfHwgcHJvZ3Jlc3MgPiAxKSB7XG4gICAgcHJvZ3Jlc3MgPSBfd3JhcFByb2dyZXNzKHByb2dyZXNzKTtcbiAgfVxuXG4gIHZhciBzZWdJbmRleCA9IDAsXG4gICAgICBzZWdtZW50ID0gcmF3UGF0aFswXSxcbiAgICAgIHNhbXBsZXMsXG4gICAgICByZXNvbHV0aW9uLFxuICAgICAgbGVuZ3RoLFxuICAgICAgbWluLFxuICAgICAgbWF4LFxuICAgICAgaSxcbiAgICAgIHQ7XG5cbiAgaWYgKCFwcm9ncmVzcykge1xuICAgIHQgPSBpID0gc2VnSW5kZXggPSAwO1xuICAgIHNlZ21lbnQgPSByYXdQYXRoWzBdO1xuICB9IGVsc2UgaWYgKHByb2dyZXNzID09PSAxKSB7XG4gICAgdCA9IDE7XG4gICAgc2VnSW5kZXggPSByYXdQYXRoLmxlbmd0aCAtIDE7XG4gICAgc2VnbWVudCA9IHJhd1BhdGhbc2VnSW5kZXhdO1xuICAgIGkgPSBzZWdtZW50Lmxlbmd0aCAtIDg7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHJhd1BhdGgubGVuZ3RoID4gMSkge1xuICAgICAgLy9zcGVlZCBvcHRpbWl6YXRpb246IG1vc3Qgb2YgdGhlIHRpbWUsIHRoZXJlJ3Mgb25seSBvbmUgc2VnbWVudCBzbyBza2lwIHRoZSByZWN1cnNpb24uXG4gICAgICBsZW5ndGggPSByYXdQYXRoLnRvdGFsTGVuZ3RoICogcHJvZ3Jlc3M7XG4gICAgICBtYXggPSBpID0gMDtcblxuICAgICAgd2hpbGUgKChtYXggKz0gcmF3UGF0aFtpKytdLnRvdGFsTGVuZ3RoKSA8IGxlbmd0aCkge1xuICAgICAgICBzZWdJbmRleCA9IGk7XG4gICAgICB9XG5cbiAgICAgIHNlZ21lbnQgPSByYXdQYXRoW3NlZ0luZGV4XTtcbiAgICAgIG1pbiA9IG1heCAtIHNlZ21lbnQudG90YWxMZW5ndGg7XG4gICAgICBwcm9ncmVzcyA9IChsZW5ndGggLSBtaW4pIC8gKG1heCAtIG1pbikgfHwgMDtcbiAgICB9XG5cbiAgICBzYW1wbGVzID0gc2VnbWVudC5zYW1wbGVzO1xuICAgIHJlc29sdXRpb24gPSBzZWdtZW50LnJlc29sdXRpb247IC8vaG93IG1hbnkgc2FtcGxlcyBwZXIgY3ViaWMgYmV6aWVyIGNodW5rXG5cbiAgICBsZW5ndGggPSBzZWdtZW50LnRvdGFsTGVuZ3RoICogcHJvZ3Jlc3M7XG4gICAgaSA9IHNlZ21lbnQubG9va3VwLmxlbmd0aCA/IHNlZ21lbnQubG9va3VwW35+KGxlbmd0aCAvIHNlZ21lbnQubWluTGVuZ3RoKV0gfHwgMCA6IF9nZXRTYW1wbGVJbmRleChzYW1wbGVzLCBsZW5ndGgsIHByb2dyZXNzKTtcbiAgICBtaW4gPSBpID8gc2FtcGxlc1tpIC0gMV0gOiAwO1xuICAgIG1heCA9IHNhbXBsZXNbaV07XG5cbiAgICBpZiAobWF4IDwgbGVuZ3RoKSB7XG4gICAgICBtaW4gPSBtYXg7XG4gICAgICBtYXggPSBzYW1wbGVzWysraV07XG4gICAgfVxuXG4gICAgdCA9IDEgLyByZXNvbHV0aW9uICogKChsZW5ndGggLSBtaW4pIC8gKG1heCAtIG1pbikgKyBpICUgcmVzb2x1dGlvbik7XG4gICAgaSA9IH5+KGkgLyByZXNvbHV0aW9uKSAqIDY7XG5cbiAgICBpZiAocHVzaFRvTmV4dElmQXRFbmQgJiYgdCA9PT0gMSkge1xuICAgICAgaWYgKGkgKyA2IDwgc2VnbWVudC5sZW5ndGgpIHtcbiAgICAgICAgaSArPSA2O1xuICAgICAgICB0ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoc2VnSW5kZXggKyAxIDwgcmF3UGF0aC5sZW5ndGgpIHtcbiAgICAgICAgaSA9IHQgPSAwO1xuICAgICAgICBzZWdtZW50ID0gcmF3UGF0aFsrK3NlZ0luZGV4XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBkZWNvcmF0ZWUudCA9IHQ7XG4gIGRlY29yYXRlZS5pID0gaTtcbiAgZGVjb3JhdGVlLnBhdGggPSByYXdQYXRoO1xuICBkZWNvcmF0ZWUuc2VnbWVudCA9IHNlZ21lbnQ7XG4gIGRlY29yYXRlZS5zZWdJbmRleCA9IHNlZ0luZGV4O1xuICByZXR1cm4gZGVjb3JhdGVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UG9zaXRpb25PblBhdGgocmF3UGF0aCwgcHJvZ3Jlc3MsIGluY2x1ZGVBbmdsZSwgcG9pbnQpIHtcbiAgdmFyIHNlZ21lbnQgPSByYXdQYXRoWzBdLFxuICAgICAgcmVzdWx0ID0gcG9pbnQgfHwge30sXG4gICAgICBzYW1wbGVzLFxuICAgICAgcmVzb2x1dGlvbixcbiAgICAgIGxlbmd0aCxcbiAgICAgIG1pbixcbiAgICAgIG1heCxcbiAgICAgIGksXG4gICAgICB0LFxuICAgICAgYSxcbiAgICAgIGludjtcblxuICBpZiAocHJvZ3Jlc3MgPCAwIHx8IHByb2dyZXNzID4gMSkge1xuICAgIHByb2dyZXNzID0gX3dyYXBQcm9ncmVzcyhwcm9ncmVzcyk7XG4gIH1cblxuICBpZiAocmF3UGF0aC5sZW5ndGggPiAxKSB7XG4gICAgLy9zcGVlZCBvcHRpbWl6YXRpb246IG1vc3Qgb2YgdGhlIHRpbWUsIHRoZXJlJ3Mgb25seSBvbmUgc2VnbWVudCBzbyBza2lwIHRoZSByZWN1cnNpb24uXG4gICAgbGVuZ3RoID0gcmF3UGF0aC50b3RhbExlbmd0aCAqIHByb2dyZXNzO1xuICAgIG1heCA9IGkgPSAwO1xuXG4gICAgd2hpbGUgKChtYXggKz0gcmF3UGF0aFtpKytdLnRvdGFsTGVuZ3RoKSA8IGxlbmd0aCkge1xuICAgICAgc2VnbWVudCA9IHJhd1BhdGhbaV07XG4gICAgfVxuXG4gICAgbWluID0gbWF4IC0gc2VnbWVudC50b3RhbExlbmd0aDtcbiAgICBwcm9ncmVzcyA9IChsZW5ndGggLSBtaW4pIC8gKG1heCAtIG1pbikgfHwgMDtcbiAgfVxuXG4gIHNhbXBsZXMgPSBzZWdtZW50LnNhbXBsZXM7XG4gIHJlc29sdXRpb24gPSBzZWdtZW50LnJlc29sdXRpb247XG4gIGxlbmd0aCA9IHNlZ21lbnQudG90YWxMZW5ndGggKiBwcm9ncmVzcztcbiAgaSA9IHNlZ21lbnQubG9va3VwLmxlbmd0aCA/IHNlZ21lbnQubG9va3VwW3Byb2dyZXNzIDwgMSA/IH5+KGxlbmd0aCAvIHNlZ21lbnQubWluTGVuZ3RoKSA6IHNlZ21lbnQubG9va3VwLmxlbmd0aCAtIDFdIHx8IDAgOiBfZ2V0U2FtcGxlSW5kZXgoc2FtcGxlcywgbGVuZ3RoLCBwcm9ncmVzcyk7XG4gIG1pbiA9IGkgPyBzYW1wbGVzW2kgLSAxXSA6IDA7XG4gIG1heCA9IHNhbXBsZXNbaV07XG5cbiAgaWYgKG1heCA8IGxlbmd0aCkge1xuICAgIG1pbiA9IG1heDtcbiAgICBtYXggPSBzYW1wbGVzWysraV07XG4gIH1cblxuICB0ID0gMSAvIHJlc29sdXRpb24gKiAoKGxlbmd0aCAtIG1pbikgLyAobWF4IC0gbWluKSArIGkgJSByZXNvbHV0aW9uKSB8fCAwO1xuICBpbnYgPSAxIC0gdDtcbiAgaSA9IH5+KGkgLyByZXNvbHV0aW9uKSAqIDY7XG4gIGEgPSBzZWdtZW50W2ldO1xuICByZXN1bHQueCA9IF9yb3VuZCgodCAqIHQgKiAoc2VnbWVudFtpICsgNl0gLSBhKSArIDMgKiBpbnYgKiAodCAqIChzZWdtZW50W2kgKyA0XSAtIGEpICsgaW52ICogKHNlZ21lbnRbaSArIDJdIC0gYSkpKSAqIHQgKyBhKTtcbiAgcmVzdWx0LnkgPSBfcm91bmQoKHQgKiB0ICogKHNlZ21lbnRbaSArIDddIC0gKGEgPSBzZWdtZW50W2kgKyAxXSkpICsgMyAqIGludiAqICh0ICogKHNlZ21lbnRbaSArIDVdIC0gYSkgKyBpbnYgKiAoc2VnbWVudFtpICsgM10gLSBhKSkpICogdCArIGEpO1xuXG4gIGlmIChpbmNsdWRlQW5nbGUpIHtcbiAgICByZXN1bHQuYW5nbGUgPSBzZWdtZW50LnRvdGFsTGVuZ3RoID8gZ2V0Um90YXRpb25BdEJlemllclQoc2VnbWVudCwgaSwgdCA+PSAxID8gMSAtIDFlLTkgOiB0ID8gdCA6IDFlLTkpIDogc2VnbWVudC5hbmdsZSB8fCAwO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn0gLy9hcHBsaWVzIGEgbWF0cml4IHRyYW5zZm9ybSB0byBSYXdQYXRoIChvciBhIHNlZ21lbnQgaW4gYSBSYXdQYXRoKSBhbmQgcmV0dXJucyB3aGF0ZXZlciB3YXMgcGFzc2VkIGluIChpdCB0cmFuc2Zvcm1zIHRoZSB2YWx1ZXMgaW4gdGhlIGFycmF5KHMpLCBub3QgYSBjb3B5KS5cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybVJhd1BhdGgocmF3UGF0aCwgYSwgYiwgYywgZCwgdHgsIHR5KSB7XG4gIHZhciBqID0gcmF3UGF0aC5sZW5ndGgsXG4gICAgICBzZWdtZW50LFxuICAgICAgbCxcbiAgICAgIGksXG4gICAgICB4LFxuICAgICAgeTtcblxuICB3aGlsZSAoLS1qID4gLTEpIHtcbiAgICBzZWdtZW50ID0gcmF3UGF0aFtqXTtcbiAgICBsID0gc2VnbWVudC5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgICB4ID0gc2VnbWVudFtpXTtcbiAgICAgIHkgPSBzZWdtZW50W2kgKyAxXTtcbiAgICAgIHNlZ21lbnRbaV0gPSB4ICogYSArIHkgKiBjICsgdHg7XG4gICAgICBzZWdtZW50W2kgKyAxXSA9IHggKiBiICsgeSAqIGQgKyB0eTtcbiAgICB9XG4gIH1cblxuICByYXdQYXRoLl9kaXJ0eSA9IDE7XG4gIHJldHVybiByYXdQYXRoO1xufSAvLyB0cmFuc2xhdGVzIFNWRyBhcmMgZGF0YSBpbnRvIGEgc2VnbWVudCAoY3ViaWMgYmV6aWVycykuIEFuZ2xlIGlzIGluIGRlZ3JlZXMuXG5cbmZ1bmN0aW9uIGFyY1RvU2VnbWVudChsYXN0WCwgbGFzdFksIHJ4LCByeSwgYW5nbGUsIGxhcmdlQXJjRmxhZywgc3dlZXBGbGFnLCB4LCB5KSB7XG4gIGlmIChsYXN0WCA9PT0geCAmJiBsYXN0WSA9PT0geSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJ4ID0gX2FicyhyeCk7XG4gIHJ5ID0gX2FicyhyeSk7XG5cbiAgdmFyIGFuZ2xlUmFkID0gYW5nbGUgJSAzNjAgKiBfREVHMlJBRCxcbiAgICAgIGNvc0FuZ2xlID0gX2NvcyhhbmdsZVJhZCksXG4gICAgICBzaW5BbmdsZSA9IF9zaW4oYW5nbGVSYWQpLFxuICAgICAgUEkgPSBNYXRoLlBJLFxuICAgICAgVFdPUEkgPSBQSSAqIDIsXG4gICAgICBkeDIgPSAobGFzdFggLSB4KSAvIDIsXG4gICAgICBkeTIgPSAobGFzdFkgLSB5KSAvIDIsXG4gICAgICB4MSA9IGNvc0FuZ2xlICogZHgyICsgc2luQW5nbGUgKiBkeTIsXG4gICAgICB5MSA9IC1zaW5BbmdsZSAqIGR4MiArIGNvc0FuZ2xlICogZHkyLFxuICAgICAgeDFfc3EgPSB4MSAqIHgxLFxuICAgICAgeTFfc3EgPSB5MSAqIHkxLFxuICAgICAgcmFkaWlDaGVjayA9IHgxX3NxIC8gKHJ4ICogcngpICsgeTFfc3EgLyAocnkgKiByeSk7XG5cbiAgaWYgKHJhZGlpQ2hlY2sgPiAxKSB7XG4gICAgcnggPSBfc3FydChyYWRpaUNoZWNrKSAqIHJ4O1xuICAgIHJ5ID0gX3NxcnQocmFkaWlDaGVjaykgKiByeTtcbiAgfVxuXG4gIHZhciByeF9zcSA9IHJ4ICogcngsXG4gICAgICByeV9zcSA9IHJ5ICogcnksXG4gICAgICBzcSA9IChyeF9zcSAqIHJ5X3NxIC0gcnhfc3EgKiB5MV9zcSAtIHJ5X3NxICogeDFfc3EpIC8gKHJ4X3NxICogeTFfc3EgKyByeV9zcSAqIHgxX3NxKTtcblxuICBpZiAoc3EgPCAwKSB7XG4gICAgc3EgPSAwO1xuICB9XG5cbiAgdmFyIGNvZWYgPSAobGFyZ2VBcmNGbGFnID09PSBzd2VlcEZsYWcgPyAtMSA6IDEpICogX3NxcnQoc3EpLFxuICAgICAgY3gxID0gY29lZiAqIChyeCAqIHkxIC8gcnkpLFxuICAgICAgY3kxID0gY29lZiAqIC0ocnkgKiB4MSAvIHJ4KSxcbiAgICAgIHN4MiA9IChsYXN0WCArIHgpIC8gMixcbiAgICAgIHN5MiA9IChsYXN0WSArIHkpIC8gMixcbiAgICAgIGN4ID0gc3gyICsgKGNvc0FuZ2xlICogY3gxIC0gc2luQW5nbGUgKiBjeTEpLFxuICAgICAgY3kgPSBzeTIgKyAoc2luQW5nbGUgKiBjeDEgKyBjb3NBbmdsZSAqIGN5MSksXG4gICAgICB1eCA9ICh4MSAtIGN4MSkgLyByeCxcbiAgICAgIHV5ID0gKHkxIC0gY3kxKSAvIHJ5LFxuICAgICAgdnggPSAoLXgxIC0gY3gxKSAvIHJ4LFxuICAgICAgdnkgPSAoLXkxIC0gY3kxKSAvIHJ5LFxuICAgICAgdGVtcCA9IHV4ICogdXggKyB1eSAqIHV5LFxuICAgICAgYW5nbGVTdGFydCA9ICh1eSA8IDAgPyAtMSA6IDEpICogTWF0aC5hY29zKHV4IC8gX3NxcnQodGVtcCkpLFxuICAgICAgYW5nbGVFeHRlbnQgPSAodXggKiB2eSAtIHV5ICogdnggPCAwID8gLTEgOiAxKSAqIE1hdGguYWNvcygodXggKiB2eCArIHV5ICogdnkpIC8gX3NxcnQodGVtcCAqICh2eCAqIHZ4ICsgdnkgKiB2eSkpKTtcblxuICBpc05hTihhbmdsZUV4dGVudCkgJiYgKGFuZ2xlRXh0ZW50ID0gUEkpOyAvL3JhcmUgZWRnZSBjYXNlLiBNYXRoLmNvcygtMSkgaXMgTmFOLlxuXG4gIGlmICghc3dlZXBGbGFnICYmIGFuZ2xlRXh0ZW50ID4gMCkge1xuICAgIGFuZ2xlRXh0ZW50IC09IFRXT1BJO1xuICB9IGVsc2UgaWYgKHN3ZWVwRmxhZyAmJiBhbmdsZUV4dGVudCA8IDApIHtcbiAgICBhbmdsZUV4dGVudCArPSBUV09QSTtcbiAgfVxuXG4gIGFuZ2xlU3RhcnQgJT0gVFdPUEk7XG4gIGFuZ2xlRXh0ZW50ICU9IFRXT1BJO1xuXG4gIHZhciBzZWdtZW50cyA9IE1hdGguY2VpbChfYWJzKGFuZ2xlRXh0ZW50KSAvIChUV09QSSAvIDQpKSxcbiAgICAgIHJhd1BhdGggPSBbXSxcbiAgICAgIGFuZ2xlSW5jcmVtZW50ID0gYW5nbGVFeHRlbnQgLyBzZWdtZW50cyxcbiAgICAgIGNvbnRyb2xMZW5ndGggPSA0IC8gMyAqIF9zaW4oYW5nbGVJbmNyZW1lbnQgLyAyKSAvICgxICsgX2NvcyhhbmdsZUluY3JlbWVudCAvIDIpKSxcbiAgICAgIG1hID0gY29zQW5nbGUgKiByeCxcbiAgICAgIG1iID0gc2luQW5nbGUgKiByeCxcbiAgICAgIG1jID0gc2luQW5nbGUgKiAtcnksXG4gICAgICBtZCA9IGNvc0FuZ2xlICogcnksXG4gICAgICBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzZWdtZW50czsgaSsrKSB7XG4gICAgYW5nbGUgPSBhbmdsZVN0YXJ0ICsgaSAqIGFuZ2xlSW5jcmVtZW50O1xuICAgIHgxID0gX2NvcyhhbmdsZSk7XG4gICAgeTEgPSBfc2luKGFuZ2xlKTtcbiAgICB1eCA9IF9jb3MoYW5nbGUgKz0gYW5nbGVJbmNyZW1lbnQpO1xuICAgIHV5ID0gX3NpbihhbmdsZSk7XG4gICAgcmF3UGF0aC5wdXNoKHgxIC0gY29udHJvbExlbmd0aCAqIHkxLCB5MSArIGNvbnRyb2xMZW5ndGggKiB4MSwgdXggKyBjb250cm9sTGVuZ3RoICogdXksIHV5IC0gY29udHJvbExlbmd0aCAqIHV4LCB1eCwgdXkpO1xuICB9IC8vbm93IHRyYW5zZm9ybSBhY2NvcmRpbmcgdG8gdGhlIGFjdHVhbCBzaXplIG9mIHRoZSBlbGxpcHNlL2FyYyAodGhlIGJlemllcnMgd2VyZSBub3JhbWxpemVkLCBiZXR3ZWVuIDAgYW5kIDEgb24gYSBjaXJjbGUpLlxuXG5cbiAgZm9yIChpID0gMDsgaSA8IHJhd1BhdGgubGVuZ3RoOyBpICs9IDIpIHtcbiAgICB4MSA9IHJhd1BhdGhbaV07XG4gICAgeTEgPSByYXdQYXRoW2kgKyAxXTtcbiAgICByYXdQYXRoW2ldID0geDEgKiBtYSArIHkxICogbWMgKyBjeDtcbiAgICByYXdQYXRoW2kgKyAxXSA9IHgxICogbWIgKyB5MSAqIG1kICsgY3k7XG4gIH1cblxuICByYXdQYXRoW2kgLSAyXSA9IHg7IC8vYWx3YXlzIHNldCB0aGUgZW5kIHRvIGV4YWN0bHkgd2hlcmUgaXQncyBzdXBwb3NlZCB0byBiZVxuXG4gIHJhd1BhdGhbaSAtIDFdID0geTtcbiAgcmV0dXJuIHJhd1BhdGg7XG59IC8vU3BpdHMgYmFjayBhIFJhd1BhdGggd2l0aCBhYnNvbHV0ZSBjb29yZGluYXRlcy4gRWFjaCBzZWdtZW50IHN0YXJ0cyB3aXRoIGEgXCJtb3ZlVG9cIiBjb21tYW5kICh4IGNvb3JkaW5hdGUsIHRoZW4geSkgYW5kIHRoZW4gMiBjb250cm9sIHBvaW50cyAoeCwgeSwgeCwgeSksIHRoZW4gYW5jaG9yLiBUaGUgZ29hbCBpcyB0byBtaW5pbWl6ZSBtZW1vcnkgYW5kIG1heGltaXplIHNwZWVkLlxuXG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdUb1Jhd1BhdGgoZCkge1xuICB2YXIgYSA9IChkICsgXCJcIikucmVwbGFjZShfc2NpZW50aWZpYywgZnVuY3Rpb24gKG0pIHtcbiAgICB2YXIgbiA9ICttO1xuICAgIHJldHVybiBuIDwgMC4wMDAxICYmIG4gPiAtMC4wMDAxID8gMCA6IG47XG4gIH0pLm1hdGNoKF9zdmdQYXRoRXhwKSB8fCBbXSxcbiAgICAgIC8vc29tZSBhdXRob3JpbmcgcHJvZ3JhbXMgc3BpdCBvdXQgdmVyeSBzbWFsbCBudW1iZXJzIGluIHNjaWVudGlmaWMgbm90YXRpb24gbGlrZSBcIjFlLTVcIiwgc28gbWFrZSBzdXJlIHdlIHJvdW5kIHRoYXQgZG93biB0byAwIGZpcnN0LlxuICBwYXRoID0gW10sXG4gICAgICByZWxhdGl2ZVggPSAwLFxuICAgICAgcmVsYXRpdmVZID0gMCxcbiAgICAgIHR3b1RoaXJkcyA9IDIgLyAzLFxuICAgICAgZWxlbWVudHMgPSBhLmxlbmd0aCxcbiAgICAgIHBvaW50cyA9IDAsXG4gICAgICBlcnJvck1lc3NhZ2UgPSBcIkVSUk9SOiBtYWxmb3JtZWQgcGF0aDogXCIgKyBkLFxuICAgICAgaSxcbiAgICAgIGosXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGNvbW1hbmQsXG4gICAgICBpc1JlbGF0aXZlLFxuICAgICAgc2VnbWVudCxcbiAgICAgIHN0YXJ0WCxcbiAgICAgIHN0YXJ0WSxcbiAgICAgIGRpZlgsXG4gICAgICBkaWZZLFxuICAgICAgYmV6aWVycyxcbiAgICAgIHByZXZDb21tYW5kLFxuICAgICAgZmxhZzEsXG4gICAgICBmbGFnMixcbiAgICAgIGxpbmUgPSBmdW5jdGlvbiBsaW5lKHN4LCBzeSwgZXgsIGV5KSB7XG4gICAgZGlmWCA9IChleCAtIHN4KSAvIDM7XG4gICAgZGlmWSA9IChleSAtIHN5KSAvIDM7XG4gICAgc2VnbWVudC5wdXNoKHN4ICsgZGlmWCwgc3kgKyBkaWZZLCBleCAtIGRpZlgsIGV5IC0gZGlmWSwgZXgsIGV5KTtcbiAgfTtcblxuICBpZiAoIWQgfHwgIWlzTmFOKGFbMF0pIHx8IGlzTmFOKGFbMV0pKSB7XG4gICAgY29uc29sZS5sb2coZXJyb3JNZXNzYWdlKTtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBlbGVtZW50czsgaSsrKSB7XG4gICAgcHJldkNvbW1hbmQgPSBjb21tYW5kO1xuXG4gICAgaWYgKGlzTmFOKGFbaV0pKSB7XG4gICAgICBjb21tYW5kID0gYVtpXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgaXNSZWxhdGl2ZSA9IGNvbW1hbmQgIT09IGFbaV07IC8vbG93ZXIgY2FzZSBtZWFucyByZWxhdGl2ZVxuICAgIH0gZWxzZSB7XG4gICAgICAvL2NvbW1hbmRzIGxpa2UgXCJDXCIgY2FuIGJlIHN0cnVuZyB0b2dldGhlciB3aXRob3V0IGFueSBuZXcgY29tbWFuZCBjaGFyYWN0ZXJzIGJldHdlZW4uXG4gICAgICBpLS07XG4gICAgfVxuXG4gICAgeCA9ICthW2kgKyAxXTtcbiAgICB5ID0gK2FbaSArIDJdO1xuXG4gICAgaWYgKGlzUmVsYXRpdmUpIHtcbiAgICAgIHggKz0gcmVsYXRpdmVYO1xuICAgICAgeSArPSByZWxhdGl2ZVk7XG4gICAgfVxuXG4gICAgaWYgKCFpKSB7XG4gICAgICBzdGFydFggPSB4O1xuICAgICAgc3RhcnRZID0geTtcbiAgICB9IC8vIFwiTVwiIChtb3ZlKVxuXG5cbiAgICBpZiAoY29tbWFuZCA9PT0gXCJNXCIpIHtcbiAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA8IDgpIHtcbiAgICAgICAgICAvL2lmIHRoZSBwYXRoIGRhdGEgd2FzIGZ1bmt5IGFuZCBqdXN0IGhhZCBhIE0gd2l0aCBubyBhY3R1YWwgZHJhd2luZyBhbnl3aGVyZSwgc2tpcCBpdC5cbiAgICAgICAgICBwYXRoLmxlbmd0aCAtPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvaW50cyArPSBzZWdtZW50Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZWxhdGl2ZVggPSBzdGFydFggPSB4O1xuICAgICAgcmVsYXRpdmVZID0gc3RhcnRZID0geTtcbiAgICAgIHNlZ21lbnQgPSBbeCwgeV07XG4gICAgICBwYXRoLnB1c2goc2VnbWVudCk7XG4gICAgICBpICs9IDI7XG4gICAgICBjb21tYW5kID0gXCJMXCI7IC8vYW4gXCJNXCIgd2l0aCBtb3JlIHRoYW4gMiB2YWx1ZXMgZ2V0cyBpbnRlcnByZXRlZCBhcyBcImxpbmVUb1wiIGNvbW1hbmRzIChcIkxcIikuXG4gICAgICAvLyBcIkNcIiAoY3ViaWMgYmV6aWVyKVxuICAgIH0gZWxzZSBpZiAoY29tbWFuZCA9PT0gXCJDXCIpIHtcbiAgICAgIGlmICghc2VnbWVudCkge1xuICAgICAgICBzZWdtZW50ID0gWzAsIDBdO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzUmVsYXRpdmUpIHtcbiAgICAgICAgcmVsYXRpdmVYID0gcmVsYXRpdmVZID0gMDtcbiAgICAgIH0gLy9ub3RlOiBcIioxXCIgaXMganVzdCBhIGZhc3Qvc2hvcnQgd2F5IHRvIGNhc3QgdGhlIHZhbHVlIGFzIGEgTnVtYmVyLiBXQUFBWSBmYXN0ZXIgaW4gQ2hyb21lLCBzbGlnaHRseSBzbG93ZXIgaW4gRmlyZWZveC5cblxuXG4gICAgICBzZWdtZW50LnB1c2goeCwgeSwgcmVsYXRpdmVYICsgYVtpICsgM10gKiAxLCByZWxhdGl2ZVkgKyBhW2kgKyA0XSAqIDEsIHJlbGF0aXZlWCArPSBhW2kgKyA1XSAqIDEsIHJlbGF0aXZlWSArPSBhW2kgKyA2XSAqIDEpO1xuICAgICAgaSArPSA2OyAvLyBcIlNcIiAoY29udGludWF0aW9uIG9mIGN1YmljIGJlemllcilcbiAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT09IFwiU1wiKSB7XG4gICAgICBkaWZYID0gcmVsYXRpdmVYO1xuICAgICAgZGlmWSA9IHJlbGF0aXZlWTtcblxuICAgICAgaWYgKHByZXZDb21tYW5kID09PSBcIkNcIiB8fCBwcmV2Q29tbWFuZCA9PT0gXCJTXCIpIHtcbiAgICAgICAgZGlmWCArPSByZWxhdGl2ZVggLSBzZWdtZW50W3NlZ21lbnQubGVuZ3RoIC0gNF07XG4gICAgICAgIGRpZlkgKz0gcmVsYXRpdmVZIC0gc2VnbWVudFtzZWdtZW50Lmxlbmd0aCAtIDNdO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzUmVsYXRpdmUpIHtcbiAgICAgICAgcmVsYXRpdmVYID0gcmVsYXRpdmVZID0gMDtcbiAgICAgIH1cblxuICAgICAgc2VnbWVudC5wdXNoKGRpZlgsIGRpZlksIHgsIHksIHJlbGF0aXZlWCArPSBhW2kgKyAzXSAqIDEsIHJlbGF0aXZlWSArPSBhW2kgKyA0XSAqIDEpO1xuICAgICAgaSArPSA0OyAvLyBcIlFcIiAocXVhZHJhdGljIGJlemllcilcbiAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT09IFwiUVwiKSB7XG4gICAgICBkaWZYID0gcmVsYXRpdmVYICsgKHggLSByZWxhdGl2ZVgpICogdHdvVGhpcmRzO1xuICAgICAgZGlmWSA9IHJlbGF0aXZlWSArICh5IC0gcmVsYXRpdmVZKSAqIHR3b1RoaXJkcztcblxuICAgICAgaWYgKCFpc1JlbGF0aXZlKSB7XG4gICAgICAgIHJlbGF0aXZlWCA9IHJlbGF0aXZlWSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJlbGF0aXZlWCArPSBhW2kgKyAzXSAqIDE7XG4gICAgICByZWxhdGl2ZVkgKz0gYVtpICsgNF0gKiAxO1xuICAgICAgc2VnbWVudC5wdXNoKGRpZlgsIGRpZlksIHJlbGF0aXZlWCArICh4IC0gcmVsYXRpdmVYKSAqIHR3b1RoaXJkcywgcmVsYXRpdmVZICsgKHkgLSByZWxhdGl2ZVkpICogdHdvVGhpcmRzLCByZWxhdGl2ZVgsIHJlbGF0aXZlWSk7XG4gICAgICBpICs9IDQ7IC8vIFwiVFwiIChjb250aW51YXRpb24gb2YgcXVhZHJhdGljIGJlemllcilcbiAgICB9IGVsc2UgaWYgKGNvbW1hbmQgPT09IFwiVFwiKSB7XG4gICAgICBkaWZYID0gcmVsYXRpdmVYIC0gc2VnbWVudFtzZWdtZW50Lmxlbmd0aCAtIDRdO1xuICAgICAgZGlmWSA9IHJlbGF0aXZlWSAtIHNlZ21lbnRbc2VnbWVudC5sZW5ndGggLSAzXTtcbiAgICAgIHNlZ21lbnQucHVzaChyZWxhdGl2ZVggKyBkaWZYLCByZWxhdGl2ZVkgKyBkaWZZLCB4ICsgKHJlbGF0aXZlWCArIGRpZlggKiAxLjUgLSB4KSAqIHR3b1RoaXJkcywgeSArIChyZWxhdGl2ZVkgKyBkaWZZICogMS41IC0geSkgKiB0d29UaGlyZHMsIHJlbGF0aXZlWCA9IHgsIHJlbGF0aXZlWSA9IHkpO1xuICAgICAgaSArPSAyOyAvLyBcIkhcIiAoaG9yaXpvbnRhbCBsaW5lKVxuICAgIH0gZWxzZSBpZiAoY29tbWFuZCA9PT0gXCJIXCIpIHtcbiAgICAgIGxpbmUocmVsYXRpdmVYLCByZWxhdGl2ZVksIHJlbGF0aXZlWCA9IHgsIHJlbGF0aXZlWSk7XG4gICAgICBpICs9IDE7IC8vIFwiVlwiICh2ZXJ0aWNhbCBsaW5lKVxuICAgIH0gZWxzZSBpZiAoY29tbWFuZCA9PT0gXCJWXCIpIHtcbiAgICAgIC8vYWRqdXN0IHZhbHVlcyBiZWNhdXNlIHRoZSBmaXJzdCAoYW5kIG9ubHkgb25lKSBpc24ndCB4IGluIHRoaXMgY2FzZSwgaXQncyB5LlxuICAgICAgbGluZShyZWxhdGl2ZVgsIHJlbGF0aXZlWSwgcmVsYXRpdmVYLCByZWxhdGl2ZVkgPSB4ICsgKGlzUmVsYXRpdmUgPyByZWxhdGl2ZVkgLSByZWxhdGl2ZVggOiAwKSk7XG4gICAgICBpICs9IDE7IC8vIFwiTFwiIChsaW5lKSBvciBcIlpcIiAoY2xvc2UpXG4gICAgfSBlbHNlIGlmIChjb21tYW5kID09PSBcIkxcIiB8fCBjb21tYW5kID09PSBcIlpcIikge1xuICAgICAgaWYgKGNvbW1hbmQgPT09IFwiWlwiKSB7XG4gICAgICAgIHggPSBzdGFydFg7XG4gICAgICAgIHkgPSBzdGFydFk7XG4gICAgICAgIHNlZ21lbnQuY2xvc2VkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbW1hbmQgPT09IFwiTFwiIHx8IF9hYnMocmVsYXRpdmVYIC0geCkgPiAwLjUgfHwgX2FicyhyZWxhdGl2ZVkgLSB5KSA+IDAuNSkge1xuICAgICAgICBsaW5lKHJlbGF0aXZlWCwgcmVsYXRpdmVZLCB4LCB5KTtcblxuICAgICAgICBpZiAoY29tbWFuZCA9PT0gXCJMXCIpIHtcbiAgICAgICAgICBpICs9IDI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVsYXRpdmVYID0geDtcbiAgICAgIHJlbGF0aXZlWSA9IHk7IC8vIFwiQVwiIChhcmMpXG4gICAgfSBlbHNlIGlmIChjb21tYW5kID09PSBcIkFcIikge1xuICAgICAgZmxhZzEgPSBhW2kgKyA0XTtcbiAgICAgIGZsYWcyID0gYVtpICsgNV07XG4gICAgICBkaWZYID0gYVtpICsgNl07XG4gICAgICBkaWZZID0gYVtpICsgN107XG4gICAgICBqID0gNztcblxuICAgICAgaWYgKGZsYWcxLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgLy8gZm9yIGNhc2VzIHdoZW4gdGhlIGZsYWdzIGFyZSBtZXJnZWQsIGxpa2UgXCJhOCA4IDAgMDE4IDhcIiAodGhlIDAgYW5kIDEgZmxhZ3MgYXJlIFdJVEggdGhlIHggdmFsdWUgb2YgOCwgYnV0IGl0IGNvdWxkIGFsc28gYmUgXCJhOCA4IDAgMDEtOCA4XCIgc28gaXQgbWF5IGluY2x1ZGUgeCBvciBub3QpXG4gICAgICAgIGlmIChmbGFnMS5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgZGlmWSA9IGRpZlg7XG4gICAgICAgICAgZGlmWCA9IGZsYWcyO1xuICAgICAgICAgIGotLTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaWZZID0gZmxhZzI7XG4gICAgICAgICAgZGlmWCA9IGZsYWcxLnN1YnN0cigyKTtcbiAgICAgICAgICBqIC09IDI7XG4gICAgICAgIH1cblxuICAgICAgICBmbGFnMiA9IGZsYWcxLmNoYXJBdCgxKTtcbiAgICAgICAgZmxhZzEgPSBmbGFnMS5jaGFyQXQoMCk7XG4gICAgICB9XG5cbiAgICAgIGJlemllcnMgPSBhcmNUb1NlZ21lbnQocmVsYXRpdmVYLCByZWxhdGl2ZVksICthW2kgKyAxXSwgK2FbaSArIDJdLCArYVtpICsgM10sICtmbGFnMSwgK2ZsYWcyLCAoaXNSZWxhdGl2ZSA/IHJlbGF0aXZlWCA6IDApICsgZGlmWCAqIDEsIChpc1JlbGF0aXZlID8gcmVsYXRpdmVZIDogMCkgKyBkaWZZICogMSk7XG4gICAgICBpICs9IGo7XG5cbiAgICAgIGlmIChiZXppZXJzKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBiZXppZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgc2VnbWVudC5wdXNoKGJlemllcnNbal0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlbGF0aXZlWCA9IHNlZ21lbnRbc2VnbWVudC5sZW5ndGggLSAyXTtcbiAgICAgIHJlbGF0aXZlWSA9IHNlZ21lbnRbc2VnbWVudC5sZW5ndGggLSAxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coZXJyb3JNZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICBpID0gc2VnbWVudC5sZW5ndGg7XG5cbiAgaWYgKGkgPCA2KSB7XG4gICAgLy9pbiBjYXNlIHRoZXJlJ3Mgb2RkIFNWRyBsaWtlIGEgTTAsMCBjb21tYW5kIGF0IHRoZSB2ZXJ5IGVuZC5cbiAgICBwYXRoLnBvcCgpO1xuICAgIGkgPSAwO1xuICB9IGVsc2UgaWYgKHNlZ21lbnRbMF0gPT09IHNlZ21lbnRbaSAtIDJdICYmIHNlZ21lbnRbMV0gPT09IHNlZ21lbnRbaSAtIDFdKSB7XG4gICAgc2VnbWVudC5jbG9zZWQgPSB0cnVlO1xuICB9XG5cbiAgcGF0aC50b3RhbFBvaW50cyA9IHBvaW50cyArIGk7XG4gIHJldHVybiBwYXRoO1xufSAvL3BvcHVsYXRlcyB0aGUgcG9pbnRzIGFycmF5IGluIGFsdGVybmF0aW5nIHgveSB2YWx1ZXMgKGxpa2UgW3gsIHksIHgsIHkuLi5dIGluc3RlYWQgb2YgaW5kaXZpZHVhbCBwb2ludCBvYmplY3RzIFt7eCwgeX0sIHt4LCB5fS4uLl0gdG8gY29uc2VydmUgbWVtb3J5IGFuZCBzdGF5IGluIGxpbmUgd2l0aCBob3cgd2UncmUgaGFuZGxpbmcgc2VnbWVudCBhcnJheXNcblxuZXhwb3J0IGZ1bmN0aW9uIGJlemllclRvUG9pbnRzKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgdGhyZXNob2xkLCBwb2ludHMsIGluZGV4KSB7XG4gIHZhciB4MTIgPSAoeDEgKyB4MikgLyAyLFxuICAgICAgeTEyID0gKHkxICsgeTIpIC8gMixcbiAgICAgIHgyMyA9ICh4MiArIHgzKSAvIDIsXG4gICAgICB5MjMgPSAoeTIgKyB5MykgLyAyLFxuICAgICAgeDM0ID0gKHgzICsgeDQpIC8gMixcbiAgICAgIHkzNCA9ICh5MyArIHk0KSAvIDIsXG4gICAgICB4MTIzID0gKHgxMiArIHgyMykgLyAyLFxuICAgICAgeTEyMyA9ICh5MTIgKyB5MjMpIC8gMixcbiAgICAgIHgyMzQgPSAoeDIzICsgeDM0KSAvIDIsXG4gICAgICB5MjM0ID0gKHkyMyArIHkzNCkgLyAyLFxuICAgICAgeDEyMzQgPSAoeDEyMyArIHgyMzQpIC8gMixcbiAgICAgIHkxMjM0ID0gKHkxMjMgKyB5MjM0KSAvIDIsXG4gICAgICBkeCA9IHg0IC0geDEsXG4gICAgICBkeSA9IHk0IC0geTEsXG4gICAgICBkMiA9IF9hYnMoKHgyIC0geDQpICogZHkgLSAoeTIgLSB5NCkgKiBkeCksXG4gICAgICBkMyA9IF9hYnMoKHgzIC0geDQpICogZHkgLSAoeTMgLSB5NCkgKiBkeCksXG4gICAgICBsZW5ndGg7XG5cbiAgaWYgKCFwb2ludHMpIHtcbiAgICBwb2ludHMgPSBbeDEsIHkxLCB4NCwgeTRdO1xuICAgIGluZGV4ID0gMjtcbiAgfVxuXG4gIHBvaW50cy5zcGxpY2UoaW5kZXggfHwgcG9pbnRzLmxlbmd0aCAtIDIsIDAsIHgxMjM0LCB5MTIzNCk7XG5cbiAgaWYgKChkMiArIGQzKSAqIChkMiArIGQzKSA+IHRocmVzaG9sZCAqIChkeCAqIGR4ICsgZHkgKiBkeSkpIHtcbiAgICBsZW5ndGggPSBwb2ludHMubGVuZ3RoO1xuICAgIGJlemllclRvUG9pbnRzKHgxLCB5MSwgeDEyLCB5MTIsIHgxMjMsIHkxMjMsIHgxMjM0LCB5MTIzNCwgdGhyZXNob2xkLCBwb2ludHMsIGluZGV4KTtcbiAgICBiZXppZXJUb1BvaW50cyh4MTIzNCwgeTEyMzQsIHgyMzQsIHkyMzQsIHgzNCwgeTM0LCB4NCwgeTQsIHRocmVzaG9sZCwgcG9pbnRzLCBpbmRleCArIDIgKyAocG9pbnRzLmxlbmd0aCAtIGxlbmd0aCkpO1xuICB9XG5cbiAgcmV0dXJuIHBvaW50cztcbn1cbi8qXG5mdW5jdGlvbiBnZXRBbmdsZUJldHdlZW5Qb2ludHMoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MikgeyAvL2FuZ2xlIGJldHdlZW4gMyBwb2ludHMgaW4gcmFkaWFuc1xuXHR2YXIgZHgxID0geDEgLSB4MCxcblx0XHRkeTEgPSB5MSAtIHkwLFxuXHRcdGR4MiA9IHgyIC0geDEsXG5cdFx0ZHkyID0geTIgLSB5MSxcblx0XHRkeDMgPSB4MiAtIHgwLFxuXHRcdGR5MyA9IHkyIC0geTAsXG5cdFx0YSA9IGR4MSAqIGR4MSArIGR5MSAqIGR5MSxcblx0XHRiID0gZHgyICogZHgyICsgZHkyICogZHkyLFxuXHRcdGMgPSBkeDMgKiBkeDMgKyBkeTMgKiBkeTM7XG5cdHJldHVybiBNYXRoLmFjb3MoIChhICsgYiAtIGMpIC8gX3NxcnQoNCAqIGEgKiBiKSApO1xufSxcbiovXG4vL3BvaW50c1RvU2VnbWVudCgpIGRvZXNuJ3QgaGFuZGxlIGZsYXQgY29vcmRpbmF0ZXMgKHdoZXJlIHkgaXMgYWx3YXlzIDApIHRoZSB3YXkgd2UgbmVlZCAodGhlIHJlc3VsdGluZyBjb250cm9sIHBvaW50cyBhcmUgYWx3YXlzIHJpZ2h0IG9uIHRvcCBvZiB0aGUgYW5jaG9ycyksIHNvIHRoaXMgZnVuY3Rpb24gYmFzaWNhbGx5IG1ha2VzIHRoZSBjb250cm9sIHBvaW50cyBnbyBkaXJlY3RseSB1cCBhbmQgZG93biwgdmFyeWluZyBpbiBsZW5ndGggYmFzZWQgb24gdGhlIGN1cnZpbmVzcyAobW9yZSBjdXJ2eSwgZnVydGhlciBjb250cm9sIHBvaW50cylcblxuZXhwb3J0IGZ1bmN0aW9uIGZsYXRQb2ludHNUb1NlZ21lbnQocG9pbnRzLCBjdXJ2aW5lc3MpIHtcbiAgaWYgKGN1cnZpbmVzcyA9PT0gdm9pZCAwKSB7XG4gICAgY3VydmluZXNzID0gMTtcbiAgfVxuXG4gIHZhciB4ID0gcG9pbnRzWzBdLFxuICAgICAgeSA9IDAsXG4gICAgICBzZWdtZW50ID0gW3gsIHldLFxuICAgICAgaSA9IDI7XG5cbiAgZm9yICg7IGkgPCBwb2ludHMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBzZWdtZW50LnB1c2goeCwgeSwgcG9pbnRzW2ldLCB5ID0gKHBvaW50c1tpXSAtIHgpICogY3VydmluZXNzIC8gMiwgeCA9IHBvaW50c1tpXSwgLXkpO1xuICB9XG5cbiAgcmV0dXJuIHNlZ21lbnQ7XG59IC8vcG9pbnRzIGlzIGFuIGFycmF5IG9mIHgveSBwb2ludHMsIGxpa2UgW3gsIHksIHgsIHksIHgsIHldXG5cbmV4cG9ydCBmdW5jdGlvbiBwb2ludHNUb1NlZ21lbnQocG9pbnRzLCBjdXJ2aW5lc3MsIGNvcm5lclRocmVzaG9sZCkge1xuICAvL3BvaW50cyA9IHNpbXBsaWZ5UG9pbnRzKHBvaW50cywgdG9sZXJhbmNlKTtcbiAgX2Ficyhwb2ludHNbMF0gLSBwb2ludHNbMl0pIDwgMWUtNCAmJiBfYWJzKHBvaW50c1sxXSAtIHBvaW50c1szXSkgPCAxZS00ICYmIChwb2ludHMgPSBwb2ludHMuc2xpY2UoMikpOyAvLyBpZiB0aGUgZmlyc3QgdHdvIHBvaW50cyBhcmUgc3VwZXIgY2xvc2UsIGR1bXAgdGhlIGZpcnN0IG9uZS5cblxuICB2YXIgbCA9IHBvaW50cy5sZW5ndGggLSAyLFxuICAgICAgeCA9ICtwb2ludHNbMF0sXG4gICAgICB5ID0gK3BvaW50c1sxXSxcbiAgICAgIG5leHRYID0gK3BvaW50c1syXSxcbiAgICAgIG5leHRZID0gK3BvaW50c1szXSxcbiAgICAgIHNlZ21lbnQgPSBbeCwgeSwgeCwgeV0sXG4gICAgICBkeDIgPSBuZXh0WCAtIHgsXG4gICAgICBkeTIgPSBuZXh0WSAtIHksXG4gICAgICBjbG9zZWQgPSBNYXRoLmFicyhwb2ludHNbbF0gLSB4KSA8IDAuMDAxICYmIE1hdGguYWJzKHBvaW50c1tsICsgMV0gLSB5KSA8IDAuMDAxLFxuICAgICAgcHJldlgsXG4gICAgICBwcmV2WSxcbiAgICAgIGFuZ2xlLFxuICAgICAgc2xvcGUsXG4gICAgICBpLFxuICAgICAgZHgxLFxuICAgICAgZHgzLFxuICAgICAgZHkxLFxuICAgICAgZHkzLFxuICAgICAgZDEsXG4gICAgICBkMixcbiAgICAgIGEsXG4gICAgICBiLFxuICAgICAgYztcblxuICBpZiAoaXNOYU4oY29ybmVyVGhyZXNob2xkKSkge1xuICAgIGNvcm5lclRocmVzaG9sZCA9IE1hdGguUEkgLyAxMDtcbiAgfVxuXG4gIGlmIChjbG9zZWQpIHtcbiAgICAvLyBpZiB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludHMgYXJlIGJhc2ljYWxseSBvbiB0b3Agb2YgZWFjaCBvdGhlciwgY2xvc2UgdGhlIHNlZ21lbnQgYnkgYWRkaW5nIHRoZSAybmQgcG9pbnQgdG8gdGhlIGVuZCwgYW5kIHRoZSAybmQtdG8tbGFzdCBwb2ludCB0byB0aGUgYmVnaW5uaW5nICh3ZSdsbCByZW1vdmUgdGhlbSBhdCB0aGUgZW5kLCBidXQgdGhpcyBhbGxvd3MgdGhlIGN1cnZhdHVyZSB0byBsb29rIHBlcmZlY3QpXG4gICAgcG9pbnRzLnB1c2gobmV4dFgsIG5leHRZKTtcbiAgICBuZXh0WCA9IHg7XG4gICAgbmV4dFkgPSB5O1xuICAgIHggPSBwb2ludHNbbCAtIDJdO1xuICAgIHkgPSBwb2ludHNbbCAtIDFdO1xuICAgIHBvaW50cy51bnNoaWZ0KHgsIHkpO1xuICAgIGwgKz0gNDtcbiAgfVxuXG4gIGN1cnZpbmVzcyA9IGN1cnZpbmVzcyB8fCBjdXJ2aW5lc3MgPT09IDAgPyArY3VydmluZXNzIDogMTtcblxuICBmb3IgKGkgPSAyOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgcHJldlggPSB4O1xuICAgIHByZXZZID0geTtcbiAgICB4ID0gbmV4dFg7XG4gICAgeSA9IG5leHRZO1xuICAgIG5leHRYID0gK3BvaW50c1tpICsgMl07XG4gICAgbmV4dFkgPSArcG9pbnRzW2kgKyAzXTtcblxuICAgIGlmICh4ID09PSBuZXh0WCAmJiB5ID09PSBuZXh0WSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgZHgxID0gZHgyO1xuICAgIGR5MSA9IGR5MjtcbiAgICBkeDIgPSBuZXh0WCAtIHg7XG4gICAgZHkyID0gbmV4dFkgLSB5O1xuICAgIGR4MyA9IG5leHRYIC0gcHJldlg7XG4gICAgZHkzID0gbmV4dFkgLSBwcmV2WTtcbiAgICBhID0gZHgxICogZHgxICsgZHkxICogZHkxO1xuICAgIGIgPSBkeDIgKiBkeDIgKyBkeTIgKiBkeTI7XG4gICAgYyA9IGR4MyAqIGR4MyArIGR5MyAqIGR5MztcbiAgICBhbmdsZSA9IE1hdGguYWNvcygoYSArIGIgLSBjKSAvIF9zcXJ0KDQgKiBhICogYikpOyAvL2FuZ2xlIGJldHdlZW4gdGhlIDMgcG9pbnRzXG5cbiAgICBkMiA9IGFuZ2xlIC8gTWF0aC5QSSAqIGN1cnZpbmVzczsgLy90ZW1wb3JhcnkgcHJlY2FsY3VsYXRpb24gZm9yIHNwZWVkIChyZXVzaW5nIGQyIHZhcmlhYmxlKVxuXG4gICAgZDEgPSBfc3FydChhKSAqIGQyOyAvL3RoZSB0aWdodGVyIHRoZSBhbmdsZSwgdGhlIHNob3J0ZXIgd2UgbWFrZSB0aGUgaGFuZGxlcyBpbiBwcm9wb3J0aW9uLlxuXG4gICAgZDIgKj0gX3NxcnQoYik7XG5cbiAgICBpZiAoeCAhPT0gcHJldlggfHwgeSAhPT0gcHJldlkpIHtcbiAgICAgIGlmIChhbmdsZSA+IGNvcm5lclRocmVzaG9sZCkge1xuICAgICAgICBzbG9wZSA9IF9hdGFuMihkeTMsIGR4Myk7XG4gICAgICAgIHNlZ21lbnQucHVzaChfcm91bmQoeCAtIF9jb3Moc2xvcGUpICogZDEpLCAvL2ZpcnN0IGNvbnRyb2wgcG9pbnRcbiAgICAgICAgX3JvdW5kKHkgLSBfc2luKHNsb3BlKSAqIGQxKSwgX3JvdW5kKHgpLCAvL2FuY2hvclxuICAgICAgICBfcm91bmQoeSksIF9yb3VuZCh4ICsgX2NvcyhzbG9wZSkgKiBkMiksIC8vc2Vjb25kIGNvbnRyb2wgcG9pbnRcbiAgICAgICAgX3JvdW5kKHkgKyBfc2luKHNsb3BlKSAqIGQyKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbG9wZSA9IF9hdGFuMihkeTEsIGR4MSk7XG4gICAgICAgIHNlZ21lbnQucHVzaChfcm91bmQoeCAtIF9jb3Moc2xvcGUpICogZDEpLCAvL2ZpcnN0IGNvbnRyb2wgcG9pbnRcbiAgICAgICAgX3JvdW5kKHkgLSBfc2luKHNsb3BlKSAqIGQxKSk7XG4gICAgICAgIHNsb3BlID0gX2F0YW4yKGR5MiwgZHgyKTtcbiAgICAgICAgc2VnbWVudC5wdXNoKF9yb3VuZCh4KSwgLy9hbmNob3JcbiAgICAgICAgX3JvdW5kKHkpLCBfcm91bmQoeCArIF9jb3Moc2xvcGUpICogZDIpLCAvL3NlY29uZCBjb250cm9sIHBvaW50XG4gICAgICAgIF9yb3VuZCh5ICsgX3NpbihzbG9wZSkgKiBkMikpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHggIT09IG5leHRYIHx8IHkgIT09IG5leHRZIHx8IHNlZ21lbnQubGVuZ3RoIDwgNCA/IHNlZ21lbnQucHVzaChfcm91bmQobmV4dFgpLCBfcm91bmQobmV4dFkpLCBfcm91bmQobmV4dFgpLCBfcm91bmQobmV4dFkpKSA6IHNlZ21lbnQubGVuZ3RoIC09IDI7XG5cbiAgaWYgKGNsb3NlZCkge1xuICAgIHNlZ21lbnQuc3BsaWNlKDAsIDYpO1xuICAgIHNlZ21lbnQubGVuZ3RoID0gc2VnbWVudC5sZW5ndGggLSA2O1xuICB9XG5cbiAgcmV0dXJuIHNlZ21lbnQ7XG59IC8vcmV0dXJucyB0aGUgc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGFuIHgveSBjb29yZGluYXRlIGFuZCBhIHNlZ21lbnQgYmV0d2VlbiB4MS95MSBhbmQgeDIveTJcblxuZnVuY3Rpb24gcG9pbnRUb1NlZ0Rpc3QoeCwgeSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgdmFyIGR4ID0geDIgLSB4MSxcbiAgICAgIGR5ID0geTIgLSB5MSxcbiAgICAgIHQ7XG5cbiAgaWYgKGR4IHx8IGR5KSB7XG4gICAgdCA9ICgoeCAtIHgxKSAqIGR4ICsgKHkgLSB5MSkgKiBkeSkgLyAoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgaWYgKHQgPiAxKSB7XG4gICAgICB4MSA9IHgyO1xuICAgICAgeTEgPSB5MjtcbiAgICB9IGVsc2UgaWYgKHQgPiAwKSB7XG4gICAgICB4MSArPSBkeCAqIHQ7XG4gICAgICB5MSArPSBkeSAqIHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIE1hdGgucG93KHggLSB4MSwgMikgKyBNYXRoLnBvdyh5IC0geTEsIDIpO1xufVxuXG5mdW5jdGlvbiBzaW1wbGlmeVN0ZXAocG9pbnRzLCBmaXJzdCwgbGFzdCwgdG9sZXJhbmNlLCBzaW1wbGlmaWVkKSB7XG4gIHZhciBtYXhTcURpc3QgPSB0b2xlcmFuY2UsXG4gICAgICBmaXJzdFggPSBwb2ludHNbZmlyc3RdLFxuICAgICAgZmlyc3RZID0gcG9pbnRzW2ZpcnN0ICsgMV0sXG4gICAgICBsYXN0WCA9IHBvaW50c1tsYXN0XSxcbiAgICAgIGxhc3RZID0gcG9pbnRzW2xhc3QgKyAxXSxcbiAgICAgIGluZGV4LFxuICAgICAgaSxcbiAgICAgIGQ7XG5cbiAgZm9yIChpID0gZmlyc3QgKyAyOyBpIDwgbGFzdDsgaSArPSAyKSB7XG4gICAgZCA9IHBvaW50VG9TZWdEaXN0KHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSwgZmlyc3RYLCBmaXJzdFksIGxhc3RYLCBsYXN0WSk7XG5cbiAgICBpZiAoZCA+IG1heFNxRGlzdCkge1xuICAgICAgaW5kZXggPSBpO1xuICAgICAgbWF4U3FEaXN0ID0gZDtcbiAgICB9XG4gIH1cblxuICBpZiAobWF4U3FEaXN0ID4gdG9sZXJhbmNlKSB7XG4gICAgaW5kZXggLSBmaXJzdCA+IDIgJiYgc2ltcGxpZnlTdGVwKHBvaW50cywgZmlyc3QsIGluZGV4LCB0b2xlcmFuY2UsIHNpbXBsaWZpZWQpO1xuICAgIHNpbXBsaWZpZWQucHVzaChwb2ludHNbaW5kZXhdLCBwb2ludHNbaW5kZXggKyAxXSk7XG4gICAgbGFzdCAtIGluZGV4ID4gMiAmJiBzaW1wbGlmeVN0ZXAocG9pbnRzLCBpbmRleCwgbGFzdCwgdG9sZXJhbmNlLCBzaW1wbGlmaWVkKTtcbiAgfVxufSAvL3BvaW50cyBpcyBhbiBhcnJheSBvZiB4L3kgdmFsdWVzIGxpa2UgW3gsIHksIHgsIHksIHgsIHldXG5cblxuZXhwb3J0IGZ1bmN0aW9uIHNpbXBsaWZ5UG9pbnRzKHBvaW50cywgdG9sZXJhbmNlKSB7XG4gIHZhciBwcmV2WCA9IHBhcnNlRmxvYXQocG9pbnRzWzBdKSxcbiAgICAgIHByZXZZID0gcGFyc2VGbG9hdChwb2ludHNbMV0pLFxuICAgICAgdGVtcCA9IFtwcmV2WCwgcHJldlldLFxuICAgICAgbCA9IHBvaW50cy5sZW5ndGggLSAyLFxuICAgICAgaSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgZHgsXG4gICAgICBkeSxcbiAgICAgIHJlc3VsdCxcbiAgICAgIGxhc3Q7XG4gIHRvbGVyYW5jZSA9IE1hdGgucG93KHRvbGVyYW5jZSB8fCAxLCAyKTtcblxuICBmb3IgKGkgPSAyOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgeCA9IHBhcnNlRmxvYXQocG9pbnRzW2ldKTtcbiAgICB5ID0gcGFyc2VGbG9hdChwb2ludHNbaSArIDFdKTtcbiAgICBkeCA9IHByZXZYIC0geDtcbiAgICBkeSA9IHByZXZZIC0geTtcblxuICAgIGlmIChkeCAqIGR4ICsgZHkgKiBkeSA+IHRvbGVyYW5jZSkge1xuICAgICAgdGVtcC5wdXNoKHgsIHkpO1xuICAgICAgcHJldlggPSB4O1xuICAgICAgcHJldlkgPSB5O1xuICAgIH1cbiAgfVxuXG4gIHRlbXAucHVzaChwYXJzZUZsb2F0KHBvaW50c1tsXSksIHBhcnNlRmxvYXQocG9pbnRzW2wgKyAxXSkpO1xuICBsYXN0ID0gdGVtcC5sZW5ndGggLSAyO1xuICByZXN1bHQgPSBbdGVtcFswXSwgdGVtcFsxXV07XG4gIHNpbXBsaWZ5U3RlcCh0ZW1wLCAwLCBsYXN0LCB0b2xlcmFuY2UsIHJlc3VsdCk7XG4gIHJlc3VsdC5wdXNoKHRlbXBbbGFzdF0sIHRlbXBbbGFzdCArIDFdKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xvc2VzdFByb2dyZXNzT25CZXppZXIoaXRlcmF0aW9ucywgcHgsIHB5LCBzdGFydCwgZW5kLCBzbGljZXMsIHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICB2YXIgaW5jID0gKGVuZCAtIHN0YXJ0KSAvIHNsaWNlcyxcbiAgICAgIGJlc3QgPSAwLFxuICAgICAgdCA9IHN0YXJ0LFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBkLFxuICAgICAgZHgsXG4gICAgICBkeSxcbiAgICAgIGludjtcbiAgX2Jlc3REaXN0YW5jZSA9IF9sYXJnZU51bTtcblxuICB3aGlsZSAodCA8PSBlbmQpIHtcbiAgICBpbnYgPSAxIC0gdDtcbiAgICB4ID0gaW52ICogaW52ICogaW52ICogeDAgKyAzICogaW52ICogaW52ICogdCAqIHgxICsgMyAqIGludiAqIHQgKiB0ICogeDIgKyB0ICogdCAqIHQgKiB4MztcbiAgICB5ID0gaW52ICogaW52ICogaW52ICogeTAgKyAzICogaW52ICogaW52ICogdCAqIHkxICsgMyAqIGludiAqIHQgKiB0ICogeTIgKyB0ICogdCAqIHQgKiB5MztcbiAgICBkeCA9IHggLSBweDtcbiAgICBkeSA9IHkgLSBweTtcbiAgICBkID0gZHggKiBkeCArIGR5ICogZHk7XG5cbiAgICBpZiAoZCA8IF9iZXN0RGlzdGFuY2UpIHtcbiAgICAgIF9iZXN0RGlzdGFuY2UgPSBkO1xuICAgICAgYmVzdCA9IHQ7XG4gICAgfVxuXG4gICAgdCArPSBpbmM7XG4gIH1cblxuICByZXR1cm4gaXRlcmF0aW9ucyA+IDEgPyBnZXRDbG9zZXN0UHJvZ3Jlc3NPbkJlemllcihpdGVyYXRpb25zIC0gMSwgcHgsIHB5LCBNYXRoLm1heChiZXN0IC0gaW5jLCAwKSwgTWF0aC5taW4oYmVzdCArIGluYywgMSksIHNsaWNlcywgeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSA6IGJlc3Q7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDbG9zZXN0RGF0YShyYXdQYXRoLCB4LCB5LCBzbGljZXMpIHtcbiAgLy9yZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRoZSBjbG9zZXN0IGosIGksIGFuZCB0IChqIGlzIHRoZSBzZWdtZW50IGluZGV4LCBpIGlzIHRoZSBpbmRleCBvZiB0aGUgcG9pbnQgaW4gdGhhdCBzZWdtZW50LCBhbmQgdCBpcyB0aGUgdGltZS9wcm9ncmVzcyBhbG9uZyB0aGF0IGJlemllcilcbiAgdmFyIGNsb3Nlc3QgPSB7XG4gICAgajogMCxcbiAgICBpOiAwLFxuICAgIHQ6IDBcbiAgfSxcbiAgICAgIGJlc3REaXN0YW5jZSA9IF9sYXJnZU51bSxcbiAgICAgIGksXG4gICAgICBqLFxuICAgICAgdCxcbiAgICAgIHNlZ21lbnQ7XG5cbiAgZm9yIChqID0gMDsgaiA8IHJhd1BhdGgubGVuZ3RoOyBqKyspIHtcbiAgICBzZWdtZW50ID0gcmF3UGF0aFtqXTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzZWdtZW50Lmxlbmd0aDsgaSArPSA2KSB7XG4gICAgICB0ID0gZ2V0Q2xvc2VzdFByb2dyZXNzT25CZXppZXIoMSwgeCwgeSwgMCwgMSwgc2xpY2VzIHx8IDIwLCBzZWdtZW50W2ldLCBzZWdtZW50W2kgKyAxXSwgc2VnbWVudFtpICsgMl0sIHNlZ21lbnRbaSArIDNdLCBzZWdtZW50W2kgKyA0XSwgc2VnbWVudFtpICsgNV0sIHNlZ21lbnRbaSArIDZdLCBzZWdtZW50W2kgKyA3XSk7XG5cbiAgICAgIGlmIChiZXN0RGlzdGFuY2UgPiBfYmVzdERpc3RhbmNlKSB7XG4gICAgICAgIGJlc3REaXN0YW5jZSA9IF9iZXN0RGlzdGFuY2U7XG4gICAgICAgIGNsb3Nlc3QuaiA9IGo7XG4gICAgICAgIGNsb3Nlc3QuaSA9IGk7XG4gICAgICAgIGNsb3Nlc3QudCA9IHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNsb3Nlc3Q7XG59IC8vc3ViZGl2aWRlIGEgU2VnbWVudCBjbG9zZXN0IHRvIGEgc3BlY2lmaWMgeCx5IGNvb3JkaW5hdGVcblxuZXhwb3J0IGZ1bmN0aW9uIHN1YmRpdmlkZVNlZ21lbnROZWFyKHgsIHksIHNlZ21lbnQsIHNsaWNlcywgaXRlcmF0aW9ucykge1xuICB2YXIgbCA9IHNlZ21lbnQubGVuZ3RoLFxuICAgICAgYmVzdERpc3RhbmNlID0gX2xhcmdlTnVtLFxuICAgICAgYmVzdFQgPSAwLFxuICAgICAgYmVzdFNlZ21lbnRJbmRleCA9IDAsXG4gICAgICB0LFxuICAgICAgaTtcbiAgc2xpY2VzID0gc2xpY2VzIHx8IDIwO1xuICBpdGVyYXRpb25zID0gaXRlcmF0aW9ucyB8fCAzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBsOyBpICs9IDYpIHtcbiAgICB0ID0gZ2V0Q2xvc2VzdFByb2dyZXNzT25CZXppZXIoMSwgeCwgeSwgMCwgMSwgc2xpY2VzLCBzZWdtZW50W2ldLCBzZWdtZW50W2kgKyAxXSwgc2VnbWVudFtpICsgMl0sIHNlZ21lbnRbaSArIDNdLCBzZWdtZW50W2kgKyA0XSwgc2VnbWVudFtpICsgNV0sIHNlZ21lbnRbaSArIDZdLCBzZWdtZW50W2kgKyA3XSk7XG5cbiAgICBpZiAoYmVzdERpc3RhbmNlID4gX2Jlc3REaXN0YW5jZSkge1xuICAgICAgYmVzdERpc3RhbmNlID0gX2Jlc3REaXN0YW5jZTtcbiAgICAgIGJlc3RUID0gdDtcbiAgICAgIGJlc3RTZWdtZW50SW5kZXggPSBpO1xuICAgIH1cbiAgfVxuXG4gIHQgPSBnZXRDbG9zZXN0UHJvZ3Jlc3NPbkJlemllcihpdGVyYXRpb25zLCB4LCB5LCBiZXN0VCAtIDAuMDUsIGJlc3RUICsgMC4wNSwgc2xpY2VzLCBzZWdtZW50W2Jlc3RTZWdtZW50SW5kZXhdLCBzZWdtZW50W2Jlc3RTZWdtZW50SW5kZXggKyAxXSwgc2VnbWVudFtiZXN0U2VnbWVudEluZGV4ICsgMl0sIHNlZ21lbnRbYmVzdFNlZ21lbnRJbmRleCArIDNdLCBzZWdtZW50W2Jlc3RTZWdtZW50SW5kZXggKyA0XSwgc2VnbWVudFtiZXN0U2VnbWVudEluZGV4ICsgNV0sIHNlZ21lbnRbYmVzdFNlZ21lbnRJbmRleCArIDZdLCBzZWdtZW50W2Jlc3RTZWdtZW50SW5kZXggKyA3XSk7XG4gIHN1YmRpdmlkZVNlZ21lbnQoc2VnbWVudCwgYmVzdFNlZ21lbnRJbmRleCwgdCk7XG4gIHJldHVybiBiZXN0U2VnbWVudEluZGV4ICsgNjtcbn1cbi8qXG5UYWtlcyBhbnkgb2YgdGhlIGZvbGxvd2luZyBhbmQgY29udmVydHMgaXQgdG8gYW4gYWxsIEN1YmljIEJlemllciBTVkcgZGF0YSBzdHJpbmc6XG4tIEEgPHBhdGg+IGRhdGEgc3RyaW5nIGxpa2UgXCJNMCwwIEwyLDQgdjIwLDE1IEgxMDBcIlxuLSBBIFJhd1BhdGgsIGxpa2UgW1t4LCB5LCB4LCB5LCB4LCB5LCB4LCB5XVtbeCwgeSwgeCwgeSwgeCwgeSwgeCwgeV1dXG4tIEEgU2VnbWVudCwgbGlrZSBbeCwgeSwgeCwgeSwgeCwgeSwgeCwgeV1cblxuTm90ZTogYWxsIG51bWJlcnMgYXJlIHJvdW5kZWQgZG93biB0byB0aGUgY2xvc2VzdCAwLjAwMSB0byBtaW5pbWl6ZSBtZW1vcnksIG1heGltaXplIHNwZWVkLCBhbmQgYXZvaWQgb2RkIG51bWJlcnMgbGlrZSAxZS0xM1xuKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJhd1BhdGhUb1N0cmluZyhyYXdQYXRoKSB7XG4gIGlmIChfaXNOdW1iZXIocmF3UGF0aFswXSkpIHtcbiAgICAvL2luIGNhc2UgYSBzZWdtZW50IGlzIHBhc3NlZCBpbiBpbnN0ZWFkXG4gICAgcmF3UGF0aCA9IFtyYXdQYXRoXTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBcIlwiLFxuICAgICAgbCA9IHJhd1BhdGgubGVuZ3RoLFxuICAgICAgc2wsXG4gICAgICBzLFxuICAgICAgaSxcbiAgICAgIHNlZ21lbnQ7XG5cbiAgZm9yIChzID0gMDsgcyA8IGw7IHMrKykge1xuICAgIHNlZ21lbnQgPSByYXdQYXRoW3NdO1xuICAgIHJlc3VsdCArPSBcIk1cIiArIF9yb3VuZChzZWdtZW50WzBdKSArIFwiLFwiICsgX3JvdW5kKHNlZ21lbnRbMV0pICsgXCIgQ1wiO1xuICAgIHNsID0gc2VnbWVudC5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAyOyBpIDwgc2w7IGkrKykge1xuICAgICAgcmVzdWx0ICs9IF9yb3VuZChzZWdtZW50W2krK10pICsgXCIsXCIgKyBfcm91bmQoc2VnbWVudFtpKytdKSArIFwiIFwiICsgX3JvdW5kKHNlZ21lbnRbaSsrXSkgKyBcIixcIiArIF9yb3VuZChzZWdtZW50W2krK10pICsgXCIgXCIgKyBfcm91bmQoc2VnbWVudFtpKytdKSArIFwiLFwiICsgX3JvdW5kKHNlZ21lbnRbaV0pICsgXCIgXCI7XG4gICAgfVxuXG4gICAgaWYgKHNlZ21lbnQuY2xvc2VkKSB7XG4gICAgICByZXN1bHQgKz0gXCJ6XCI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qXG4vLyB0YWtlcyBhIHNlZ21lbnQgd2l0aCBjb29yZGluYXRlcyBbeCwgeSwgeCwgeSwgLi4uXSBhbmQgY29udmVydHMgdGhlIGNvbnRyb2wgcG9pbnRzIGludG8gYW5nbGVzIGFuZCBsZW5ndGhzIFt4LCB5LCBhbmdsZSwgbGVuZ3RoLCBhbmdsZSwgbGVuZ3RoLCB4LCB5LCBhbmdsZSwgbGVuZ3RoLCAuLi5dIHNvIHRoYXQgaXQgYW5pbWF0ZXMgbW9yZSBjbGVhbmx5IGFuZCBhdm9pZHMgb2RkIGJyZWFrcy9raW5rcy4gRm9yIGV4YW1wbGUsIGlmIHlvdSBhbmltYXRlIGZyb20gMSBvJ2Nsb2NrIHRvIDYgbydjbG9jaywgaXQnZCBqdXN0IGdvIGRpcmVjdGx5L2xpbmVhcmx5IHJhdGhlciB0aGFuIGFyb3VuZC4gU28gdGhlIGxlbmd0aCB3b3VsZCBiZSB2ZXJ5IHNob3J0IGluIHRoZSBtaWRkbGUgb2YgdGhlIHR3ZWVuLlxuZXhwb3J0IGZ1bmN0aW9uIGNwQ29vcmRzVG9BbmdsZXMoc2VnbWVudCwgY29weSkge1xuXHR2YXIgcmVzdWx0ID0gY29weSA/IHNlZ21lbnQuc2xpY2UoMCkgOiBzZWdtZW50LFxuXHRcdHgsIHksIGk7XG5cdGZvciAoaSA9IDA7IGkgPCBzZWdtZW50Lmxlbmd0aDsgaSs9Nikge1xuXHRcdHggPSBzZWdtZW50W2krMl0gLSBzZWdtZW50W2ldO1xuXHRcdHkgPSBzZWdtZW50W2krM10gLSBzZWdtZW50W2krMV07XG5cdFx0cmVzdWx0W2krMl0gPSBNYXRoLmF0YW4yKHksIHgpO1xuXHRcdHJlc3VsdFtpKzNdID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXHRcdHggPSBzZWdtZW50W2krNl0gLSBzZWdtZW50W2krNF07XG5cdFx0eSA9IHNlZ21lbnRbaSs3XSAtIHNlZ21lbnRbaSs1XTtcblx0XHRyZXN1bHRbaSs0XSA9IE1hdGguYXRhbjIoeSwgeCk7XG5cdFx0cmVzdWx0W2krNV0gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG5cdH1cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gdGFrZXMgYSBzZWdtZW50IHRoYXQgd2FzIGNvbnZlcnRlZCB3aXRoIGNwQ29vcmRzVG9BbmdsZXMoKSB0byBoYXZlIGFuZ2xlcyBhbmQgbGVuZ3RocyBpbnN0ZWFkIG9mIGNvb3JkaW5hdGVzIGZvciB0aGUgY29udHJvbCBwb2ludHMsIGFuZCBjb252ZXJ0cyBpdCBCQUNLIGludG8gY29vcmRpbmF0ZXMuXG5leHBvcnQgZnVuY3Rpb24gY3BBbmdsZXNUb0Nvb3JkcyhzZWdtZW50LCBjb3B5KSB7XG5cdHZhciByZXN1bHQgPSBjb3B5ID8gc2VnbWVudC5zbGljZSgwKSA6IHNlZ21lbnQsXG5cdFx0bGVuZ3RoID0gc2VnbWVudC5sZW5ndGgsXG5cdFx0cm5kID0gMTAwMCxcblx0XHRhbmdsZSwgbCwgaSwgajtcblx0Zm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSs9Nikge1xuXHRcdGFuZ2xlID0gc2VnbWVudFtpKzJdO1xuXHRcdGwgPSBzZWdtZW50W2krM107IC8vbGVuZ3RoXG5cdFx0cmVzdWx0W2krMl0gPSAoKChzZWdtZW50W2ldICsgTWF0aC5jb3MoYW5nbGUpICogbCkgKiBybmQpIHwgMCkgLyBybmQ7XG5cdFx0cmVzdWx0W2krM10gPSAoKChzZWdtZW50W2krMV0gKyBNYXRoLnNpbihhbmdsZSkgKiBsKSAqIHJuZCkgfCAwKSAvIHJuZDtcblx0XHRhbmdsZSA9IHNlZ21lbnRbaSs0XTtcblx0XHRsID0gc2VnbWVudFtpKzVdOyAvL2xlbmd0aFxuXHRcdHJlc3VsdFtpKzRdID0gKCgoc2VnbWVudFtpKzZdIC0gTWF0aC5jb3MoYW5nbGUpICogbCkgKiBybmQpIHwgMCkgLyBybmQ7XG5cdFx0cmVzdWx0W2krNV0gPSAoKChzZWdtZW50W2krN10gLSBNYXRoLnNpbihhbmdsZSkgKiBsKSAqIHJuZCkgfCAwKSAvIHJuZDtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufVxuXG4vL2FkZHMgYW4gXCJpc1Ntb290aFwiIGFycmF5IHRvIGVhY2ggc2VnbWVudCBhbmQgcG9wdWxhdGVzIGl0IHdpdGggYSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgaXQncyBzbW9vdGggKHRoZSBjb250cm9sIHBvaW50cyBoYXZlIGJhc2ljYWxseSB0aGUgc2FtZSBzbG9wZSkuIEZvciBhbnkgc21vb3RoIGNvbnRyb2wgcG9pbnRzLCBpdCBjb252ZXJ0cyB0aGUgY29vcmRpbmF0ZXMgaW50byBhbmdsZSAoeCwgaW4gcmFkaWFucykgYW5kIGxlbmd0aCAoeSkgYW5kIHB1dHMgdGhlbSBpbnRvIHRoZSBzYW1lIGluZGV4IHZhbHVlIGluIGEgc21vb3RoRGF0YSBhcnJheS5cbmV4cG9ydCBmdW5jdGlvbiBwb3B1bGF0ZVNtb290aERhdGEocmF3UGF0aCkge1xuXHRsZXQgaiA9IHJhd1BhdGgubGVuZ3RoLFxuXHRcdHNtb290aCwgc2VnbWVudCwgeCwgeSwgeDIsIHkyLCBpLCBsLCBhLCBhMiwgaXNTbW9vdGgsIHNtb290aERhdGE7XG5cdHdoaWxlICgtLWogPiAtMSkge1xuXHRcdHNlZ21lbnQgPSByYXdQYXRoW2pdO1xuXHRcdGlzU21vb3RoID0gc2VnbWVudC5pc1Ntb290aCA9IHNlZ21lbnQuaXNTbW9vdGggfHwgWzAsIDAsIDAsIDBdO1xuXHRcdHNtb290aERhdGEgPSBzZWdtZW50LnNtb290aERhdGEgPSBzZWdtZW50LnNtb290aERhdGEgfHwgWzAsIDAsIDAsIDBdO1xuXHRcdGlzU21vb3RoLmxlbmd0aCA9IDQ7XG5cdFx0bCA9IHNlZ21lbnQubGVuZ3RoIC0gMjtcblx0XHRmb3IgKGkgPSA2OyBpIDwgbDsgaSArPSA2KSB7XG5cdFx0XHR4ID0gc2VnbWVudFtpXSAtIHNlZ21lbnRbaSAtIDJdO1xuXHRcdFx0eSA9IHNlZ21lbnRbaSArIDFdIC0gc2VnbWVudFtpIC0gMV07XG5cdFx0XHR4MiA9IHNlZ21lbnRbaSArIDJdIC0gc2VnbWVudFtpXTtcblx0XHRcdHkyID0gc2VnbWVudFtpICsgM10gLSBzZWdtZW50W2kgKyAxXTtcblx0XHRcdGEgPSBfYXRhbjIoeSwgeCk7XG5cdFx0XHRhMiA9IF9hdGFuMih5MiwgeDIpO1xuXHRcdFx0c21vb3RoID0gKE1hdGguYWJzKGEgLSBhMikgPCAwLjA5KTtcblx0XHRcdGlmIChzbW9vdGgpIHtcblx0XHRcdFx0c21vb3RoRGF0YVtpIC0gMl0gPSBhO1xuXHRcdFx0XHRzbW9vdGhEYXRhW2kgKyAyXSA9IGEyO1xuXHRcdFx0XHRzbW9vdGhEYXRhW2kgLSAxXSA9IF9zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXHRcdFx0XHRzbW9vdGhEYXRhW2kgKyAzXSA9IF9zcXJ0KHgyICogeDIgKyB5MiAqIHkyKTtcblx0XHRcdH1cblx0XHRcdGlzU21vb3RoLnB1c2goc21vb3RoLCBzbW9vdGgsIDAsIDAsIHNtb290aCwgc21vb3RoKTtcblx0XHR9XG5cdFx0Ly9pZiB0aGUgZmlyc3QgYW5kIGxhc3QgcG9pbnRzIGFyZSBpZGVudGljYWwsIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSdzIGEgc21vb3RoIHRyYW5zaXRpb24uIFdlIG11c3QgaGFuZGxlIHRoaXMgYSBiaXQgZGlmZmVyZW50bHkgZHVlIHRvIHRoZWlyIHBvc2l0aW9ucyBpbiB0aGUgYXJyYXkuXG5cdFx0aWYgKHNlZ21lbnRbbF0gPT09IHNlZ21lbnRbMF0gJiYgc2VnbWVudFtsKzFdID09PSBzZWdtZW50WzFdKSB7XG5cdFx0XHR4ID0gc2VnbWVudFswXSAtIHNlZ21lbnRbbC0yXTtcblx0XHRcdHkgPSBzZWdtZW50WzFdIC0gc2VnbWVudFtsLTFdO1xuXHRcdFx0eDIgPSBzZWdtZW50WzJdIC0gc2VnbWVudFswXTtcblx0XHRcdHkyID0gc2VnbWVudFszXSAtIHNlZ21lbnRbMV07XG5cdFx0XHRhID0gX2F0YW4yKHksIHgpO1xuXHRcdFx0YTIgPSBfYXRhbjIoeTIsIHgyKTtcblx0XHRcdGlmIChNYXRoLmFicyhhIC0gYTIpIDwgMC4wOSkge1xuXHRcdFx0XHRzbW9vdGhEYXRhW2wtMl0gPSBhO1xuXHRcdFx0XHRzbW9vdGhEYXRhWzJdID0gYTI7XG5cdFx0XHRcdHNtb290aERhdGFbbC0xXSA9IF9zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXHRcdFx0XHRzbW9vdGhEYXRhWzNdID0gX3NxcnQoeDIgKiB4MiArIHkyICogeTIpO1xuXHRcdFx0XHRpc1Ntb290aFtsLTJdID0gaXNTbW9vdGhbbC0xXSA9IHRydWU7IC8vZG9uJ3QgY2hhbmdlIGluZGV4ZXMgMiBhbmQgMyBiZWNhdXNlIHdlJ2xsIHRyaWdnZXIgZXZlcnl0aGluZyBmcm9tIHRoZSBFTkQsIGFuZCB0aGlzIHdpbGwgb3B0aW1pemUgZmlsZSBzaXplIGEgYml0LlxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmF3UGF0aDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb2ludFRvU2NyZWVuKHN2Z0VsZW1lbnQsIHBvaW50KSB7XG5cdGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikgeyAvL2J5IGRlZmF1bHQsIHRha2UgdGhlIGZpcnN0IHNldCBvZiBjb29yZGluYXRlcyBpbiB0aGUgcGF0aCBhcyB0aGUgcG9pbnRcblx0XHRsZXQgcmF3UGF0aCA9IGdldFJhd1BhdGgoc3ZnRWxlbWVudCk7XG5cdFx0cG9pbnQgPSBzdmdFbGVtZW50Lm93bmVyU1ZHRWxlbWVudC5jcmVhdGVTVkdQb2ludCgpO1xuXHRcdHBvaW50LnggPSByYXdQYXRoWzBdWzBdO1xuXHRcdHBvaW50LnkgPSByYXdQYXRoWzBdWzFdO1xuXHR9XG5cdHJldHVybiBwb2ludC5tYXRyaXhUcmFuc2Zvcm0oc3ZnRWxlbWVudC5nZXRTY3JlZW5DVE0oKSk7XG59XG5cbiovIiwiLyohXG4gKiBzdHJpbmdzOiAzLjkuMVxuICogaHR0cHM6Ly9ncmVlbnNvY2suY29tXG4gKlxuICogQ29weXJpZ2h0IDIwMDgtMjAyMSwgR3JlZW5Tb2NrLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogU3ViamVjdCB0byB0aGUgdGVybXMgYXQgaHR0cHM6Ly9ncmVlbnNvY2suY29tL3N0YW5kYXJkLWxpY2Vuc2Ugb3IgZm9yXG4gKiBDbHViIEdyZWVuU29jayBtZW1iZXJzLCB0aGUgYWdyZWVtZW50IGlzc3VlZCB3aXRoIHRoYXQgbWVtYmVyc2hpcC5cbiAqIEBhdXRob3I6IEphY2sgRG95bGUsIGphY2tAZ3JlZW5zb2NrLmNvbVxuKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbnZhciBfdHJpbUV4cCA9IC8oXlxccyt8XFxzKyQpL2c7XG5leHBvcnQgdmFyIGVtb2ppRXhwID0gLyhbXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdKD86W1xcdTIwMERcXHVGRTBGXVtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0pezIsfXxcXHVEODNEXFx1REM2OSg/OlxcdTIwMEQoPzooPzpcXHVEODNEXFx1REM2OVxcdTIwMEQpP1xcdUQ4M0RcXHVEQzY3fCg/OlxcdUQ4M0RcXHVEQzY5XFx1MjAwRCk/XFx1RDgzRFxcdURDNjYpfFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8XFx1RDgzRFxcdURDNjlcXHUyMDBEKD86XFx1RDgzRFxcdURDNjlcXHUyMDBEKT9cXHVEODNEXFx1REM2NlxcdTIwMERcXHVEODNEXFx1REM2NnxcXHVEODNEXFx1REM2OVxcdTIwMEQoPzpcXHVEODNEXFx1REM2OVxcdTIwMEQpP1xcdUQ4M0RcXHVEQzY3XFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2NlxcdURDNjddKXxcXHVEODNDXFx1REZGM1xcdUZFMEZcXHUyMDBEXFx1RDgzQ1xcdURGMDh8KD86XFx1RDgzQ1tcXHVERkMzXFx1REZDNFxcdURGQ0FdfFxcdUQ4M0RbXFx1REM2RVxcdURDNzFcXHVEQzczXFx1REM3N1xcdURDODFcXHVEQzgyXFx1REM4NlxcdURDODdcXHVERTQ1LVxcdURFNDdcXHVERTRCXFx1REU0RFxcdURFNEVcXHVERUEzXFx1REVCNC1cXHVERUI2XXxcXHVEODNFW1xcdUREMjZcXHVERDM3LVxcdUREMzlcXHVERDNEXFx1REQzRVxcdURERDYtXFx1RERERF0pKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKVxcdTIwMERbXFx1MjY0MFxcdTI2NDJdXFx1RkUwRnxcXHVEODNEXFx1REM2OSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSlcXHUyMDBEKD86XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml0pfCg/OlxcdUQ4M0NbXFx1REZDM1xcdURGQzRcXHVERkNBXXxcXHVEODNEW1xcdURDNkVcXHVEQzZGXFx1REM3MVxcdURDNzNcXHVEQzc3XFx1REM4MVxcdURDODJcXHVEQzg2XFx1REM4N1xcdURFNDUtXFx1REU0N1xcdURFNEJcXHVERTREXFx1REU0RVxcdURFQTNcXHVERUI0LVxcdURFQjZdfFxcdUQ4M0VbXFx1REQyNlxcdUREMzctXFx1REQzOVxcdUREM0MtXFx1REQzRVxcdURERDYtXFx1RERERl0pXFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml1cXHVGRTBGfFxcdUQ4M0NcXHVEREZEXFx1RDgzQ1xcdURERjB8XFx1RDgzQ1xcdURERjZcXHVEODNDXFx1RERFNnxcXHVEODNDXFx1RERGNFxcdUQ4M0NcXHVEREYyfFxcdUQ4M0NcXHVEREU5KD86XFx1RDgzQ1tcXHVEREVBXFx1RERFQ1xcdURERUZcXHVEREYwXFx1RERGMlxcdURERjRcXHVEREZGXSl8XFx1RDgzQ1xcdURERjcoPzpcXHVEODNDW1xcdURERUFcXHVEREY0XFx1RERGOFxcdURERkFcXHVEREZDXSl8XFx1RDgzQ1xcdURERTgoPzpcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFOVxcdURERUItXFx1RERFRVxcdURERjAtXFx1RERGNVxcdURERjdcXHVEREZBLVxcdURERkZdKXwoPzpcXHUyNkY5fFxcdUQ4M0NbXFx1REZDQlxcdURGQ0NdfFxcdUQ4M0RcXHVERDc1KSg/OlxcdUZFMEZcXHUyMDBEW1xcdTI2NDBcXHUyNjQyXXwoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pXFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml0pXFx1RkUwRnwoPzpcXHVEODNEXFx1REM0MVxcdUZFMEZcXHUyMDBEXFx1RDgzRFxcdURERTh8XFx1RDgzRFxcdURDNjkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdUQ4M0RcXHVEQzY5XFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdUQ4M0RcXHVEQzY4KD86KD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKVxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XXxcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF0pKVxcdUZFMEZ8XFx1RDgzQ1xcdURERjIoPzpcXHVEODNDW1xcdURERTZcXHVEREU4LVxcdURERURcXHVEREYwLVxcdURERkZdKXxcXHVEODNEXFx1REM2OVxcdTIwMEQoPzpcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHUyNzY0XFx1RkUwRlxcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMEQoPzpcXHVEODNEW1xcdURDNjhcXHVEQzY5XSl8XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pKXxcXHVEODNDXFx1RERGMSg/OlxcdUQ4M0NbXFx1RERFNi1cXHVEREU4XFx1RERFRVxcdURERjBcXHVEREY3LVxcdURERkJcXHVEREZFXSl8XFx1RDgzQ1xcdURERUYoPzpcXHVEODNDW1xcdURERUFcXHVEREYyXFx1RERGNFxcdURERjVdKXxcXHVEODNDXFx1RERFRCg/OlxcdUQ4M0NbXFx1RERGMFxcdURERjJcXHVEREYzXFx1RERGN1xcdURERjlcXHVEREZBXSl8XFx1RDgzQ1xcdURERUIoPzpcXHVEODNDW1xcdURERUUtXFx1RERGMFxcdURERjJcXHVEREY0XFx1RERGN10pfFsjXFwqMC05XVxcdUZFMEZcXHUyMEUzfFxcdUQ4M0NcXHVEREU3KD86XFx1RDgzQ1tcXHVEREU2XFx1RERFN1xcdURERTktXFx1RERFRlxcdURERjEtXFx1RERGNFxcdURERjYtXFx1RERGOVxcdURERkJcXHVEREZDXFx1RERGRVxcdURERkZdKXxcXHVEODNDXFx1RERFNig/OlxcdUQ4M0NbXFx1RERFOC1cXHVEREVDXFx1RERFRVxcdURERjFcXHVEREYyXFx1RERGNFxcdURERjYtXFx1RERGQVxcdURERkNcXHVEREZEXFx1RERGRl0pfFxcdUQ4M0NcXHVEREZGKD86XFx1RDgzQ1tcXHVEREU2XFx1RERGMlxcdURERkNdKXxcXHVEODNDXFx1RERGNSg/OlxcdUQ4M0NbXFx1RERFNlxcdURERUEtXFx1RERFRFxcdURERjAtXFx1RERGM1xcdURERjctXFx1RERGOVxcdURERkNcXHVEREZFXSl8XFx1RDgzQ1xcdURERkIoPzpcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFQVxcdURERUNcXHVEREVFXFx1RERGM1xcdURERkFdKXxcXHVEODNDXFx1RERGMyg/OlxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREVBLVxcdURERUNcXHVEREVFXFx1RERGMVxcdURERjRcXHVEREY1XFx1RERGN1xcdURERkFcXHVEREZGXSl8XFx1RDgzQ1xcdURGRjRcXHVEQjQwXFx1REM2N1xcdURCNDBcXHVEQzYyKD86XFx1REI0MFxcdURDNzdcXHVEQjQwXFx1REM2Q1xcdURCNDBcXHVEQzczfFxcdURCNDBcXHVEQzczXFx1REI0MFxcdURDNjNcXHVEQjQwXFx1REM3NHxcXHVEQjQwXFx1REM2NVxcdURCNDBcXHVEQzZFXFx1REI0MFxcdURDNjcpXFx1REI0MFxcdURDN0Z8XFx1RDgzRFxcdURDNjgoPzpcXHUyMDBEKD86XFx1Mjc2NFxcdUZFMEZcXHUyMDBEKD86XFx1RDgzRFxcdURDOEJcXHUyMDBEKT9cXHVEODNEXFx1REM2OHwoPzooPzpcXHVEODNEW1xcdURDNjhcXHVEQzY5XSlcXHUyMDBEKT9cXHVEODNEXFx1REM2NlxcdTIwMERcXHVEODNEXFx1REM2NnwoPzooPzpcXHVEODNEW1xcdURDNjhcXHVEQzY5XSlcXHUyMDBEKT9cXHVEODNEXFx1REM2N1xcdTIwMEQoPzpcXHVEODNEW1xcdURDNjZcXHVEQzY3XSl8XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml0pfCg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSlcXHUyMDBEKD86XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml0pKXxcXHVEODNDXFx1RERGOCg/OlxcdUQ4M0NbXFx1RERFNi1cXHVEREVBXFx1RERFQy1cXHVEREY0XFx1RERGNy1cXHVEREY5XFx1RERGQlxcdURERkQtXFx1RERGRl0pfFxcdUQ4M0NcXHVEREYwKD86XFx1RDgzQ1tcXHVEREVBXFx1RERFQy1cXHVEREVFXFx1RERGMlxcdURERjNcXHVEREY1XFx1RERGN1xcdURERkNcXHVEREZFXFx1RERGRl0pfFxcdUQ4M0NcXHVEREZFKD86XFx1RDgzQ1tcXHVEREVBXFx1RERGOV0pfFxcdUQ4M0NcXHVEREVFKD86XFx1RDgzQ1tcXHVEREU4LVxcdURERUFcXHVEREYxLVxcdURERjRcXHVEREY2LVxcdURERjldKXxcXHVEODNDXFx1RERGOSg/OlxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREU5XFx1RERFQi1cXHVEREVEXFx1RERFRi1cXHVEREY0XFx1RERGN1xcdURERjlcXHVEREZCXFx1RERGQ1xcdURERkZdKXxcXHVEODNDXFx1RERFQyg/OlxcdUQ4M0NbXFx1RERFNlxcdURERTdcXHVEREU5LVxcdURERUVcXHVEREYxLVxcdURERjNcXHVEREY1LVxcdURERkFcXHVEREZDXFx1RERGRV0pfFxcdUQ4M0NcXHVEREZBKD86XFx1RDgzQ1tcXHVEREU2XFx1RERFQ1xcdURERjJcXHVEREYzXFx1RERGOFxcdURERkVcXHVEREZGXSl8XFx1RDgzQ1xcdURERUEoPzpcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFQVxcdURERUNcXHVEREVEXFx1RERGNy1cXHVEREZBXSl8XFx1RDgzQ1xcdURERkMoPzpcXHVEODNDW1xcdURERUJcXHVEREY4XSl8KD86XFx1MjZGOXxcXHVEODNDW1xcdURGQ0JcXHVERkNDXXxcXHVEODNEXFx1REQ3NSkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfCg/OlxcdUQ4M0NbXFx1REZDM1xcdURGQzRcXHVERkNBXXxcXHVEODNEW1xcdURDNkVcXHVEQzcxXFx1REM3M1xcdURDNzdcXHVEQzgxXFx1REM4MlxcdURDODZcXHVEQzg3XFx1REU0NS1cXHVERTQ3XFx1REU0QlxcdURFNERcXHVERTRFXFx1REVBM1xcdURFQjQtXFx1REVCNl18XFx1RDgzRVtcXHVERDI2XFx1REQzNy1cXHVERDM5XFx1REQzRFxcdUREM0VcXHVEREQ2LVxcdURERERdKSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8KD86W1xcdTI2MURcXHUyNzBBLVxcdTI3MERdfFxcdUQ4M0NbXFx1REY4NVxcdURGQzJcXHVERkM3XXxcXHVEODNEW1xcdURDNDJcXHVEQzQzXFx1REM0Ni1cXHVEQzUwXFx1REM2NlxcdURDNjdcXHVEQzcwXFx1REM3MlxcdURDNzQtXFx1REM3NlxcdURDNzhcXHVEQzdDXFx1REM4M1xcdURDODVcXHVEQ0FBXFx1REQ3NFxcdUREN0FcXHVERDkwXFx1REQ5NVxcdUREOTZcXHVERTRDXFx1REU0RlxcdURFQzBcXHVERUNDXXxcXHVEODNFW1xcdUREMTgtXFx1REQxQ1xcdUREMUVcXHVERDFGXFx1REQzMC1cXHVERDM2XFx1REREMS1cXHVEREQ1XSkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfFxcdUQ4M0RcXHVEQzY4KD86XFx1MjAwRCg/Oig/Oig/OlxcdUQ4M0RbXFx1REM2OFxcdURDNjldKVxcdTIwMEQpP1xcdUQ4M0RcXHVEQzY3fCg/Oig/OlxcdUQ4M0RbXFx1REM2OFxcdURDNjldKVxcdTIwMEQpP1xcdUQ4M0RcXHVEQzY2KXxcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfCg/OltcXHUyNjFEXFx1MjZGOVxcdTI3MEEtXFx1MjcwRF18XFx1RDgzQ1tcXHVERjg1XFx1REZDMi1cXHVERkM0XFx1REZDN1xcdURGQ0EtXFx1REZDQ118XFx1RDgzRFtcXHVEQzQyXFx1REM0M1xcdURDNDYtXFx1REM1MFxcdURDNjYtXFx1REM2OVxcdURDNkVcXHVEQzcwLVxcdURDNzhcXHVEQzdDXFx1REM4MS1cXHVEQzgzXFx1REM4NS1cXHVEQzg3XFx1RENBQVxcdURENzRcXHVERDc1XFx1REQ3QVxcdUREOTBcXHVERDk1XFx1REQ5NlxcdURFNDUtXFx1REU0N1xcdURFNEItXFx1REU0RlxcdURFQTNcXHVERUI0LVxcdURFQjZcXHVERUMwXFx1REVDQ118XFx1RDgzRVtcXHVERDE4LVxcdUREMUNcXHVERDFFXFx1REQxRlxcdUREMjZcXHVERDMwLVxcdUREMzlcXHVERDNEXFx1REQzRVxcdURERDEtXFx1RERERF0pKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKT98KD86W1xcdTIzMUFcXHUyMzFCXFx1MjNFOS1cXHUyM0VDXFx1MjNGMFxcdTIzRjNcXHUyNUZEXFx1MjVGRVxcdTI2MTRcXHUyNjE1XFx1MjY0OC1cXHUyNjUzXFx1MjY3RlxcdTI2OTNcXHUyNkExXFx1MjZBQVxcdTI2QUJcXHUyNkJEXFx1MjZCRVxcdTI2QzRcXHUyNkM1XFx1MjZDRVxcdTI2RDRcXHUyNkVBXFx1MjZGMlxcdTI2RjNcXHUyNkY1XFx1MjZGQVxcdTI2RkRcXHUyNzA1XFx1MjcwQVxcdTI3MEJcXHUyNzI4XFx1Mjc0Q1xcdTI3NEVcXHUyNzUzLVxcdTI3NTVcXHUyNzU3XFx1Mjc5NS1cXHUyNzk3XFx1MjdCMFxcdTI3QkZcXHUyQjFCXFx1MkIxQ1xcdTJCNTBcXHUyQjU1XXxcXHVEODNDW1xcdURDMDRcXHVEQ0NGXFx1REQ4RVxcdUREOTEtXFx1REQ5QVxcdURERTYtXFx1RERGRlxcdURFMDFcXHVERTFBXFx1REUyRlxcdURFMzItXFx1REUzNlxcdURFMzgtXFx1REUzQVxcdURFNTBcXHVERTUxXFx1REYwMC1cXHVERjIwXFx1REYyRC1cXHVERjM1XFx1REYzNy1cXHVERjdDXFx1REY3RS1cXHVERjkzXFx1REZBMC1cXHVERkNBXFx1REZDRi1cXHVERkQzXFx1REZFMC1cXHVERkYwXFx1REZGNFxcdURGRjgtXFx1REZGRl18XFx1RDgzRFtcXHVEQzAwLVxcdURDM0VcXHVEQzQwXFx1REM0Mi1cXHVEQ0ZDXFx1RENGRi1cXHVERDNEXFx1REQ0Qi1cXHVERDRFXFx1REQ1MC1cXHVERDY3XFx1REQ3QVxcdUREOTVcXHVERDk2XFx1RERBNFxcdURERkItXFx1REU0RlxcdURFODAtXFx1REVDNVxcdURFQ0NcXHVERUQwLVxcdURFRDJcXHVERUVCXFx1REVFQ1xcdURFRjQtXFx1REVGOF18XFx1RDgzRVtcXHVERDEwLVxcdUREM0FcXHVERDNDLVxcdUREM0VcXHVERDQwLVxcdURENDVcXHVERDQ3LVxcdURENENcXHVERDUwLVxcdURENkJcXHVERDgwLVxcdUREOTdcXHVEREMwXFx1REREMC1cXHVEREU2XSl8KD86WyNcXCowLTlcXHhBOVxceEFFXFx1MjAzQ1xcdTIwNDlcXHUyMTIyXFx1MjEzOVxcdTIxOTQtXFx1MjE5OVxcdTIxQTlcXHUyMUFBXFx1MjMxQVxcdTIzMUJcXHUyMzI4XFx1MjNDRlxcdTIzRTktXFx1MjNGM1xcdTIzRjgtXFx1MjNGQVxcdTI0QzJcXHUyNUFBXFx1MjVBQlxcdTI1QjZcXHUyNUMwXFx1MjVGQi1cXHUyNUZFXFx1MjYwMC1cXHUyNjA0XFx1MjYwRVxcdTI2MTFcXHUyNjE0XFx1MjYxNVxcdTI2MThcXHUyNjFEXFx1MjYyMFxcdTI2MjJcXHUyNjIzXFx1MjYyNlxcdTI2MkFcXHUyNjJFXFx1MjYyRlxcdTI2MzgtXFx1MjYzQVxcdTI2NDBcXHUyNjQyXFx1MjY0OC1cXHUyNjUzXFx1MjY2MFxcdTI2NjNcXHUyNjY1XFx1MjY2NlxcdTI2NjhcXHUyNjdCXFx1MjY3RlxcdTI2OTItXFx1MjY5N1xcdTI2OTlcXHUyNjlCXFx1MjY5Q1xcdTI2QTBcXHUyNkExXFx1MjZBQVxcdTI2QUJcXHUyNkIwXFx1MjZCMVxcdTI2QkRcXHUyNkJFXFx1MjZDNFxcdTI2QzVcXHUyNkM4XFx1MjZDRVxcdTI2Q0ZcXHUyNkQxXFx1MjZEM1xcdTI2RDRcXHUyNkU5XFx1MjZFQVxcdTI2RjAtXFx1MjZGNVxcdTI2RjctXFx1MjZGQVxcdTI2RkRcXHUyNzAyXFx1MjcwNVxcdTI3MDgtXFx1MjcwRFxcdTI3MEZcXHUyNzEyXFx1MjcxNFxcdTI3MTZcXHUyNzFEXFx1MjcyMVxcdTI3MjhcXHUyNzMzXFx1MjczNFxcdTI3NDRcXHUyNzQ3XFx1Mjc0Q1xcdTI3NEVcXHUyNzUzLVxcdTI3NTVcXHUyNzU3XFx1Mjc2M1xcdTI3NjRcXHUyNzk1LVxcdTI3OTdcXHUyN0ExXFx1MjdCMFxcdTI3QkZcXHUyOTM0XFx1MjkzNVxcdTJCMDUtXFx1MkIwN1xcdTJCMUJcXHUyQjFDXFx1MkI1MFxcdTJCNTVcXHUzMDMwXFx1MzAzRFxcdTMyOTdcXHUzMjk5XXxcXHVEODNDW1xcdURDMDRcXHVEQ0NGXFx1REQ3MFxcdURENzFcXHVERDdFXFx1REQ3RlxcdUREOEVcXHVERDkxLVxcdUREOUFcXHVEREU2LVxcdURERkZcXHVERTAxXFx1REUwMlxcdURFMUFcXHVERTJGXFx1REUzMi1cXHVERTNBXFx1REU1MFxcdURFNTFcXHVERjAwLVxcdURGMjFcXHVERjI0LVxcdURGOTNcXHVERjk2XFx1REY5N1xcdURGOTktXFx1REY5QlxcdURGOUUtXFx1REZGMFxcdURGRjMtXFx1REZGNVxcdURGRjctXFx1REZGRl18XFx1RDgzRFtcXHVEQzAwLVxcdURDRkRcXHVEQ0ZGLVxcdUREM0RcXHVERDQ5LVxcdURENEVcXHVERDUwLVxcdURENjdcXHVERDZGXFx1REQ3MFxcdURENzMtXFx1REQ3QVxcdUREODdcXHVERDhBLVxcdUREOERcXHVERDkwXFx1REQ5NVxcdUREOTZcXHVEREE0XFx1RERBNVxcdUREQThcXHVEREIxXFx1RERCMlxcdUREQkNcXHVEREMyLVxcdUREQzRcXHVEREQxLVxcdURERDNcXHVERERDLVxcdUREREVcXHVEREUxXFx1RERFM1xcdURERThcXHVEREVGXFx1RERGM1xcdURERkEtXFx1REU0RlxcdURFODAtXFx1REVDNVxcdURFQ0ItXFx1REVEMlxcdURFRTAtXFx1REVFNVxcdURFRTlcXHVERUVCXFx1REVFQ1xcdURFRjBcXHVERUYzLVxcdURFRjhdfFxcdUQ4M0VbXFx1REQxMC1cXHVERDNBXFx1REQzQy1cXHVERDNFXFx1REQ0MC1cXHVERDQ1XFx1REQ0Ny1cXHVERDRDXFx1REQ1MC1cXHVERDZCXFx1REQ4MC1cXHVERDk3XFx1RERDMFxcdURERDAtXFx1RERFNl0pXFx1RkUwRikvO1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRleHQoZSkge1xuICB2YXIgdHlwZSA9IGUubm9kZVR5cGUsXG4gICAgICByZXN1bHQgPSBcIlwiO1xuXG4gIGlmICh0eXBlID09PSAxIHx8IHR5cGUgPT09IDkgfHwgdHlwZSA9PT0gMTEpIHtcbiAgICBpZiAodHlwZW9mIGUudGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBlLnRleHRDb250ZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGUgPSBlLmZpcnN0Q2hpbGQ7IGU7IGUgPSBlLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIHJlc3VsdCArPSBnZXRUZXh0KGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSAzIHx8IHR5cGUgPT09IDQpIHtcbiAgICByZXR1cm4gZS5ub2RlVmFsdWU7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0SW5uZXJIVE1MKGVsZW1lbnQsIGRlbGltaXRlciwgdHJpbSwgcHJlc2VydmVTcGFjZXMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50LmZpcnN0Q2hpbGQsXG4gICAgICByZXN1bHQgPSBbXSxcbiAgICAgIHM7XG5cbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgcyA9IChub2RlLm5vZGVWYWx1ZSArIFwiXCIpLnJlcGxhY2UoL15cXG4rL2csIFwiXCIpO1xuXG4gICAgICBpZiAoIXByZXNlcnZlU3BhY2VzKSB7XG4gICAgICAgIHMgPSBzLnJlcGxhY2UoL1xccysvZywgXCIgXCIpO1xuICAgICAgfVxuXG4gICAgICByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIGVtb2ppU2FmZVNwbGl0KHMsIGRlbGltaXRlciwgdHJpbSwgcHJlc2VydmVTcGFjZXMpKTtcbiAgICB9IGVsc2UgaWYgKChub2RlLm5vZGVOYW1lICsgXCJcIikudG9Mb3dlckNhc2UoKSA9PT0gXCJiclwiKSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdICs9IFwiPGJyPlwiO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucHVzaChub2RlLm91dGVySFRNTCk7XG4gICAgfVxuXG4gICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gIH1cblxuICBzID0gcmVzdWx0Lmxlbmd0aDtcblxuICB3aGlsZSAocy0tKSB7XG4gICAgcmVzdWx0W3NdID09PSBcIiZcIiAmJiByZXN1bHQuc3BsaWNlKHMsIDEsIFwiJmFtcDtcIik7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuLypcbi8vc21hbGxlciBrYiB2ZXJzaW9uIHRoYXQgb25seSBoYW5kbGVzIHRoZSBzaW1wbGVyIGVtb2ppJ3MsIHdoaWNoIGlzIG9mdGVuIHBlcmZlY3RseSBhZGVxdWF0ZS5cblxubGV0IF9lbW9qaSA9IFwiW1xcdUUwMDAtXFx1RjhGRl18XFx1RDgzQ1tcXHVEQzAwLVxcdURGRkZdfFxcdUQ4M0RbXFx1REMwMC1cXHVERkZGXXxbXFx1MjY5NC1cXHUyNjk3XXxcXHVEODNFW1xcdUREMTAtXFx1REQ1RF18W1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXVwiLFxuXHRfZW1vamlFeHAgPSBuZXcgUmVnRXhwKF9lbW9qaSksXG5cdF9lbW9qaUFuZENoYXJzRXhwID0gbmV3IFJlZ0V4cChfZW1vamkgKyBcInwuXCIsIFwiZ1wiKSxcblx0X2Vtb2ppU2FmZVNwbGl0ID0gKHRleHQsIGRlbGltaXRlciwgdHJpbSkgPT4ge1xuXHRcdGlmICh0cmltKSB7XG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKF90cmltRXhwLCBcIlwiKTtcblx0XHR9XG5cdFx0cmV0dXJuICgoZGVsaW1pdGVyID09PSBcIlwiIHx8ICFkZWxpbWl0ZXIpICYmIF9lbW9qaUV4cC50ZXN0KHRleHQpKSA/IHRleHQubWF0Y2goX2Vtb2ppQW5kQ2hhcnNFeHApIDogdGV4dC5zcGxpdChkZWxpbWl0ZXIgfHwgXCJcIik7XG5cdH07XG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGVtb2ppU2FmZVNwbGl0KHRleHQsIGRlbGltaXRlciwgdHJpbSwgcHJlc2VydmVTcGFjZXMpIHtcbiAgdGV4dCArPSBcIlwiOyAvLyBtYWtlIHN1cmUgaXQncyBjYXN0IGFzIGEgc3RyaW5nLiBTb21lb25lIG1heSBwYXNzIGluIGEgbnVtYmVyLlxuXG4gIGlmICh0cmltKSB7XG4gICAgdGV4dCA9IHRleHQucmVwbGFjZShfdHJpbUV4cCwgXCJcIik7XG4gIH1cblxuICBpZiAoZGVsaW1pdGVyICYmIGRlbGltaXRlciAhPT0gXCJcIikge1xuICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpLnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpLnNwbGl0KGRlbGltaXRlcik7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICBsID0gdGV4dC5sZW5ndGgsXG4gICAgICBpID0gMCxcbiAgICAgIGosXG4gICAgICBjaGFyYWN0ZXI7XG5cbiAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICBjaGFyYWN0ZXIgPSB0ZXh0LmNoYXJBdChpKTtcblxuICAgIGlmIChjaGFyYWN0ZXIuY2hhckNvZGVBdCgwKSA+PSAweEQ4MDAgJiYgY2hhcmFjdGVyLmNoYXJDb2RlQXQoMCkgPD0gMHhEQkZGIHx8IHRleHQuY2hhckNvZGVBdChpICsgMSkgPj0gMHhGRTAwICYmIHRleHQuY2hhckNvZGVBdChpICsgMSkgPD0gMHhGRTBGKSB7XG4gICAgICAvL3NwZWNpYWwgZW1vamkgY2hhcmFjdGVycyB1c2UgMiBvciA0IHVuaWNvZGUgY2hhcmFjdGVycyB0aGF0IHdlIG11c3Qga2VlcCB0b2dldGhlci5cbiAgICAgIGogPSAoKHRleHQuc3Vic3RyKGksIDEyKS5zcGxpdChlbW9qaUV4cCkgfHwgW10pWzFdIHx8IFwiXCIpLmxlbmd0aCB8fCAyO1xuICAgICAgY2hhcmFjdGVyID0gdGV4dC5zdWJzdHIoaSwgaik7XG4gICAgICByZXN1bHQuZW1vamkgPSAxO1xuICAgICAgaSArPSBqIC0gMTtcbiAgICB9XG5cbiAgICByZXN1bHQucHVzaChjaGFyYWN0ZXIgPT09IFwiPlwiID8gXCImZ3Q7XCIgOiBjaGFyYWN0ZXIgPT09IFwiPFwiID8gXCImbHQ7XCIgOiBwcmVzZXJ2ZVNwYWNlcyAmJiBjaGFyYWN0ZXIgPT09IFwiIFwiICYmICh0ZXh0LmNoYXJBdChpIC0gMSkgPT09IFwiIFwiIHx8IHRleHQuY2hhckF0KGkgKyAxKSA9PT0gXCIgXCIpID8gXCImbmJzcDtcIiA6IGNoYXJhY3Rlcik7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufSIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJ2YXIgc2NyaXB0VXJsO1xuaWYgKF9fd2VicGFja19yZXF1aXJlX18uZy5pbXBvcnRTY3JpcHRzKSBzY3JpcHRVcmwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmcubG9jYXRpb24gKyBcIlwiO1xudmFyIGRvY3VtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXy5nLmRvY3VtZW50O1xuaWYgKCFzY3JpcHRVcmwgJiYgZG9jdW1lbnQpIHtcblx0aWYgKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpXG5cdFx0c2NyaXB0VXJsID0gZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmNcblx0aWYgKCFzY3JpcHRVcmwpIHtcblx0XHR2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuXHRcdGlmKHNjcmlwdHMubGVuZ3RoKSBzY3JpcHRVcmwgPSBzY3JpcHRzW3NjcmlwdHMubGVuZ3RoIC0gMV0uc3JjXG5cdH1cbn1cbi8vIFdoZW4gc3VwcG9ydGluZyBicm93c2VycyB3aGVyZSBhbiBhdXRvbWF0aWMgcHVibGljUGF0aCBpcyBub3Qgc3VwcG9ydGVkIHlvdSBtdXN0IHNwZWNpZnkgYW4gb3V0cHV0LnB1YmxpY1BhdGggbWFudWFsbHkgdmlhIGNvbmZpZ3VyYXRpb25cbi8vIG9yIHBhc3MgYW4gZW1wdHkgc3RyaW5nIChcIlwiKSBhbmQgc2V0IHRoZSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyB2YXJpYWJsZSBmcm9tIHlvdXIgY29kZSB0byB1c2UgeW91ciBvd24gbG9naWMuXG5pZiAoIXNjcmlwdFVybCkgdGhyb3cgbmV3IEVycm9yKFwiQXV0b21hdGljIHB1YmxpY1BhdGggaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXJcIik7XG5zY3JpcHRVcmwgPSBzY3JpcHRVcmwucmVwbGFjZSgvIy4qJC8sIFwiXCIpLnJlcGxhY2UoL1xcPy4qJC8sIFwiXCIpLnJlcGxhY2UoL1xcL1teXFwvXSskLywgXCIvXCIpO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5wID0gc2NyaXB0VXJsICsgXCIuLi9cIjsiLCJpbXBvcnQgeyBnc2FwLCBTY3JvbGxUcmlnZ2VyLCBEcmFnZ2FibGUsIE1vdGlvblBhdGhQbHVnaW4gfSBmcm9tIFwiZ3NhcC9hbGxcIjtcclxuZ3NhcC5mcm9tKCcubmF2aWdhdGlvbicsIHsgb3BhY2l0eTogMCwgeTogJy0xMDAlJywgZHVyYXRpb246IDEsIGVhc2U6ICdCb3VuY2UuZWFzZU91dCcgfSk7XHJcblxyXG5nc2FwLnJlZ2lzdGVyRWZmZWN0KHtcclxuICAgIG5hbWU6IFwiZmFkZVwiLFxyXG4gICAgZGVmYXVsdHM6IHsgZHVyYXRpb246IDIgfSwgLy9kZWZhdWx0cyBnZXQgYXBwbGllZCB0byB0aGUgXCJjb25maWdcIiBvYmplY3QgcGFzc2VkIHRvIHRoZSBlZmZlY3QgYmVsb3dcclxuICAgIGVmZmVjdDogKHRhcmdldHMsIGNvbmZpZykgPT4ge1xyXG4gICAgICAgIHJldHVybiBnc2FwLnRvKHRhcmdldHMsIHsgZHVyYXRpb246IGNvbmZpZy5kdXJhdGlvbiwgb3BhY2l0eTogMCB9KTtcclxuICAgIH1cclxufSk7XHJcblxyXG4vL25vdyB3ZSBjYW4gdXNlIGl0IGxpa2UgdGhpczpcclxuLy9nc2FwLmVmZmVjdHMuZmFkZShcIi5ib3hcIik7XHJcblxyXG5sZXQgaSA9IDAuMTtcclxuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5ib3hcIikuZm9yRWFjaChmdW5jdGlvbihib3gpIHtcclxuICAgIGkrK1xyXG4gICAgY29uc29sZS5sb2coMSk7XHJcbiAgICBnc2FwLmZyb20oYm94LCB7IG9wYWNpdHk6IDAsIHk6ICctMTAwJScsIGR1cmF0aW9uOiBpLCBlYXNlOiAnQm91bmNlLmVhc2VPdXQnIH0pO1xyXG4gICAgYm94LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGdzYXAuZWZmZWN0cy5mYWRlKHRoaXMpO1xyXG4gICAgfSk7XHJcbn0pOyIsImV4cG9ydCBkZWZhdWx0IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJjc3MvbWFpbi5jc3NcIjsiXSwibmFtZXMiOlsiZ3NhcCIsIlNjcm9sbFRyaWdnZXIiLCJEcmFnZ2FibGUiLCJNb3Rpb25QYXRoUGx1Z2luIiwiZnJvbSIsIm9wYWNpdHkiLCJ5IiwiZHVyYXRpb24iLCJlYXNlIiwicmVnaXN0ZXJFZmZlY3QiLCJuYW1lIiwiZGVmYXVsdHMiLCJlZmZlY3QiLCJ0YXJnZXRzIiwiY29uZmlnIiwidG8iLCJpIiwiZG9jdW1lbnQiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZm9yRWFjaCIsImJveCIsImNvbnNvbGUiLCJsb2ciLCJhZGRFdmVudExpc3RlbmVyIiwiZWZmZWN0cyIsImZhZGUiXSwic291cmNlUm9vdCI6IiJ9